; ModuleID = '/usr/local/google/home/aeubanks/repos/test-suite/MultiSource/Applications/treecc/skels.c'
source_filename = "/usr/local/google/home/aeubanks/repos/test-suite/MultiSource/Applications/treecc/skels.c"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

@.str = private unnamed_addr constant [9 x i8] c"c_skel.c\00", align 1
@TreeCCSkel_c_skel_c = internal constant [6587 x i8] c"/*\0A * treecc node allocation routines for C.\0A *\0A * Copyright (C) 2001  Southern Storm Software, Pty Ltd.\0A *\0A * This program is free software; you can redistribute it and/or modify\0A * it under the terms of the GNU General Public License as published by\0A * the Free Software Foundation; either version 2 of the License, or\0A * (at your option) any later version.\0A *\0A * This program is distributed in the hope that it will be useful,\0A * but WITHOUT ANY WARRANTY; without even the implied warranty of\0A * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\0A * GNU General Public License for more details.\0A *\0A * You should have received a copy of the GNU General Public License\0A * along with this program; if not, write to the Free Software\0A * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\0A *\0A * As a special exception, when this file is copied by treecc into\0A * a treecc output file, you may use that output file without restriction.\0A */\0A\0A#include <stdlib.h>\0A\0A#ifndef YYNODESTATE_BLKSIZ\0A#define\09YYNODESTATE_BLKSIZ\092048\0A#endif\0A\0A/*\0A * Types used by the allocation routines.\0A */\0Astruct YYNODESTATE_block\0A{\0A\09char data__[YYNODESTATE_BLKSIZ];\0A\09struct YYNODESTATE_block *next__;\0A\0A};\0Astruct YYNODESTATE_push\0A{\0A\09struct YYNODESTATE_push *next__;\0A\09struct YYNODESTATE_block *saved_block__;\0A\09int saved_used__;\0A};\0A\0A/*\0A * The fixed global state to use for non-reentrant allocation.\0A */\0A#ifndef YYNODESTATE_REENTRANT\0Astatic YYNODESTATE fixed_state__;\0A#endif\0A\0A/*\0A * Some macro magic to determine the default alignment\0A * on this machine.  This will compile down to a constant.\0A */\0A#define\09YYNODESTATE_ALIGN_CHECK_TYPE(type,name)\09\\\0A\09struct _YYNODESTATE_align_##name { \\\0A\09\09char pad; \\\0A\09\09type field; \\\0A\09}\0A#define\09YYNODESTATE_ALIGN_FOR_TYPE(type)\09\\\0A\09((unsigned)(&(((struct _YYNODESTATE_align_##type *)0)->field)))\0A#define\09YYNODESTATE_ALIGN_MAX(a,b)\09\\\0A\09((a) > (b) ? (a) : (b))\0A#define\09YYNODESTATE_ALIGN_MAX3(a,b,c) \\\0A\09(YYNODESTATE_ALIGN_MAX((a), YYNODESTATE_ALIGN_MAX((b), (c))))\0AYYNODESTATE_ALIGN_CHECK_TYPE(int, int);\0AYYNODESTATE_ALIGN_CHECK_TYPE(long, long);\0A#if defined(WIN32) && !defined(__CYGWIN__)\0AYYNODESTATE_ALIGN_CHECK_TYPE(__int64, long_long);\0A#else\0AYYNODESTATE_ALIGN_CHECK_TYPE(long long, long_long);\0A#endif\0AYYNODESTATE_ALIGN_CHECK_TYPE(void *, void_p);\0AYYNODESTATE_ALIGN_CHECK_TYPE(float, float);\0AYYNODESTATE_ALIGN_CHECK_TYPE(double, double);\0A#define\09YYNODESTATE_ALIGNMENT\09\\\0A\09YYNODESTATE_ALIGN_MAX( \\\0A\09\09\09YYNODESTATE_ALIGN_MAX3\09\\\0A\09\09\09(YYNODESTATE_ALIGN_FOR_TYPE(int), \\\0A\09\09     YYNODESTATE_ALIGN_FOR_TYPE(long), \\\0A\09\09\09 YYNODESTATE_ALIGN_FOR_TYPE(long_long)), \\\0A  \09     YYNODESTATE_ALIGN_MAX3 \\\0A\09\09 \09(YYNODESTATE_ALIGN_FOR_TYPE(void_p), \\\0A\09\09\09 YYNODESTATE_ALIGN_FOR_TYPE(float), \\\0A\09\09\09 YYNODESTATE_ALIGN_FOR_TYPE(double)))\0A\0A/*\0A * Initialize the node allocation pool.\0A */\0A#ifdef YYNODESTATE_REENTRANT\0Avoid yynodeinit(state__)\0AYYNODESTATE *state__;\0A{\0A#else\0Avoid yynodeinit()\0A{\0A\09YYNODESTATE *state__ = &fixed_state__;\0A#endif\0A\09state__->blocks__ = 0;\0A\09state__->push_stack__ = 0;\0A\09state__->used__ = 0;\0A}\0A\0A/*\0A * Allocate a block of memory.\0A */\0A#ifdef YYNODESTATE_REENTRANT\0Avoid *yynodealloc(state__, size__)\0AYYNODESTATE *state__;\0Aunsigned int size__;\0A{\0A#else\0Avoid *yynodealloc(size__)\0Aunsigned int size__;\0A{\0A\09YYNODESTATE *state__ = &fixed_state__;\0A#endif\0A\09struct YYNODESTATE_block *block__;\0A\09void *result__;\0A\0A\09/* Round the size to the next alignment boundary */\0A\09size__ = (size__ + YYNODESTATE_ALIGNMENT - 1) &\0A\09\09\09\09~(YYNODESTATE_ALIGNMENT - 1);\0A\0A\09/* Do we need to allocate a new block? */\0A\09block__ = state__->blocks__;\0A\09if(!block__ || (state__->used__ + size__) > YYNODESTATE_BLKSIZ)\0A\09{\0A\09\09if(size__ > YYNODESTATE_BLKSIZ)\0A\09\09{\0A\09\09\09/* The allocation is too big for the node pool */\0A\09\09\09return (void *)0;\0A\09\09}\0A\09\09block__ = (struct YYNODESTATE_block *)\0A\09\09\09\09\09\09malloc(sizeof(struct YYNODESTATE_block));\0A\09\09if(!block__)\0A\09\09{\0A\09\09\09/* The system is out of memory.  The programmer can\0A\09\09\09   supply the \22yynodefailed\22 function to report the\0A\09\09\09   out of memory state and/or abort the program */\0A#ifdef YYNODESTATE_REENTRANT\0A\09\09\09yynodefailed(state__);\0A#else\0A\09\09\09yynodefailed();\0A#endif\0A\09\09\09return (void *)0;\0A\09\09}\0A\09\09block__->next__ = state__->blocks__;\0A\09\09state__->blocks__ = block__;\0A\09\09state__->used__ = 0;\0A\09}\0A\0A\09/* Allocate the memory and return it */\0A\09result__ = (void *)(block__->data__ + state__->used__);\0A\09state__->used__ += size__;\0A\09return result__;\0A}\0A\0A/*\0A * Push the node allocation state.\0A */\0A#ifdef YYNODESTATE_REENTRANT\0Aint yynodepush(state__)\0AYYNODESTATE *state__;\0A{\0A#else\0Aint yynodepush()\0A{\0A\09YYNODESTATE *state__ = &fixed_state__;\0A#endif\0A\09struct YYNODESTATE_block *saved_block__;\0A\09int saved_used__;\0A\09struct YYNODESTATE_push *push_item__;\0A\0A\09/* Save the current state of the node allocation pool */\0A\09saved_block__ = state__->blocks__;\0A\09saved_used__ = state__->used__;\0A\0A\09/* Allocate space for a push item */\0A#ifdef YYNODESTATE_REENTRANT\0A\09push_item__ = (struct YYNODESTATE_push *)\0A\09\09\09yynodealloc(state__, sizeof(struct YYNODESTATE_push));\0A#else\0A\09push_item__ = (struct YYNODESTATE_push *)\0A\09\09\09yynodealloc(sizeof(struct YYNODESTATE_push));\0A#endif\0A\09if(!push_item__)\0A\09{\0A\09\09return 0;\0A\09}\0A\0A\09/* Copy the saved information to the push item */\0A\09push_item__->saved_block__ = saved_block__;\0A\09push_item__->saved_used__ = saved_used__;\0A\0A\09/* Add the push item to the push stack */\0A\09push_item__->next__ = state__->push_stack__;\0A\09state__->push_stack__ = push_item__;\0A\09return 1;\0A}\0A\0A/*\0A * Pop the node allocation state.\0A */\0A#ifdef YYNODESTATE_REENTRANT\0Avoid yynodepop(state__)\0AYYNODESTATE *state__;\0A{\0A#else\0Avoid yynodepop()\0A{\0A\09YYNODESTATE *state__ = &fixed_state__;\0A#endif\0A\09struct YYNODESTATE_push *push_item__;\0A\09struct YYNODESTATE_block *saved_block__;\0A\09struct YYNODESTATE_block *temp_block__;\0A\0A\09/* Pop the top of the push stack */\0A\09push_item__ = state__->push_stack__;\0A\09if(push_item__ == 0)\0A\09{\0A\09\09saved_block__ = 0;\0A\09\09state__->used__ = 0;\0A\09}\0A\09else\0A\09{\0A\09\09saved_block__ = push_item__->saved_block__;\0A\09\09state__->used__ = push_item__->saved_used__;\0A\09\09state__->push_stack__ = push_item__->next__;\0A\09}\0A\0A\09/* Free unnecessary blocks */\0A\09while(state__->blocks__ != saved_block__)\0A\09{\0A\09\09temp_block__ = state__->blocks__;\0A\09\09state__->blocks__ = temp_block__->next__;\0A\09\09free(temp_block__);\0A\09}\0A}\0A\0A/*\0A * Clear the node allocation pool completely.\0A */\0A#ifdef YYNODESTATE_REENTRANT\0Avoid yynodeclear(state__)\0AYYNODESTATE *state__;\0A{\0A#else\0Avoid yynodeclear()\0A{\0A\09YYNODESTATE *state__ = &fixed_state__;\0A#endif\0A\09struct YYNODESTATE_block *temp_block__;\0A\09while(state__->blocks__ != 0)\0A\09{\0A\09\09temp_block__ = state__->blocks__;\0A\09\09state__->blocks__ = temp_block__->next__;\0A\09\09free(temp_block__);\0A\09}\0A\09state__->push_stack__ = 0;\0A\09state__->used__ = 0;\0A}\0A\00", align 16
@.str.1 = private unnamed_addr constant [9 x i8] c"c_skel.h\00", align 1
@TreeCCSkel_c_skel_h = internal constant [124 x i8] c"typedef struct\0A{\0A\09struct YYNODESTATE_block *blocks__;\0A\09struct YYNODESTATE_push *push_stack__;\0A\09int used__;\0A\0A} YYNODESTATE;\0A\00", align 16
@.str.2 = private unnamed_addr constant [12 x i8] c"cpp_skel.cc\00", align 1
@TreeCCSkel_cpp_skel_cc = internal constant [6242 x i8] c"/*\0A * treecc node allocation routines for C++.\0A *\0A * Copyright (C) 2001  Southern Storm Software, Pty Ltd.\0A *\0A * This program is free software; you can redistribute it and/or modify\0A * it under the terms of the GNU General Public License as published by\0A * the Free Software Foundation; either version 2 of the License, or\0A * (at your option) any later version.\0A *\0A * This program is distributed in the hope that it will be useful,\0A * but WITHOUT ANY WARRANTY; without even the implied warranty of\0A * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\0A * GNU General Public License for more details.\0A *\0A * You should have received a copy of the GNU General Public License\0A * along with this program; if not, write to the Free Software\0A * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\0A *\0A * As a special exception, when this file is copied by treecc into\0A * a treecc output file, you may use that output file without restriction.\0A */\0A\0A#ifndef YYNODESTATE_BLKSIZ\0A#define\09YYNODESTATE_BLKSIZ\092048\0A#endif\0A\0A/*\0A * Types used by the allocation routines.\0A */\0Astruct YYNODESTATE_block\0A{\0A\09char data__[YYNODESTATE_BLKSIZ];\0A\09struct YYNODESTATE_block *next__;\0A\0A};\0Astruct YYNODESTATE_push\0A{\0A\09struct YYNODESTATE_push *next__;\0A\09struct YYNODESTATE_block *saved_block__;\0A\09int saved_used__;\0A};\0A\0A/*\0A * Initialize the singleton instance.\0A */\0A#ifndef YYNODESTATE_REENTRANT\0AYYNODESTATE *YYNODESTATE::state__ = 0;\0A#endif\0A\0A/*\0A * Some macro magic to determine the default alignment\0A * on this machine.  This will compile down to a constant.\0A */\0A#define\09YYNODESTATE_ALIGN_CHECK_TYPE(type,name)\09\\\0A\09struct _YYNODESTATE_align_##name { \\\0A\09\09char pad; \\\0A\09\09type field; \\\0A\09}\0A#define\09YYNODESTATE_ALIGN_FOR_TYPE(type)\09\\\0A\09((unsigned)(&(((struct _YYNODESTATE_align_##type *)0)->field)))\0A#define\09YYNODESTATE_ALIGN_MAX(a,b)\09\\\0A\09((a) > (b) ? (a) : (b))\0A#define\09YYNODESTATE_ALIGN_MAX3(a,b,c) \\\0A\09(YYNODESTATE_ALIGN_MAX((a), YYNODESTATE_ALIGN_MAX((b), (c))))\0AYYNODESTATE_ALIGN_CHECK_TYPE(int, int);\0AYYNODESTATE_ALIGN_CHECK_TYPE(long, long);\0A#if defined(WIN32) && !defined(__CYGWIN__)\0AYYNODESTATE_ALIGN_CHECK_TYPE(__int64, long_long);\0A#else\0AYYNODESTATE_ALIGN_CHECK_TYPE(long long, long_long);\0A#endif\0AYYNODESTATE_ALIGN_CHECK_TYPE(void *, void_p);\0AYYNODESTATE_ALIGN_CHECK_TYPE(float, float);\0AYYNODESTATE_ALIGN_CHECK_TYPE(double, double);\0A#define\09YYNODESTATE_ALIGNMENT\09\\\0A\09YYNODESTATE_ALIGN_MAX( \\\0A\09\09\09YYNODESTATE_ALIGN_MAX3\09\\\0A\09\09\09(YYNODESTATE_ALIGN_FOR_TYPE(int), \\\0A\09\09     YYNODESTATE_ALIGN_FOR_TYPE(long), \\\0A\09\09\09 YYNODESTATE_ALIGN_FOR_TYPE(long_long)), \\\0A  \09     YYNODESTATE_ALIGN_MAX3 \\\0A\09\09 \09(YYNODESTATE_ALIGN_FOR_TYPE(void_p), \\\0A\09\09\09 YYNODESTATE_ALIGN_FOR_TYPE(float), \\\0A\09\09\09 YYNODESTATE_ALIGN_FOR_TYPE(double)))\0A\0A/*\0A * Constructor for YYNODESTATE.\0A */\0AYYNODESTATE::YYNODESTATE()\0A{\0A\09/* Initialize the allocation state */\0A\09blocks__ = 0;\0A\09push_stack__ = 0;\0A\09used__ = 0;\0A\0A#ifndef YYNODESTATE_REENTRANT\0A\09/* Register this object as the singleton instance */\0A\09if(!state__)\0A\09{\0A\09\09state__ = this;\0A\09}\0A#endif\0A}\0A\0A/*\0A * Destructor for YYNODESTATE.\0A */\0AYYNODESTATE::~YYNODESTATE()\0A{\0A\09/* Free all node memory */\0A\09clear();\0A\0A#ifndef YYNODESTATE_REENTRANT\0A\09/* We are no longer the singleton instance */\0A\09if(state__ == this)\0A\09{\0A\09\09state__ = 0;\0A\09}\0A#endif\0A}\0A\0A#ifdef YYNODESTATE_USE_ALLOCATOR\0A\0A/*\0A * Allocate a block of memory.\0A */\0Avoid *YYNODESTATE::alloc(size_t size__)\0A{\0A\09struct YYNODESTATE_block *block__;\0A\09void *result__;\0A\0A\09/* Round the size to the next alignment boundary */\0A\09size__ = (size__ + YYNODESTATE_ALIGNMENT - 1) &\0A\09\09\09\09~(YYNODESTATE_ALIGNMENT - 1);\0A\0A\09/* Do we need to allocate a new block? */\0A\09block__ = blocks__;\0A\09if(!block__ || (used__ + size__) > YYNODESTATE_BLKSIZ)\0A\09{\0A\09\09if(size__ > YYNODESTATE_BLKSIZ)\0A\09\09{\0A\09\09\09/* The allocation is too big for the node pool */\0A\09\09\09return (void *)0;\0A\09\09}\0A\09\09block__ = new YYNODESTATE_block;\0A\09\09if(!block__)\0A\09\09{\0A\09\09\09/* The system is out of memory.  The programmer can\0A\09\09\09   inherit the \22failed\22 method to report the\0A\09\09\09   out of memory state and/or abort the program */\0A\09\09\09failed();\0A\09\09\09return (void *)0;\0A\09\09}\0A\09\09block__->next__ = blocks__;\0A\09\09blocks__ = block__;\0A\09\09used__ = 0;\0A\09}\0A\0A\09/* Allocate the memory and return it */\0A\09result__ = (void *)(block__->data__ + used__);\0A\09used__ += size__;\0A\09return result__;\0A}\0A\0A/*\0A * Deallocate a block of memory.\0A */\0Avoid YYNODESTATE::dealloc(void *ptr__, size_t size__)\0A{\0A\09/* Nothing to do for this type of node allocator */\0A}\0A\0A/*\0A * Push the node allocation state.\0A */\0Aint YYNODESTATE::push()\0A{\0A\09struct YYNODESTATE_block *saved_block__;\0A\09int saved_used__;\0A\09struct YYNODESTATE_push *push_item__;\0A\0A\09/* Save the current state of the node allocation pool */\0A\09saved_block__ = blocks__;\0A\09saved_used__ = used__;\0A\0A\09/* Allocate space for a push item */\0A\09push_item__ = (struct YYNODESTATE_push *)\0A\09\09\09alloc(sizeof(struct YYNODESTATE_push));\0A\09if(!push_item__)\0A\09{\0A\09\09return 0;\0A\09}\0A\0A\09/* Copy the saved information to the push item */\0A\09push_item__->saved_block__ = saved_block__;\0A\09push_item__->saved_used__ = saved_used__;\0A\0A\09/* Add the push item to the push stack */\0A\09push_item__->next__ = push_stack__;\0A\09push_stack__ = push_item__;\0A\09return 1;\0A}\0A\0A/*\0A * Pop the node allocation state.\0A */\0Avoid YYNODESTATE::pop()\0A{\0A\09struct YYNODESTATE_push *push_item__;\0A\09struct YYNODESTATE_block *saved_block__;\0A\09struct YYNODESTATE_block *temp_block__;\0A\0A\09/* Pop the top of the push stack */\0A\09push_item__ = push_stack__;\0A\09if(push_item__ == 0)\0A\09{\0A\09\09saved_block__ = 0;\0A\09\09used__ = 0;\0A\09}\0A\09else\0A\09{\0A\09\09saved_block__ = push_item__->saved_block__;\0A\09\09used__ = push_item__->saved_used__;\0A\09\09push_stack__ = push_item__->next__;\0A\09}\0A\0A\09/* Free unnecessary blocks */\0A\09while(blocks__ != saved_block__)\0A\09{\0A\09\09temp_block__ = blocks__;\0A\09\09blocks__ = temp_block__->next__;\0A\09\09delete temp_block__;\0A\09}\0A}\0A\0A/*\0A * Clear the node allocation pool completely.\0A */\0Avoid YYNODESTATE::clear()\0A{\0A\09struct YYNODESTATE_block *temp_block__;\0A\09while(blocks__ != 0)\0A\09{\0A\09\09temp_block__ = blocks__;\0A\09\09blocks__ = temp_block__->next__;\0A\09\09delete temp_block__;\0A\09}\0A\09push_stack__ = 0;\0A\09used__ = 0;\0A}\0A\0A#endif /* YYNODESTATE_USE_ALLOCATOR */\0A\0A/*\0A * Default implementation of functions which may be overridden.\0A */\0Avoid YYNODESTATE::failed()\0A{\0A}\0A\0A#ifdef YYNODESTATE_TRACK_LINES\0A\0Achar *YYNODESTATE::currFilename()\0A{\0A\09return (char *)0;\0A}\0A\0Along YYNODESTATE::currLinenum()\0A{\0A\09return 0;\0A}\0A\0A#endif\0A\00", align 16
@.str.3 = private unnamed_addr constant [11 x i8] c"cpp_skel.h\00", align 1
@TreeCCSkel_cpp_skel_h = internal constant [101 x i8] c"private:\0A\0A\09struct YYNODESTATE_block *blocks__;\0A\09struct YYNODESTATE_push *push_stack__;\0A\09int used__;\0A\00", align 16
@.str.4 = private unnamed_addr constant [12 x i8] c"c_gc_skel.h\00", align 1
@TreeCCSkel_c_gc_skel_h = internal constant [48 x i8] c"typedef struct\0A{\0A\09int dummy__;\0A\0A} YYNODESTATE;\0A\00", align 16
@.str.5 = private unnamed_addr constant [12 x i8] c"c_gc_skel.c\00", align 1
@TreeCCSkel_c_gc_skel_c = internal constant [2022 x i8] c"/*\0A * treecc node allocation routines for C.\0A *\0A * Copyright (C) 2003  Southern Storm Software, Pty Ltd.\0A *\0A * This program is free software; you can redistribute it and/or modify\0A * it under the terms of the GNU General Public License as published by\0A * the Free Software Foundation; either version 2 of the License, or\0A * (at your option) any later version.\0A *\0A * This program is distributed in the hope that it will be useful,\0A * but WITHOUT ANY WARRANTY; without even the implied warranty of\0A * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\0A * GNU General Public License for more details.\0A *\0A * You should have received a copy of the GNU General Public License\0A * along with this program; if not, write to the Free Software\0A * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\0A *\0A * As a special exception, when this file is copied by treecc into\0A * a treecc output file, you may use that output file without restriction.\0A */\0A\0A#include <stdlib.h>\0A#include <gc.h>\0A\0A/*\0A * Initialize the node allocation pool.\0A */\0A#ifdef YYNODESTATE_REENTRANT\0Avoid yynodeinit(state__)\0AYYNODESTATE *state__;\0A{\0A#else\0Avoid yynodeinit()\0A{\0A#endif\0A\09GC_INIT();\0A\09GC_init();\0A}\0A\0A/*\0A * Allocate a block of memory.\0A */\0A#ifdef YYNODESTATE_REENTRANT\0Avoid *yynodealloc(state__, size__)\0AYYNODESTATE *state__;\0Aunsigned int size__;\0A{\0A#else\0Avoid *yynodealloc(size__)\0Aunsigned int size__;\0A{\0A#endif\0A\09return (void *)GC_MALLOC((size_t)size__);\0A}\0A\0A/*\0A * Push the node allocation state.  Not used in the GC version.\0A */\0A#ifdef YYNODESTATE_REENTRANT\0Aint yynodepush(state__)\0AYYNODESTATE *state__;\0A{\0A#else\0Aint yynodepush()\0A{\0A#endif\0A\09return 1;\0A}\0A\0A/*\0A * Pop the node allocation state.  Not used in the GC version.\0A */\0A#ifdef YYNODESTATE_REENTRANT\0Avoid yynodepop(state__)\0AYYNODESTATE *state__;\0A{\0A#else\0Avoid yynodepop()\0A{\0A#endif\0A}\0A\0A/*\0A * Clear the node allocation pool completely.  Not used in the GC version.\0A */\0A#ifdef YYNODESTATE_REENTRANT\0Avoid yynodeclear(state__)\0AYYNODESTATE *state__;\0A{\0A#else\0Avoid yynodeclear()\0A{\0A#endif\0A}\0A\00", align 16
@.str.6 = private unnamed_addr constant [14 x i8] c"cpp_gc_skel.h\00", align 1
@TreeCCSkel_cpp_gc_skel_h = internal constant [2 x i8] c"\0A\00", align 1
@.str.7 = private unnamed_addr constant [15 x i8] c"cpp_gc_skel.cc\00", align 1
@TreeCCSkel_cpp_gc_skel_cc = internal constant [2540 x i8] c"/*\0A * treecc node allocation routines for C++.\0A *\0A * Copyright (C) 2003  Southern Storm Software, Pty Ltd.\0A *\0A * This program is free software; you can redistribute it and/or modify\0A * it under the terms of the GNU General Public License as published by\0A * the Free Software Foundation; either version 2 of the License, or\0A * (at your option) any later version.\0A *\0A * This program is distributed in the hope that it will be useful,\0A * but WITHOUT ANY WARRANTY; without even the implied warranty of\0A * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\0A * GNU General Public License for more details.\0A *\0A * You should have received a copy of the GNU General Public License\0A * along with this program; if not, write to the Free Software\0A * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\0A *\0A * As a special exception, when this file is copied by treecc into\0A * a treecc output file, you may use that output file without restriction.\0A */\0A\0A#include <gc.h>\0A\0A/*\0A * Initialize the singleton instance.\0A */\0A#ifndef YYNODESTATE_REENTRANT\0AYYNODESTATE *YYNODESTATE::state__ = 0;\0A#endif\0A\0A/*\0A * Constructor for YYNODESTATE.\0A */\0AYYNODESTATE::YYNODESTATE()\0A{\0A\09/* Initialize the garbage collector */\0A\09GC_INIT();\0A\09GC_init();\0A\0A#ifndef YYNODESTATE_REENTRANT\0A\09/* Register this object as the singleton instance */\0A\09if(!state__)\0A\09{\0A\09\09state__ = this;\0A\09}\0A#endif\0A}\0A\0A/*\0A * Destructor for YYNODESTATE.\0A */\0AYYNODESTATE::~YYNODESTATE()\0A{\0A#ifndef YYNODESTATE_REENTRANT\0A\09/* We are no longer the singleton instance */\0A\09if(state__ == this)\0A\09{\0A\09\09state__ = 0;\0A\09}\0A#endif\0A}\0A\0A#ifdef YYNODESTATE_USE_ALLOCATOR\0A\0A/*\0A * Allocate a block of memory.\0A */\0Avoid *YYNODESTATE::alloc(size_t size__)\0A{\0A\09return (void *)GC_MALLOC((size_t)size__);\0A}\0A\0A/*\0A * Deallocate a block of memory.\0A */\0Avoid YYNODESTATE::dealloc(void *ptr__, size_t size__)\0A{\0A\09/* Nothing to do for this type of node allocator */\0A}\0A\0A/*\0A * Push the node allocation state.\0A */\0Aint YYNODESTATE::push()\0A{\0A\09/* Not used with the garbage collector */\0A\09return 1;\0A}\0A\0A/*\0A * Pop the node allocation state.\0A */\0Avoid YYNODESTATE::pop()\0A{\0A\09/* Not used with the garbage collector */\0A}\0A\0A/*\0A * Clear the node allocation pool completely.\0A */\0Avoid YYNODESTATE::clear()\0A{\0A\09/* Not used with the garbage collector */\0A}\0A\0A#endif /* YYNODESTATE_USE_ALLOCATOR */\0A\0A/*\0A * Default implementation of functions which may be overridden.\0A */\0Avoid YYNODESTATE::failed()\0A{\0A}\0A\0A#ifdef YYNODESTATE_TRACK_LINES\0A\0Achar *YYNODESTATE::currFilename()\0A{\0A\09return (char *)0;\0A}\0A\0Along YYNODESTATE::currLinenum()\0A{\0A\09return 0;\0A}\0A\0A#endif\0A\00", align 16
@TreeCCSkelFiles = dso_local local_unnamed_addr constant [17 x ptr] [ptr @.str, ptr @TreeCCSkel_c_skel_c, ptr @.str.1, ptr @TreeCCSkel_c_skel_h, ptr @.str.2, ptr @TreeCCSkel_cpp_skel_cc, ptr @.str.3, ptr @TreeCCSkel_cpp_skel_h, ptr @.str.4, ptr @TreeCCSkel_c_gc_skel_h, ptr @.str.5, ptr @TreeCCSkel_c_gc_skel_c, ptr @.str.6, ptr @TreeCCSkel_cpp_gc_skel_h, ptr @.str.7, ptr @TreeCCSkel_cpp_gc_skel_cc, ptr null], align 16

!llvm.module.flags = !{!0, !1, !2, !3}
!llvm.ident = !{!4}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 8, !"PIC Level", i32 2}
!2 = !{i32 7, !"PIE Level", i32 2}
!3 = !{i32 7, !"uwtable", i32 2}
!4 = !{!"clang version 17.0.0"}

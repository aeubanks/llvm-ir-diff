; ModuleID = '/usr/local/google/home/aeubanks/repos/test-suite/SingleSource/Benchmarks/Adobe-C++/simple_types_loop_invariant.cpp'
source_filename = "/usr/local/google/home/aeubanks/repos/test-suite/SingleSource/Benchmarks/Adobe-C++/simple_types_loop_invariant.cpp"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.one_result = type { double, ptr }

$_Z14test_variable1Ia19custom_add_variableIaEEvPT_iS2_PKc = comdat any

$_Z22test_hoisted_variable1Ia19custom_add_variableIaEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Ia28custom_add_multiple_variableIaEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Ia19custom_sub_variableIaEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Ia28custom_sub_multiple_variableIaEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Ia24custom_multiply_variableIaEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Ia33custom_multiply_multiple_variableIaEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable4Ia34custom_multiply_multiple_variable2IaEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Ia22custom_divide_variableIaEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Ia31custom_divide_multiple_variableIaEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable4Ia32custom_divide_multiple_variable2IaEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable4Ia30custom_mixed_multiple_variableIaEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Ia19custom_variable_andIaEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Ia28custom_multiple_variable_andIaEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Ia18custom_variable_orIaEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Ia27custom_multiple_variable_orIaEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Ia19custom_variable_xorIaEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Ia28custom_multiple_variable_xorIaEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Ih19custom_add_variableIhEEvPT_iS2_PKc = comdat any

$_Z22test_hoisted_variable1Ih19custom_add_variableIhEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Ih28custom_add_multiple_variableIhEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Ih19custom_sub_variableIhEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Ih28custom_sub_multiple_variableIhEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Ih24custom_multiply_variableIhEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Ih33custom_multiply_multiple_variableIhEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable4Ih34custom_multiply_multiple_variable2IhEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Ih22custom_divide_variableIhEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Ih31custom_divide_multiple_variableIhEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable4Ih32custom_divide_multiple_variable2IhEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable4Ih30custom_mixed_multiple_variableIhEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Ih19custom_variable_andIhEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Ih28custom_multiple_variable_andIhEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Ih18custom_variable_orIhEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Ih27custom_multiple_variable_orIhEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Ih19custom_variable_xorIhEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Ih28custom_multiple_variable_xorIhEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Is19custom_add_variableIsEEvPT_iS2_PKc = comdat any

$_Z22test_hoisted_variable1Is19custom_add_variableIsEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Is28custom_add_multiple_variableIsEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Is19custom_sub_variableIsEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Is28custom_sub_multiple_variableIsEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Is24custom_multiply_variableIsEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Is33custom_multiply_multiple_variableIsEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable4Is34custom_multiply_multiple_variable2IsEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Is22custom_divide_variableIsEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Is31custom_divide_multiple_variableIsEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable4Is32custom_divide_multiple_variable2IsEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable4Is30custom_mixed_multiple_variableIsEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Is19custom_variable_andIsEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Is28custom_multiple_variable_andIsEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Is18custom_variable_orIsEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Is27custom_multiple_variable_orIsEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Is19custom_variable_xorIsEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Is28custom_multiple_variable_xorIsEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1It19custom_add_variableItEEvPT_iS2_PKc = comdat any

$_Z22test_hoisted_variable1It19custom_add_variableItEEvPT_iS2_PKc = comdat any

$_Z14test_variable4It28custom_add_multiple_variableItEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1It19custom_sub_variableItEEvPT_iS2_PKc = comdat any

$_Z14test_variable4It28custom_sub_multiple_variableItEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1It24custom_multiply_variableItEEvPT_iS2_PKc = comdat any

$_Z14test_variable4It33custom_multiply_multiple_variableItEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable4It34custom_multiply_multiple_variable2ItEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1It22custom_divide_variableItEEvPT_iS2_PKc = comdat any

$_Z14test_variable4It31custom_divide_multiple_variableItEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable4It32custom_divide_multiple_variable2ItEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable4It30custom_mixed_multiple_variableItEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1It19custom_variable_andItEEvPT_iS2_PKc = comdat any

$_Z14test_variable4It28custom_multiple_variable_andItEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1It18custom_variable_orItEEvPT_iS2_PKc = comdat any

$_Z14test_variable4It27custom_multiple_variable_orItEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1It19custom_variable_xorItEEvPT_iS2_PKc = comdat any

$_Z14test_variable4It28custom_multiple_variable_xorItEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Ii19custom_add_variableIiEEvPT_iS2_PKc = comdat any

$_Z22test_hoisted_variable1Ii19custom_add_variableIiEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Ii28custom_add_multiple_variableIiEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Ii19custom_sub_variableIiEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Ii28custom_sub_multiple_variableIiEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Ii24custom_multiply_variableIiEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Ii33custom_multiply_multiple_variableIiEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable4Ii34custom_multiply_multiple_variable2IiEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Ii22custom_divide_variableIiEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Ii31custom_divide_multiple_variableIiEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable4Ii32custom_divide_multiple_variable2IiEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable4Ii30custom_mixed_multiple_variableIiEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Ii19custom_variable_andIiEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Ii28custom_multiple_variable_andIiEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Ii18custom_variable_orIiEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Ii27custom_multiple_variable_orIiEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Ii19custom_variable_xorIiEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Ii28custom_multiple_variable_xorIiEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Ij19custom_add_variableIjEEvPT_iS2_PKc = comdat any

$_Z22test_hoisted_variable1Ij19custom_add_variableIjEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Ij28custom_add_multiple_variableIjEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Ij19custom_sub_variableIjEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Ij28custom_sub_multiple_variableIjEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Ij24custom_multiply_variableIjEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Ij33custom_multiply_multiple_variableIjEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable4Ij34custom_multiply_multiple_variable2IjEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Ij22custom_divide_variableIjEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Ij31custom_divide_multiple_variableIjEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable4Ij32custom_divide_multiple_variable2IjEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable4Ij30custom_mixed_multiple_variableIjEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Ij19custom_variable_andIjEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Ij28custom_multiple_variable_andIjEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Ij18custom_variable_orIjEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Ij27custom_multiple_variable_orIjEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Ij19custom_variable_xorIjEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Ij28custom_multiple_variable_xorIjEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Il19custom_add_variableIlEEvPT_iS2_PKc = comdat any

$_Z22test_hoisted_variable1Il19custom_add_variableIlEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Il28custom_add_multiple_variableIlEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Il19custom_sub_variableIlEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Il28custom_sub_multiple_variableIlEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Il24custom_multiply_variableIlEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Il33custom_multiply_multiple_variableIlEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable4Il34custom_multiply_multiple_variable2IlEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Il22custom_divide_variableIlEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Il31custom_divide_multiple_variableIlEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable4Il32custom_divide_multiple_variable2IlEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable4Il30custom_mixed_multiple_variableIlEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Il19custom_variable_andIlEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Il28custom_multiple_variable_andIlEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Il18custom_variable_orIlEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Il27custom_multiple_variable_orIlEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Il19custom_variable_xorIlEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Il28custom_multiple_variable_xorIlEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Im19custom_add_variableImEEvPT_iS2_PKc = comdat any

$_Z22test_hoisted_variable1Im19custom_add_variableImEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Im28custom_add_multiple_variableImEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Im19custom_sub_variableImEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Im28custom_sub_multiple_variableImEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Im24custom_multiply_variableImEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Im33custom_multiply_multiple_variableImEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable4Im34custom_multiply_multiple_variable2ImEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Im22custom_divide_variableImEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Im31custom_divide_multiple_variableImEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable4Im32custom_divide_multiple_variable2ImEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable4Im30custom_mixed_multiple_variableImEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Im19custom_variable_andImEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Im28custom_multiple_variable_andImEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Im18custom_variable_orImEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Im27custom_multiple_variable_orImEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Im19custom_variable_xorImEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Im28custom_multiple_variable_xorImEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1If19custom_add_variableIfEEvPT_iS2_PKc = comdat any

$_Z22test_hoisted_variable1If19custom_add_variableIfEEvPT_iS2_PKc = comdat any

$_Z14test_variable4If28custom_add_multiple_variableIfEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1If19custom_sub_variableIfEEvPT_iS2_PKc = comdat any

$_Z14test_variable4If28custom_sub_multiple_variableIfEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1If24custom_multiply_variableIfEEvPT_iS2_PKc = comdat any

$_Z14test_variable4If33custom_multiply_multiple_variableIfEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable4If34custom_multiply_multiple_variable2IfEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1If22custom_divide_variableIfEEvPT_iS2_PKc = comdat any

$_Z14test_variable4If31custom_divide_multiple_variableIfEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable4If32custom_divide_multiple_variable2IfEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable4If30custom_mixed_multiple_variableIfEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Id19custom_add_variableIdEEvPT_iS2_PKc = comdat any

$_Z22test_hoisted_variable1Id19custom_add_variableIdEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Id28custom_add_multiple_variableIdEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Id19custom_sub_variableIdEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Id28custom_sub_multiple_variableIdEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Id24custom_multiply_variableIdEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Id33custom_multiply_multiple_variableIdEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable4Id34custom_multiply_multiple_variable2IdEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Id22custom_divide_variableIdEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Id31custom_divide_multiple_variableIdEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable4Id32custom_divide_multiple_variable2IdEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable4Id30custom_mixed_multiple_variableIdEEvPT_iS2_S2_S2_S2_PKc = comdat any

@results = dso_local local_unnamed_addr global ptr null, align 8
@current_test = dso_local local_unnamed_addr global i32 0, align 4
@allocated_results = dso_local local_unnamed_addr global i32 0, align 4
@.str = private unnamed_addr constant [31 x i8] c"Could not allocate %d results\0A\00", align 1
@.str.1 = private unnamed_addr constant [60 x i8] c"\0Atest %*s description   absolute   operations   ratio with\0A\00", align 1
@.str.2 = private unnamed_addr constant [2 x i8] c" \00", align 1
@.str.3 = private unnamed_addr constant [43 x i8] c"number %*s time       per second   test0\0A\0A\00", align 1
@.str.4 = private unnamed_addr constant [43 x i8] c"%2i %*s\22%s\22  %5.2f sec   %5.2f M     %.2f\0A\00", align 1
@.str.5 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
@.str.6 = private unnamed_addr constant [39 x i8] c"\0ATotal absolute time for %s: %.2f sec\0A\00", align 1
@.str.7 = private unnamed_addr constant [20 x i8] c"\0A%s Penalty: %.2f\0A\0A\00", align 1
@.str.8 = private unnamed_addr constant [34 x i8] c"\0Atest %*s description   absolute\0A\00", align 1
@.str.9 = private unnamed_addr constant [18 x i8] c"number %*s time\0A\0A\00", align 1
@.str.10 = private unnamed_addr constant [24 x i8] c"%2i %*s\22%s\22  %5.2f sec\0A\00", align 1
@start_time = dso_local local_unnamed_addr global i64 0, align 8
@end_time = dso_local local_unnamed_addr global i64 0, align 8
@iterations = dso_local local_unnamed_addr global i32 1000, align 4
@init_value = dso_local local_unnamed_addr global double 1.000000e+00, align 8
@dataDouble = dso_local global [8000 x double] zeroinitializer, align 16
@dataFloat = dso_local global [8000 x float] zeroinitializer, align 16
@data64unsigned = dso_local global [8000 x i64] zeroinitializer, align 16
@data64 = dso_local global [8000 x i64] zeroinitializer, align 16
@data32unsigned = dso_local global [8000 x i32] zeroinitializer, align 16
@data32 = dso_local global [8000 x i32] zeroinitializer, align 16
@data16unsigned = dso_local global [8000 x i16] zeroinitializer, align 16
@data16 = dso_local global [8000 x i16] zeroinitializer, align 16
@data8unsigned = dso_local global [8000 x i8] zeroinitializer, align 16
@data8 = dso_local global [8000 x i8] zeroinitializer, align 16
@.str.11 = private unnamed_addr constant [20 x i8] c"int8_t variable add\00", align 1
@.str.12 = private unnamed_addr constant [28 x i8] c"int8_t variable add hoisted\00", align 1
@.str.13 = private unnamed_addr constant [30 x i8] c"int8_t multiple variable adds\00", align 1
@.str.14 = private unnamed_addr constant [25 x i8] c"int8_t variable subtract\00", align 1
@.str.15 = private unnamed_addr constant [35 x i8] c"int8_t multiple variable subtracts\00", align 1
@.str.16 = private unnamed_addr constant [25 x i8] c"int8_t variable multiply\00", align 1
@.str.17 = private unnamed_addr constant [36 x i8] c"int8_t multiple variable multiplies\00", align 1
@.str.18 = private unnamed_addr constant [37 x i8] c"int8_t multiple variable multiplies2\00", align 1
@.str.19 = private unnamed_addr constant [23 x i8] c"int8_t variable divide\00", align 1
@.str.20 = private unnamed_addr constant [33 x i8] c"int8_t multiple variable divides\00", align 1
@.str.21 = private unnamed_addr constant [34 x i8] c"int8_t multiple variable divides2\00", align 1
@.str.22 = private unnamed_addr constant [31 x i8] c"int8_t multiple variable mixed\00", align 1
@.str.23 = private unnamed_addr constant [20 x i8] c"int8_t variable and\00", align 1
@.str.24 = private unnamed_addr constant [29 x i8] c"int8_t multiple variable and\00", align 1
@.str.25 = private unnamed_addr constant [19 x i8] c"int8_t variable or\00", align 1
@.str.26 = private unnamed_addr constant [28 x i8] c"int8_t multiple variable or\00", align 1
@.str.27 = private unnamed_addr constant [20 x i8] c"int8_t variable xor\00", align 1
@.str.28 = private unnamed_addr constant [29 x i8] c"int8_t multiple variable xor\00", align 1
@.str.29 = private unnamed_addr constant [21 x i8] c"uint8_t variable add\00", align 1
@.str.30 = private unnamed_addr constant [29 x i8] c"uint8_t variable add hoisted\00", align 1
@.str.31 = private unnamed_addr constant [31 x i8] c"uint8_t multiple variable adds\00", align 1
@.str.32 = private unnamed_addr constant [26 x i8] c"uint8_t variable subtract\00", align 1
@.str.33 = private unnamed_addr constant [36 x i8] c"uint8_t multiple variable subtracts\00", align 1
@.str.34 = private unnamed_addr constant [26 x i8] c"uint8_t variable multiply\00", align 1
@.str.35 = private unnamed_addr constant [37 x i8] c"uint8_t multiple variable multiplies\00", align 1
@.str.36 = private unnamed_addr constant [38 x i8] c"uint8_t multiple variable multiplies2\00", align 1
@.str.37 = private unnamed_addr constant [24 x i8] c"uint8_t variable divide\00", align 1
@.str.38 = private unnamed_addr constant [34 x i8] c"uint8_t multiple variable divides\00", align 1
@.str.39 = private unnamed_addr constant [35 x i8] c"uint8_t multiple variable divides2\00", align 1
@.str.40 = private unnamed_addr constant [32 x i8] c"uint8_t multiple variable mixed\00", align 1
@.str.41 = private unnamed_addr constant [21 x i8] c"uint8_t variable and\00", align 1
@.str.42 = private unnamed_addr constant [30 x i8] c"uint8_t multiple variable and\00", align 1
@.str.43 = private unnamed_addr constant [20 x i8] c"uint8_t variable or\00", align 1
@.str.44 = private unnamed_addr constant [29 x i8] c"uint8_t multiple variable or\00", align 1
@.str.45 = private unnamed_addr constant [21 x i8] c"uint8_t variable xor\00", align 1
@.str.46 = private unnamed_addr constant [30 x i8] c"uint8_t multiple variable xor\00", align 1
@.str.47 = private unnamed_addr constant [21 x i8] c"int16_t variable add\00", align 1
@.str.48 = private unnamed_addr constant [29 x i8] c"int16_t variable add hoisted\00", align 1
@.str.49 = private unnamed_addr constant [31 x i8] c"int16_t multiple variable adds\00", align 1
@.str.50 = private unnamed_addr constant [26 x i8] c"int16_t variable subtract\00", align 1
@.str.51 = private unnamed_addr constant [36 x i8] c"int16_t multiple variable subtracts\00", align 1
@.str.52 = private unnamed_addr constant [26 x i8] c"int16_t variable multiply\00", align 1
@.str.53 = private unnamed_addr constant [37 x i8] c"int16_t multiple variable multiplies\00", align 1
@.str.54 = private unnamed_addr constant [38 x i8] c"int16_t multiple variable multiplies2\00", align 1
@.str.55 = private unnamed_addr constant [24 x i8] c"int16_t variable divide\00", align 1
@.str.56 = private unnamed_addr constant [34 x i8] c"int16_t multiple variable divides\00", align 1
@.str.57 = private unnamed_addr constant [35 x i8] c"int16_t multiple variable divides2\00", align 1
@.str.58 = private unnamed_addr constant [32 x i8] c"int16_t multiple variable mixed\00", align 1
@.str.59 = private unnamed_addr constant [21 x i8] c"int16_t variable and\00", align 1
@.str.60 = private unnamed_addr constant [30 x i8] c"int16_t multiple variable and\00", align 1
@.str.61 = private unnamed_addr constant [20 x i8] c"int16_t variable or\00", align 1
@.str.62 = private unnamed_addr constant [29 x i8] c"int16_t multiple variable or\00", align 1
@.str.63 = private unnamed_addr constant [21 x i8] c"int16_t variable xor\00", align 1
@.str.64 = private unnamed_addr constant [30 x i8] c"int16_t multiple variable xor\00", align 1
@.str.65 = private unnamed_addr constant [22 x i8] c"uint16_t variable add\00", align 1
@.str.66 = private unnamed_addr constant [30 x i8] c"uint16_t variable add hoisted\00", align 1
@.str.67 = private unnamed_addr constant [32 x i8] c"uint16_t multiple variable adds\00", align 1
@.str.68 = private unnamed_addr constant [27 x i8] c"uint16_t variable subtract\00", align 1
@.str.69 = private unnamed_addr constant [37 x i8] c"uint16_t multiple variable subtracts\00", align 1
@.str.70 = private unnamed_addr constant [27 x i8] c"uint16_t variable multiply\00", align 1
@.str.71 = private unnamed_addr constant [38 x i8] c"uint16_t multiple variable multiplies\00", align 1
@.str.72 = private unnamed_addr constant [39 x i8] c"uint16_t multiple variable multiplies2\00", align 1
@.str.73 = private unnamed_addr constant [25 x i8] c"uint16_t variable divide\00", align 1
@.str.74 = private unnamed_addr constant [35 x i8] c"uint16_t multiple variable divides\00", align 1
@.str.75 = private unnamed_addr constant [36 x i8] c"uint16_t multiple variable divides2\00", align 1
@.str.76 = private unnamed_addr constant [33 x i8] c"uint16_t multiple variable mixed\00", align 1
@.str.77 = private unnamed_addr constant [22 x i8] c"uint16_t variable and\00", align 1
@.str.78 = private unnamed_addr constant [31 x i8] c"uint16_t multiple variable and\00", align 1
@.str.79 = private unnamed_addr constant [21 x i8] c"uint16_t variable or\00", align 1
@.str.80 = private unnamed_addr constant [30 x i8] c"uint16_t multiple variable or\00", align 1
@.str.81 = private unnamed_addr constant [22 x i8] c"uint16_t variable xor\00", align 1
@.str.82 = private unnamed_addr constant [31 x i8] c"uint16_t multiple variable xor\00", align 1
@.str.83 = private unnamed_addr constant [21 x i8] c"int32_t variable add\00", align 1
@.str.84 = private unnamed_addr constant [29 x i8] c"int32_t variable add hoisted\00", align 1
@.str.85 = private unnamed_addr constant [31 x i8] c"int32_t multiple variable adds\00", align 1
@.str.86 = private unnamed_addr constant [26 x i8] c"int32_t variable subtract\00", align 1
@.str.87 = private unnamed_addr constant [36 x i8] c"int32_t multiple variable subtracts\00", align 1
@.str.88 = private unnamed_addr constant [26 x i8] c"int32_t variable multiply\00", align 1
@.str.89 = private unnamed_addr constant [37 x i8] c"int32_t multiple variable multiplies\00", align 1
@.str.90 = private unnamed_addr constant [38 x i8] c"int32_t multiple variable multiplies2\00", align 1
@.str.91 = private unnamed_addr constant [24 x i8] c"int32_t variable divide\00", align 1
@.str.92 = private unnamed_addr constant [34 x i8] c"int32_t multiple variable divides\00", align 1
@.str.93 = private unnamed_addr constant [35 x i8] c"int32_t multiple variable divides2\00", align 1
@.str.94 = private unnamed_addr constant [32 x i8] c"int32_t multiple variable mixed\00", align 1
@.str.95 = private unnamed_addr constant [21 x i8] c"int32_t variable and\00", align 1
@.str.96 = private unnamed_addr constant [30 x i8] c"int32_t multiple variable and\00", align 1
@.str.97 = private unnamed_addr constant [20 x i8] c"int32_t variable or\00", align 1
@.str.98 = private unnamed_addr constant [29 x i8] c"int32_t multiple variable or\00", align 1
@.str.99 = private unnamed_addr constant [21 x i8] c"int32_t variable xor\00", align 1
@.str.100 = private unnamed_addr constant [30 x i8] c"int32_t multiple variable xor\00", align 1
@.str.101 = private unnamed_addr constant [22 x i8] c"uint32_t variable add\00", align 1
@.str.102 = private unnamed_addr constant [30 x i8] c"uint32_t variable add hoisted\00", align 1
@.str.103 = private unnamed_addr constant [32 x i8] c"uint32_t multiple variable adds\00", align 1
@.str.104 = private unnamed_addr constant [27 x i8] c"uint32_t variable subtract\00", align 1
@.str.105 = private unnamed_addr constant [37 x i8] c"uint32_t multiple variable subtracts\00", align 1
@.str.106 = private unnamed_addr constant [27 x i8] c"uint32_t variable multiply\00", align 1
@.str.107 = private unnamed_addr constant [38 x i8] c"uint32_t multiple variable multiplies\00", align 1
@.str.108 = private unnamed_addr constant [39 x i8] c"uint32_t multiple variable multiplies2\00", align 1
@.str.109 = private unnamed_addr constant [25 x i8] c"uint32_t variable divide\00", align 1
@.str.110 = private unnamed_addr constant [35 x i8] c"uint32_t multiple variable divides\00", align 1
@.str.111 = private unnamed_addr constant [36 x i8] c"uint32_t multiple variable divides2\00", align 1
@.str.112 = private unnamed_addr constant [33 x i8] c"uint32_t multiple variable mixed\00", align 1
@.str.113 = private unnamed_addr constant [22 x i8] c"uint32_t variable and\00", align 1
@.str.114 = private unnamed_addr constant [31 x i8] c"uint32_t multiple variable and\00", align 1
@.str.115 = private unnamed_addr constant [21 x i8] c"uint32_t variable or\00", align 1
@.str.116 = private unnamed_addr constant [30 x i8] c"uint32_t multiple variable or\00", align 1
@.str.117 = private unnamed_addr constant [22 x i8] c"uint32_t variable xor\00", align 1
@.str.118 = private unnamed_addr constant [31 x i8] c"uint32_t multiple variable xor\00", align 1
@.str.119 = private unnamed_addr constant [21 x i8] c"int64_t variable add\00", align 1
@.str.120 = private unnamed_addr constant [29 x i8] c"int64_t variable add hoisted\00", align 1
@.str.121 = private unnamed_addr constant [31 x i8] c"int64_t multiple variable adds\00", align 1
@.str.122 = private unnamed_addr constant [26 x i8] c"int64_t variable subtract\00", align 1
@.str.123 = private unnamed_addr constant [36 x i8] c"int64_t multiple variable subtracts\00", align 1
@.str.124 = private unnamed_addr constant [26 x i8] c"int64_t variable multiply\00", align 1
@.str.125 = private unnamed_addr constant [37 x i8] c"int64_t multiple variable multiplies\00", align 1
@.str.126 = private unnamed_addr constant [38 x i8] c"int64_t multiple variable multiplies2\00", align 1
@.str.127 = private unnamed_addr constant [24 x i8] c"int64_t variable divide\00", align 1
@.str.128 = private unnamed_addr constant [34 x i8] c"int64_t multiple variable divides\00", align 1
@.str.129 = private unnamed_addr constant [35 x i8] c"int64_t multiple variable divides2\00", align 1
@.str.130 = private unnamed_addr constant [32 x i8] c"int64_t multiple variable mixed\00", align 1
@.str.131 = private unnamed_addr constant [21 x i8] c"int64_t variable and\00", align 1
@.str.132 = private unnamed_addr constant [30 x i8] c"int64_t multiple variable and\00", align 1
@.str.133 = private unnamed_addr constant [20 x i8] c"int64_t variable or\00", align 1
@.str.134 = private unnamed_addr constant [29 x i8] c"int64_t multiple variable or\00", align 1
@.str.135 = private unnamed_addr constant [21 x i8] c"int64_t variable xor\00", align 1
@.str.136 = private unnamed_addr constant [30 x i8] c"int64_t multiple variable xor\00", align 1
@.str.137 = private unnamed_addr constant [22 x i8] c"uint64_t variable add\00", align 1
@.str.138 = private unnamed_addr constant [30 x i8] c"uint64_t variable add hoisted\00", align 1
@.str.139 = private unnamed_addr constant [32 x i8] c"uint64_t multiple variable adds\00", align 1
@.str.140 = private unnamed_addr constant [27 x i8] c"uint64_t variable subtract\00", align 1
@.str.141 = private unnamed_addr constant [37 x i8] c"uint64_t multiple variable subtracts\00", align 1
@.str.142 = private unnamed_addr constant [27 x i8] c"uint64_t variable multiply\00", align 1
@.str.143 = private unnamed_addr constant [38 x i8] c"uint64_t multiple variable multiplies\00", align 1
@.str.144 = private unnamed_addr constant [39 x i8] c"uint64_t multiple variable multiplies2\00", align 1
@.str.145 = private unnamed_addr constant [25 x i8] c"uint64_t variable divide\00", align 1
@.str.146 = private unnamed_addr constant [35 x i8] c"uint64_t multiple variable divides\00", align 1
@.str.147 = private unnamed_addr constant [36 x i8] c"uint64_t multiple variable divides2\00", align 1
@.str.148 = private unnamed_addr constant [33 x i8] c"uint64_t multiple variable mixed\00", align 1
@.str.149 = private unnamed_addr constant [22 x i8] c"uint64_t variable and\00", align 1
@.str.150 = private unnamed_addr constant [31 x i8] c"uint64_t multiple variable and\00", align 1
@.str.151 = private unnamed_addr constant [21 x i8] c"uint64_t variable or\00", align 1
@.str.152 = private unnamed_addr constant [30 x i8] c"uint64_t multiple variable or\00", align 1
@.str.153 = private unnamed_addr constant [22 x i8] c"uint64_t variable xor\00", align 1
@.str.154 = private unnamed_addr constant [31 x i8] c"uint64_t multiple variable xor\00", align 1
@.str.155 = private unnamed_addr constant [19 x i8] c"float variable add\00", align 1
@.str.156 = private unnamed_addr constant [27 x i8] c"float variable add hoisted\00", align 1
@.str.157 = private unnamed_addr constant [29 x i8] c"float multiple variable adds\00", align 1
@.str.158 = private unnamed_addr constant [24 x i8] c"float variable subtract\00", align 1
@.str.159 = private unnamed_addr constant [34 x i8] c"float multiple variable subtracts\00", align 1
@.str.160 = private unnamed_addr constant [24 x i8] c"float variable multiply\00", align 1
@.str.161 = private unnamed_addr constant [35 x i8] c"float multiple variable multiplies\00", align 1
@.str.162 = private unnamed_addr constant [36 x i8] c"float multiple variable multiplies2\00", align 1
@.str.163 = private unnamed_addr constant [22 x i8] c"float variable divide\00", align 1
@.str.164 = private unnamed_addr constant [32 x i8] c"float multiple variable divides\00", align 1
@.str.165 = private unnamed_addr constant [33 x i8] c"float multiple variable divides2\00", align 1
@.str.166 = private unnamed_addr constant [30 x i8] c"float multiple variable mixed\00", align 1
@.str.167 = private unnamed_addr constant [20 x i8] c"double variable add\00", align 1
@.str.168 = private unnamed_addr constant [28 x i8] c"double variable add hoisted\00", align 1
@.str.169 = private unnamed_addr constant [30 x i8] c"double multiple variable adds\00", align 1
@.str.170 = private unnamed_addr constant [25 x i8] c"double variable subtract\00", align 1
@.str.171 = private unnamed_addr constant [35 x i8] c"double multiple variable subtracts\00", align 1
@.str.172 = private unnamed_addr constant [25 x i8] c"double variable multiply\00", align 1
@.str.173 = private unnamed_addr constant [36 x i8] c"double multiple variable multiplies\00", align 1
@.str.174 = private unnamed_addr constant [37 x i8] c"double multiple variable multiplies2\00", align 1
@.str.175 = private unnamed_addr constant [23 x i8] c"double variable divide\00", align 1
@.str.176 = private unnamed_addr constant [33 x i8] c"double multiple variable divides\00", align 1
@.str.177 = private unnamed_addr constant [34 x i8] c"double multiple variable divides2\00", align 1
@.str.178 = private unnamed_addr constant [31 x i8] c"double multiple variable mixed\00", align 1
@.str.179 = private unnamed_addr constant [16 x i8] c"test %i failed\0A\00", align 1

; Function Attrs: mustprogress nounwind uwtable
define dso_local void @_Z13record_resultdPKc(double noundef %0, ptr noundef %1) local_unnamed_addr #0 {
  %3 = load ptr, ptr @results, align 8, !tbaa !5
  %4 = icmp eq ptr %3, null
  br i1 %4, label %5, label %7

5:                                                ; preds = %2
  %6 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %11

7:                                                ; preds = %2
  %8 = load i32, ptr @current_test, align 4, !tbaa !9
  %9 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %10 = icmp slt i32 %8, %9
  br i1 %10, label %23, label %11

11:                                               ; preds = %5, %7
  %12 = phi i32 [ %6, %5 ], [ %9, %7 ]
  %13 = add nsw i32 %12, 10
  store i32 %13, ptr @allocated_results, align 4, !tbaa !9
  %14 = sext i32 %13 to i64
  %15 = shl nsw i64 %14, 4
  %16 = tail call ptr @realloc(ptr noundef %3, i64 noundef %15) #14
  store ptr %16, ptr @results, align 8, !tbaa !5
  %17 = icmp eq ptr %16, null
  br i1 %17, label %20, label %18

18:                                               ; preds = %11
  %19 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %23

20:                                               ; preds = %11
  %21 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %22 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %21)
  tail call void @exit(i32 noundef -1) #15
  unreachable

23:                                               ; preds = %18, %7
  %24 = phi i32 [ %19, %18 ], [ %8, %7 ]
  %25 = phi ptr [ %16, %18 ], [ %3, %7 ]
  %26 = sext i32 %24 to i64
  %27 = getelementptr inbounds %struct.one_result, ptr %25, i64 %26
  store double %0, ptr %27, align 8, !tbaa !11
  %28 = getelementptr inbounds %struct.one_result, ptr %25, i64 %26, i32 1
  store ptr %1, ptr %28, align 8, !tbaa !14
  %29 = add nsw i32 %24, 1
  store i32 %29, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress nounwind willreturn allockind("realloc") allocsize(1) memory(argmem: readwrite, inaccessiblemem: readwrite)
declare noalias noundef ptr @realloc(ptr allocptr nocapture noundef, i64 noundef) local_unnamed_addr #1

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #2

; Function Attrs: noreturn nounwind
declare void @exit(i32 noundef) local_unnamed_addr #3

; Function Attrs: mustprogress nofree nounwind uwtable
define dso_local void @_Z9summarizePKciiii(ptr noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3, i32 noundef %4) local_unnamed_addr #4 {
  %6 = sitofp i32 %1 to double
  %7 = sitofp i32 %2 to double
  %8 = fmul double %6, %7
  %9 = fdiv double %8, 1.000000e+06
  %10 = load i32, ptr @current_test, align 4, !tbaa !9
  %11 = icmp sgt i32 %10, 0
  br i1 %11, label %12, label %25

12:                                               ; preds = %5
  %13 = load ptr, ptr @results, align 8, !tbaa !5
  %14 = zext i32 %10 to i64
  br label %15

15:                                               ; preds = %12, %15
  %16 = phi i64 [ 0, %12 ], [ %23, %15 ]
  %17 = phi i32 [ 12, %12 ], [ %22, %15 ]
  %18 = getelementptr inbounds %struct.one_result, ptr %13, i64 %16, i32 1
  %19 = load ptr, ptr %18, align 8, !tbaa !14
  %20 = tail call i64 @strlen(ptr noundef nonnull dereferenceable(1) %19) #16
  %21 = trunc i64 %20 to i32
  %22 = tail call i32 @llvm.smax.i32(i32 %17, i32 %21)
  %23 = add nuw nsw i64 %16, 1
  %24 = icmp eq i64 %23, %14
  br i1 %24, label %25, label %15, !llvm.loop !15

25:                                               ; preds = %15, %5
  %26 = phi i32 [ 12, %5 ], [ %22, %15 ]
  %27 = add nsw i32 %26, -12
  %28 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.1, i32 noundef %27, ptr noundef nonnull @.str.2)
  %29 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.3, i32 noundef %26, ptr noundef nonnull @.str.2)
  %30 = load i32, ptr @current_test, align 4, !tbaa !9
  %31 = icmp sgt i32 %30, 0
  br i1 %31, label %41, label %97

32:                                               ; preds = %41
  %33 = icmp sgt i32 %57, 0
  br i1 %33, label %34, label %97

34:                                               ; preds = %32
  %35 = load ptr, ptr @results, align 8, !tbaa !5
  %36 = zext i32 %57 to i64
  %37 = and i64 %36, 3
  %38 = icmp ult i32 %57, 4
  br i1 %38, label %82, label %39

39:                                               ; preds = %34
  %40 = and i64 %36, 4294967292
  br label %60

41:                                               ; preds = %25, %41
  %42 = phi i64 [ %56, %41 ], [ 0, %25 ]
  %43 = load ptr, ptr @results, align 8, !tbaa !5
  %44 = getelementptr inbounds %struct.one_result, ptr %43, i64 %42
  %45 = getelementptr inbounds %struct.one_result, ptr %43, i64 %42, i32 1
  %46 = load ptr, ptr %45, align 8, !tbaa !14
  %47 = tail call i64 @strlen(ptr noundef nonnull dereferenceable(1) %46) #16
  %48 = trunc i64 %47 to i32
  %49 = sub i32 %26, %48
  %50 = load double, ptr %44, align 8, !tbaa !11
  %51 = fdiv double %9, %50
  %52 = load double, ptr %43, align 8, !tbaa !11
  %53 = fdiv double %50, %52
  %54 = trunc i64 %42 to i32
  %55 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.4, i32 noundef %54, i32 noundef %49, ptr noundef nonnull @.str.5, ptr noundef %46, double noundef %50, double noundef %51, double noundef %53)
  %56 = add nuw nsw i64 %42, 1
  %57 = load i32, ptr @current_test, align 4, !tbaa !9
  %58 = sext i32 %57 to i64
  %59 = icmp slt i64 %56, %58
  br i1 %59, label %41, label %32, !llvm.loop !17

60:                                               ; preds = %60, %39
  %61 = phi i64 [ 0, %39 ], [ %79, %60 ]
  %62 = phi double [ 0.000000e+00, %39 ], [ %78, %60 ]
  %63 = phi i64 [ 0, %39 ], [ %80, %60 ]
  %64 = getelementptr inbounds %struct.one_result, ptr %35, i64 %61
  %65 = load double, ptr %64, align 8, !tbaa !11
  %66 = fadd double %62, %65
  %67 = or i64 %61, 1
  %68 = getelementptr inbounds %struct.one_result, ptr %35, i64 %67
  %69 = load double, ptr %68, align 8, !tbaa !11
  %70 = fadd double %66, %69
  %71 = or i64 %61, 2
  %72 = getelementptr inbounds %struct.one_result, ptr %35, i64 %71
  %73 = load double, ptr %72, align 8, !tbaa !11
  %74 = fadd double %70, %73
  %75 = or i64 %61, 3
  %76 = getelementptr inbounds %struct.one_result, ptr %35, i64 %75
  %77 = load double, ptr %76, align 8, !tbaa !11
  %78 = fadd double %74, %77
  %79 = add nuw nsw i64 %61, 4
  %80 = add i64 %63, 4
  %81 = icmp eq i64 %80, %40
  br i1 %81, label %82, label %60, !llvm.loop !18

82:                                               ; preds = %60, %34
  %83 = phi double [ undef, %34 ], [ %78, %60 ]
  %84 = phi i64 [ 0, %34 ], [ %79, %60 ]
  %85 = phi double [ 0.000000e+00, %34 ], [ %78, %60 ]
  %86 = icmp eq i64 %37, 0
  br i1 %86, label %97, label %87

87:                                               ; preds = %82, %87
  %88 = phi i64 [ %94, %87 ], [ %84, %82 ]
  %89 = phi double [ %93, %87 ], [ %85, %82 ]
  %90 = phi i64 [ %95, %87 ], [ 0, %82 ]
  %91 = getelementptr inbounds %struct.one_result, ptr %35, i64 %88
  %92 = load double, ptr %91, align 8, !tbaa !11
  %93 = fadd double %89, %92
  %94 = add nuw nsw i64 %88, 1
  %95 = add i64 %90, 1
  %96 = icmp eq i64 %95, %37
  br i1 %96, label %97, label %87, !llvm.loop !19

97:                                               ; preds = %82, %87, %25, %32
  %98 = phi double [ 0.000000e+00, %32 ], [ 0.000000e+00, %25 ], [ %83, %82 ], [ %93, %87 ]
  %99 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.6, ptr noundef %0, double noundef %98)
  %100 = load i32, ptr @current_test, align 4, !tbaa !9
  %101 = icmp sgt i32 %100, 1
  %102 = icmp ne i32 %4, 0
  %103 = and i1 %102, %101
  br i1 %103, label %104, label %124

104:                                              ; preds = %97, %104
  %105 = phi i64 [ %114, %104 ], [ 1, %97 ]
  %106 = phi double [ %113, %104 ], [ 0.000000e+00, %97 ]
  %107 = load ptr, ptr @results, align 8, !tbaa !5
  %108 = getelementptr inbounds %struct.one_result, ptr %107, i64 %105
  %109 = load double, ptr %108, align 8, !tbaa !11
  %110 = load double, ptr %107, align 8, !tbaa !11
  %111 = fdiv double %109, %110
  %112 = tail call double @log(double noundef %111) #17
  %113 = fadd double %106, %112
  %114 = add nuw nsw i64 %105, 1
  %115 = load i32, ptr @current_test, align 4, !tbaa !9
  %116 = sext i32 %115 to i64
  %117 = icmp slt i64 %114, %116
  br i1 %117, label %104, label %118, !llvm.loop !21

118:                                              ; preds = %104
  %119 = add nsw i32 %115, -1
  %120 = sitofp i32 %119 to double
  %121 = fdiv double %113, %120
  %122 = tail call double @exp(double noundef %121) #17
  %123 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.7, ptr noundef %0, double noundef %122)
  br label %124

124:                                              ; preds = %118, %97
  store i32 0, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress nofree nounwind willreturn memory(argmem: read)
declare i64 @strlen(ptr nocapture noundef) local_unnamed_addr #5

; Function Attrs: mustprogress nofree nounwind willreturn memory(write)
declare double @log(double noundef) local_unnamed_addr #6

; Function Attrs: mustprogress nofree nounwind willreturn memory(write)
declare double @exp(double noundef) local_unnamed_addr #6

; Function Attrs: mustprogress nofree nounwind uwtable
define dso_local void @_Z17summarize_simplefP8_IO_FILEPKc(ptr nocapture noundef %0, ptr noundef %1) local_unnamed_addr #4 {
  %3 = load i32, ptr @current_test, align 4, !tbaa !9
  %4 = icmp sgt i32 %3, 0
  br i1 %4, label %5, label %18

5:                                                ; preds = %2
  %6 = load ptr, ptr @results, align 8, !tbaa !5
  %7 = zext i32 %3 to i64
  br label %8

8:                                                ; preds = %5, %8
  %9 = phi i64 [ 0, %5 ], [ %16, %8 ]
  %10 = phi i32 [ 12, %5 ], [ %15, %8 ]
  %11 = getelementptr inbounds %struct.one_result, ptr %6, i64 %9, i32 1
  %12 = load ptr, ptr %11, align 8, !tbaa !14
  %13 = tail call i64 @strlen(ptr noundef nonnull dereferenceable(1) %12) #16
  %14 = trunc i64 %13 to i32
  %15 = tail call i32 @llvm.smax.i32(i32 %10, i32 %14)
  %16 = add nuw nsw i64 %9, 1
  %17 = icmp eq i64 %16, %7
  br i1 %17, label %18, label %8, !llvm.loop !22

18:                                               ; preds = %8, %2
  %19 = phi i32 [ 12, %2 ], [ %15, %8 ]
  %20 = add nsw i32 %19, -12
  %21 = tail call i32 (ptr, ptr, ...) @fprintf(ptr noundef %0, ptr noundef nonnull @.str.8, i32 noundef %20, ptr noundef nonnull @.str.2)
  %22 = tail call i32 (ptr, ptr, ...) @fprintf(ptr noundef %0, ptr noundef nonnull @.str.9, i32 noundef %19, ptr noundef nonnull @.str.2)
  %23 = load i32, ptr @current_test, align 4, !tbaa !9
  %24 = icmp sgt i32 %23, 0
  br i1 %24, label %34, label %87

25:                                               ; preds = %34
  %26 = icmp sgt i32 %47, 0
  br i1 %26, label %27, label %87

27:                                               ; preds = %25
  %28 = load ptr, ptr @results, align 8, !tbaa !5
  %29 = zext i32 %47 to i64
  %30 = and i64 %29, 3
  %31 = icmp ult i32 %47, 4
  br i1 %31, label %72, label %32

32:                                               ; preds = %27
  %33 = and i64 %29, 4294967292
  br label %50

34:                                               ; preds = %18, %34
  %35 = phi i64 [ %46, %34 ], [ 0, %18 ]
  %36 = load ptr, ptr @results, align 8, !tbaa !5
  %37 = getelementptr inbounds %struct.one_result, ptr %36, i64 %35
  %38 = getelementptr inbounds %struct.one_result, ptr %36, i64 %35, i32 1
  %39 = load ptr, ptr %38, align 8, !tbaa !14
  %40 = tail call i64 @strlen(ptr noundef nonnull dereferenceable(1) %39) #16
  %41 = trunc i64 %40 to i32
  %42 = sub i32 %19, %41
  %43 = load double, ptr %37, align 8, !tbaa !11
  %44 = trunc i64 %35 to i32
  %45 = tail call i32 (ptr, ptr, ...) @fprintf(ptr noundef %0, ptr noundef nonnull @.str.10, i32 noundef %44, i32 noundef %42, ptr noundef nonnull @.str.5, ptr noundef %39, double noundef %43)
  %46 = add nuw nsw i64 %35, 1
  %47 = load i32, ptr @current_test, align 4, !tbaa !9
  %48 = sext i32 %47 to i64
  %49 = icmp slt i64 %46, %48
  br i1 %49, label %34, label %25, !llvm.loop !23

50:                                               ; preds = %50, %32
  %51 = phi i64 [ 0, %32 ], [ %69, %50 ]
  %52 = phi double [ 0.000000e+00, %32 ], [ %68, %50 ]
  %53 = phi i64 [ 0, %32 ], [ %70, %50 ]
  %54 = getelementptr inbounds %struct.one_result, ptr %28, i64 %51
  %55 = load double, ptr %54, align 8, !tbaa !11
  %56 = fadd double %52, %55
  %57 = or i64 %51, 1
  %58 = getelementptr inbounds %struct.one_result, ptr %28, i64 %57
  %59 = load double, ptr %58, align 8, !tbaa !11
  %60 = fadd double %56, %59
  %61 = or i64 %51, 2
  %62 = getelementptr inbounds %struct.one_result, ptr %28, i64 %61
  %63 = load double, ptr %62, align 8, !tbaa !11
  %64 = fadd double %60, %63
  %65 = or i64 %51, 3
  %66 = getelementptr inbounds %struct.one_result, ptr %28, i64 %65
  %67 = load double, ptr %66, align 8, !tbaa !11
  %68 = fadd double %64, %67
  %69 = add nuw nsw i64 %51, 4
  %70 = add i64 %53, 4
  %71 = icmp eq i64 %70, %33
  br i1 %71, label %72, label %50, !llvm.loop !24

72:                                               ; preds = %50, %27
  %73 = phi double [ undef, %27 ], [ %68, %50 ]
  %74 = phi i64 [ 0, %27 ], [ %69, %50 ]
  %75 = phi double [ 0.000000e+00, %27 ], [ %68, %50 ]
  %76 = icmp eq i64 %30, 0
  br i1 %76, label %87, label %77

77:                                               ; preds = %72, %77
  %78 = phi i64 [ %84, %77 ], [ %74, %72 ]
  %79 = phi double [ %83, %77 ], [ %75, %72 ]
  %80 = phi i64 [ %85, %77 ], [ 0, %72 ]
  %81 = getelementptr inbounds %struct.one_result, ptr %28, i64 %78
  %82 = load double, ptr %81, align 8, !tbaa !11
  %83 = fadd double %79, %82
  %84 = add nuw nsw i64 %78, 1
  %85 = add i64 %80, 1
  %86 = icmp eq i64 %85, %30
  br i1 %86, label %87, label %77, !llvm.loop !25

87:                                               ; preds = %72, %77, %18, %25
  %88 = phi double [ 0.000000e+00, %25 ], [ 0.000000e+00, %18 ], [ %73, %72 ], [ %83, %77 ]
  %89 = tail call i32 (ptr, ptr, ...) @fprintf(ptr noundef %0, ptr noundef nonnull @.str.6, ptr noundef %1, double noundef %88)
  store i32 0, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @fprintf(ptr nocapture noundef, ptr nocapture noundef readonly, ...) local_unnamed_addr #2

; Function Attrs: mustprogress nounwind uwtable
define dso_local void @_Z11start_timerv() local_unnamed_addr #0 {
  %1 = tail call i64 @clock() #17
  store i64 %1, ptr @start_time, align 8, !tbaa !26
  ret void
}

; Function Attrs: nounwind
declare i64 @clock() local_unnamed_addr #7

; Function Attrs: mustprogress nounwind uwtable
define dso_local noundef double @_Z5timerv() local_unnamed_addr #0 {
  %1 = tail call i64 @clock() #17
  store i64 %1, ptr @end_time, align 8, !tbaa !26
  %2 = load i64, ptr @start_time, align 8, !tbaa !26
  %3 = sub nsw i64 %1, %2
  %4 = sitofp i64 %3 to double
  %5 = fdiv double %4, 1.000000e+06
  ret double %5
}

; Function Attrs: mustprogress norecurse uwtable
define dso_local noundef i32 @main(i32 noundef %0, ptr nocapture noundef readonly %1) local_unnamed_addr #8 {
  %3 = icmp sgt i32 %0, 1
  br i1 %3, label %4, label %19

4:                                                ; preds = %2
  %5 = getelementptr inbounds ptr, ptr %1, i64 1
  %6 = load ptr, ptr %5, align 8, !tbaa !5
  %7 = tail call i64 @strtol(ptr nocapture noundef nonnull %6, ptr noundef null, i32 noundef 10) #17
  %8 = trunc i64 %7 to i32
  store i32 %8, ptr @iterations, align 4, !tbaa !9
  %9 = icmp eq i32 %0, 2
  br i1 %9, label %19, label %10

10:                                               ; preds = %4
  %11 = getelementptr inbounds ptr, ptr %1, i64 2
  %12 = load ptr, ptr %11, align 8, !tbaa !5
  %13 = tail call double @strtod(ptr nocapture noundef nonnull %12, ptr noundef null) #17
  store double %13, ptr @init_value, align 8, !tbaa !28
  %14 = icmp ugt i32 %0, 3
  br i1 %14, label %15, label %19

15:                                               ; preds = %10
  %16 = getelementptr inbounds ptr, ptr %1, i64 3
  %17 = load ptr, ptr %16, align 8, !tbaa !5
  %18 = tail call double @strtod(ptr nocapture noundef nonnull %17, ptr noundef null) #17
  br label %19

19:                                               ; preds = %2, %4, %15, %10
  %20 = phi double [ %18, %15 ], [ 1.000000e+00, %10 ], [ 1.000000e+00, %4 ], [ 1.000000e+00, %2 ]
  %21 = load double, ptr @init_value, align 8, !tbaa !28
  %22 = fptosi double %21 to i8
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 16 dereferenceable(8000) @data8, i8 %22, i64 8000, i1 false), !tbaa !29
  %23 = fptosi double %20 to i8
  %24 = shl i8 %23, 1
  %25 = add i8 %23, 2
  %26 = sext i8 %24 to i16
  %27 = sext i8 %25 to i16
  %28 = sdiv i16 %26, %27
  %29 = trunc i16 %28 to i8
  %30 = add i8 %29, %23
  tail call void @_Z14test_variable1Ia19custom_add_variableIaEEvPT_iS2_PKc(ptr noundef nonnull @data8, i32 noundef 8000, i8 noundef signext %23, ptr noundef nonnull @.str.11)
  tail call void @_Z22test_hoisted_variable1Ia19custom_add_variableIaEEvPT_iS2_PKc(ptr noundef nonnull @data8, i32 noundef 8000, i8 noundef signext %23, ptr noundef nonnull @.str.12)
  tail call void @_Z14test_variable4Ia28custom_add_multiple_variableIaEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data8, i32 noundef 8000, i8 noundef signext %23, i8 noundef signext %24, i8 noundef signext %25, i8 noundef signext %30, ptr noundef nonnull @.str.13)
  tail call void @_Z14test_variable1Ia19custom_sub_variableIaEEvPT_iS2_PKc(ptr noundef nonnull @data8, i32 noundef 8000, i8 noundef signext %23, ptr noundef nonnull @.str.14)
  tail call void @_Z14test_variable4Ia28custom_sub_multiple_variableIaEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data8, i32 noundef 8000, i8 noundef signext %23, i8 noundef signext %24, i8 noundef signext %25, i8 noundef signext %30, ptr noundef nonnull @.str.15)
  tail call void @_Z14test_variable1Ia24custom_multiply_variableIaEEvPT_iS2_PKc(ptr noundef nonnull @data8, i32 noundef 8000, i8 noundef signext %23, ptr noundef nonnull @.str.16)
  tail call void @_Z14test_variable4Ia33custom_multiply_multiple_variableIaEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data8, i32 noundef 8000, i8 noundef signext %23, i8 noundef signext %24, i8 noundef signext %25, i8 noundef signext %30, ptr noundef nonnull @.str.17)
  tail call void @_Z14test_variable4Ia34custom_multiply_multiple_variable2IaEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data8, i32 noundef 8000, i8 noundef signext %23, i8 noundef signext %24, i8 noundef signext %25, i8 noundef signext %30, ptr noundef nonnull @.str.18)
  tail call void @_Z14test_variable1Ia22custom_divide_variableIaEEvPT_iS2_PKc(ptr noundef nonnull @data8, i32 noundef 8000, i8 noundef signext %23, ptr noundef nonnull @.str.19)
  tail call void @_Z14test_variable4Ia31custom_divide_multiple_variableIaEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data8, i32 noundef 8000, i8 noundef signext %23, i8 noundef signext %24, i8 noundef signext %25, i8 noundef signext %30, ptr noundef nonnull @.str.20)
  tail call void @_Z14test_variable4Ia32custom_divide_multiple_variable2IaEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data8, i32 noundef 8000, i8 noundef signext %23, i8 noundef signext %24, i8 noundef signext %25, i8 noundef signext %30, ptr noundef nonnull @.str.21)
  tail call void @_Z14test_variable4Ia30custom_mixed_multiple_variableIaEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data8, i32 noundef 8000, i8 noundef signext %23, i8 noundef signext %24, i8 noundef signext %25, i8 noundef signext %30, ptr noundef nonnull @.str.22)
  tail call void @_Z14test_variable1Ia19custom_variable_andIaEEvPT_iS2_PKc(ptr noundef nonnull @data8, i32 noundef 8000, i8 noundef signext %23, ptr noundef nonnull @.str.23)
  tail call void @_Z14test_variable4Ia28custom_multiple_variable_andIaEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data8, i32 noundef 8000, i8 noundef signext %23, i8 noundef signext %24, i8 noundef signext %25, i8 noundef signext %30, ptr noundef nonnull @.str.24)
  tail call void @_Z14test_variable1Ia18custom_variable_orIaEEvPT_iS2_PKc(ptr noundef nonnull @data8, i32 noundef 8000, i8 noundef signext %23, ptr noundef nonnull @.str.25)
  tail call void @_Z14test_variable4Ia27custom_multiple_variable_orIaEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data8, i32 noundef 8000, i8 noundef signext %23, i8 noundef signext %24, i8 noundef signext %25, i8 noundef signext %30, ptr noundef nonnull @.str.26)
  tail call void @_Z14test_variable1Ia19custom_variable_xorIaEEvPT_iS2_PKc(ptr noundef nonnull @data8, i32 noundef 8000, i8 noundef signext %23, ptr noundef nonnull @.str.27)
  tail call void @_Z14test_variable4Ia28custom_multiple_variable_xorIaEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data8, i32 noundef 8000, i8 noundef signext %23, i8 noundef signext %24, i8 noundef signext %25, i8 noundef signext %30, ptr noundef nonnull @.str.28)
  %31 = load double, ptr @init_value, align 8, !tbaa !28
  %32 = fptoui double %31 to i8
  tail call void @llvm.memset.p0.i64(ptr noundef nonnull align 16 dereferenceable(8000) @data8unsigned, i8 %32, i64 8000, i1 false), !tbaa !29
  %33 = fptoui double %20 to i8
  %34 = shl i8 %33, 1
  %35 = add i8 %33, 2
  %36 = udiv i8 %34, %35
  %37 = add i8 %36, %33
  tail call void @_Z14test_variable1Ih19custom_add_variableIhEEvPT_iS2_PKc(ptr noundef nonnull @data8unsigned, i32 noundef 8000, i8 noundef zeroext %33, ptr noundef nonnull @.str.29)
  tail call void @_Z22test_hoisted_variable1Ih19custom_add_variableIhEEvPT_iS2_PKc(ptr noundef nonnull @data8unsigned, i32 noundef 8000, i8 noundef zeroext %33, ptr noundef nonnull @.str.30)
  tail call void @_Z14test_variable4Ih28custom_add_multiple_variableIhEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data8unsigned, i32 noundef 8000, i8 noundef zeroext %33, i8 noundef zeroext %34, i8 noundef zeroext %35, i8 noundef zeroext %37, ptr noundef nonnull @.str.31)
  tail call void @_Z14test_variable1Ih19custom_sub_variableIhEEvPT_iS2_PKc(ptr noundef nonnull @data8unsigned, i32 noundef 8000, i8 noundef zeroext %33, ptr noundef nonnull @.str.32)
  tail call void @_Z14test_variable4Ih28custom_sub_multiple_variableIhEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data8unsigned, i32 noundef 8000, i8 noundef zeroext %33, i8 noundef zeroext %34, i8 noundef zeroext %35, i8 noundef zeroext %37, ptr noundef nonnull @.str.33)
  tail call void @_Z14test_variable1Ih24custom_multiply_variableIhEEvPT_iS2_PKc(ptr noundef nonnull @data8unsigned, i32 noundef 8000, i8 noundef zeroext %33, ptr noundef nonnull @.str.34)
  tail call void @_Z14test_variable4Ih33custom_multiply_multiple_variableIhEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data8unsigned, i32 noundef 8000, i8 noundef zeroext %33, i8 noundef zeroext %34, i8 noundef zeroext %35, i8 noundef zeroext %37, ptr noundef nonnull @.str.35)
  tail call void @_Z14test_variable4Ih34custom_multiply_multiple_variable2IhEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data8unsigned, i32 noundef 8000, i8 noundef zeroext %33, i8 noundef zeroext %34, i8 noundef zeroext %35, i8 noundef zeroext %37, ptr noundef nonnull @.str.36)
  tail call void @_Z14test_variable1Ih22custom_divide_variableIhEEvPT_iS2_PKc(ptr noundef nonnull @data8unsigned, i32 noundef 8000, i8 noundef zeroext %33, ptr noundef nonnull @.str.37)
  tail call void @_Z14test_variable4Ih31custom_divide_multiple_variableIhEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data8unsigned, i32 noundef 8000, i8 noundef zeroext %33, i8 noundef zeroext %34, i8 noundef zeroext %35, i8 noundef zeroext %37, ptr noundef nonnull @.str.38)
  tail call void @_Z14test_variable4Ih32custom_divide_multiple_variable2IhEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data8unsigned, i32 noundef 8000, i8 noundef zeroext %33, i8 noundef zeroext %34, i8 noundef zeroext %35, i8 noundef zeroext %37, ptr noundef nonnull @.str.39)
  tail call void @_Z14test_variable4Ih30custom_mixed_multiple_variableIhEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data8unsigned, i32 noundef 8000, i8 noundef zeroext %33, i8 noundef zeroext %34, i8 noundef zeroext %35, i8 noundef zeroext %37, ptr noundef nonnull @.str.40)
  tail call void @_Z14test_variable1Ih19custom_variable_andIhEEvPT_iS2_PKc(ptr noundef nonnull @data8unsigned, i32 noundef 8000, i8 noundef zeroext %33, ptr noundef nonnull @.str.41)
  tail call void @_Z14test_variable4Ih28custom_multiple_variable_andIhEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data8unsigned, i32 noundef 8000, i8 noundef zeroext %33, i8 noundef zeroext %34, i8 noundef zeroext %35, i8 noundef zeroext %37, ptr noundef nonnull @.str.42)
  tail call void @_Z14test_variable1Ih18custom_variable_orIhEEvPT_iS2_PKc(ptr noundef nonnull @data8unsigned, i32 noundef 8000, i8 noundef zeroext %33, ptr noundef nonnull @.str.43)
  tail call void @_Z14test_variable4Ih27custom_multiple_variable_orIhEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data8unsigned, i32 noundef 8000, i8 noundef zeroext %33, i8 noundef zeroext %34, i8 noundef zeroext %35, i8 noundef zeroext %37, ptr noundef nonnull @.str.44)
  tail call void @_Z14test_variable1Ih19custom_variable_xorIhEEvPT_iS2_PKc(ptr noundef nonnull @data8unsigned, i32 noundef 8000, i8 noundef zeroext %33, ptr noundef nonnull @.str.45)
  tail call void @_Z14test_variable4Ih28custom_multiple_variable_xorIhEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data8unsigned, i32 noundef 8000, i8 noundef zeroext %33, i8 noundef zeroext %34, i8 noundef zeroext %35, i8 noundef zeroext %37, ptr noundef nonnull @.str.46)
  %38 = load double, ptr @init_value, align 8, !tbaa !28
  %39 = fptosi double %38 to i16
  %40 = insertelement <8 x i16> poison, i16 %39, i64 0
  %41 = shufflevector <8 x i16> %40, <8 x i16> poison, <8 x i32> zeroinitializer
  %42 = insertelement <8 x i16> poison, i16 %39, i64 0
  %43 = shufflevector <8 x i16> %42, <8 x i16> poison, <8 x i32> zeroinitializer
  br label %44

44:                                               ; preds = %44, %19
  %45 = phi i64 [ 0, %19 ], [ %65, %44 ]
  %46 = shl nuw i64 %45, 1
  %47 = getelementptr i8, ptr @data16, i64 %46
  store <8 x i16> %41, ptr %47, align 16, !tbaa !30
  %48 = getelementptr i16, ptr %47, i64 8
  store <8 x i16> %43, ptr %48, align 16, !tbaa !30
  %49 = shl nuw i64 %45, 1
  %50 = add i64 %49, 32
  %51 = getelementptr i8, ptr @data16, i64 %50
  store <8 x i16> %41, ptr %51, align 16, !tbaa !30
  %52 = getelementptr i16, ptr %51, i64 8
  store <8 x i16> %43, ptr %52, align 16, !tbaa !30
  %53 = shl nuw i64 %45, 1
  %54 = add i64 %53, 64
  %55 = getelementptr i8, ptr @data16, i64 %54
  store <8 x i16> %41, ptr %55, align 16, !tbaa !30
  %56 = getelementptr i16, ptr %55, i64 8
  store <8 x i16> %43, ptr %56, align 16, !tbaa !30
  %57 = shl nuw i64 %45, 1
  %58 = add i64 %57, 96
  %59 = getelementptr i8, ptr @data16, i64 %58
  store <8 x i16> %41, ptr %59, align 16, !tbaa !30
  %60 = getelementptr i16, ptr %59, i64 8
  store <8 x i16> %43, ptr %60, align 16, !tbaa !30
  %61 = shl nuw i64 %45, 1
  %62 = add i64 %61, 128
  %63 = getelementptr i8, ptr @data16, i64 %62
  store <8 x i16> %41, ptr %63, align 16, !tbaa !30
  %64 = getelementptr i16, ptr %63, i64 8
  store <8 x i16> %43, ptr %64, align 16, !tbaa !30
  %65 = add nuw nsw i64 %45, 80
  %66 = icmp eq i64 %65, 8000
  br i1 %66, label %67, label %44, !llvm.loop !32

67:                                               ; preds = %44
  %68 = fptosi double %20 to i16
  %69 = shl i16 %68, 1
  %70 = add i16 %68, 2
  %71 = sext i16 %69 to i32
  %72 = sext i16 %70 to i32
  %73 = sdiv i32 %71, %72
  %74 = trunc i32 %73 to i16
  %75 = add i16 %74, %68
  tail call void @_Z14test_variable1Is19custom_add_variableIsEEvPT_iS2_PKc(ptr noundef nonnull @data16, i32 noundef 8000, i16 noundef signext %68, ptr noundef nonnull @.str.47)
  tail call void @_Z22test_hoisted_variable1Is19custom_add_variableIsEEvPT_iS2_PKc(ptr noundef nonnull @data16, i32 noundef 8000, i16 noundef signext %68, ptr noundef nonnull @.str.48)
  tail call void @_Z14test_variable4Is28custom_add_multiple_variableIsEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data16, i32 noundef 8000, i16 noundef signext %68, i16 noundef signext %69, i16 noundef signext %70, i16 noundef signext %75, ptr noundef nonnull @.str.49)
  tail call void @_Z14test_variable1Is19custom_sub_variableIsEEvPT_iS2_PKc(ptr noundef nonnull @data16, i32 noundef 8000, i16 noundef signext %68, ptr noundef nonnull @.str.50)
  tail call void @_Z14test_variable4Is28custom_sub_multiple_variableIsEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data16, i32 noundef 8000, i16 noundef signext %68, i16 noundef signext %69, i16 noundef signext %70, i16 noundef signext %75, ptr noundef nonnull @.str.51)
  tail call void @_Z14test_variable1Is24custom_multiply_variableIsEEvPT_iS2_PKc(ptr noundef nonnull @data16, i32 noundef 8000, i16 noundef signext %68, ptr noundef nonnull @.str.52)
  tail call void @_Z14test_variable4Is33custom_multiply_multiple_variableIsEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data16, i32 noundef 8000, i16 noundef signext %68, i16 noundef signext %69, i16 noundef signext %70, i16 noundef signext %75, ptr noundef nonnull @.str.53)
  tail call void @_Z14test_variable4Is34custom_multiply_multiple_variable2IsEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data16, i32 noundef 8000, i16 noundef signext %68, i16 noundef signext %69, i16 noundef signext %70, i16 noundef signext %75, ptr noundef nonnull @.str.54)
  tail call void @_Z14test_variable1Is22custom_divide_variableIsEEvPT_iS2_PKc(ptr noundef nonnull @data16, i32 noundef 8000, i16 noundef signext %68, ptr noundef nonnull @.str.55)
  tail call void @_Z14test_variable4Is31custom_divide_multiple_variableIsEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data16, i32 noundef 8000, i16 noundef signext %68, i16 noundef signext %69, i16 noundef signext %70, i16 noundef signext %75, ptr noundef nonnull @.str.56)
  tail call void @_Z14test_variable4Is32custom_divide_multiple_variable2IsEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data16, i32 noundef 8000, i16 noundef signext %68, i16 noundef signext %69, i16 noundef signext %70, i16 noundef signext %75, ptr noundef nonnull @.str.57)
  tail call void @_Z14test_variable4Is30custom_mixed_multiple_variableIsEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data16, i32 noundef 8000, i16 noundef signext %68, i16 noundef signext %69, i16 noundef signext %70, i16 noundef signext %75, ptr noundef nonnull @.str.58)
  tail call void @_Z14test_variable1Is19custom_variable_andIsEEvPT_iS2_PKc(ptr noundef nonnull @data16, i32 noundef 8000, i16 noundef signext %68, ptr noundef nonnull @.str.59)
  tail call void @_Z14test_variable4Is28custom_multiple_variable_andIsEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data16, i32 noundef 8000, i16 noundef signext %68, i16 noundef signext %69, i16 noundef signext %70, i16 noundef signext %75, ptr noundef nonnull @.str.60)
  tail call void @_Z14test_variable1Is18custom_variable_orIsEEvPT_iS2_PKc(ptr noundef nonnull @data16, i32 noundef 8000, i16 noundef signext %68, ptr noundef nonnull @.str.61)
  tail call void @_Z14test_variable4Is27custom_multiple_variable_orIsEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data16, i32 noundef 8000, i16 noundef signext %68, i16 noundef signext %69, i16 noundef signext %70, i16 noundef signext %75, ptr noundef nonnull @.str.62)
  tail call void @_Z14test_variable1Is19custom_variable_xorIsEEvPT_iS2_PKc(ptr noundef nonnull @data16, i32 noundef 8000, i16 noundef signext %68, ptr noundef nonnull @.str.63)
  tail call void @_Z14test_variable4Is28custom_multiple_variable_xorIsEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data16, i32 noundef 8000, i16 noundef signext %68, i16 noundef signext %69, i16 noundef signext %70, i16 noundef signext %75, ptr noundef nonnull @.str.64)
  %76 = load double, ptr @init_value, align 8, !tbaa !28
  %77 = fptoui double %76 to i16
  %78 = insertelement <8 x i16> poison, i16 %77, i64 0
  %79 = shufflevector <8 x i16> %78, <8 x i16> poison, <8 x i32> zeroinitializer
  %80 = insertelement <8 x i16> poison, i16 %77, i64 0
  %81 = shufflevector <8 x i16> %80, <8 x i16> poison, <8 x i32> zeroinitializer
  br label %82

82:                                               ; preds = %82, %67
  %83 = phi i64 [ 0, %67 ], [ %103, %82 ]
  %84 = shl nuw i64 %83, 1
  %85 = getelementptr i8, ptr @data16unsigned, i64 %84
  store <8 x i16> %79, ptr %85, align 16, !tbaa !30
  %86 = getelementptr i16, ptr %85, i64 8
  store <8 x i16> %81, ptr %86, align 16, !tbaa !30
  %87 = shl nuw i64 %83, 1
  %88 = add i64 %87, 32
  %89 = getelementptr i8, ptr @data16unsigned, i64 %88
  store <8 x i16> %79, ptr %89, align 16, !tbaa !30
  %90 = getelementptr i16, ptr %89, i64 8
  store <8 x i16> %81, ptr %90, align 16, !tbaa !30
  %91 = shl nuw i64 %83, 1
  %92 = add i64 %91, 64
  %93 = getelementptr i8, ptr @data16unsigned, i64 %92
  store <8 x i16> %79, ptr %93, align 16, !tbaa !30
  %94 = getelementptr i16, ptr %93, i64 8
  store <8 x i16> %81, ptr %94, align 16, !tbaa !30
  %95 = shl nuw i64 %83, 1
  %96 = add i64 %95, 96
  %97 = getelementptr i8, ptr @data16unsigned, i64 %96
  store <8 x i16> %79, ptr %97, align 16, !tbaa !30
  %98 = getelementptr i16, ptr %97, i64 8
  store <8 x i16> %81, ptr %98, align 16, !tbaa !30
  %99 = shl nuw i64 %83, 1
  %100 = add i64 %99, 128
  %101 = getelementptr i8, ptr @data16unsigned, i64 %100
  store <8 x i16> %79, ptr %101, align 16, !tbaa !30
  %102 = getelementptr i16, ptr %101, i64 8
  store <8 x i16> %81, ptr %102, align 16, !tbaa !30
  %103 = add nuw nsw i64 %83, 80
  %104 = icmp eq i64 %103, 8000
  br i1 %104, label %105, label %82, !llvm.loop !35

105:                                              ; preds = %82
  %106 = fptoui double %20 to i16
  %107 = shl i16 %106, 1
  %108 = add i16 %106, 2
  %109 = udiv i16 %107, %108
  %110 = add i16 %109, %106
  tail call void @_Z14test_variable1It19custom_add_variableItEEvPT_iS2_PKc(ptr noundef nonnull @data16unsigned, i32 noundef 8000, i16 noundef zeroext %106, ptr noundef nonnull @.str.65)
  tail call void @_Z22test_hoisted_variable1It19custom_add_variableItEEvPT_iS2_PKc(ptr noundef nonnull @data16unsigned, i32 noundef 8000, i16 noundef zeroext %106, ptr noundef nonnull @.str.66)
  tail call void @_Z14test_variable4It28custom_add_multiple_variableItEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data16unsigned, i32 noundef 8000, i16 noundef zeroext %106, i16 noundef zeroext %107, i16 noundef zeroext %108, i16 noundef zeroext %110, ptr noundef nonnull @.str.67)
  tail call void @_Z14test_variable1It19custom_sub_variableItEEvPT_iS2_PKc(ptr noundef nonnull @data16unsigned, i32 noundef 8000, i16 noundef zeroext %106, ptr noundef nonnull @.str.68)
  tail call void @_Z14test_variable4It28custom_sub_multiple_variableItEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data16unsigned, i32 noundef 8000, i16 noundef zeroext %106, i16 noundef zeroext %107, i16 noundef zeroext %108, i16 noundef zeroext %110, ptr noundef nonnull @.str.69)
  tail call void @_Z14test_variable1It24custom_multiply_variableItEEvPT_iS2_PKc(ptr noundef nonnull @data16unsigned, i32 noundef 8000, i16 noundef zeroext %106, ptr noundef nonnull @.str.70)
  tail call void @_Z14test_variable4It33custom_multiply_multiple_variableItEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data16unsigned, i32 noundef 8000, i16 noundef zeroext %106, i16 noundef zeroext %107, i16 noundef zeroext %108, i16 noundef zeroext %110, ptr noundef nonnull @.str.71)
  tail call void @_Z14test_variable4It34custom_multiply_multiple_variable2ItEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data16unsigned, i32 noundef 8000, i16 noundef zeroext %106, i16 noundef zeroext %107, i16 noundef zeroext %108, i16 noundef zeroext %110, ptr noundef nonnull @.str.72)
  tail call void @_Z14test_variable1It22custom_divide_variableItEEvPT_iS2_PKc(ptr noundef nonnull @data16unsigned, i32 noundef 8000, i16 noundef zeroext %106, ptr noundef nonnull @.str.73)
  tail call void @_Z14test_variable4It31custom_divide_multiple_variableItEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data16unsigned, i32 noundef 8000, i16 noundef zeroext %106, i16 noundef zeroext %107, i16 noundef zeroext %108, i16 noundef zeroext %110, ptr noundef nonnull @.str.74)
  tail call void @_Z14test_variable4It32custom_divide_multiple_variable2ItEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data16unsigned, i32 noundef 8000, i16 noundef zeroext %106, i16 noundef zeroext %107, i16 noundef zeroext %108, i16 noundef zeroext %110, ptr noundef nonnull @.str.75)
  tail call void @_Z14test_variable4It30custom_mixed_multiple_variableItEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data16unsigned, i32 noundef 8000, i16 noundef zeroext %106, i16 noundef zeroext %107, i16 noundef zeroext %108, i16 noundef zeroext %110, ptr noundef nonnull @.str.76)
  tail call void @_Z14test_variable1It19custom_variable_andItEEvPT_iS2_PKc(ptr noundef nonnull @data16unsigned, i32 noundef 8000, i16 noundef zeroext %106, ptr noundef nonnull @.str.77)
  tail call void @_Z14test_variable4It28custom_multiple_variable_andItEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data16unsigned, i32 noundef 8000, i16 noundef zeroext %106, i16 noundef zeroext %107, i16 noundef zeroext %108, i16 noundef zeroext %110, ptr noundef nonnull @.str.78)
  tail call void @_Z14test_variable1It18custom_variable_orItEEvPT_iS2_PKc(ptr noundef nonnull @data16unsigned, i32 noundef 8000, i16 noundef zeroext %106, ptr noundef nonnull @.str.79)
  tail call void @_Z14test_variable4It27custom_multiple_variable_orItEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data16unsigned, i32 noundef 8000, i16 noundef zeroext %106, i16 noundef zeroext %107, i16 noundef zeroext %108, i16 noundef zeroext %110, ptr noundef nonnull @.str.80)
  tail call void @_Z14test_variable1It19custom_variable_xorItEEvPT_iS2_PKc(ptr noundef nonnull @data16unsigned, i32 noundef 8000, i16 noundef zeroext %106, ptr noundef nonnull @.str.81)
  tail call void @_Z14test_variable4It28custom_multiple_variable_xorItEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data16unsigned, i32 noundef 8000, i16 noundef zeroext %106, i16 noundef zeroext %107, i16 noundef zeroext %108, i16 noundef zeroext %110, ptr noundef nonnull @.str.82)
  %111 = load double, ptr @init_value, align 8, !tbaa !28
  %112 = fptosi double %111 to i32
  %113 = insertelement <4 x i32> poison, i32 %112, i64 0
  %114 = shufflevector <4 x i32> %113, <4 x i32> poison, <4 x i32> zeroinitializer
  %115 = insertelement <4 x i32> poison, i32 %112, i64 0
  %116 = shufflevector <4 x i32> %115, <4 x i32> poison, <4 x i32> zeroinitializer
  br label %117

117:                                              ; preds = %117, %105
  %118 = phi i64 [ 0, %105 ], [ %138, %117 ]
  %119 = shl i64 %118, 2
  %120 = getelementptr i8, ptr @data32, i64 %119
  store <4 x i32> %114, ptr %120, align 16, !tbaa !9
  %121 = getelementptr i32, ptr %120, i64 4
  store <4 x i32> %116, ptr %121, align 16, !tbaa !9
  %122 = shl i64 %118, 2
  %123 = add i64 %122, 32
  %124 = getelementptr i8, ptr @data32, i64 %123
  store <4 x i32> %114, ptr %124, align 16, !tbaa !9
  %125 = getelementptr i32, ptr %124, i64 4
  store <4 x i32> %116, ptr %125, align 16, !tbaa !9
  %126 = shl i64 %118, 2
  %127 = add i64 %126, 64
  %128 = getelementptr i8, ptr @data32, i64 %127
  store <4 x i32> %114, ptr %128, align 16, !tbaa !9
  %129 = getelementptr i32, ptr %128, i64 4
  store <4 x i32> %116, ptr %129, align 16, !tbaa !9
  %130 = shl i64 %118, 2
  %131 = add i64 %130, 96
  %132 = getelementptr i8, ptr @data32, i64 %131
  store <4 x i32> %114, ptr %132, align 16, !tbaa !9
  %133 = getelementptr i32, ptr %132, i64 4
  store <4 x i32> %116, ptr %133, align 16, !tbaa !9
  %134 = shl i64 %118, 2
  %135 = add i64 %134, 128
  %136 = getelementptr i8, ptr @data32, i64 %135
  store <4 x i32> %114, ptr %136, align 16, !tbaa !9
  %137 = getelementptr i32, ptr %136, i64 4
  store <4 x i32> %116, ptr %137, align 16, !tbaa !9
  %138 = add nuw nsw i64 %118, 40
  %139 = icmp eq i64 %138, 8000
  br i1 %139, label %140, label %117, !llvm.loop !36

140:                                              ; preds = %117
  %141 = fptosi double %20 to i32
  %142 = shl nsw i32 %141, 1
  %143 = add nsw i32 %141, 2
  %144 = sdiv i32 %142, %143
  %145 = add nsw i32 %144, %141
  tail call void @_Z14test_variable1Ii19custom_add_variableIiEEvPT_iS2_PKc(ptr noundef nonnull @data32, i32 noundef 8000, i32 noundef %141, ptr noundef nonnull @.str.83)
  tail call void @_Z22test_hoisted_variable1Ii19custom_add_variableIiEEvPT_iS2_PKc(ptr noundef nonnull @data32, i32 noundef 8000, i32 noundef %141, ptr noundef nonnull @.str.84)
  tail call void @_Z14test_variable4Ii28custom_add_multiple_variableIiEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data32, i32 noundef 8000, i32 noundef %141, i32 noundef %142, i32 noundef %143, i32 noundef %145, ptr noundef nonnull @.str.85)
  tail call void @_Z14test_variable1Ii19custom_sub_variableIiEEvPT_iS2_PKc(ptr noundef nonnull @data32, i32 noundef 8000, i32 noundef %141, ptr noundef nonnull @.str.86)
  tail call void @_Z14test_variable4Ii28custom_sub_multiple_variableIiEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data32, i32 noundef 8000, i32 noundef %141, i32 noundef %142, i32 noundef %143, i32 noundef %145, ptr noundef nonnull @.str.87)
  tail call void @_Z14test_variable1Ii24custom_multiply_variableIiEEvPT_iS2_PKc(ptr noundef nonnull @data32, i32 noundef 8000, i32 noundef %141, ptr noundef nonnull @.str.88)
  tail call void @_Z14test_variable4Ii33custom_multiply_multiple_variableIiEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data32, i32 noundef 8000, i32 noundef %141, i32 noundef %142, i32 noundef %143, i32 noundef %145, ptr noundef nonnull @.str.89)
  tail call void @_Z14test_variable4Ii34custom_multiply_multiple_variable2IiEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data32, i32 noundef 8000, i32 noundef %141, i32 noundef %142, i32 noundef %143, i32 noundef %145, ptr noundef nonnull @.str.90)
  tail call void @_Z14test_variable1Ii22custom_divide_variableIiEEvPT_iS2_PKc(ptr noundef nonnull @data32, i32 noundef 8000, i32 noundef %141, ptr noundef nonnull @.str.91)
  tail call void @_Z14test_variable4Ii31custom_divide_multiple_variableIiEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data32, i32 noundef 8000, i32 noundef %141, i32 noundef %142, i32 noundef %143, i32 noundef %145, ptr noundef nonnull @.str.92)
  tail call void @_Z14test_variable4Ii32custom_divide_multiple_variable2IiEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data32, i32 noundef 8000, i32 noundef %141, i32 noundef %142, i32 noundef %143, i32 noundef %145, ptr noundef nonnull @.str.93)
  tail call void @_Z14test_variable4Ii30custom_mixed_multiple_variableIiEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data32, i32 noundef 8000, i32 noundef %141, i32 noundef %142, i32 noundef %143, i32 noundef %145, ptr noundef nonnull @.str.94)
  tail call void @_Z14test_variable1Ii19custom_variable_andIiEEvPT_iS2_PKc(ptr noundef nonnull @data32, i32 noundef 8000, i32 noundef %141, ptr noundef nonnull @.str.95)
  tail call void @_Z14test_variable4Ii28custom_multiple_variable_andIiEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data32, i32 noundef 8000, i32 noundef %141, i32 noundef %142, i32 noundef %143, i32 noundef %145, ptr noundef nonnull @.str.96)
  tail call void @_Z14test_variable1Ii18custom_variable_orIiEEvPT_iS2_PKc(ptr noundef nonnull @data32, i32 noundef 8000, i32 noundef %141, ptr noundef nonnull @.str.97)
  tail call void @_Z14test_variable4Ii27custom_multiple_variable_orIiEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data32, i32 noundef 8000, i32 noundef %141, i32 noundef %142, i32 noundef %143, i32 noundef %145, ptr noundef nonnull @.str.98)
  tail call void @_Z14test_variable1Ii19custom_variable_xorIiEEvPT_iS2_PKc(ptr noundef nonnull @data32, i32 noundef 8000, i32 noundef %141, ptr noundef nonnull @.str.99)
  tail call void @_Z14test_variable4Ii28custom_multiple_variable_xorIiEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data32, i32 noundef 8000, i32 noundef %141, i32 noundef %142, i32 noundef %143, i32 noundef %145, ptr noundef nonnull @.str.100)
  %146 = load double, ptr @init_value, align 8, !tbaa !28
  %147 = fptoui double %146 to i32
  %148 = insertelement <4 x i32> poison, i32 %147, i64 0
  %149 = shufflevector <4 x i32> %148, <4 x i32> poison, <4 x i32> zeroinitializer
  %150 = insertelement <4 x i32> poison, i32 %147, i64 0
  %151 = shufflevector <4 x i32> %150, <4 x i32> poison, <4 x i32> zeroinitializer
  br label %152

152:                                              ; preds = %152, %140
  %153 = phi i64 [ 0, %140 ], [ %173, %152 ]
  %154 = shl i64 %153, 2
  %155 = getelementptr i8, ptr @data32unsigned, i64 %154
  store <4 x i32> %149, ptr %155, align 16, !tbaa !9
  %156 = getelementptr i32, ptr %155, i64 4
  store <4 x i32> %151, ptr %156, align 16, !tbaa !9
  %157 = shl i64 %153, 2
  %158 = add i64 %157, 32
  %159 = getelementptr i8, ptr @data32unsigned, i64 %158
  store <4 x i32> %149, ptr %159, align 16, !tbaa !9
  %160 = getelementptr i32, ptr %159, i64 4
  store <4 x i32> %151, ptr %160, align 16, !tbaa !9
  %161 = shl i64 %153, 2
  %162 = add i64 %161, 64
  %163 = getelementptr i8, ptr @data32unsigned, i64 %162
  store <4 x i32> %149, ptr %163, align 16, !tbaa !9
  %164 = getelementptr i32, ptr %163, i64 4
  store <4 x i32> %151, ptr %164, align 16, !tbaa !9
  %165 = shl i64 %153, 2
  %166 = add i64 %165, 96
  %167 = getelementptr i8, ptr @data32unsigned, i64 %166
  store <4 x i32> %149, ptr %167, align 16, !tbaa !9
  %168 = getelementptr i32, ptr %167, i64 4
  store <4 x i32> %151, ptr %168, align 16, !tbaa !9
  %169 = shl i64 %153, 2
  %170 = add i64 %169, 128
  %171 = getelementptr i8, ptr @data32unsigned, i64 %170
  store <4 x i32> %149, ptr %171, align 16, !tbaa !9
  %172 = getelementptr i32, ptr %171, i64 4
  store <4 x i32> %151, ptr %172, align 16, !tbaa !9
  %173 = add nuw nsw i64 %153, 40
  %174 = icmp eq i64 %173, 8000
  br i1 %174, label %175, label %152, !llvm.loop !37

175:                                              ; preds = %152
  %176 = fptoui double %20 to i32
  %177 = shl i32 %176, 1
  %178 = add i32 %176, 2
  %179 = udiv i32 %177, %178
  %180 = add i32 %179, %176
  tail call void @_Z14test_variable1Ij19custom_add_variableIjEEvPT_iS2_PKc(ptr noundef nonnull @data32unsigned, i32 noundef 8000, i32 noundef %176, ptr noundef nonnull @.str.101)
  tail call void @_Z22test_hoisted_variable1Ij19custom_add_variableIjEEvPT_iS2_PKc(ptr noundef nonnull @data32unsigned, i32 noundef 8000, i32 noundef %176, ptr noundef nonnull @.str.102)
  tail call void @_Z14test_variable4Ij28custom_add_multiple_variableIjEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data32unsigned, i32 noundef 8000, i32 noundef %176, i32 noundef %177, i32 noundef %178, i32 noundef %180, ptr noundef nonnull @.str.103)
  tail call void @_Z14test_variable1Ij19custom_sub_variableIjEEvPT_iS2_PKc(ptr noundef nonnull @data32unsigned, i32 noundef 8000, i32 noundef %176, ptr noundef nonnull @.str.104)
  tail call void @_Z14test_variable4Ij28custom_sub_multiple_variableIjEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data32unsigned, i32 noundef 8000, i32 noundef %176, i32 noundef %177, i32 noundef %178, i32 noundef %180, ptr noundef nonnull @.str.105)
  tail call void @_Z14test_variable1Ij24custom_multiply_variableIjEEvPT_iS2_PKc(ptr noundef nonnull @data32unsigned, i32 noundef 8000, i32 noundef %176, ptr noundef nonnull @.str.106)
  tail call void @_Z14test_variable4Ij33custom_multiply_multiple_variableIjEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data32unsigned, i32 noundef 8000, i32 noundef %176, i32 noundef %177, i32 noundef %178, i32 noundef %180, ptr noundef nonnull @.str.107)
  tail call void @_Z14test_variable4Ij34custom_multiply_multiple_variable2IjEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data32unsigned, i32 noundef 8000, i32 noundef %176, i32 noundef %177, i32 noundef %178, i32 noundef %180, ptr noundef nonnull @.str.108)
  tail call void @_Z14test_variable1Ij22custom_divide_variableIjEEvPT_iS2_PKc(ptr noundef nonnull @data32unsigned, i32 noundef 8000, i32 noundef %176, ptr noundef nonnull @.str.109)
  tail call void @_Z14test_variable4Ij31custom_divide_multiple_variableIjEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data32unsigned, i32 noundef 8000, i32 noundef %176, i32 noundef %177, i32 noundef %178, i32 noundef %180, ptr noundef nonnull @.str.110)
  tail call void @_Z14test_variable4Ij32custom_divide_multiple_variable2IjEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data32unsigned, i32 noundef 8000, i32 noundef %176, i32 noundef %177, i32 noundef %178, i32 noundef %180, ptr noundef nonnull @.str.111)
  tail call void @_Z14test_variable4Ij30custom_mixed_multiple_variableIjEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data32unsigned, i32 noundef 8000, i32 noundef %176, i32 noundef %177, i32 noundef %178, i32 noundef %180, ptr noundef nonnull @.str.112)
  tail call void @_Z14test_variable1Ij19custom_variable_andIjEEvPT_iS2_PKc(ptr noundef nonnull @data32unsigned, i32 noundef 8000, i32 noundef %176, ptr noundef nonnull @.str.113)
  tail call void @_Z14test_variable4Ij28custom_multiple_variable_andIjEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data32unsigned, i32 noundef 8000, i32 noundef %176, i32 noundef %177, i32 noundef %178, i32 noundef %180, ptr noundef nonnull @.str.114)
  tail call void @_Z14test_variable1Ij18custom_variable_orIjEEvPT_iS2_PKc(ptr noundef nonnull @data32unsigned, i32 noundef 8000, i32 noundef %176, ptr noundef nonnull @.str.115)
  tail call void @_Z14test_variable4Ij27custom_multiple_variable_orIjEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data32unsigned, i32 noundef 8000, i32 noundef %176, i32 noundef %177, i32 noundef %178, i32 noundef %180, ptr noundef nonnull @.str.116)
  tail call void @_Z14test_variable1Ij19custom_variable_xorIjEEvPT_iS2_PKc(ptr noundef nonnull @data32unsigned, i32 noundef 8000, i32 noundef %176, ptr noundef nonnull @.str.117)
  tail call void @_Z14test_variable4Ij28custom_multiple_variable_xorIjEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data32unsigned, i32 noundef 8000, i32 noundef %176, i32 noundef %177, i32 noundef %178, i32 noundef %180, ptr noundef nonnull @.str.118)
  %181 = load double, ptr @init_value, align 8, !tbaa !28
  %182 = fptosi double %181 to i64
  %183 = insertelement <2 x i64> poison, i64 %182, i64 0
  %184 = shufflevector <2 x i64> %183, <2 x i64> poison, <2 x i32> zeroinitializer
  %185 = insertelement <2 x i64> poison, i64 %182, i64 0
  %186 = shufflevector <2 x i64> %185, <2 x i64> poison, <2 x i32> zeroinitializer
  br label %187

187:                                              ; preds = %187, %175
  %188 = phi i64 [ 0, %175 ], [ %208, %187 ]
  %189 = shl i64 %188, 3
  %190 = getelementptr i8, ptr @data64, i64 %189
  store <2 x i64> %184, ptr %190, align 16, !tbaa !26
  %191 = getelementptr i64, ptr %190, i64 2
  store <2 x i64> %186, ptr %191, align 16, !tbaa !26
  %192 = shl i64 %188, 3
  %193 = add i64 %192, 32
  %194 = getelementptr i8, ptr @data64, i64 %193
  store <2 x i64> %184, ptr %194, align 16, !tbaa !26
  %195 = getelementptr i64, ptr %194, i64 2
  store <2 x i64> %186, ptr %195, align 16, !tbaa !26
  %196 = shl i64 %188, 3
  %197 = add i64 %196, 64
  %198 = getelementptr i8, ptr @data64, i64 %197
  store <2 x i64> %184, ptr %198, align 16, !tbaa !26
  %199 = getelementptr i64, ptr %198, i64 2
  store <2 x i64> %186, ptr %199, align 16, !tbaa !26
  %200 = shl i64 %188, 3
  %201 = add i64 %200, 96
  %202 = getelementptr i8, ptr @data64, i64 %201
  store <2 x i64> %184, ptr %202, align 16, !tbaa !26
  %203 = getelementptr i64, ptr %202, i64 2
  store <2 x i64> %186, ptr %203, align 16, !tbaa !26
  %204 = shl i64 %188, 3
  %205 = add i64 %204, 128
  %206 = getelementptr i8, ptr @data64, i64 %205
  store <2 x i64> %184, ptr %206, align 16, !tbaa !26
  %207 = getelementptr i64, ptr %206, i64 2
  store <2 x i64> %186, ptr %207, align 16, !tbaa !26
  %208 = add nuw nsw i64 %188, 20
  %209 = icmp eq i64 %208, 8000
  br i1 %209, label %210, label %187, !llvm.loop !38

210:                                              ; preds = %187
  %211 = fptosi double %20 to i64
  %212 = shl nsw i64 %211, 1
  %213 = add nsw i64 %211, 2
  %214 = sdiv i64 %212, %213
  %215 = add nsw i64 %214, %211
  tail call void @_Z14test_variable1Il19custom_add_variableIlEEvPT_iS2_PKc(ptr noundef nonnull @data64, i32 noundef 8000, i64 noundef %211, ptr noundef nonnull @.str.119)
  tail call void @_Z22test_hoisted_variable1Il19custom_add_variableIlEEvPT_iS2_PKc(ptr noundef nonnull @data64, i32 noundef 8000, i64 noundef %211, ptr noundef nonnull @.str.120)
  tail call void @_Z14test_variable4Il28custom_add_multiple_variableIlEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data64, i32 noundef 8000, i64 noundef %211, i64 noundef %212, i64 noundef %213, i64 noundef %215, ptr noundef nonnull @.str.121)
  tail call void @_Z14test_variable1Il19custom_sub_variableIlEEvPT_iS2_PKc(ptr noundef nonnull @data64, i32 noundef 8000, i64 noundef %211, ptr noundef nonnull @.str.122)
  tail call void @_Z14test_variable4Il28custom_sub_multiple_variableIlEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data64, i32 noundef 8000, i64 noundef %211, i64 noundef %212, i64 noundef %213, i64 noundef %215, ptr noundef nonnull @.str.123)
  tail call void @_Z14test_variable1Il24custom_multiply_variableIlEEvPT_iS2_PKc(ptr noundef nonnull @data64, i32 noundef 8000, i64 noundef %211, ptr noundef nonnull @.str.124)
  tail call void @_Z14test_variable4Il33custom_multiply_multiple_variableIlEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data64, i32 noundef 8000, i64 noundef %211, i64 noundef %212, i64 noundef %213, i64 noundef %215, ptr noundef nonnull @.str.125)
  tail call void @_Z14test_variable4Il34custom_multiply_multiple_variable2IlEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data64, i32 noundef 8000, i64 noundef %211, i64 noundef %212, i64 noundef %213, i64 noundef %215, ptr noundef nonnull @.str.126)
  tail call void @_Z14test_variable1Il22custom_divide_variableIlEEvPT_iS2_PKc(ptr noundef nonnull @data64, i32 noundef 8000, i64 noundef %211, ptr noundef nonnull @.str.127)
  tail call void @_Z14test_variable4Il31custom_divide_multiple_variableIlEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data64, i32 noundef 8000, i64 noundef %211, i64 noundef %212, i64 noundef %213, i64 noundef %215, ptr noundef nonnull @.str.128)
  tail call void @_Z14test_variable4Il32custom_divide_multiple_variable2IlEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data64, i32 noundef 8000, i64 noundef %211, i64 noundef %212, i64 noundef %213, i64 noundef %215, ptr noundef nonnull @.str.129)
  tail call void @_Z14test_variable4Il30custom_mixed_multiple_variableIlEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data64, i32 noundef 8000, i64 noundef %211, i64 noundef %212, i64 noundef %213, i64 noundef %215, ptr noundef nonnull @.str.130)
  tail call void @_Z14test_variable1Il19custom_variable_andIlEEvPT_iS2_PKc(ptr noundef nonnull @data64, i32 noundef 8000, i64 noundef %211, ptr noundef nonnull @.str.131)
  tail call void @_Z14test_variable4Il28custom_multiple_variable_andIlEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data64, i32 noundef 8000, i64 noundef %211, i64 noundef %212, i64 noundef %213, i64 noundef %215, ptr noundef nonnull @.str.132)
  tail call void @_Z14test_variable1Il18custom_variable_orIlEEvPT_iS2_PKc(ptr noundef nonnull @data64, i32 noundef 8000, i64 noundef %211, ptr noundef nonnull @.str.133)
  tail call void @_Z14test_variable4Il27custom_multiple_variable_orIlEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data64, i32 noundef 8000, i64 noundef %211, i64 noundef %212, i64 noundef %213, i64 noundef %215, ptr noundef nonnull @.str.134)
  tail call void @_Z14test_variable1Il19custom_variable_xorIlEEvPT_iS2_PKc(ptr noundef nonnull @data64, i32 noundef 8000, i64 noundef %211, ptr noundef nonnull @.str.135)
  tail call void @_Z14test_variable4Il28custom_multiple_variable_xorIlEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data64, i32 noundef 8000, i64 noundef %211, i64 noundef %212, i64 noundef %213, i64 noundef %215, ptr noundef nonnull @.str.136)
  %216 = load double, ptr @init_value, align 8, !tbaa !28
  %217 = fptoui double %216 to i64
  %218 = insertelement <2 x i64> poison, i64 %217, i64 0
  %219 = shufflevector <2 x i64> %218, <2 x i64> poison, <2 x i32> zeroinitializer
  %220 = insertelement <2 x i64> poison, i64 %217, i64 0
  %221 = shufflevector <2 x i64> %220, <2 x i64> poison, <2 x i32> zeroinitializer
  br label %222

222:                                              ; preds = %222, %210
  %223 = phi i64 [ 0, %210 ], [ %243, %222 ]
  %224 = shl i64 %223, 3
  %225 = getelementptr i8, ptr @data64unsigned, i64 %224
  store <2 x i64> %219, ptr %225, align 16, !tbaa !26
  %226 = getelementptr i64, ptr %225, i64 2
  store <2 x i64> %221, ptr %226, align 16, !tbaa !26
  %227 = shl i64 %223, 3
  %228 = add i64 %227, 32
  %229 = getelementptr i8, ptr @data64unsigned, i64 %228
  store <2 x i64> %219, ptr %229, align 16, !tbaa !26
  %230 = getelementptr i64, ptr %229, i64 2
  store <2 x i64> %221, ptr %230, align 16, !tbaa !26
  %231 = shl i64 %223, 3
  %232 = add i64 %231, 64
  %233 = getelementptr i8, ptr @data64unsigned, i64 %232
  store <2 x i64> %219, ptr %233, align 16, !tbaa !26
  %234 = getelementptr i64, ptr %233, i64 2
  store <2 x i64> %221, ptr %234, align 16, !tbaa !26
  %235 = shl i64 %223, 3
  %236 = add i64 %235, 96
  %237 = getelementptr i8, ptr @data64unsigned, i64 %236
  store <2 x i64> %219, ptr %237, align 16, !tbaa !26
  %238 = getelementptr i64, ptr %237, i64 2
  store <2 x i64> %221, ptr %238, align 16, !tbaa !26
  %239 = shl i64 %223, 3
  %240 = add i64 %239, 128
  %241 = getelementptr i8, ptr @data64unsigned, i64 %240
  store <2 x i64> %219, ptr %241, align 16, !tbaa !26
  %242 = getelementptr i64, ptr %241, i64 2
  store <2 x i64> %221, ptr %242, align 16, !tbaa !26
  %243 = add nuw nsw i64 %223, 20
  %244 = icmp eq i64 %243, 8000
  br i1 %244, label %245, label %222, !llvm.loop !39

245:                                              ; preds = %222
  %246 = fptoui double %20 to i64
  %247 = shl i64 %246, 1
  %248 = add i64 %246, 2
  %249 = udiv i64 %247, %248
  %250 = add i64 %249, %246
  tail call void @_Z14test_variable1Im19custom_add_variableImEEvPT_iS2_PKc(ptr noundef nonnull @data64unsigned, i32 noundef 8000, i64 noundef %246, ptr noundef nonnull @.str.137)
  tail call void @_Z22test_hoisted_variable1Im19custom_add_variableImEEvPT_iS2_PKc(ptr noundef nonnull @data64unsigned, i32 noundef 8000, i64 noundef %246, ptr noundef nonnull @.str.138)
  tail call void @_Z14test_variable4Im28custom_add_multiple_variableImEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data64unsigned, i32 noundef 8000, i64 noundef %246, i64 noundef %247, i64 noundef %248, i64 noundef %250, ptr noundef nonnull @.str.139)
  tail call void @_Z14test_variable1Im19custom_sub_variableImEEvPT_iS2_PKc(ptr noundef nonnull @data64unsigned, i32 noundef 8000, i64 noundef %246, ptr noundef nonnull @.str.140)
  tail call void @_Z14test_variable4Im28custom_sub_multiple_variableImEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data64unsigned, i32 noundef 8000, i64 noundef %246, i64 noundef %247, i64 noundef %248, i64 noundef %250, ptr noundef nonnull @.str.141)
  tail call void @_Z14test_variable1Im24custom_multiply_variableImEEvPT_iS2_PKc(ptr noundef nonnull @data64unsigned, i32 noundef 8000, i64 noundef %246, ptr noundef nonnull @.str.142)
  tail call void @_Z14test_variable4Im33custom_multiply_multiple_variableImEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data64unsigned, i32 noundef 8000, i64 noundef %246, i64 noundef %247, i64 noundef %248, i64 noundef %250, ptr noundef nonnull @.str.143)
  tail call void @_Z14test_variable4Im34custom_multiply_multiple_variable2ImEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data64unsigned, i32 noundef 8000, i64 noundef %246, i64 noundef %247, i64 noundef %248, i64 noundef %250, ptr noundef nonnull @.str.144)
  tail call void @_Z14test_variable1Im22custom_divide_variableImEEvPT_iS2_PKc(ptr noundef nonnull @data64unsigned, i32 noundef 8000, i64 noundef %246, ptr noundef nonnull @.str.145)
  tail call void @_Z14test_variable4Im31custom_divide_multiple_variableImEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data64unsigned, i32 noundef 8000, i64 noundef %246, i64 noundef %247, i64 noundef %248, i64 noundef %250, ptr noundef nonnull @.str.146)
  tail call void @_Z14test_variable4Im32custom_divide_multiple_variable2ImEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data64unsigned, i32 noundef 8000, i64 noundef %246, i64 noundef %247, i64 noundef %248, i64 noundef %250, ptr noundef nonnull @.str.147)
  tail call void @_Z14test_variable4Im30custom_mixed_multiple_variableImEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data64unsigned, i32 noundef 8000, i64 noundef %246, i64 noundef %247, i64 noundef %248, i64 noundef %250, ptr noundef nonnull @.str.148)
  tail call void @_Z14test_variable1Im19custom_variable_andImEEvPT_iS2_PKc(ptr noundef nonnull @data64unsigned, i32 noundef 8000, i64 noundef %246, ptr noundef nonnull @.str.149)
  tail call void @_Z14test_variable4Im28custom_multiple_variable_andImEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data64unsigned, i32 noundef 8000, i64 noundef %246, i64 noundef %247, i64 noundef %248, i64 noundef %250, ptr noundef nonnull @.str.150)
  tail call void @_Z14test_variable1Im18custom_variable_orImEEvPT_iS2_PKc(ptr noundef nonnull @data64unsigned, i32 noundef 8000, i64 noundef %246, ptr noundef nonnull @.str.151)
  tail call void @_Z14test_variable4Im27custom_multiple_variable_orImEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data64unsigned, i32 noundef 8000, i64 noundef %246, i64 noundef %247, i64 noundef %248, i64 noundef %250, ptr noundef nonnull @.str.152)
  tail call void @_Z14test_variable1Im19custom_variable_xorImEEvPT_iS2_PKc(ptr noundef nonnull @data64unsigned, i32 noundef 8000, i64 noundef %246, ptr noundef nonnull @.str.153)
  tail call void @_Z14test_variable4Im28custom_multiple_variable_xorImEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @data64unsigned, i32 noundef 8000, i64 noundef %246, i64 noundef %247, i64 noundef %248, i64 noundef %250, ptr noundef nonnull @.str.154)
  %251 = load double, ptr @init_value, align 8, !tbaa !28
  %252 = fptrunc double %251 to float
  %253 = insertelement <4 x float> poison, float %252, i64 0
  %254 = shufflevector <4 x float> %253, <4 x float> poison, <4 x i32> zeroinitializer
  %255 = insertelement <4 x float> poison, float %252, i64 0
  %256 = shufflevector <4 x float> %255, <4 x float> poison, <4 x i32> zeroinitializer
  br label %257

257:                                              ; preds = %257, %245
  %258 = phi i64 [ 0, %245 ], [ %278, %257 ]
  %259 = shl i64 %258, 2
  %260 = getelementptr i8, ptr @dataFloat, i64 %259
  store <4 x float> %254, ptr %260, align 16, !tbaa !40
  %261 = getelementptr float, ptr %260, i64 4
  store <4 x float> %256, ptr %261, align 16, !tbaa !40
  %262 = shl i64 %258, 2
  %263 = add i64 %262, 32
  %264 = getelementptr i8, ptr @dataFloat, i64 %263
  store <4 x float> %254, ptr %264, align 16, !tbaa !40
  %265 = getelementptr float, ptr %264, i64 4
  store <4 x float> %256, ptr %265, align 16, !tbaa !40
  %266 = shl i64 %258, 2
  %267 = add i64 %266, 64
  %268 = getelementptr i8, ptr @dataFloat, i64 %267
  store <4 x float> %254, ptr %268, align 16, !tbaa !40
  %269 = getelementptr float, ptr %268, i64 4
  store <4 x float> %256, ptr %269, align 16, !tbaa !40
  %270 = shl i64 %258, 2
  %271 = add i64 %270, 96
  %272 = getelementptr i8, ptr @dataFloat, i64 %271
  store <4 x float> %254, ptr %272, align 16, !tbaa !40
  %273 = getelementptr float, ptr %272, i64 4
  store <4 x float> %256, ptr %273, align 16, !tbaa !40
  %274 = shl i64 %258, 2
  %275 = add i64 %274, 128
  %276 = getelementptr i8, ptr @dataFloat, i64 %275
  store <4 x float> %254, ptr %276, align 16, !tbaa !40
  %277 = getelementptr float, ptr %276, i64 4
  store <4 x float> %256, ptr %277, align 16, !tbaa !40
  %278 = add nuw nsw i64 %258, 40
  %279 = icmp eq i64 %278, 8000
  br i1 %279, label %280, label %257, !llvm.loop !42

280:                                              ; preds = %257
  %281 = fptrunc double %20 to float
  %282 = fmul float %281, 2.000000e+00
  %283 = fadd float %281, 2.000000e+00
  %284 = fdiv float %282, %283
  %285 = fadd float %284, %281
  tail call void @_Z14test_variable1If19custom_add_variableIfEEvPT_iS2_PKc(ptr noundef nonnull @dataFloat, i32 noundef 8000, float noundef %281, ptr noundef nonnull @.str.155)
  tail call void @_Z22test_hoisted_variable1If19custom_add_variableIfEEvPT_iS2_PKc(ptr noundef nonnull @dataFloat, i32 noundef 8000, float noundef %281, ptr noundef nonnull @.str.156)
  tail call void @_Z14test_variable4If28custom_add_multiple_variableIfEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @dataFloat, i32 noundef 8000, float noundef %281, float noundef %282, float noundef %283, float noundef %285, ptr noundef nonnull @.str.157)
  tail call void @_Z14test_variable1If19custom_sub_variableIfEEvPT_iS2_PKc(ptr noundef nonnull @dataFloat, i32 noundef 8000, float noundef %281, ptr noundef nonnull @.str.158)
  tail call void @_Z14test_variable4If28custom_sub_multiple_variableIfEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @dataFloat, i32 noundef 8000, float noundef %281, float noundef %282, float noundef %283, float noundef %285, ptr noundef nonnull @.str.159)
  tail call void @_Z14test_variable1If24custom_multiply_variableIfEEvPT_iS2_PKc(ptr noundef nonnull @dataFloat, i32 noundef 8000, float noundef %281, ptr noundef nonnull @.str.160)
  tail call void @_Z14test_variable4If33custom_multiply_multiple_variableIfEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @dataFloat, i32 noundef 8000, float noundef %281, float noundef %282, float noundef %283, float noundef %285, ptr noundef nonnull @.str.161)
  tail call void @_Z14test_variable4If34custom_multiply_multiple_variable2IfEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @dataFloat, i32 noundef 8000, float noundef %281, float noundef %282, float noundef %283, float noundef %285, ptr noundef nonnull @.str.162)
  tail call void @_Z14test_variable1If22custom_divide_variableIfEEvPT_iS2_PKc(ptr noundef nonnull @dataFloat, i32 noundef 8000, float noundef %281, ptr noundef nonnull @.str.163)
  tail call void @_Z14test_variable4If31custom_divide_multiple_variableIfEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @dataFloat, i32 noundef 8000, float noundef %281, float noundef %282, float noundef %283, float noundef %285, ptr noundef nonnull @.str.164)
  tail call void @_Z14test_variable4If32custom_divide_multiple_variable2IfEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @dataFloat, i32 noundef 8000, float noundef %281, float noundef %282, float noundef %283, float noundef %285, ptr noundef nonnull @.str.165)
  tail call void @_Z14test_variable4If30custom_mixed_multiple_variableIfEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @dataFloat, i32 noundef 8000, float noundef %281, float noundef %282, float noundef %283, float noundef %285, ptr noundef nonnull @.str.166)
  %286 = load double, ptr @init_value, align 8, !tbaa !28
  %287 = insertelement <2 x double> poison, double %286, i64 0
  %288 = shufflevector <2 x double> %287, <2 x double> poison, <2 x i32> zeroinitializer
  %289 = insertelement <2 x double> poison, double %286, i64 0
  %290 = shufflevector <2 x double> %289, <2 x double> poison, <2 x i32> zeroinitializer
  br label %291

291:                                              ; preds = %291, %280
  %292 = phi i64 [ 0, %280 ], [ %312, %291 ]
  %293 = shl i64 %292, 3
  %294 = getelementptr i8, ptr @dataDouble, i64 %293
  store <2 x double> %288, ptr %294, align 16, !tbaa !28
  %295 = getelementptr double, ptr %294, i64 2
  store <2 x double> %290, ptr %295, align 16, !tbaa !28
  %296 = shl i64 %292, 3
  %297 = add i64 %296, 32
  %298 = getelementptr i8, ptr @dataDouble, i64 %297
  store <2 x double> %288, ptr %298, align 16, !tbaa !28
  %299 = getelementptr double, ptr %298, i64 2
  store <2 x double> %290, ptr %299, align 16, !tbaa !28
  %300 = shl i64 %292, 3
  %301 = add i64 %300, 64
  %302 = getelementptr i8, ptr @dataDouble, i64 %301
  store <2 x double> %288, ptr %302, align 16, !tbaa !28
  %303 = getelementptr double, ptr %302, i64 2
  store <2 x double> %290, ptr %303, align 16, !tbaa !28
  %304 = shl i64 %292, 3
  %305 = add i64 %304, 96
  %306 = getelementptr i8, ptr @dataDouble, i64 %305
  store <2 x double> %288, ptr %306, align 16, !tbaa !28
  %307 = getelementptr double, ptr %306, i64 2
  store <2 x double> %290, ptr %307, align 16, !tbaa !28
  %308 = shl i64 %292, 3
  %309 = add i64 %308, 128
  %310 = getelementptr i8, ptr @dataDouble, i64 %309
  store <2 x double> %288, ptr %310, align 16, !tbaa !28
  %311 = getelementptr double, ptr %310, i64 2
  store <2 x double> %290, ptr %311, align 16, !tbaa !28
  %312 = add nuw nsw i64 %292, 20
  %313 = icmp eq i64 %312, 8000
  br i1 %313, label %314, label %291, !llvm.loop !43

314:                                              ; preds = %291
  %315 = fmul double %20, 2.000000e+00
  %316 = fadd double %20, 2.000000e+00
  %317 = fdiv double %315, %316
  %318 = fadd double %20, %317
  tail call void @_Z14test_variable1Id19custom_add_variableIdEEvPT_iS2_PKc(ptr noundef nonnull @dataDouble, i32 noundef 8000, double noundef %20, ptr noundef nonnull @.str.167)
  tail call void @_Z22test_hoisted_variable1Id19custom_add_variableIdEEvPT_iS2_PKc(ptr noundef nonnull @dataDouble, i32 noundef 8000, double noundef %20, ptr noundef nonnull @.str.168)
  tail call void @_Z14test_variable4Id28custom_add_multiple_variableIdEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @dataDouble, i32 noundef 8000, double noundef %20, double noundef %315, double noundef %316, double noundef %318, ptr noundef nonnull @.str.169)
  tail call void @_Z14test_variable1Id19custom_sub_variableIdEEvPT_iS2_PKc(ptr noundef nonnull @dataDouble, i32 noundef 8000, double noundef %20, ptr noundef nonnull @.str.170)
  tail call void @_Z14test_variable4Id28custom_sub_multiple_variableIdEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @dataDouble, i32 noundef 8000, double noundef %20, double noundef %315, double noundef %316, double noundef %318, ptr noundef nonnull @.str.171)
  tail call void @_Z14test_variable1Id24custom_multiply_variableIdEEvPT_iS2_PKc(ptr noundef nonnull @dataDouble, i32 noundef 8000, double noundef %20, ptr noundef nonnull @.str.172)
  tail call void @_Z14test_variable4Id33custom_multiply_multiple_variableIdEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @dataDouble, i32 noundef 8000, double noundef %20, double noundef %315, double noundef %316, double noundef %318, ptr noundef nonnull @.str.173)
  tail call void @_Z14test_variable4Id34custom_multiply_multiple_variable2IdEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @dataDouble, i32 noundef 8000, double noundef %20, double noundef %315, double noundef %316, double noundef %318, ptr noundef nonnull @.str.174)
  tail call void @_Z14test_variable1Id22custom_divide_variableIdEEvPT_iS2_PKc(ptr noundef nonnull @dataDouble, i32 noundef 8000, double noundef %20, ptr noundef nonnull @.str.175)
  tail call void @_Z14test_variable4Id31custom_divide_multiple_variableIdEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @dataDouble, i32 noundef 8000, double noundef %20, double noundef %315, double noundef %316, double noundef %318, ptr noundef nonnull @.str.176)
  tail call void @_Z14test_variable4Id32custom_divide_multiple_variable2IdEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @dataDouble, i32 noundef 8000, double noundef %20, double noundef %315, double noundef %316, double noundef %318, ptr noundef nonnull @.str.177)
  tail call void @_Z14test_variable4Id30custom_mixed_multiple_variableIdEEvPT_iS2_S2_S2_S2_PKc(ptr noundef nonnull @dataDouble, i32 noundef 8000, double noundef %20, double noundef %315, double noundef %316, double noundef %318, ptr noundef nonnull @.str.178)
  ret i32 0
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1Ia19custom_add_variableIaEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i8 noundef signext %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !26
  %6 = load i32, ptr @iterations, align 4, !tbaa !9
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %110

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  br i1 %9, label %12, label %10

10:                                               ; preds = %8
  %11 = load double, ptr @init_value, align 8, !tbaa !28
  br label %92

12:                                               ; preds = %8
  %13 = zext i32 %1 to i64
  %14 = icmp ult i32 %1, 8
  %15 = icmp ult i32 %1, 32
  %16 = and i64 %13, 4294967264
  %17 = insertelement <16 x i8> poison, i8 %2, i64 0
  %18 = shufflevector <16 x i8> %17, <16 x i8> poison, <16 x i32> zeroinitializer
  %19 = insertelement <16 x i8> poison, i8 %2, i64 0
  %20 = shufflevector <16 x i8> %19, <16 x i8> poison, <16 x i32> zeroinitializer
  %21 = icmp eq i64 %16, %13
  %22 = and i64 %13, 24
  %23 = icmp eq i64 %22, 0
  %24 = and i64 %13, 4294967288
  %25 = insertelement <8 x i8> poison, i8 %2, i64 0
  %26 = shufflevector <8 x i8> %25, <8 x i8> poison, <8 x i32> zeroinitializer
  %27 = icmp eq i64 %24, %13
  br label %28

28:                                               ; preds = %12, %72
  %29 = phi i32 [ %73, %72 ], [ %6, %12 ]
  %30 = phi i32 [ %74, %72 ], [ 0, %12 ]
  br i1 %14, label %65, label %31

31:                                               ; preds = %28
  br i1 %15, label %50, label %32

32:                                               ; preds = %31, %32
  %33 = phi i64 [ %44, %32 ], [ 0, %31 ]
  %34 = phi <16 x i8> [ %42, %32 ], [ zeroinitializer, %31 ]
  %35 = phi <16 x i8> [ %43, %32 ], [ zeroinitializer, %31 ]
  %36 = getelementptr inbounds i8, ptr %0, i64 %33
  %37 = load <16 x i8>, ptr %36, align 1, !tbaa !29
  %38 = getelementptr inbounds i8, ptr %36, i64 16
  %39 = load <16 x i8>, ptr %38, align 1, !tbaa !29
  %40 = add <16 x i8> %34, %18
  %41 = add <16 x i8> %35, %20
  %42 = add <16 x i8> %40, %37
  %43 = add <16 x i8> %41, %39
  %44 = add nuw i64 %33, 32
  %45 = icmp eq i64 %44, %16
  br i1 %45, label %46, label %32, !llvm.loop !44

46:                                               ; preds = %32
  %47 = add <16 x i8> %43, %42
  %48 = tail call i8 @llvm.vector.reduce.add.v16i8(<16 x i8> %47)
  br i1 %21, label %85, label %49

49:                                               ; preds = %46
  br i1 %23, label %65, label %50

50:                                               ; preds = %31, %49
  %51 = phi i8 [ 0, %31 ], [ %48, %49 ]
  %52 = phi i64 [ 0, %31 ], [ %16, %49 ]
  %53 = insertelement <8 x i8> <i8 poison, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0>, i8 %51, i64 0
  br label %54

54:                                               ; preds = %54, %50
  %55 = phi i64 [ %52, %50 ], [ %61, %54 ]
  %56 = phi <8 x i8> [ %53, %50 ], [ %60, %54 ]
  %57 = getelementptr inbounds i8, ptr %0, i64 %55
  %58 = load <8 x i8>, ptr %57, align 1, !tbaa !29
  %59 = add <8 x i8> %56, %26
  %60 = add <8 x i8> %59, %58
  %61 = add nuw i64 %55, 8
  %62 = icmp eq i64 %61, %24
  br i1 %62, label %63, label %54, !llvm.loop !45

63:                                               ; preds = %54
  %64 = tail call i8 @llvm.vector.reduce.add.v8i8(<8 x i8> %60)
  br i1 %27, label %85, label %65

65:                                               ; preds = %28, %49, %63
  %66 = phi i64 [ 0, %28 ], [ %16, %49 ], [ %24, %63 ]
  %67 = phi i8 [ 0, %28 ], [ %48, %49 ], [ %64, %63 ]
  br label %76

68:                                               ; preds = %85
  %69 = load i32, ptr @current_test, align 4, !tbaa !9
  %70 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %69)
  %71 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %72

72:                                               ; preds = %68, %85
  %73 = phi i32 [ %71, %68 ], [ %29, %85 ]
  %74 = add nuw nsw i32 %30, 1
  %75 = icmp slt i32 %74, %73
  br i1 %75, label %28, label %110, !llvm.loop !46

76:                                               ; preds = %65, %76
  %77 = phi i64 [ %83, %76 ], [ %66, %65 ]
  %78 = phi i8 [ %82, %76 ], [ %67, %65 ]
  %79 = getelementptr inbounds i8, ptr %0, i64 %77
  %80 = load i8, ptr %79, align 1, !tbaa !29
  %81 = add i8 %78, %2
  %82 = add i8 %81, %80
  %83 = add nuw nsw i64 %77, 1
  %84 = icmp eq i64 %83, %13
  br i1 %84, label %85, label %76, !llvm.loop !47

85:                                               ; preds = %76, %63, %46
  %86 = phi i8 [ %48, %46 ], [ %64, %63 ], [ %82, %76 ]
  %87 = load double, ptr @init_value, align 8, !tbaa !28
  %88 = fptosi double %87 to i8
  %89 = add i8 %88, %2
  %90 = shl i8 %89, 6
  %91 = icmp eq i8 %90, %86
  br i1 %91, label %72, label %68

92:                                               ; preds = %10, %105
  %93 = phi i32 [ %106, %105 ], [ %6, %10 ]
  %94 = phi double [ %107, %105 ], [ %11, %10 ]
  %95 = phi i32 [ %108, %105 ], [ 0, %10 ]
  %96 = fptosi double %94 to i8
  %97 = add i8 %96, %2
  %98 = and i8 %97, 3
  %99 = icmp eq i8 %98, 0
  br i1 %99, label %105, label %100

100:                                              ; preds = %92
  %101 = load i32, ptr @current_test, align 4, !tbaa !9
  %102 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %101)
  %103 = load double, ptr @init_value, align 8, !tbaa !28
  %104 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %105

105:                                              ; preds = %92, %100
  %106 = phi i32 [ %93, %92 ], [ %104, %100 ]
  %107 = phi double [ %94, %92 ], [ %103, %100 ]
  %108 = add nuw nsw i32 %95, 1
  %109 = icmp slt i32 %108, %106
  br i1 %109, label %92, label %110, !llvm.loop !46

110:                                              ; preds = %105, %72, %4
  %111 = tail call i64 @clock() #17
  store i64 %111, ptr @end_time, align 8, !tbaa !26
  %112 = load i64, ptr @start_time, align 8, !tbaa !26
  %113 = load ptr, ptr @results, align 8, !tbaa !5
  %114 = icmp eq ptr %113, null
  br i1 %114, label %115, label %117

115:                                              ; preds = %110
  %116 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %121

117:                                              ; preds = %110
  %118 = load i32, ptr @current_test, align 4, !tbaa !9
  %119 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %120 = icmp slt i32 %118, %119
  br i1 %120, label %133, label %121

121:                                              ; preds = %117, %115
  %122 = phi i32 [ %116, %115 ], [ %119, %117 ]
  %123 = add nsw i32 %122, 10
  store i32 %123, ptr @allocated_results, align 4, !tbaa !9
  %124 = sext i32 %123 to i64
  %125 = shl nsw i64 %124, 4
  %126 = tail call ptr @realloc(ptr noundef %113, i64 noundef %125) #14
  store ptr %126, ptr @results, align 8, !tbaa !5
  %127 = icmp eq ptr %126, null
  br i1 %127, label %130, label %128

128:                                              ; preds = %121
  %129 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %133

130:                                              ; preds = %121
  %131 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %132 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %131)
  tail call void @exit(i32 noundef -1) #15
  unreachable

133:                                              ; preds = %117, %128
  %134 = phi i32 [ %129, %128 ], [ %118, %117 ]
  %135 = phi ptr [ %126, %128 ], [ %113, %117 ]
  %136 = sub nsw i64 %111, %112
  %137 = sitofp i64 %136 to double
  %138 = fdiv double %137, 1.000000e+06
  %139 = sext i32 %134 to i64
  %140 = getelementptr inbounds %struct.one_result, ptr %135, i64 %139
  store double %138, ptr %140, align 8, !tbaa !11
  %141 = getelementptr inbounds %struct.one_result, ptr %135, i64 %139, i32 1
  store ptr %3, ptr %141, align 8, !tbaa !14
  %142 = add nsw i32 %134, 1
  store i32 %142, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z22test_hoisted_variable1Ia19custom_add_variableIaEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i8 noundef signext %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !26
  %6 = load i32, ptr @iterations, align 4, !tbaa !9
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %103

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  %10 = trunc i32 %1 to i8
  %11 = mul i8 %10, %2
  br i1 %9, label %14, label %12

12:                                               ; preds = %8
  %13 = load double, ptr @init_value, align 8, !tbaa !28
  br label %85

14:                                               ; preds = %8
  %15 = zext i32 %1 to i64
  %16 = icmp ult i32 %1, 8
  %17 = icmp ult i32 %1, 32
  %18 = and i64 %15, 4294967264
  %19 = icmp eq i64 %18, %15
  %20 = and i64 %15, 24
  %21 = icmp eq i64 %20, 0
  %22 = and i64 %15, 4294967288
  %23 = icmp eq i64 %22, %15
  br label %24

24:                                               ; preds = %14, %65
  %25 = phi i32 [ %66, %65 ], [ %6, %14 ]
  %26 = phi i32 [ %67, %65 ], [ 0, %14 ]
  br i1 %16, label %58, label %27

27:                                               ; preds = %24
  br i1 %17, label %44, label %28

28:                                               ; preds = %27, %28
  %29 = phi i64 [ %38, %28 ], [ 0, %27 ]
  %30 = phi <16 x i8> [ %36, %28 ], [ zeroinitializer, %27 ]
  %31 = phi <16 x i8> [ %37, %28 ], [ zeroinitializer, %27 ]
  %32 = getelementptr inbounds i8, ptr %0, i64 %29
  %33 = load <16 x i8>, ptr %32, align 1, !tbaa !29
  %34 = getelementptr inbounds i8, ptr %32, i64 16
  %35 = load <16 x i8>, ptr %34, align 1, !tbaa !29
  %36 = add <16 x i8> %33, %30
  %37 = add <16 x i8> %35, %31
  %38 = add nuw i64 %29, 32
  %39 = icmp eq i64 %38, %18
  br i1 %39, label %40, label %28, !llvm.loop !48

40:                                               ; preds = %28
  %41 = add <16 x i8> %37, %36
  %42 = tail call i8 @llvm.vector.reduce.add.v16i8(<16 x i8> %41)
  br i1 %19, label %77, label %43

43:                                               ; preds = %40
  br i1 %21, label %58, label %44

44:                                               ; preds = %27, %43
  %45 = phi i8 [ 0, %27 ], [ %42, %43 ]
  %46 = phi i64 [ 0, %27 ], [ %18, %43 ]
  %47 = insertelement <8 x i8> <i8 poison, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0>, i8 %45, i64 0
  br label %48

48:                                               ; preds = %48, %44
  %49 = phi i64 [ %46, %44 ], [ %54, %48 ]
  %50 = phi <8 x i8> [ %47, %44 ], [ %53, %48 ]
  %51 = getelementptr inbounds i8, ptr %0, i64 %49
  %52 = load <8 x i8>, ptr %51, align 1, !tbaa !29
  %53 = add <8 x i8> %52, %50
  %54 = add nuw i64 %49, 8
  %55 = icmp eq i64 %54, %22
  br i1 %55, label %56, label %48, !llvm.loop !49

56:                                               ; preds = %48
  %57 = tail call i8 @llvm.vector.reduce.add.v8i8(<8 x i8> %53)
  br i1 %23, label %77, label %58

58:                                               ; preds = %24, %43, %56
  %59 = phi i64 [ 0, %24 ], [ %18, %43 ], [ %22, %56 ]
  %60 = phi i8 [ 0, %24 ], [ %42, %43 ], [ %57, %56 ]
  br label %69

61:                                               ; preds = %77
  %62 = load i32, ptr @current_test, align 4, !tbaa !9
  %63 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %62)
  %64 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %65

65:                                               ; preds = %61, %77
  %66 = phi i32 [ %64, %61 ], [ %25, %77 ]
  %67 = add nuw nsw i32 %26, 1
  %68 = icmp slt i32 %67, %66
  br i1 %68, label %24, label %103, !llvm.loop !50

69:                                               ; preds = %58, %69
  %70 = phi i64 [ %75, %69 ], [ %59, %58 ]
  %71 = phi i8 [ %74, %69 ], [ %60, %58 ]
  %72 = getelementptr inbounds i8, ptr %0, i64 %70
  %73 = load i8, ptr %72, align 1, !tbaa !29
  %74 = add i8 %73, %71
  %75 = add nuw nsw i64 %70, 1
  %76 = icmp eq i64 %75, %15
  br i1 %76, label %77, label %69, !llvm.loop !51

77:                                               ; preds = %69, %56, %40
  %78 = phi i8 [ %42, %40 ], [ %57, %56 ], [ %74, %69 ]
  %79 = add i8 %78, %11
  %80 = load double, ptr @init_value, align 8, !tbaa !28
  %81 = fptosi double %80 to i8
  %82 = add i8 %81, %2
  %83 = shl i8 %82, 6
  %84 = icmp eq i8 %83, %79
  br i1 %84, label %65, label %61

85:                                               ; preds = %12, %98
  %86 = phi i32 [ %99, %98 ], [ %6, %12 ]
  %87 = phi double [ %100, %98 ], [ %13, %12 ]
  %88 = phi i32 [ %101, %98 ], [ 0, %12 ]
  %89 = fptosi double %87 to i8
  %90 = add i8 %89, %2
  %91 = shl i8 %90, 6
  %92 = icmp eq i8 %91, %11
  br i1 %92, label %98, label %93

93:                                               ; preds = %85
  %94 = load i32, ptr @current_test, align 4, !tbaa !9
  %95 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %94)
  %96 = load double, ptr @init_value, align 8, !tbaa !28
  %97 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %98

98:                                               ; preds = %85, %93
  %99 = phi i32 [ %86, %85 ], [ %97, %93 ]
  %100 = phi double [ %87, %85 ], [ %96, %93 ]
  %101 = add nuw nsw i32 %88, 1
  %102 = icmp slt i32 %101, %99
  br i1 %102, label %85, label %103, !llvm.loop !50

103:                                              ; preds = %98, %65, %4
  %104 = tail call i64 @clock() #17
  store i64 %104, ptr @end_time, align 8, !tbaa !26
  %105 = load i64, ptr @start_time, align 8, !tbaa !26
  %106 = load ptr, ptr @results, align 8, !tbaa !5
  %107 = icmp eq ptr %106, null
  br i1 %107, label %108, label %110

108:                                              ; preds = %103
  %109 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %114

110:                                              ; preds = %103
  %111 = load i32, ptr @current_test, align 4, !tbaa !9
  %112 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %113 = icmp slt i32 %111, %112
  br i1 %113, label %126, label %114

114:                                              ; preds = %110, %108
  %115 = phi i32 [ %109, %108 ], [ %112, %110 ]
  %116 = add nsw i32 %115, 10
  store i32 %116, ptr @allocated_results, align 4, !tbaa !9
  %117 = sext i32 %116 to i64
  %118 = shl nsw i64 %117, 4
  %119 = tail call ptr @realloc(ptr noundef %106, i64 noundef %118) #14
  store ptr %119, ptr @results, align 8, !tbaa !5
  %120 = icmp eq ptr %119, null
  br i1 %120, label %123, label %121

121:                                              ; preds = %114
  %122 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %126

123:                                              ; preds = %114
  %124 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %125 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %124)
  tail call void @exit(i32 noundef -1) #15
  unreachable

126:                                              ; preds = %110, %121
  %127 = phi i32 [ %122, %121 ], [ %111, %110 ]
  %128 = phi ptr [ %119, %121 ], [ %106, %110 ]
  %129 = sub nsw i64 %104, %105
  %130 = sitofp i64 %129 to double
  %131 = fdiv double %130, 1.000000e+06
  %132 = sext i32 %127 to i64
  %133 = getelementptr inbounds %struct.one_result, ptr %128, i64 %132
  store double %131, ptr %133, align 8, !tbaa !11
  %134 = getelementptr inbounds %struct.one_result, ptr %128, i64 %132, i32 1
  store ptr %3, ptr %134, align 8, !tbaa !14
  %135 = add nsw i32 %127, 1
  store i32 %135, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Ia28custom_add_multiple_variableIaEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i8 noundef signext %2, i8 noundef signext %3, i8 noundef signext %4, i8 noundef signext %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !26
  %9 = load i32, ptr @iterations, align 4, !tbaa !9
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %116

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  %13 = add i8 %3, %2
  %14 = add i8 %13, %4
  %15 = add i8 %14, %5
  br i1 %12, label %18, label %16

16:                                               ; preds = %11
  %17 = load double, ptr @init_value, align 8, !tbaa !28
  br label %98

18:                                               ; preds = %11
  %19 = zext i32 %1 to i64
  %20 = icmp ult i32 %1, 8
  %21 = icmp ult i32 %1, 32
  %22 = and i64 %19, 4294967264
  %23 = insertelement <16 x i8> poison, i8 %15, i64 0
  %24 = shufflevector <16 x i8> %23, <16 x i8> poison, <16 x i32> zeroinitializer
  %25 = insertelement <16 x i8> poison, i8 %15, i64 0
  %26 = shufflevector <16 x i8> %25, <16 x i8> poison, <16 x i32> zeroinitializer
  %27 = icmp eq i64 %22, %19
  %28 = and i64 %19, 24
  %29 = icmp eq i64 %28, 0
  %30 = and i64 %19, 4294967288
  %31 = insertelement <8 x i8> poison, i8 %15, i64 0
  %32 = shufflevector <8 x i8> %31, <8 x i8> poison, <8 x i32> zeroinitializer
  %33 = icmp eq i64 %30, %19
  br label %34

34:                                               ; preds = %18, %78
  %35 = phi i32 [ %79, %78 ], [ %9, %18 ]
  %36 = phi i32 [ %80, %78 ], [ 0, %18 ]
  br i1 %20, label %71, label %37

37:                                               ; preds = %34
  br i1 %21, label %56, label %38

38:                                               ; preds = %37, %38
  %39 = phi i64 [ %50, %38 ], [ 0, %37 ]
  %40 = phi <16 x i8> [ %48, %38 ], [ zeroinitializer, %37 ]
  %41 = phi <16 x i8> [ %49, %38 ], [ zeroinitializer, %37 ]
  %42 = getelementptr inbounds i8, ptr %0, i64 %39
  %43 = load <16 x i8>, ptr %42, align 1, !tbaa !29
  %44 = getelementptr inbounds i8, ptr %42, i64 16
  %45 = load <16 x i8>, ptr %44, align 1, !tbaa !29
  %46 = add <16 x i8> %24, %40
  %47 = add <16 x i8> %26, %41
  %48 = add <16 x i8> %46, %43
  %49 = add <16 x i8> %47, %45
  %50 = add nuw i64 %39, 32
  %51 = icmp eq i64 %50, %22
  br i1 %51, label %52, label %38, !llvm.loop !52

52:                                               ; preds = %38
  %53 = add <16 x i8> %49, %48
  %54 = tail call i8 @llvm.vector.reduce.add.v16i8(<16 x i8> %53)
  br i1 %27, label %91, label %55

55:                                               ; preds = %52
  br i1 %29, label %71, label %56

56:                                               ; preds = %37, %55
  %57 = phi i8 [ 0, %37 ], [ %54, %55 ]
  %58 = phi i64 [ 0, %37 ], [ %22, %55 ]
  %59 = insertelement <8 x i8> <i8 poison, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0>, i8 %57, i64 0
  br label %60

60:                                               ; preds = %60, %56
  %61 = phi i64 [ %58, %56 ], [ %67, %60 ]
  %62 = phi <8 x i8> [ %59, %56 ], [ %66, %60 ]
  %63 = getelementptr inbounds i8, ptr %0, i64 %61
  %64 = load <8 x i8>, ptr %63, align 1, !tbaa !29
  %65 = add <8 x i8> %32, %62
  %66 = add <8 x i8> %65, %64
  %67 = add nuw i64 %61, 8
  %68 = icmp eq i64 %67, %30
  br i1 %68, label %69, label %60, !llvm.loop !53

69:                                               ; preds = %60
  %70 = tail call i8 @llvm.vector.reduce.add.v8i8(<8 x i8> %66)
  br i1 %33, label %91, label %71

71:                                               ; preds = %34, %55, %69
  %72 = phi i64 [ 0, %34 ], [ %22, %55 ], [ %30, %69 ]
  %73 = phi i8 [ 0, %34 ], [ %54, %55 ], [ %70, %69 ]
  br label %82

74:                                               ; preds = %91
  %75 = load i32, ptr @current_test, align 4, !tbaa !9
  %76 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %75)
  %77 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %78

78:                                               ; preds = %74, %91
  %79 = phi i32 [ %77, %74 ], [ %35, %91 ]
  %80 = add nuw nsw i32 %36, 1
  %81 = icmp slt i32 %80, %79
  br i1 %81, label %34, label %116, !llvm.loop !54

82:                                               ; preds = %71, %82
  %83 = phi i64 [ %89, %82 ], [ %72, %71 ]
  %84 = phi i8 [ %88, %82 ], [ %73, %71 ]
  %85 = getelementptr inbounds i8, ptr %0, i64 %83
  %86 = load i8, ptr %85, align 1, !tbaa !29
  %87 = add i8 %15, %84
  %88 = add i8 %87, %86
  %89 = add nuw nsw i64 %83, 1
  %90 = icmp eq i64 %89, %19
  br i1 %90, label %91, label %82, !llvm.loop !55

91:                                               ; preds = %82, %69, %52
  %92 = phi i8 [ %54, %52 ], [ %70, %69 ], [ %88, %82 ]
  %93 = load double, ptr @init_value, align 8, !tbaa !28
  %94 = fptosi double %93 to i8
  %95 = add i8 %15, %94
  %96 = shl i8 %95, 6
  %97 = icmp eq i8 %96, %92
  br i1 %97, label %78, label %74

98:                                               ; preds = %16, %111
  %99 = phi i32 [ %112, %111 ], [ %9, %16 ]
  %100 = phi double [ %113, %111 ], [ %17, %16 ]
  %101 = phi i32 [ %114, %111 ], [ 0, %16 ]
  %102 = fptosi double %100 to i8
  %103 = add i8 %15, %102
  %104 = and i8 %103, 3
  %105 = icmp eq i8 %104, 0
  br i1 %105, label %111, label %106

106:                                              ; preds = %98
  %107 = load i32, ptr @current_test, align 4, !tbaa !9
  %108 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %107)
  %109 = load double, ptr @init_value, align 8, !tbaa !28
  %110 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %111

111:                                              ; preds = %98, %106
  %112 = phi i32 [ %99, %98 ], [ %110, %106 ]
  %113 = phi double [ %100, %98 ], [ %109, %106 ]
  %114 = add nuw nsw i32 %101, 1
  %115 = icmp slt i32 %114, %112
  br i1 %115, label %98, label %116, !llvm.loop !54

116:                                              ; preds = %111, %78, %7
  %117 = tail call i64 @clock() #17
  store i64 %117, ptr @end_time, align 8, !tbaa !26
  %118 = load i64, ptr @start_time, align 8, !tbaa !26
  %119 = load ptr, ptr @results, align 8, !tbaa !5
  %120 = icmp eq ptr %119, null
  br i1 %120, label %121, label %123

121:                                              ; preds = %116
  %122 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %127

123:                                              ; preds = %116
  %124 = load i32, ptr @current_test, align 4, !tbaa !9
  %125 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %126 = icmp slt i32 %124, %125
  br i1 %126, label %139, label %127

127:                                              ; preds = %123, %121
  %128 = phi i32 [ %122, %121 ], [ %125, %123 ]
  %129 = add nsw i32 %128, 10
  store i32 %129, ptr @allocated_results, align 4, !tbaa !9
  %130 = sext i32 %129 to i64
  %131 = shl nsw i64 %130, 4
  %132 = tail call ptr @realloc(ptr noundef %119, i64 noundef %131) #14
  store ptr %132, ptr @results, align 8, !tbaa !5
  %133 = icmp eq ptr %132, null
  br i1 %133, label %136, label %134

134:                                              ; preds = %127
  %135 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %139

136:                                              ; preds = %127
  %137 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %138 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %137)
  tail call void @exit(i32 noundef -1) #15
  unreachable

139:                                              ; preds = %123, %134
  %140 = phi i32 [ %135, %134 ], [ %124, %123 ]
  %141 = phi ptr [ %132, %134 ], [ %119, %123 ]
  %142 = sub nsw i64 %117, %118
  %143 = sitofp i64 %142 to double
  %144 = fdiv double %143, 1.000000e+06
  %145 = sext i32 %140 to i64
  %146 = getelementptr inbounds %struct.one_result, ptr %141, i64 %145
  store double %144, ptr %146, align 8, !tbaa !11
  %147 = getelementptr inbounds %struct.one_result, ptr %141, i64 %145, i32 1
  store ptr %6, ptr %147, align 8, !tbaa !14
  %148 = add nsw i32 %140, 1
  store i32 %148, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1Ia19custom_sub_variableIaEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i8 noundef signext %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !26
  %6 = load i32, ptr @iterations, align 4, !tbaa !9
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %110

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  br i1 %9, label %12, label %10

10:                                               ; preds = %8
  %11 = load double, ptr @init_value, align 8, !tbaa !28
  br label %92

12:                                               ; preds = %8
  %13 = zext i32 %1 to i64
  %14 = icmp ult i32 %1, 8
  %15 = icmp ult i32 %1, 32
  %16 = and i64 %13, 4294967264
  %17 = insertelement <16 x i8> poison, i8 %2, i64 0
  %18 = shufflevector <16 x i8> %17, <16 x i8> poison, <16 x i32> zeroinitializer
  %19 = insertelement <16 x i8> poison, i8 %2, i64 0
  %20 = shufflevector <16 x i8> %19, <16 x i8> poison, <16 x i32> zeroinitializer
  %21 = icmp eq i64 %16, %13
  %22 = and i64 %13, 24
  %23 = icmp eq i64 %22, 0
  %24 = and i64 %13, 4294967288
  %25 = insertelement <8 x i8> poison, i8 %2, i64 0
  %26 = shufflevector <8 x i8> %25, <8 x i8> poison, <8 x i32> zeroinitializer
  %27 = icmp eq i64 %24, %13
  br label %28

28:                                               ; preds = %12, %72
  %29 = phi i32 [ %73, %72 ], [ %6, %12 ]
  %30 = phi i32 [ %74, %72 ], [ 0, %12 ]
  br i1 %14, label %65, label %31

31:                                               ; preds = %28
  br i1 %15, label %50, label %32

32:                                               ; preds = %31, %32
  %33 = phi i64 [ %44, %32 ], [ 0, %31 ]
  %34 = phi <16 x i8> [ %42, %32 ], [ zeroinitializer, %31 ]
  %35 = phi <16 x i8> [ %43, %32 ], [ zeroinitializer, %31 ]
  %36 = getelementptr inbounds i8, ptr %0, i64 %33
  %37 = load <16 x i8>, ptr %36, align 1, !tbaa !29
  %38 = getelementptr inbounds i8, ptr %36, i64 16
  %39 = load <16 x i8>, ptr %38, align 1, !tbaa !29
  %40 = sub <16 x i8> %34, %18
  %41 = sub <16 x i8> %35, %20
  %42 = add <16 x i8> %40, %37
  %43 = add <16 x i8> %41, %39
  %44 = add nuw i64 %33, 32
  %45 = icmp eq i64 %44, %16
  br i1 %45, label %46, label %32, !llvm.loop !56

46:                                               ; preds = %32
  %47 = add <16 x i8> %43, %42
  %48 = tail call i8 @llvm.vector.reduce.add.v16i8(<16 x i8> %47)
  br i1 %21, label %85, label %49

49:                                               ; preds = %46
  br i1 %23, label %65, label %50

50:                                               ; preds = %31, %49
  %51 = phi i8 [ 0, %31 ], [ %48, %49 ]
  %52 = phi i64 [ 0, %31 ], [ %16, %49 ]
  %53 = insertelement <8 x i8> <i8 poison, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0>, i8 %51, i64 0
  br label %54

54:                                               ; preds = %54, %50
  %55 = phi i64 [ %52, %50 ], [ %61, %54 ]
  %56 = phi <8 x i8> [ %53, %50 ], [ %60, %54 ]
  %57 = getelementptr inbounds i8, ptr %0, i64 %55
  %58 = load <8 x i8>, ptr %57, align 1, !tbaa !29
  %59 = sub <8 x i8> %56, %26
  %60 = add <8 x i8> %59, %58
  %61 = add nuw i64 %55, 8
  %62 = icmp eq i64 %61, %24
  br i1 %62, label %63, label %54, !llvm.loop !57

63:                                               ; preds = %54
  %64 = tail call i8 @llvm.vector.reduce.add.v8i8(<8 x i8> %60)
  br i1 %27, label %85, label %65

65:                                               ; preds = %28, %49, %63
  %66 = phi i64 [ 0, %28 ], [ %16, %49 ], [ %24, %63 ]
  %67 = phi i8 [ 0, %28 ], [ %48, %49 ], [ %64, %63 ]
  br label %76

68:                                               ; preds = %85
  %69 = load i32, ptr @current_test, align 4, !tbaa !9
  %70 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %69)
  %71 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %72

72:                                               ; preds = %68, %85
  %73 = phi i32 [ %71, %68 ], [ %29, %85 ]
  %74 = add nuw nsw i32 %30, 1
  %75 = icmp slt i32 %74, %73
  br i1 %75, label %28, label %110, !llvm.loop !58

76:                                               ; preds = %65, %76
  %77 = phi i64 [ %83, %76 ], [ %66, %65 ]
  %78 = phi i8 [ %82, %76 ], [ %67, %65 ]
  %79 = getelementptr inbounds i8, ptr %0, i64 %77
  %80 = load i8, ptr %79, align 1, !tbaa !29
  %81 = sub i8 %78, %2
  %82 = add i8 %81, %80
  %83 = add nuw nsw i64 %77, 1
  %84 = icmp eq i64 %83, %13
  br i1 %84, label %85, label %76, !llvm.loop !59

85:                                               ; preds = %76, %63, %46
  %86 = phi i8 [ %48, %46 ], [ %64, %63 ], [ %82, %76 ]
  %87 = load double, ptr @init_value, align 8, !tbaa !28
  %88 = fptosi double %87 to i8
  %89 = sub i8 %88, %2
  %90 = shl i8 %89, 6
  %91 = icmp eq i8 %90, %86
  br i1 %91, label %72, label %68

92:                                               ; preds = %10, %105
  %93 = phi i32 [ %106, %105 ], [ %6, %10 ]
  %94 = phi double [ %107, %105 ], [ %11, %10 ]
  %95 = phi i32 [ %108, %105 ], [ 0, %10 ]
  %96 = fptosi double %94 to i8
  %97 = sub i8 %96, %2
  %98 = and i8 %97, 3
  %99 = icmp eq i8 %98, 0
  br i1 %99, label %105, label %100

100:                                              ; preds = %92
  %101 = load i32, ptr @current_test, align 4, !tbaa !9
  %102 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %101)
  %103 = load double, ptr @init_value, align 8, !tbaa !28
  %104 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %105

105:                                              ; preds = %92, %100
  %106 = phi i32 [ %93, %92 ], [ %104, %100 ]
  %107 = phi double [ %94, %92 ], [ %103, %100 ]
  %108 = add nuw nsw i32 %95, 1
  %109 = icmp slt i32 %108, %106
  br i1 %109, label %92, label %110, !llvm.loop !58

110:                                              ; preds = %105, %72, %4
  %111 = tail call i64 @clock() #17
  store i64 %111, ptr @end_time, align 8, !tbaa !26
  %112 = load i64, ptr @start_time, align 8, !tbaa !26
  %113 = load ptr, ptr @results, align 8, !tbaa !5
  %114 = icmp eq ptr %113, null
  br i1 %114, label %115, label %117

115:                                              ; preds = %110
  %116 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %121

117:                                              ; preds = %110
  %118 = load i32, ptr @current_test, align 4, !tbaa !9
  %119 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %120 = icmp slt i32 %118, %119
  br i1 %120, label %133, label %121

121:                                              ; preds = %117, %115
  %122 = phi i32 [ %116, %115 ], [ %119, %117 ]
  %123 = add nsw i32 %122, 10
  store i32 %123, ptr @allocated_results, align 4, !tbaa !9
  %124 = sext i32 %123 to i64
  %125 = shl nsw i64 %124, 4
  %126 = tail call ptr @realloc(ptr noundef %113, i64 noundef %125) #14
  store ptr %126, ptr @results, align 8, !tbaa !5
  %127 = icmp eq ptr %126, null
  br i1 %127, label %130, label %128

128:                                              ; preds = %121
  %129 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %133

130:                                              ; preds = %121
  %131 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %132 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %131)
  tail call void @exit(i32 noundef -1) #15
  unreachable

133:                                              ; preds = %117, %128
  %134 = phi i32 [ %129, %128 ], [ %118, %117 ]
  %135 = phi ptr [ %126, %128 ], [ %113, %117 ]
  %136 = sub nsw i64 %111, %112
  %137 = sitofp i64 %136 to double
  %138 = fdiv double %137, 1.000000e+06
  %139 = sext i32 %134 to i64
  %140 = getelementptr inbounds %struct.one_result, ptr %135, i64 %139
  store double %138, ptr %140, align 8, !tbaa !11
  %141 = getelementptr inbounds %struct.one_result, ptr %135, i64 %139, i32 1
  store ptr %3, ptr %141, align 8, !tbaa !14
  %142 = add nsw i32 %134, 1
  store i32 %142, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Ia28custom_sub_multiple_variableIaEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i8 noundef signext %2, i8 noundef signext %3, i8 noundef signext %4, i8 noundef signext %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !26
  %9 = load i32, ptr @iterations, align 4, !tbaa !9
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %116

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  %13 = add i8 %3, %2
  %14 = add i8 %13, %4
  %15 = add i8 %14, %5
  br i1 %12, label %18, label %16

16:                                               ; preds = %11
  %17 = load double, ptr @init_value, align 8, !tbaa !28
  br label %98

18:                                               ; preds = %11
  %19 = zext i32 %1 to i64
  %20 = icmp ult i32 %1, 8
  %21 = icmp ult i32 %1, 32
  %22 = and i64 %19, 4294967264
  %23 = insertelement <16 x i8> poison, i8 %15, i64 0
  %24 = shufflevector <16 x i8> %23, <16 x i8> poison, <16 x i32> zeroinitializer
  %25 = insertelement <16 x i8> poison, i8 %15, i64 0
  %26 = shufflevector <16 x i8> %25, <16 x i8> poison, <16 x i32> zeroinitializer
  %27 = icmp eq i64 %22, %19
  %28 = and i64 %19, 24
  %29 = icmp eq i64 %28, 0
  %30 = and i64 %19, 4294967288
  %31 = insertelement <8 x i8> poison, i8 %15, i64 0
  %32 = shufflevector <8 x i8> %31, <8 x i8> poison, <8 x i32> zeroinitializer
  %33 = icmp eq i64 %30, %19
  br label %34

34:                                               ; preds = %18, %78
  %35 = phi i32 [ %79, %78 ], [ %9, %18 ]
  %36 = phi i32 [ %80, %78 ], [ 0, %18 ]
  br i1 %20, label %71, label %37

37:                                               ; preds = %34
  br i1 %21, label %56, label %38

38:                                               ; preds = %37, %38
  %39 = phi i64 [ %50, %38 ], [ 0, %37 ]
  %40 = phi <16 x i8> [ %48, %38 ], [ zeroinitializer, %37 ]
  %41 = phi <16 x i8> [ %49, %38 ], [ zeroinitializer, %37 ]
  %42 = getelementptr inbounds i8, ptr %0, i64 %39
  %43 = load <16 x i8>, ptr %42, align 1, !tbaa !29
  %44 = getelementptr inbounds i8, ptr %42, i64 16
  %45 = load <16 x i8>, ptr %44, align 1, !tbaa !29
  %46 = sub <16 x i8> %40, %24
  %47 = sub <16 x i8> %41, %26
  %48 = add <16 x i8> %46, %43
  %49 = add <16 x i8> %47, %45
  %50 = add nuw i64 %39, 32
  %51 = icmp eq i64 %50, %22
  br i1 %51, label %52, label %38, !llvm.loop !60

52:                                               ; preds = %38
  %53 = add <16 x i8> %49, %48
  %54 = tail call i8 @llvm.vector.reduce.add.v16i8(<16 x i8> %53)
  br i1 %27, label %91, label %55

55:                                               ; preds = %52
  br i1 %29, label %71, label %56

56:                                               ; preds = %37, %55
  %57 = phi i8 [ 0, %37 ], [ %54, %55 ]
  %58 = phi i64 [ 0, %37 ], [ %22, %55 ]
  %59 = insertelement <8 x i8> <i8 poison, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0>, i8 %57, i64 0
  br label %60

60:                                               ; preds = %60, %56
  %61 = phi i64 [ %58, %56 ], [ %67, %60 ]
  %62 = phi <8 x i8> [ %59, %56 ], [ %66, %60 ]
  %63 = getelementptr inbounds i8, ptr %0, i64 %61
  %64 = load <8 x i8>, ptr %63, align 1, !tbaa !29
  %65 = sub <8 x i8> %62, %32
  %66 = add <8 x i8> %65, %64
  %67 = add nuw i64 %61, 8
  %68 = icmp eq i64 %67, %30
  br i1 %68, label %69, label %60, !llvm.loop !61

69:                                               ; preds = %60
  %70 = tail call i8 @llvm.vector.reduce.add.v8i8(<8 x i8> %66)
  br i1 %33, label %91, label %71

71:                                               ; preds = %34, %55, %69
  %72 = phi i64 [ 0, %34 ], [ %22, %55 ], [ %30, %69 ]
  %73 = phi i8 [ 0, %34 ], [ %54, %55 ], [ %70, %69 ]
  br label %82

74:                                               ; preds = %91
  %75 = load i32, ptr @current_test, align 4, !tbaa !9
  %76 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %75)
  %77 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %78

78:                                               ; preds = %74, %91
  %79 = phi i32 [ %77, %74 ], [ %35, %91 ]
  %80 = add nuw nsw i32 %36, 1
  %81 = icmp slt i32 %80, %79
  br i1 %81, label %34, label %116, !llvm.loop !62

82:                                               ; preds = %71, %82
  %83 = phi i64 [ %89, %82 ], [ %72, %71 ]
  %84 = phi i8 [ %88, %82 ], [ %73, %71 ]
  %85 = getelementptr inbounds i8, ptr %0, i64 %83
  %86 = load i8, ptr %85, align 1, !tbaa !29
  %87 = sub i8 %84, %15
  %88 = add i8 %87, %86
  %89 = add nuw nsw i64 %83, 1
  %90 = icmp eq i64 %89, %19
  br i1 %90, label %91, label %82, !llvm.loop !63

91:                                               ; preds = %82, %69, %52
  %92 = phi i8 [ %54, %52 ], [ %70, %69 ], [ %88, %82 ]
  %93 = load double, ptr @init_value, align 8, !tbaa !28
  %94 = fptosi double %93 to i8
  %95 = sub i8 %94, %15
  %96 = shl i8 %95, 6
  %97 = icmp eq i8 %96, %92
  br i1 %97, label %78, label %74

98:                                               ; preds = %16, %111
  %99 = phi i32 [ %112, %111 ], [ %9, %16 ]
  %100 = phi double [ %113, %111 ], [ %17, %16 ]
  %101 = phi i32 [ %114, %111 ], [ 0, %16 ]
  %102 = fptosi double %100 to i8
  %103 = sub i8 %102, %15
  %104 = and i8 %103, 3
  %105 = icmp eq i8 %104, 0
  br i1 %105, label %111, label %106

106:                                              ; preds = %98
  %107 = load i32, ptr @current_test, align 4, !tbaa !9
  %108 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %107)
  %109 = load double, ptr @init_value, align 8, !tbaa !28
  %110 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %111

111:                                              ; preds = %98, %106
  %112 = phi i32 [ %99, %98 ], [ %110, %106 ]
  %113 = phi double [ %100, %98 ], [ %109, %106 ]
  %114 = add nuw nsw i32 %101, 1
  %115 = icmp slt i32 %114, %112
  br i1 %115, label %98, label %116, !llvm.loop !62

116:                                              ; preds = %111, %78, %7
  %117 = tail call i64 @clock() #17
  store i64 %117, ptr @end_time, align 8, !tbaa !26
  %118 = load i64, ptr @start_time, align 8, !tbaa !26
  %119 = load ptr, ptr @results, align 8, !tbaa !5
  %120 = icmp eq ptr %119, null
  br i1 %120, label %121, label %123

121:                                              ; preds = %116
  %122 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %127

123:                                              ; preds = %116
  %124 = load i32, ptr @current_test, align 4, !tbaa !9
  %125 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %126 = icmp slt i32 %124, %125
  br i1 %126, label %139, label %127

127:                                              ; preds = %123, %121
  %128 = phi i32 [ %122, %121 ], [ %125, %123 ]
  %129 = add nsw i32 %128, 10
  store i32 %129, ptr @allocated_results, align 4, !tbaa !9
  %130 = sext i32 %129 to i64
  %131 = shl nsw i64 %130, 4
  %132 = tail call ptr @realloc(ptr noundef %119, i64 noundef %131) #14
  store ptr %132, ptr @results, align 8, !tbaa !5
  %133 = icmp eq ptr %132, null
  br i1 %133, label %136, label %134

134:                                              ; preds = %127
  %135 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %139

136:                                              ; preds = %127
  %137 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %138 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %137)
  tail call void @exit(i32 noundef -1) #15
  unreachable

139:                                              ; preds = %123, %134
  %140 = phi i32 [ %135, %134 ], [ %124, %123 ]
  %141 = phi ptr [ %132, %134 ], [ %119, %123 ]
  %142 = sub nsw i64 %117, %118
  %143 = sitofp i64 %142 to double
  %144 = fdiv double %143, 1.000000e+06
  %145 = sext i32 %140 to i64
  %146 = getelementptr inbounds %struct.one_result, ptr %141, i64 %145
  store double %144, ptr %146, align 8, !tbaa !11
  %147 = getelementptr inbounds %struct.one_result, ptr %141, i64 %145, i32 1
  store ptr %6, ptr %147, align 8, !tbaa !14
  %148 = add nsw i32 %140, 1
  store i32 %148, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1Ia24custom_multiply_variableIaEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i8 noundef signext %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !26
  %6 = load i32, ptr @iterations, align 4, !tbaa !9
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %109

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  %10 = shl i8 %2, 6
  br i1 %9, label %13, label %11

11:                                               ; preds = %8
  %12 = load double, ptr @init_value, align 8, !tbaa !28
  br label %92

13:                                               ; preds = %8
  %14 = zext i32 %1 to i64
  %15 = icmp ult i32 %1, 8
  %16 = icmp ult i32 %1, 32
  %17 = and i64 %14, 4294967264
  %18 = insertelement <16 x i8> poison, i8 %2, i64 0
  %19 = shufflevector <16 x i8> %18, <16 x i8> poison, <16 x i32> zeroinitializer
  %20 = insertelement <16 x i8> poison, i8 %2, i64 0
  %21 = shufflevector <16 x i8> %20, <16 x i8> poison, <16 x i32> zeroinitializer
  %22 = icmp eq i64 %17, %14
  %23 = and i64 %14, 24
  %24 = icmp eq i64 %23, 0
  %25 = and i64 %14, 4294967288
  %26 = insertelement <8 x i8> poison, i8 %2, i64 0
  %27 = shufflevector <8 x i8> %26, <8 x i8> poison, <8 x i32> zeroinitializer
  %28 = icmp eq i64 %25, %14
  br label %29

29:                                               ; preds = %13, %73
  %30 = phi i32 [ %74, %73 ], [ %6, %13 ]
  %31 = phi i32 [ %75, %73 ], [ 0, %13 ]
  br i1 %15, label %66, label %32

32:                                               ; preds = %29
  br i1 %16, label %51, label %33

33:                                               ; preds = %32, %33
  %34 = phi i64 [ %45, %33 ], [ 0, %32 ]
  %35 = phi <16 x i8> [ %43, %33 ], [ zeroinitializer, %32 ]
  %36 = phi <16 x i8> [ %44, %33 ], [ zeroinitializer, %32 ]
  %37 = getelementptr inbounds i8, ptr %0, i64 %34
  %38 = load <16 x i8>, ptr %37, align 1, !tbaa !29
  %39 = getelementptr inbounds i8, ptr %37, i64 16
  %40 = load <16 x i8>, ptr %39, align 1, !tbaa !29
  %41 = mul <16 x i8> %38, %19
  %42 = mul <16 x i8> %40, %21
  %43 = add <16 x i8> %41, %35
  %44 = add <16 x i8> %42, %36
  %45 = add nuw i64 %34, 32
  %46 = icmp eq i64 %45, %17
  br i1 %46, label %47, label %33, !llvm.loop !64

47:                                               ; preds = %33
  %48 = add <16 x i8> %44, %43
  %49 = tail call i8 @llvm.vector.reduce.add.v16i8(<16 x i8> %48)
  br i1 %22, label %86, label %50

50:                                               ; preds = %47
  br i1 %24, label %66, label %51

51:                                               ; preds = %32, %50
  %52 = phi i8 [ 0, %32 ], [ %49, %50 ]
  %53 = phi i64 [ 0, %32 ], [ %17, %50 ]
  %54 = insertelement <8 x i8> <i8 poison, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0>, i8 %52, i64 0
  br label %55

55:                                               ; preds = %55, %51
  %56 = phi i64 [ %53, %51 ], [ %62, %55 ]
  %57 = phi <8 x i8> [ %54, %51 ], [ %61, %55 ]
  %58 = getelementptr inbounds i8, ptr %0, i64 %56
  %59 = load <8 x i8>, ptr %58, align 1, !tbaa !29
  %60 = mul <8 x i8> %59, %27
  %61 = add <8 x i8> %60, %57
  %62 = add nuw i64 %56, 8
  %63 = icmp eq i64 %62, %25
  br i1 %63, label %64, label %55, !llvm.loop !65

64:                                               ; preds = %55
  %65 = tail call i8 @llvm.vector.reduce.add.v8i8(<8 x i8> %61)
  br i1 %28, label %86, label %66

66:                                               ; preds = %29, %50, %64
  %67 = phi i64 [ 0, %29 ], [ %17, %50 ], [ %25, %64 ]
  %68 = phi i8 [ 0, %29 ], [ %49, %50 ], [ %65, %64 ]
  br label %77

69:                                               ; preds = %86
  %70 = load i32, ptr @current_test, align 4, !tbaa !9
  %71 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %70)
  %72 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %73

73:                                               ; preds = %69, %86
  %74 = phi i32 [ %72, %69 ], [ %30, %86 ]
  %75 = add nuw nsw i32 %31, 1
  %76 = icmp slt i32 %75, %74
  br i1 %76, label %29, label %109, !llvm.loop !66

77:                                               ; preds = %66, %77
  %78 = phi i64 [ %84, %77 ], [ %67, %66 ]
  %79 = phi i8 [ %83, %77 ], [ %68, %66 ]
  %80 = getelementptr inbounds i8, ptr %0, i64 %78
  %81 = load i8, ptr %80, align 1, !tbaa !29
  %82 = mul i8 %81, %2
  %83 = add i8 %82, %79
  %84 = add nuw nsw i64 %78, 1
  %85 = icmp eq i64 %84, %14
  br i1 %85, label %86, label %77, !llvm.loop !67

86:                                               ; preds = %77, %64, %47
  %87 = phi i8 [ %49, %47 ], [ %65, %64 ], [ %83, %77 ]
  %88 = load double, ptr @init_value, align 8, !tbaa !28
  %89 = fptosi double %88 to i8
  %90 = mul i8 %10, %89
  %91 = icmp eq i8 %90, %87
  br i1 %91, label %73, label %69

92:                                               ; preds = %11, %104
  %93 = phi i32 [ %105, %104 ], [ %6, %11 ]
  %94 = phi double [ %106, %104 ], [ %12, %11 ]
  %95 = phi i32 [ %107, %104 ], [ 0, %11 ]
  %96 = fptosi double %94 to i8
  %97 = mul i8 %10, %96
  %98 = icmp eq i8 %97, 0
  br i1 %98, label %104, label %99

99:                                               ; preds = %92
  %100 = load i32, ptr @current_test, align 4, !tbaa !9
  %101 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %100)
  %102 = load double, ptr @init_value, align 8, !tbaa !28
  %103 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %104

104:                                              ; preds = %92, %99
  %105 = phi i32 [ %93, %92 ], [ %103, %99 ]
  %106 = phi double [ %94, %92 ], [ %102, %99 ]
  %107 = add nuw nsw i32 %95, 1
  %108 = icmp slt i32 %107, %105
  br i1 %108, label %92, label %109, !llvm.loop !66

109:                                              ; preds = %104, %73, %4
  %110 = tail call i64 @clock() #17
  store i64 %110, ptr @end_time, align 8, !tbaa !26
  %111 = load i64, ptr @start_time, align 8, !tbaa !26
  %112 = load ptr, ptr @results, align 8, !tbaa !5
  %113 = icmp eq ptr %112, null
  br i1 %113, label %114, label %116

114:                                              ; preds = %109
  %115 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %120

116:                                              ; preds = %109
  %117 = load i32, ptr @current_test, align 4, !tbaa !9
  %118 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %119 = icmp slt i32 %117, %118
  br i1 %119, label %132, label %120

120:                                              ; preds = %116, %114
  %121 = phi i32 [ %115, %114 ], [ %118, %116 ]
  %122 = add nsw i32 %121, 10
  store i32 %122, ptr @allocated_results, align 4, !tbaa !9
  %123 = sext i32 %122 to i64
  %124 = shl nsw i64 %123, 4
  %125 = tail call ptr @realloc(ptr noundef %112, i64 noundef %124) #14
  store ptr %125, ptr @results, align 8, !tbaa !5
  %126 = icmp eq ptr %125, null
  br i1 %126, label %129, label %127

127:                                              ; preds = %120
  %128 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %132

129:                                              ; preds = %120
  %130 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %131 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %130)
  tail call void @exit(i32 noundef -1) #15
  unreachable

132:                                              ; preds = %116, %127
  %133 = phi i32 [ %128, %127 ], [ %117, %116 ]
  %134 = phi ptr [ %125, %127 ], [ %112, %116 ]
  %135 = sub nsw i64 %110, %111
  %136 = sitofp i64 %135 to double
  %137 = fdiv double %136, 1.000000e+06
  %138 = sext i32 %133 to i64
  %139 = getelementptr inbounds %struct.one_result, ptr %134, i64 %138
  store double %137, ptr %139, align 8, !tbaa !11
  %140 = getelementptr inbounds %struct.one_result, ptr %134, i64 %138, i32 1
  store ptr %3, ptr %140, align 8, !tbaa !14
  %141 = add nsw i32 %133, 1
  store i32 %141, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Ia33custom_multiply_multiple_variableIaEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i8 noundef signext %2, i8 noundef signext %3, i8 noundef signext %4, i8 noundef signext %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !26
  %9 = load i32, ptr @iterations, align 4, !tbaa !9
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %117

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  %13 = mul i8 %4, %3
  %14 = mul i8 %13, %2
  %15 = mul i8 %14, %5
  %16 = shl i8 %13, 6
  %17 = mul i8 %16, %2
  %18 = mul i8 %17, %5
  br i1 %12, label %21, label %19

19:                                               ; preds = %11
  %20 = load double, ptr @init_value, align 8, !tbaa !28
  br label %100

21:                                               ; preds = %11
  %22 = zext i32 %1 to i64
  %23 = icmp ult i32 %1, 8
  %24 = icmp ult i32 %1, 32
  %25 = and i64 %22, 4294967264
  %26 = insertelement <16 x i8> poison, i8 %15, i64 0
  %27 = shufflevector <16 x i8> %26, <16 x i8> poison, <16 x i32> zeroinitializer
  %28 = insertelement <16 x i8> poison, i8 %15, i64 0
  %29 = shufflevector <16 x i8> %28, <16 x i8> poison, <16 x i32> zeroinitializer
  %30 = icmp eq i64 %25, %22
  %31 = and i64 %22, 24
  %32 = icmp eq i64 %31, 0
  %33 = and i64 %22, 4294967288
  %34 = insertelement <8 x i8> poison, i8 %15, i64 0
  %35 = shufflevector <8 x i8> %34, <8 x i8> poison, <8 x i32> zeroinitializer
  %36 = icmp eq i64 %33, %22
  br label %37

37:                                               ; preds = %21, %81
  %38 = phi i32 [ %82, %81 ], [ %9, %21 ]
  %39 = phi i32 [ %83, %81 ], [ 0, %21 ]
  br i1 %23, label %74, label %40

40:                                               ; preds = %37
  br i1 %24, label %59, label %41

41:                                               ; preds = %40, %41
  %42 = phi i64 [ %53, %41 ], [ 0, %40 ]
  %43 = phi <16 x i8> [ %51, %41 ], [ zeroinitializer, %40 ]
  %44 = phi <16 x i8> [ %52, %41 ], [ zeroinitializer, %40 ]
  %45 = getelementptr inbounds i8, ptr %0, i64 %42
  %46 = load <16 x i8>, ptr %45, align 1, !tbaa !29
  %47 = getelementptr inbounds i8, ptr %45, i64 16
  %48 = load <16 x i8>, ptr %47, align 1, !tbaa !29
  %49 = mul <16 x i8> %27, %46
  %50 = mul <16 x i8> %29, %48
  %51 = add <16 x i8> %49, %43
  %52 = add <16 x i8> %50, %44
  %53 = add nuw i64 %42, 32
  %54 = icmp eq i64 %53, %25
  br i1 %54, label %55, label %41, !llvm.loop !68

55:                                               ; preds = %41
  %56 = add <16 x i8> %52, %51
  %57 = tail call i8 @llvm.vector.reduce.add.v16i8(<16 x i8> %56)
  br i1 %30, label %94, label %58

58:                                               ; preds = %55
  br i1 %32, label %74, label %59

59:                                               ; preds = %40, %58
  %60 = phi i8 [ 0, %40 ], [ %57, %58 ]
  %61 = phi i64 [ 0, %40 ], [ %25, %58 ]
  %62 = insertelement <8 x i8> <i8 poison, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0>, i8 %60, i64 0
  br label %63

63:                                               ; preds = %63, %59
  %64 = phi i64 [ %61, %59 ], [ %70, %63 ]
  %65 = phi <8 x i8> [ %62, %59 ], [ %69, %63 ]
  %66 = getelementptr inbounds i8, ptr %0, i64 %64
  %67 = load <8 x i8>, ptr %66, align 1, !tbaa !29
  %68 = mul <8 x i8> %35, %67
  %69 = add <8 x i8> %68, %65
  %70 = add nuw i64 %64, 8
  %71 = icmp eq i64 %70, %33
  br i1 %71, label %72, label %63, !llvm.loop !69

72:                                               ; preds = %63
  %73 = tail call i8 @llvm.vector.reduce.add.v8i8(<8 x i8> %69)
  br i1 %36, label %94, label %74

74:                                               ; preds = %37, %58, %72
  %75 = phi i64 [ 0, %37 ], [ %25, %58 ], [ %33, %72 ]
  %76 = phi i8 [ 0, %37 ], [ %57, %58 ], [ %73, %72 ]
  br label %85

77:                                               ; preds = %94
  %78 = load i32, ptr @current_test, align 4, !tbaa !9
  %79 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %78)
  %80 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %81

81:                                               ; preds = %77, %94
  %82 = phi i32 [ %80, %77 ], [ %38, %94 ]
  %83 = add nuw nsw i32 %39, 1
  %84 = icmp slt i32 %83, %82
  br i1 %84, label %37, label %117, !llvm.loop !70

85:                                               ; preds = %74, %85
  %86 = phi i64 [ %92, %85 ], [ %75, %74 ]
  %87 = phi i8 [ %91, %85 ], [ %76, %74 ]
  %88 = getelementptr inbounds i8, ptr %0, i64 %86
  %89 = load i8, ptr %88, align 1, !tbaa !29
  %90 = mul i8 %15, %89
  %91 = add i8 %90, %87
  %92 = add nuw nsw i64 %86, 1
  %93 = icmp eq i64 %92, %22
  br i1 %93, label %94, label %85, !llvm.loop !71

94:                                               ; preds = %85, %72, %55
  %95 = phi i8 [ %57, %55 ], [ %73, %72 ], [ %91, %85 ]
  %96 = load double, ptr @init_value, align 8, !tbaa !28
  %97 = fptosi double %96 to i8
  %98 = mul i8 %18, %97
  %99 = icmp eq i8 %98, %95
  br i1 %99, label %81, label %77

100:                                              ; preds = %19, %112
  %101 = phi i32 [ %113, %112 ], [ %9, %19 ]
  %102 = phi double [ %114, %112 ], [ %20, %19 ]
  %103 = phi i32 [ %115, %112 ], [ 0, %19 ]
  %104 = fptosi double %102 to i8
  %105 = mul i8 %18, %104
  %106 = icmp eq i8 %105, 0
  br i1 %106, label %112, label %107

107:                                              ; preds = %100
  %108 = load i32, ptr @current_test, align 4, !tbaa !9
  %109 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %108)
  %110 = load double, ptr @init_value, align 8, !tbaa !28
  %111 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %112

112:                                              ; preds = %100, %107
  %113 = phi i32 [ %101, %100 ], [ %111, %107 ]
  %114 = phi double [ %102, %100 ], [ %110, %107 ]
  %115 = add nuw nsw i32 %103, 1
  %116 = icmp slt i32 %115, %113
  br i1 %116, label %100, label %117, !llvm.loop !70

117:                                              ; preds = %112, %81, %7
  %118 = tail call i64 @clock() #17
  store i64 %118, ptr @end_time, align 8, !tbaa !26
  %119 = load i64, ptr @start_time, align 8, !tbaa !26
  %120 = load ptr, ptr @results, align 8, !tbaa !5
  %121 = icmp eq ptr %120, null
  br i1 %121, label %122, label %124

122:                                              ; preds = %117
  %123 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %128

124:                                              ; preds = %117
  %125 = load i32, ptr @current_test, align 4, !tbaa !9
  %126 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %127 = icmp slt i32 %125, %126
  br i1 %127, label %140, label %128

128:                                              ; preds = %124, %122
  %129 = phi i32 [ %123, %122 ], [ %126, %124 ]
  %130 = add nsw i32 %129, 10
  store i32 %130, ptr @allocated_results, align 4, !tbaa !9
  %131 = sext i32 %130 to i64
  %132 = shl nsw i64 %131, 4
  %133 = tail call ptr @realloc(ptr noundef %120, i64 noundef %132) #14
  store ptr %133, ptr @results, align 8, !tbaa !5
  %134 = icmp eq ptr %133, null
  br i1 %134, label %137, label %135

135:                                              ; preds = %128
  %136 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %140

137:                                              ; preds = %128
  %138 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %139 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %138)
  tail call void @exit(i32 noundef -1) #15
  unreachable

140:                                              ; preds = %124, %135
  %141 = phi i32 [ %136, %135 ], [ %125, %124 ]
  %142 = phi ptr [ %133, %135 ], [ %120, %124 ]
  %143 = sub nsw i64 %118, %119
  %144 = sitofp i64 %143 to double
  %145 = fdiv double %144, 1.000000e+06
  %146 = sext i32 %141 to i64
  %147 = getelementptr inbounds %struct.one_result, ptr %142, i64 %146
  store double %145, ptr %147, align 8, !tbaa !11
  %148 = getelementptr inbounds %struct.one_result, ptr %142, i64 %146, i32 1
  store ptr %6, ptr %148, align 8, !tbaa !14
  %149 = add nsw i32 %141, 1
  store i32 %149, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Ia34custom_multiply_multiple_variable2IaEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i8 noundef signext %2, i8 noundef signext %3, i8 noundef signext %4, i8 noundef signext %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !26
  %9 = load i32, ptr @iterations, align 4, !tbaa !9
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %116

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  %13 = mul i8 %3, %2
  %14 = mul i8 %13, %4
  %15 = mul i8 %14, %5
  br i1 %12, label %18, label %16

16:                                               ; preds = %11
  %17 = load double, ptr @init_value, align 8, !tbaa !28
  br label %98

18:                                               ; preds = %11
  %19 = zext i32 %1 to i64
  %20 = icmp ult i32 %1, 8
  %21 = icmp ult i32 %1, 32
  %22 = and i64 %19, 4294967264
  %23 = insertelement <16 x i8> poison, i8 %15, i64 0
  %24 = shufflevector <16 x i8> %23, <16 x i8> poison, <16 x i32> zeroinitializer
  %25 = insertelement <16 x i8> poison, i8 %15, i64 0
  %26 = shufflevector <16 x i8> %25, <16 x i8> poison, <16 x i32> zeroinitializer
  %27 = icmp eq i64 %22, %19
  %28 = and i64 %19, 24
  %29 = icmp eq i64 %28, 0
  %30 = and i64 %19, 4294967288
  %31 = insertelement <8 x i8> poison, i8 %15, i64 0
  %32 = shufflevector <8 x i8> %31, <8 x i8> poison, <8 x i32> zeroinitializer
  %33 = icmp eq i64 %30, %19
  br label %34

34:                                               ; preds = %18, %78
  %35 = phi i32 [ %79, %78 ], [ %9, %18 ]
  %36 = phi i32 [ %80, %78 ], [ 0, %18 ]
  br i1 %20, label %71, label %37

37:                                               ; preds = %34
  br i1 %21, label %56, label %38

38:                                               ; preds = %37, %38
  %39 = phi i64 [ %50, %38 ], [ 0, %37 ]
  %40 = phi <16 x i8> [ %48, %38 ], [ zeroinitializer, %37 ]
  %41 = phi <16 x i8> [ %49, %38 ], [ zeroinitializer, %37 ]
  %42 = getelementptr inbounds i8, ptr %0, i64 %39
  %43 = load <16 x i8>, ptr %42, align 1, !tbaa !29
  %44 = getelementptr inbounds i8, ptr %42, i64 16
  %45 = load <16 x i8>, ptr %44, align 1, !tbaa !29
  %46 = add <16 x i8> %40, %24
  %47 = add <16 x i8> %41, %26
  %48 = add <16 x i8> %46, %43
  %49 = add <16 x i8> %47, %45
  %50 = add nuw i64 %39, 32
  %51 = icmp eq i64 %50, %22
  br i1 %51, label %52, label %38, !llvm.loop !72

52:                                               ; preds = %38
  %53 = add <16 x i8> %49, %48
  %54 = tail call i8 @llvm.vector.reduce.add.v16i8(<16 x i8> %53)
  br i1 %27, label %91, label %55

55:                                               ; preds = %52
  br i1 %29, label %71, label %56

56:                                               ; preds = %37, %55
  %57 = phi i8 [ 0, %37 ], [ %54, %55 ]
  %58 = phi i64 [ 0, %37 ], [ %22, %55 ]
  %59 = insertelement <8 x i8> <i8 poison, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0>, i8 %57, i64 0
  br label %60

60:                                               ; preds = %60, %56
  %61 = phi i64 [ %58, %56 ], [ %67, %60 ]
  %62 = phi <8 x i8> [ %59, %56 ], [ %66, %60 ]
  %63 = getelementptr inbounds i8, ptr %0, i64 %61
  %64 = load <8 x i8>, ptr %63, align 1, !tbaa !29
  %65 = add <8 x i8> %62, %32
  %66 = add <8 x i8> %65, %64
  %67 = add nuw i64 %61, 8
  %68 = icmp eq i64 %67, %30
  br i1 %68, label %69, label %60, !llvm.loop !73

69:                                               ; preds = %60
  %70 = tail call i8 @llvm.vector.reduce.add.v8i8(<8 x i8> %66)
  br i1 %33, label %91, label %71

71:                                               ; preds = %34, %55, %69
  %72 = phi i64 [ 0, %34 ], [ %22, %55 ], [ %30, %69 ]
  %73 = phi i8 [ 0, %34 ], [ %54, %55 ], [ %70, %69 ]
  br label %82

74:                                               ; preds = %91
  %75 = load i32, ptr @current_test, align 4, !tbaa !9
  %76 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %75)
  %77 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %78

78:                                               ; preds = %74, %91
  %79 = phi i32 [ %77, %74 ], [ %35, %91 ]
  %80 = add nuw nsw i32 %36, 1
  %81 = icmp slt i32 %80, %79
  br i1 %81, label %34, label %116, !llvm.loop !74

82:                                               ; preds = %71, %82
  %83 = phi i64 [ %89, %82 ], [ %72, %71 ]
  %84 = phi i8 [ %88, %82 ], [ %73, %71 ]
  %85 = getelementptr inbounds i8, ptr %0, i64 %83
  %86 = load i8, ptr %85, align 1, !tbaa !29
  %87 = add i8 %84, %15
  %88 = add i8 %87, %86
  %89 = add nuw nsw i64 %83, 1
  %90 = icmp eq i64 %89, %19
  br i1 %90, label %91, label %82, !llvm.loop !75

91:                                               ; preds = %82, %69, %52
  %92 = phi i8 [ %54, %52 ], [ %70, %69 ], [ %88, %82 ]
  %93 = load double, ptr @init_value, align 8, !tbaa !28
  %94 = fptosi double %93 to i8
  %95 = add i8 %15, %94
  %96 = shl i8 %95, 6
  %97 = icmp eq i8 %96, %92
  br i1 %97, label %78, label %74

98:                                               ; preds = %16, %111
  %99 = phi i32 [ %112, %111 ], [ %9, %16 ]
  %100 = phi double [ %113, %111 ], [ %17, %16 ]
  %101 = phi i32 [ %114, %111 ], [ 0, %16 ]
  %102 = fptosi double %100 to i8
  %103 = add i8 %15, %102
  %104 = and i8 %103, 3
  %105 = icmp eq i8 %104, 0
  br i1 %105, label %111, label %106

106:                                              ; preds = %98
  %107 = load i32, ptr @current_test, align 4, !tbaa !9
  %108 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %107)
  %109 = load double, ptr @init_value, align 8, !tbaa !28
  %110 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %111

111:                                              ; preds = %98, %106
  %112 = phi i32 [ %99, %98 ], [ %110, %106 ]
  %113 = phi double [ %100, %98 ], [ %109, %106 ]
  %114 = add nuw nsw i32 %101, 1
  %115 = icmp slt i32 %114, %112
  br i1 %115, label %98, label %116, !llvm.loop !74

116:                                              ; preds = %111, %78, %7
  %117 = tail call i64 @clock() #17
  store i64 %117, ptr @end_time, align 8, !tbaa !26
  %118 = load i64, ptr @start_time, align 8, !tbaa !26
  %119 = load ptr, ptr @results, align 8, !tbaa !5
  %120 = icmp eq ptr %119, null
  br i1 %120, label %121, label %123

121:                                              ; preds = %116
  %122 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %127

123:                                              ; preds = %116
  %124 = load i32, ptr @current_test, align 4, !tbaa !9
  %125 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %126 = icmp slt i32 %124, %125
  br i1 %126, label %139, label %127

127:                                              ; preds = %123, %121
  %128 = phi i32 [ %122, %121 ], [ %125, %123 ]
  %129 = add nsw i32 %128, 10
  store i32 %129, ptr @allocated_results, align 4, !tbaa !9
  %130 = sext i32 %129 to i64
  %131 = shl nsw i64 %130, 4
  %132 = tail call ptr @realloc(ptr noundef %119, i64 noundef %131) #14
  store ptr %132, ptr @results, align 8, !tbaa !5
  %133 = icmp eq ptr %132, null
  br i1 %133, label %136, label %134

134:                                              ; preds = %127
  %135 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %139

136:                                              ; preds = %127
  %137 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %138 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %137)
  tail call void @exit(i32 noundef -1) #15
  unreachable

139:                                              ; preds = %123, %134
  %140 = phi i32 [ %135, %134 ], [ %124, %123 ]
  %141 = phi ptr [ %132, %134 ], [ %119, %123 ]
  %142 = sub nsw i64 %117, %118
  %143 = sitofp i64 %142 to double
  %144 = fdiv double %143, 1.000000e+06
  %145 = sext i32 %140 to i64
  %146 = getelementptr inbounds %struct.one_result, ptr %141, i64 %145
  store double %144, ptr %146, align 8, !tbaa !11
  %147 = getelementptr inbounds %struct.one_result, ptr %141, i64 %145, i32 1
  store ptr %6, ptr %147, align 8, !tbaa !14
  %148 = add nsw i32 %140, 1
  store i32 %148, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1Ia22custom_divide_variableIaEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i8 noundef signext %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !26
  %6 = load i32, ptr @iterations, align 4, !tbaa !9
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %89

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  %10 = sext i8 %2 to i16
  br i1 %9, label %13, label %11

11:                                               ; preds = %8
  %12 = load double, ptr @init_value, align 8, !tbaa !28
  br label %70

13:                                               ; preds = %8
  %14 = zext i32 %1 to i64
  %15 = and i64 %14, 1
  %16 = icmp eq i32 %1, 1
  %17 = and i64 %14, 4294967294
  %18 = icmp eq i64 %15, 0
  br label %19

19:                                               ; preds = %13, %26
  %20 = phi i32 [ %27, %26 ], [ %6, %13 ]
  %21 = phi i32 [ %28, %26 ], [ 0, %13 ]
  br i1 %16, label %50, label %30

22:                                               ; preds = %61
  %23 = load i32, ptr @current_test, align 4, !tbaa !9
  %24 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %23)
  %25 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %26

26:                                               ; preds = %22, %61
  %27 = phi i32 [ %25, %22 ], [ %20, %61 ]
  %28 = add nuw nsw i32 %21, 1
  %29 = icmp slt i32 %28, %27
  br i1 %29, label %19, label %89, !llvm.loop !76

30:                                               ; preds = %19, %30
  %31 = phi i64 [ %47, %30 ], [ 0, %19 ]
  %32 = phi i8 [ %46, %30 ], [ 0, %19 ]
  %33 = phi i64 [ %48, %30 ], [ 0, %19 ]
  %34 = getelementptr inbounds i8, ptr %0, i64 %31
  %35 = load i8, ptr %34, align 1, !tbaa !29
  %36 = sext i8 %35 to i16
  %37 = sdiv i16 %36, %10
  %38 = trunc i16 %37 to i8
  %39 = add i8 %32, %38
  %40 = or i64 %31, 1
  %41 = getelementptr inbounds i8, ptr %0, i64 %40
  %42 = load i8, ptr %41, align 1, !tbaa !29
  %43 = sext i8 %42 to i16
  %44 = sdiv i16 %43, %10
  %45 = trunc i16 %44 to i8
  %46 = add i8 %39, %45
  %47 = add nuw nsw i64 %31, 2
  %48 = add i64 %33, 2
  %49 = icmp eq i64 %48, %17
  br i1 %49, label %50, label %30, !llvm.loop !77

50:                                               ; preds = %30, %19
  %51 = phi i8 [ undef, %19 ], [ %46, %30 ]
  %52 = phi i64 [ 0, %19 ], [ %47, %30 ]
  %53 = phi i8 [ 0, %19 ], [ %46, %30 ]
  br i1 %18, label %61, label %54

54:                                               ; preds = %50
  %55 = getelementptr inbounds i8, ptr %0, i64 %52
  %56 = load i8, ptr %55, align 1, !tbaa !29
  %57 = sext i8 %56 to i16
  %58 = sdiv i16 %57, %10
  %59 = trunc i16 %58 to i8
  %60 = add i8 %53, %59
  br label %61

61:                                               ; preds = %50, %54
  %62 = phi i8 [ %51, %50 ], [ %60, %54 ]
  %63 = load double, ptr @init_value, align 8, !tbaa !28
  %64 = fptosi double %63 to i8
  %65 = sext i8 %64 to i16
  %66 = sdiv i16 %65, %10
  %67 = trunc i16 %66 to i8
  %68 = shl i8 %67, 6
  %69 = icmp eq i8 %68, %62
  br i1 %69, label %26, label %22

70:                                               ; preds = %11, %84
  %71 = phi i32 [ %85, %84 ], [ %6, %11 ]
  %72 = phi double [ %86, %84 ], [ %12, %11 ]
  %73 = phi i32 [ %87, %84 ], [ 0, %11 ]
  %74 = fptosi double %72 to i8
  %75 = sext i8 %74 to i16
  %76 = sdiv i16 %75, %10
  %77 = and i16 %76, 3
  %78 = icmp eq i16 %77, 0
  br i1 %78, label %84, label %79

79:                                               ; preds = %70
  %80 = load i32, ptr @current_test, align 4, !tbaa !9
  %81 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %80)
  %82 = load double, ptr @init_value, align 8, !tbaa !28
  %83 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %84

84:                                               ; preds = %70, %79
  %85 = phi i32 [ %71, %70 ], [ %83, %79 ]
  %86 = phi double [ %72, %70 ], [ %82, %79 ]
  %87 = add nuw nsw i32 %73, 1
  %88 = icmp slt i32 %87, %85
  br i1 %88, label %70, label %89, !llvm.loop !76

89:                                               ; preds = %84, %26, %4
  %90 = tail call i64 @clock() #17
  store i64 %90, ptr @end_time, align 8, !tbaa !26
  %91 = load i64, ptr @start_time, align 8, !tbaa !26
  %92 = load ptr, ptr @results, align 8, !tbaa !5
  %93 = icmp eq ptr %92, null
  br i1 %93, label %94, label %96

94:                                               ; preds = %89
  %95 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %100

96:                                               ; preds = %89
  %97 = load i32, ptr @current_test, align 4, !tbaa !9
  %98 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %99 = icmp slt i32 %97, %98
  br i1 %99, label %112, label %100

100:                                              ; preds = %96, %94
  %101 = phi i32 [ %95, %94 ], [ %98, %96 ]
  %102 = add nsw i32 %101, 10
  store i32 %102, ptr @allocated_results, align 4, !tbaa !9
  %103 = sext i32 %102 to i64
  %104 = shl nsw i64 %103, 4
  %105 = tail call ptr @realloc(ptr noundef %92, i64 noundef %104) #14
  store ptr %105, ptr @results, align 8, !tbaa !5
  %106 = icmp eq ptr %105, null
  br i1 %106, label %109, label %107

107:                                              ; preds = %100
  %108 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %112

109:                                              ; preds = %100
  %110 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %111 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %110)
  tail call void @exit(i32 noundef -1) #15
  unreachable

112:                                              ; preds = %96, %107
  %113 = phi i32 [ %108, %107 ], [ %97, %96 ]
  %114 = phi ptr [ %105, %107 ], [ %92, %96 ]
  %115 = sub nsw i64 %90, %91
  %116 = sitofp i64 %115 to double
  %117 = fdiv double %116, 1.000000e+06
  %118 = sext i32 %113 to i64
  %119 = getelementptr inbounds %struct.one_result, ptr %114, i64 %118
  store double %117, ptr %119, align 8, !tbaa !11
  %120 = getelementptr inbounds %struct.one_result, ptr %114, i64 %118, i32 1
  store ptr %3, ptr %120, align 8, !tbaa !14
  %121 = add nsw i32 %113, 1
  store i32 %121, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Ia31custom_divide_multiple_variableIaEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i8 noundef signext %2, i8 noundef signext %3, i8 noundef signext %4, i8 noundef signext %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !26
  %9 = load i32, ptr @iterations, align 4, !tbaa !9
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %79

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  %13 = sext i8 %2 to i16
  %14 = sext i8 %3 to i16
  %15 = sext i8 %4 to i16
  %16 = sext i8 %5 to i16
  br i1 %12, label %19, label %17

17:                                               ; preds = %11
  %18 = load double, ptr @init_value, align 8, !tbaa !28
  br label %57

19:                                               ; preds = %11
  %20 = zext i32 %1 to i64
  br label %21

21:                                               ; preds = %19, %28
  %22 = phi i32 [ %29, %28 ], [ %9, %19 ]
  %23 = phi i32 [ %30, %28 ], [ 0, %19 ]
  br label %32

24:                                               ; preds = %46
  %25 = load i32, ptr @current_test, align 4, !tbaa !9
  %26 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %25)
  %27 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %28

28:                                               ; preds = %24, %46
  %29 = phi i32 [ %27, %24 ], [ %22, %46 ]
  %30 = add nuw nsw i32 %23, 1
  %31 = icmp slt i32 %30, %29
  br i1 %31, label %21, label %79, !llvm.loop !78

32:                                               ; preds = %21, %32
  %33 = phi i64 [ 0, %21 ], [ %44, %32 ]
  %34 = phi i8 [ 0, %21 ], [ %43, %32 ]
  %35 = getelementptr inbounds i8, ptr %0, i64 %33
  %36 = load i8, ptr %35, align 1, !tbaa !29
  %37 = sext i8 %36 to i16
  %38 = sdiv i16 %37, %13
  %39 = sdiv i16 %38, %14
  %40 = sdiv i16 %39, %15
  %41 = sdiv i16 %40, %16
  %42 = trunc i16 %41 to i8
  %43 = add i8 %34, %42
  %44 = add nuw nsw i64 %33, 1
  %45 = icmp eq i64 %44, %20
  br i1 %45, label %46, label %32, !llvm.loop !79

46:                                               ; preds = %32
  %47 = load double, ptr @init_value, align 8, !tbaa !28
  %48 = fptosi double %47 to i8
  %49 = sext i8 %48 to i16
  %50 = sdiv i16 %49, %13
  %51 = sdiv i16 %50, %14
  %52 = sdiv i16 %51, %15
  %53 = sdiv i16 %52, %16
  %54 = trunc i16 %53 to i8
  %55 = shl i8 %54, 6
  %56 = icmp eq i8 %55, %43
  br i1 %56, label %28, label %24

57:                                               ; preds = %17, %74
  %58 = phi i32 [ %75, %74 ], [ %9, %17 ]
  %59 = phi double [ %76, %74 ], [ %18, %17 ]
  %60 = phi i32 [ %77, %74 ], [ 0, %17 ]
  %61 = fptosi double %59 to i8
  %62 = sext i8 %61 to i16
  %63 = sdiv i16 %62, %13
  %64 = sdiv i16 %63, %14
  %65 = sdiv i16 %64, %15
  %66 = sdiv i16 %65, %16
  %67 = and i16 %66, 3
  %68 = icmp eq i16 %67, 0
  br i1 %68, label %74, label %69

69:                                               ; preds = %57
  %70 = load i32, ptr @current_test, align 4, !tbaa !9
  %71 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %70)
  %72 = load double, ptr @init_value, align 8, !tbaa !28
  %73 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %74

74:                                               ; preds = %57, %69
  %75 = phi i32 [ %58, %57 ], [ %73, %69 ]
  %76 = phi double [ %59, %57 ], [ %72, %69 ]
  %77 = add nuw nsw i32 %60, 1
  %78 = icmp slt i32 %77, %75
  br i1 %78, label %57, label %79, !llvm.loop !78

79:                                               ; preds = %74, %28, %7
  %80 = tail call i64 @clock() #17
  store i64 %80, ptr @end_time, align 8, !tbaa !26
  %81 = load i64, ptr @start_time, align 8, !tbaa !26
  %82 = load ptr, ptr @results, align 8, !tbaa !5
  %83 = icmp eq ptr %82, null
  br i1 %83, label %84, label %86

84:                                               ; preds = %79
  %85 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %90

86:                                               ; preds = %79
  %87 = load i32, ptr @current_test, align 4, !tbaa !9
  %88 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %89 = icmp slt i32 %87, %88
  br i1 %89, label %102, label %90

90:                                               ; preds = %86, %84
  %91 = phi i32 [ %85, %84 ], [ %88, %86 ]
  %92 = add nsw i32 %91, 10
  store i32 %92, ptr @allocated_results, align 4, !tbaa !9
  %93 = sext i32 %92 to i64
  %94 = shl nsw i64 %93, 4
  %95 = tail call ptr @realloc(ptr noundef %82, i64 noundef %94) #14
  store ptr %95, ptr @results, align 8, !tbaa !5
  %96 = icmp eq ptr %95, null
  br i1 %96, label %99, label %97

97:                                               ; preds = %90
  %98 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %102

99:                                               ; preds = %90
  %100 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %101 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %100)
  tail call void @exit(i32 noundef -1) #15
  unreachable

102:                                              ; preds = %86, %97
  %103 = phi i32 [ %98, %97 ], [ %87, %86 ]
  %104 = phi ptr [ %95, %97 ], [ %82, %86 ]
  %105 = sub nsw i64 %80, %81
  %106 = sitofp i64 %105 to double
  %107 = fdiv double %106, 1.000000e+06
  %108 = sext i32 %103 to i64
  %109 = getelementptr inbounds %struct.one_result, ptr %104, i64 %108
  store double %107, ptr %109, align 8, !tbaa !11
  %110 = getelementptr inbounds %struct.one_result, ptr %104, i64 %108, i32 1
  store ptr %6, ptr %110, align 8, !tbaa !14
  %111 = add nsw i32 %103, 1
  store i32 %111, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Ia32custom_divide_multiple_variable2IaEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i8 noundef signext %2, i8 noundef signext %3, i8 noundef signext %4, i8 noundef signext %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !26
  %9 = load i32, ptr @iterations, align 4, !tbaa !9
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %121

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  %13 = sext i8 %2 to i16
  %14 = sext i8 %3 to i16
  %15 = sdiv i16 %13, %14
  %16 = sext i8 %4 to i16
  %17 = sdiv i16 %15, %16
  %18 = sext i8 %5 to i16
  %19 = sdiv i16 %17, %18
  %20 = trunc i16 %19 to i8
  br i1 %12, label %23, label %21

21:                                               ; preds = %11
  %22 = load double, ptr @init_value, align 8, !tbaa !28
  br label %103

23:                                               ; preds = %11
  %24 = zext i32 %1 to i64
  %25 = icmp ult i32 %1, 8
  %26 = icmp ult i32 %1, 32
  %27 = and i64 %24, 4294967264
  %28 = insertelement <16 x i8> poison, i8 %20, i64 0
  %29 = shufflevector <16 x i8> %28, <16 x i8> poison, <16 x i32> zeroinitializer
  %30 = insertelement <16 x i8> poison, i8 %20, i64 0
  %31 = shufflevector <16 x i8> %30, <16 x i8> poison, <16 x i32> zeroinitializer
  %32 = icmp eq i64 %27, %24
  %33 = and i64 %24, 24
  %34 = icmp eq i64 %33, 0
  %35 = and i64 %24, 4294967288
  %36 = insertelement <8 x i8> poison, i8 %20, i64 0
  %37 = shufflevector <8 x i8> %36, <8 x i8> poison, <8 x i32> zeroinitializer
  %38 = icmp eq i64 %35, %24
  br label %39

39:                                               ; preds = %83, %23
  %40 = phi i32 [ %9, %23 ], [ %84, %83 ]
  %41 = phi i32 [ 0, %23 ], [ %85, %83 ]
  br i1 %25, label %76, label %42

42:                                               ; preds = %39
  br i1 %26, label %61, label %43

43:                                               ; preds = %42, %43
  %44 = phi i64 [ %55, %43 ], [ 0, %42 ]
  %45 = phi <16 x i8> [ %53, %43 ], [ zeroinitializer, %42 ]
  %46 = phi <16 x i8> [ %54, %43 ], [ zeroinitializer, %42 ]
  %47 = getelementptr inbounds i8, ptr %0, i64 %44
  %48 = load <16 x i8>, ptr %47, align 1, !tbaa !29
  %49 = getelementptr inbounds i8, ptr %47, i64 16
  %50 = load <16 x i8>, ptr %49, align 1, !tbaa !29
  %51 = add <16 x i8> %48, %45
  %52 = add <16 x i8> %50, %46
  %53 = add <16 x i8> %51, %29
  %54 = add <16 x i8> %52, %31
  %55 = add nuw i64 %44, 32
  %56 = icmp eq i64 %55, %27
  br i1 %56, label %57, label %43, !llvm.loop !80

57:                                               ; preds = %43
  %58 = add <16 x i8> %54, %53
  %59 = tail call i8 @llvm.vector.reduce.add.v16i8(<16 x i8> %58)
  br i1 %32, label %96, label %60

60:                                               ; preds = %57
  br i1 %34, label %76, label %61

61:                                               ; preds = %42, %60
  %62 = phi i8 [ 0, %42 ], [ %59, %60 ]
  %63 = phi i64 [ 0, %42 ], [ %27, %60 ]
  %64 = insertelement <8 x i8> <i8 poison, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0>, i8 %62, i64 0
  br label %65

65:                                               ; preds = %65, %61
  %66 = phi i64 [ %63, %61 ], [ %72, %65 ]
  %67 = phi <8 x i8> [ %64, %61 ], [ %71, %65 ]
  %68 = getelementptr inbounds i8, ptr %0, i64 %66
  %69 = load <8 x i8>, ptr %68, align 1, !tbaa !29
  %70 = add <8 x i8> %69, %67
  %71 = add <8 x i8> %70, %37
  %72 = add nuw i64 %66, 8
  %73 = icmp eq i64 %72, %35
  br i1 %73, label %74, label %65, !llvm.loop !81

74:                                               ; preds = %65
  %75 = tail call i8 @llvm.vector.reduce.add.v8i8(<8 x i8> %71)
  br i1 %38, label %96, label %76

76:                                               ; preds = %39, %60, %74
  %77 = phi i64 [ 0, %39 ], [ %27, %60 ], [ %35, %74 ]
  %78 = phi i8 [ 0, %39 ], [ %59, %60 ], [ %75, %74 ]
  br label %87

79:                                               ; preds = %96
  %80 = load i32, ptr @current_test, align 4, !tbaa !9
  %81 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %80)
  %82 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %83

83:                                               ; preds = %79, %96
  %84 = phi i32 [ %82, %79 ], [ %40, %96 ]
  %85 = add nuw nsw i32 %41, 1
  %86 = icmp slt i32 %85, %84
  br i1 %86, label %39, label %121, !llvm.loop !82

87:                                               ; preds = %76, %87
  %88 = phi i64 [ %94, %87 ], [ %77, %76 ]
  %89 = phi i8 [ %93, %87 ], [ %78, %76 ]
  %90 = getelementptr inbounds i8, ptr %0, i64 %88
  %91 = load i8, ptr %90, align 1, !tbaa !29
  %92 = add i8 %91, %89
  %93 = add i8 %92, %20
  %94 = add nuw nsw i64 %88, 1
  %95 = icmp eq i64 %94, %24
  br i1 %95, label %96, label %87, !llvm.loop !83

96:                                               ; preds = %87, %74, %57
  %97 = phi i8 [ %59, %57 ], [ %75, %74 ], [ %93, %87 ]
  %98 = load double, ptr @init_value, align 8, !tbaa !28
  %99 = fptosi double %98 to i8
  %100 = add i8 %20, %99
  %101 = shl i8 %100, 6
  %102 = icmp eq i8 %101, %97
  br i1 %102, label %83, label %79

103:                                              ; preds = %21, %116
  %104 = phi i32 [ %117, %116 ], [ %9, %21 ]
  %105 = phi double [ %118, %116 ], [ %22, %21 ]
  %106 = phi i32 [ %119, %116 ], [ 0, %21 ]
  %107 = fptosi double %105 to i8
  %108 = add i8 %20, %107
  %109 = and i8 %108, 3
  %110 = icmp eq i8 %109, 0
  br i1 %110, label %116, label %111

111:                                              ; preds = %103
  %112 = load i32, ptr @current_test, align 4, !tbaa !9
  %113 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %112)
  %114 = load double, ptr @init_value, align 8, !tbaa !28
  %115 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %116

116:                                              ; preds = %103, %111
  %117 = phi i32 [ %104, %103 ], [ %115, %111 ]
  %118 = phi double [ %105, %103 ], [ %114, %111 ]
  %119 = add nuw nsw i32 %106, 1
  %120 = icmp slt i32 %119, %117
  br i1 %120, label %103, label %121, !llvm.loop !82

121:                                              ; preds = %116, %83, %7
  %122 = tail call i64 @clock() #17
  store i64 %122, ptr @end_time, align 8, !tbaa !26
  %123 = load i64, ptr @start_time, align 8, !tbaa !26
  %124 = load ptr, ptr @results, align 8, !tbaa !5
  %125 = icmp eq ptr %124, null
  br i1 %125, label %126, label %128

126:                                              ; preds = %121
  %127 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %132

128:                                              ; preds = %121
  %129 = load i32, ptr @current_test, align 4, !tbaa !9
  %130 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %131 = icmp slt i32 %129, %130
  br i1 %131, label %144, label %132

132:                                              ; preds = %128, %126
  %133 = phi i32 [ %127, %126 ], [ %130, %128 ]
  %134 = add nsw i32 %133, 10
  store i32 %134, ptr @allocated_results, align 4, !tbaa !9
  %135 = sext i32 %134 to i64
  %136 = shl nsw i64 %135, 4
  %137 = tail call ptr @realloc(ptr noundef %124, i64 noundef %136) #14
  store ptr %137, ptr @results, align 8, !tbaa !5
  %138 = icmp eq ptr %137, null
  br i1 %138, label %141, label %139

139:                                              ; preds = %132
  %140 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %144

141:                                              ; preds = %132
  %142 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %143 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %142)
  tail call void @exit(i32 noundef -1) #15
  unreachable

144:                                              ; preds = %128, %139
  %145 = phi i32 [ %140, %139 ], [ %129, %128 ]
  %146 = phi ptr [ %137, %139 ], [ %124, %128 ]
  %147 = sub nsw i64 %122, %123
  %148 = sitofp i64 %147 to double
  %149 = fdiv double %148, 1.000000e+06
  %150 = sext i32 %145 to i64
  %151 = getelementptr inbounds %struct.one_result, ptr %146, i64 %150
  store double %149, ptr %151, align 8, !tbaa !11
  %152 = getelementptr inbounds %struct.one_result, ptr %146, i64 %150, i32 1
  store ptr %6, ptr %152, align 8, !tbaa !14
  %153 = add nsw i32 %145, 1
  store i32 %153, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Ia30custom_mixed_multiple_variableIaEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i8 noundef signext %2, i8 noundef signext %3, i8 noundef signext %4, i8 noundef signext %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !26
  %9 = load i32, ptr @iterations, align 4, !tbaa !9
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %131

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  %13 = sext i8 %3 to i16
  %14 = sext i8 %4 to i16
  %15 = mul nsw i16 %14, %13
  %16 = sext i8 %5 to i16
  %17 = sdiv i16 %15, %16
  %18 = trunc i16 %17 to i8
  br i1 %12, label %21, label %19

19:                                               ; preds = %11
  %20 = load double, ptr @init_value, align 8, !tbaa !28
  br label %112

21:                                               ; preds = %11
  %22 = zext i32 %1 to i64
  %23 = icmp ult i32 %1, 8
  %24 = icmp ult i32 %1, 32
  %25 = and i64 %22, 4294967264
  %26 = insertelement <16 x i8> poison, i8 %2, i64 0
  %27 = shufflevector <16 x i8> %26, <16 x i8> poison, <16 x i32> zeroinitializer
  %28 = insertelement <16 x i8> poison, i8 %2, i64 0
  %29 = shufflevector <16 x i8> %28, <16 x i8> poison, <16 x i32> zeroinitializer
  %30 = insertelement <16 x i8> poison, i8 %18, i64 0
  %31 = shufflevector <16 x i8> %30, <16 x i8> poison, <16 x i32> zeroinitializer
  %32 = insertelement <16 x i8> poison, i8 %18, i64 0
  %33 = shufflevector <16 x i8> %32, <16 x i8> poison, <16 x i32> zeroinitializer
  %34 = icmp eq i64 %25, %22
  %35 = and i64 %22, 24
  %36 = icmp eq i64 %35, 0
  %37 = and i64 %22, 4294967288
  %38 = insertelement <8 x i8> poison, i8 %2, i64 0
  %39 = shufflevector <8 x i8> %38, <8 x i8> poison, <8 x i32> zeroinitializer
  %40 = insertelement <8 x i8> poison, i8 %18, i64 0
  %41 = shufflevector <8 x i8> %40, <8 x i8> poison, <8 x i32> zeroinitializer
  %42 = icmp eq i64 %37, %22
  br label %43

43:                                               ; preds = %90, %21
  %44 = phi i32 [ %9, %21 ], [ %91, %90 ]
  %45 = phi i32 [ 0, %21 ], [ %92, %90 ]
  br i1 %23, label %83, label %46

46:                                               ; preds = %43
  br i1 %24, label %67, label %47

47:                                               ; preds = %46, %47
  %48 = phi i64 [ %61, %47 ], [ 0, %46 ]
  %49 = phi <16 x i8> [ %59, %47 ], [ zeroinitializer, %46 ]
  %50 = phi <16 x i8> [ %60, %47 ], [ zeroinitializer, %46 ]
  %51 = getelementptr inbounds i8, ptr %0, i64 %48
  %52 = load <16 x i8>, ptr %51, align 1, !tbaa !29
  %53 = getelementptr inbounds i8, ptr %51, i64 16
  %54 = load <16 x i8>, ptr %53, align 1, !tbaa !29
  %55 = add <16 x i8> %49, %27
  %56 = add <16 x i8> %50, %29
  %57 = add <16 x i8> %55, %52
  %58 = add <16 x i8> %56, %54
  %59 = sub <16 x i8> %57, %31
  %60 = sub <16 x i8> %58, %33
  %61 = add nuw i64 %48, 32
  %62 = icmp eq i64 %61, %25
  br i1 %62, label %63, label %47, !llvm.loop !84

63:                                               ; preds = %47
  %64 = add <16 x i8> %60, %59
  %65 = tail call i8 @llvm.vector.reduce.add.v16i8(<16 x i8> %64)
  br i1 %34, label %104, label %66

66:                                               ; preds = %63
  br i1 %36, label %83, label %67

67:                                               ; preds = %46, %66
  %68 = phi i8 [ 0, %46 ], [ %65, %66 ]
  %69 = phi i64 [ 0, %46 ], [ %25, %66 ]
  %70 = insertelement <8 x i8> <i8 poison, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0>, i8 %68, i64 0
  br label %71

71:                                               ; preds = %71, %67
  %72 = phi i64 [ %69, %67 ], [ %79, %71 ]
  %73 = phi <8 x i8> [ %70, %67 ], [ %78, %71 ]
  %74 = getelementptr inbounds i8, ptr %0, i64 %72
  %75 = load <8 x i8>, ptr %74, align 1, !tbaa !29
  %76 = add <8 x i8> %73, %39
  %77 = add <8 x i8> %76, %75
  %78 = sub <8 x i8> %77, %41
  %79 = add nuw i64 %72, 8
  %80 = icmp eq i64 %79, %37
  br i1 %80, label %81, label %71, !llvm.loop !85

81:                                               ; preds = %71
  %82 = tail call i8 @llvm.vector.reduce.add.v8i8(<8 x i8> %78)
  br i1 %42, label %104, label %83

83:                                               ; preds = %43, %66, %81
  %84 = phi i64 [ 0, %43 ], [ %25, %66 ], [ %37, %81 ]
  %85 = phi i8 [ 0, %43 ], [ %65, %66 ], [ %82, %81 ]
  br label %94

86:                                               ; preds = %104
  %87 = load i32, ptr @current_test, align 4, !tbaa !9
  %88 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %87)
  %89 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %90

90:                                               ; preds = %86, %104
  %91 = phi i32 [ %89, %86 ], [ %44, %104 ]
  %92 = add nuw nsw i32 %45, 1
  %93 = icmp slt i32 %92, %91
  br i1 %93, label %43, label %131, !llvm.loop !86

94:                                               ; preds = %83, %94
  %95 = phi i64 [ %102, %94 ], [ %84, %83 ]
  %96 = phi i8 [ %101, %94 ], [ %85, %83 ]
  %97 = getelementptr inbounds i8, ptr %0, i64 %95
  %98 = load i8, ptr %97, align 1, !tbaa !29
  %99 = add i8 %96, %2
  %100 = add i8 %99, %98
  %101 = sub i8 %100, %18
  %102 = add nuw nsw i64 %95, 1
  %103 = icmp eq i64 %102, %22
  br i1 %103, label %104, label %94, !llvm.loop !87

104:                                              ; preds = %94, %81, %63
  %105 = phi i8 [ %65, %63 ], [ %82, %81 ], [ %101, %94 ]
  %106 = load double, ptr @init_value, align 8, !tbaa !28
  %107 = fptosi double %106 to i8
  %108 = add i8 %107, %2
  %109 = sub i8 %108, %18
  %110 = shl i8 %109, 6
  %111 = icmp eq i8 %110, %105
  br i1 %111, label %90, label %86

112:                                              ; preds = %19, %126
  %113 = phi i32 [ %127, %126 ], [ %9, %19 ]
  %114 = phi double [ %128, %126 ], [ %20, %19 ]
  %115 = phi i32 [ %129, %126 ], [ 0, %19 ]
  %116 = fptosi double %114 to i8
  %117 = add i8 %116, %2
  %118 = sub i8 %117, %18
  %119 = and i8 %118, 3
  %120 = icmp eq i8 %119, 0
  br i1 %120, label %126, label %121

121:                                              ; preds = %112
  %122 = load i32, ptr @current_test, align 4, !tbaa !9
  %123 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %122)
  %124 = load double, ptr @init_value, align 8, !tbaa !28
  %125 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %126

126:                                              ; preds = %112, %121
  %127 = phi i32 [ %113, %112 ], [ %125, %121 ]
  %128 = phi double [ %114, %112 ], [ %124, %121 ]
  %129 = add nuw nsw i32 %115, 1
  %130 = icmp slt i32 %129, %127
  br i1 %130, label %112, label %131, !llvm.loop !86

131:                                              ; preds = %126, %90, %7
  %132 = tail call i64 @clock() #17
  store i64 %132, ptr @end_time, align 8, !tbaa !26
  %133 = load i64, ptr @start_time, align 8, !tbaa !26
  %134 = load ptr, ptr @results, align 8, !tbaa !5
  %135 = icmp eq ptr %134, null
  br i1 %135, label %136, label %138

136:                                              ; preds = %131
  %137 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %142

138:                                              ; preds = %131
  %139 = load i32, ptr @current_test, align 4, !tbaa !9
  %140 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %141 = icmp slt i32 %139, %140
  br i1 %141, label %154, label %142

142:                                              ; preds = %138, %136
  %143 = phi i32 [ %137, %136 ], [ %140, %138 ]
  %144 = add nsw i32 %143, 10
  store i32 %144, ptr @allocated_results, align 4, !tbaa !9
  %145 = sext i32 %144 to i64
  %146 = shl nsw i64 %145, 4
  %147 = tail call ptr @realloc(ptr noundef %134, i64 noundef %146) #14
  store ptr %147, ptr @results, align 8, !tbaa !5
  %148 = icmp eq ptr %147, null
  br i1 %148, label %151, label %149

149:                                              ; preds = %142
  %150 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %154

151:                                              ; preds = %142
  %152 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %153 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %152)
  tail call void @exit(i32 noundef -1) #15
  unreachable

154:                                              ; preds = %138, %149
  %155 = phi i32 [ %150, %149 ], [ %139, %138 ]
  %156 = phi ptr [ %147, %149 ], [ %134, %138 ]
  %157 = sub nsw i64 %132, %133
  %158 = sitofp i64 %157 to double
  %159 = fdiv double %158, 1.000000e+06
  %160 = sext i32 %155 to i64
  %161 = getelementptr inbounds %struct.one_result, ptr %156, i64 %160
  store double %159, ptr %161, align 8, !tbaa !11
  %162 = getelementptr inbounds %struct.one_result, ptr %156, i64 %160, i32 1
  store ptr %6, ptr %162, align 8, !tbaa !14
  %163 = add nsw i32 %155, 1
  store i32 %163, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1Ia19custom_variable_andIaEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i8 noundef signext %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !26
  %6 = load i32, ptr @iterations, align 4, !tbaa !9
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %110

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  br i1 %9, label %12, label %10

10:                                               ; preds = %8
  %11 = load double, ptr @init_value, align 8, !tbaa !28
  br label %92

12:                                               ; preds = %8
  %13 = zext i32 %1 to i64
  %14 = icmp ult i32 %1, 8
  %15 = icmp ult i32 %1, 32
  %16 = and i64 %13, 4294967264
  %17 = insertelement <16 x i8> poison, i8 %2, i64 0
  %18 = shufflevector <16 x i8> %17, <16 x i8> poison, <16 x i32> zeroinitializer
  %19 = insertelement <16 x i8> poison, i8 %2, i64 0
  %20 = shufflevector <16 x i8> %19, <16 x i8> poison, <16 x i32> zeroinitializer
  %21 = icmp eq i64 %16, %13
  %22 = and i64 %13, 24
  %23 = icmp eq i64 %22, 0
  %24 = and i64 %13, 4294967288
  %25 = insertelement <8 x i8> poison, i8 %2, i64 0
  %26 = shufflevector <8 x i8> %25, <8 x i8> poison, <8 x i32> zeroinitializer
  %27 = icmp eq i64 %24, %13
  br label %28

28:                                               ; preds = %12, %72
  %29 = phi i32 [ %73, %72 ], [ %6, %12 ]
  %30 = phi i32 [ %74, %72 ], [ 0, %12 ]
  br i1 %14, label %65, label %31

31:                                               ; preds = %28
  br i1 %15, label %50, label %32

32:                                               ; preds = %31, %32
  %33 = phi i64 [ %44, %32 ], [ 0, %31 ]
  %34 = phi <16 x i8> [ %42, %32 ], [ zeroinitializer, %31 ]
  %35 = phi <16 x i8> [ %43, %32 ], [ zeroinitializer, %31 ]
  %36 = getelementptr inbounds i8, ptr %0, i64 %33
  %37 = load <16 x i8>, ptr %36, align 1, !tbaa !29
  %38 = getelementptr inbounds i8, ptr %36, i64 16
  %39 = load <16 x i8>, ptr %38, align 1, !tbaa !29
  %40 = and <16 x i8> %37, %18
  %41 = and <16 x i8> %39, %20
  %42 = add <16 x i8> %40, %34
  %43 = add <16 x i8> %41, %35
  %44 = add nuw i64 %33, 32
  %45 = icmp eq i64 %44, %16
  br i1 %45, label %46, label %32, !llvm.loop !88

46:                                               ; preds = %32
  %47 = add <16 x i8> %43, %42
  %48 = tail call i8 @llvm.vector.reduce.add.v16i8(<16 x i8> %47)
  br i1 %21, label %85, label %49

49:                                               ; preds = %46
  br i1 %23, label %65, label %50

50:                                               ; preds = %31, %49
  %51 = phi i8 [ 0, %31 ], [ %48, %49 ]
  %52 = phi i64 [ 0, %31 ], [ %16, %49 ]
  %53 = insertelement <8 x i8> <i8 poison, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0>, i8 %51, i64 0
  br label %54

54:                                               ; preds = %54, %50
  %55 = phi i64 [ %52, %50 ], [ %61, %54 ]
  %56 = phi <8 x i8> [ %53, %50 ], [ %60, %54 ]
  %57 = getelementptr inbounds i8, ptr %0, i64 %55
  %58 = load <8 x i8>, ptr %57, align 1, !tbaa !29
  %59 = and <8 x i8> %58, %26
  %60 = add <8 x i8> %59, %56
  %61 = add nuw i64 %55, 8
  %62 = icmp eq i64 %61, %24
  br i1 %62, label %63, label %54, !llvm.loop !89

63:                                               ; preds = %54
  %64 = tail call i8 @llvm.vector.reduce.add.v8i8(<8 x i8> %60)
  br i1 %27, label %85, label %65

65:                                               ; preds = %28, %49, %63
  %66 = phi i64 [ 0, %28 ], [ %16, %49 ], [ %24, %63 ]
  %67 = phi i8 [ 0, %28 ], [ %48, %49 ], [ %64, %63 ]
  br label %76

68:                                               ; preds = %85
  %69 = load i32, ptr @current_test, align 4, !tbaa !9
  %70 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %69)
  %71 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %72

72:                                               ; preds = %68, %85
  %73 = phi i32 [ %71, %68 ], [ %29, %85 ]
  %74 = add nuw nsw i32 %30, 1
  %75 = icmp slt i32 %74, %73
  br i1 %75, label %28, label %110, !llvm.loop !90

76:                                               ; preds = %65, %76
  %77 = phi i64 [ %83, %76 ], [ %66, %65 ]
  %78 = phi i8 [ %82, %76 ], [ %67, %65 ]
  %79 = getelementptr inbounds i8, ptr %0, i64 %77
  %80 = load i8, ptr %79, align 1, !tbaa !29
  %81 = and i8 %80, %2
  %82 = add i8 %81, %78
  %83 = add nuw nsw i64 %77, 1
  %84 = icmp eq i64 %83, %13
  br i1 %84, label %85, label %76, !llvm.loop !91

85:                                               ; preds = %76, %63, %46
  %86 = phi i8 [ %48, %46 ], [ %64, %63 ], [ %82, %76 ]
  %87 = load double, ptr @init_value, align 8, !tbaa !28
  %88 = fptosi double %87 to i8
  %89 = and i8 %88, %2
  %90 = shl i8 %89, 6
  %91 = icmp eq i8 %90, %86
  br i1 %91, label %72, label %68

92:                                               ; preds = %10, %105
  %93 = phi i32 [ %106, %105 ], [ %6, %10 ]
  %94 = phi double [ %107, %105 ], [ %11, %10 ]
  %95 = phi i32 [ %108, %105 ], [ 0, %10 ]
  %96 = fptosi double %94 to i8
  %97 = and i8 %96, %2
  %98 = and i8 %97, 3
  %99 = icmp eq i8 %98, 0
  br i1 %99, label %105, label %100

100:                                              ; preds = %92
  %101 = load i32, ptr @current_test, align 4, !tbaa !9
  %102 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %101)
  %103 = load double, ptr @init_value, align 8, !tbaa !28
  %104 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %105

105:                                              ; preds = %92, %100
  %106 = phi i32 [ %93, %92 ], [ %104, %100 ]
  %107 = phi double [ %94, %92 ], [ %103, %100 ]
  %108 = add nuw nsw i32 %95, 1
  %109 = icmp slt i32 %108, %106
  br i1 %109, label %92, label %110, !llvm.loop !90

110:                                              ; preds = %105, %72, %4
  %111 = tail call i64 @clock() #17
  store i64 %111, ptr @end_time, align 8, !tbaa !26
  %112 = load i64, ptr @start_time, align 8, !tbaa !26
  %113 = load ptr, ptr @results, align 8, !tbaa !5
  %114 = icmp eq ptr %113, null
  br i1 %114, label %115, label %117

115:                                              ; preds = %110
  %116 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %121

117:                                              ; preds = %110
  %118 = load i32, ptr @current_test, align 4, !tbaa !9
  %119 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %120 = icmp slt i32 %118, %119
  br i1 %120, label %133, label %121

121:                                              ; preds = %117, %115
  %122 = phi i32 [ %116, %115 ], [ %119, %117 ]
  %123 = add nsw i32 %122, 10
  store i32 %123, ptr @allocated_results, align 4, !tbaa !9
  %124 = sext i32 %123 to i64
  %125 = shl nsw i64 %124, 4
  %126 = tail call ptr @realloc(ptr noundef %113, i64 noundef %125) #14
  store ptr %126, ptr @results, align 8, !tbaa !5
  %127 = icmp eq ptr %126, null
  br i1 %127, label %130, label %128

128:                                              ; preds = %121
  %129 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %133

130:                                              ; preds = %121
  %131 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %132 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %131)
  tail call void @exit(i32 noundef -1) #15
  unreachable

133:                                              ; preds = %117, %128
  %134 = phi i32 [ %129, %128 ], [ %118, %117 ]
  %135 = phi ptr [ %126, %128 ], [ %113, %117 ]
  %136 = sub nsw i64 %111, %112
  %137 = sitofp i64 %136 to double
  %138 = fdiv double %137, 1.000000e+06
  %139 = sext i32 %134 to i64
  %140 = getelementptr inbounds %struct.one_result, ptr %135, i64 %139
  store double %138, ptr %140, align 8, !tbaa !11
  %141 = getelementptr inbounds %struct.one_result, ptr %135, i64 %139, i32 1
  store ptr %3, ptr %141, align 8, !tbaa !14
  %142 = add nsw i32 %134, 1
  store i32 %142, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Ia28custom_multiple_variable_andIaEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i8 noundef signext %2, i8 noundef signext %3, i8 noundef signext %4, i8 noundef signext %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !26
  %9 = load i32, ptr @iterations, align 4, !tbaa !9
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %128

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  %13 = and i8 %3, %2
  %14 = and i8 %13, %4
  %15 = and i8 %14, %5
  br i1 %12, label %18, label %16

16:                                               ; preds = %11
  %17 = load double, ptr @init_value, align 8, !tbaa !28
  br label %110

18:                                               ; preds = %11
  %19 = zext i32 %1 to i64
  %20 = icmp ult i32 %1, 8
  %21 = icmp ult i32 %1, 32
  %22 = and i64 %19, 4294967264
  %23 = and i8 %3, %2
  %24 = and i8 %3, %2
  %25 = and i8 %23, %4
  %26 = and i8 %24, %4
  %27 = and i8 %25, %5
  %28 = insertelement <16 x i8> poison, i8 %27, i64 0
  %29 = shufflevector <16 x i8> %28, <16 x i8> poison, <16 x i32> zeroinitializer
  %30 = and i8 %26, %5
  %31 = insertelement <16 x i8> poison, i8 %30, i64 0
  %32 = shufflevector <16 x i8> %31, <16 x i8> poison, <16 x i32> zeroinitializer
  %33 = icmp eq i64 %22, %19
  %34 = and i64 %19, 24
  %35 = icmp eq i64 %34, 0
  %36 = and i64 %19, 4294967288
  %37 = and i8 %3, %2
  %38 = and i8 %37, %4
  %39 = and i8 %38, %5
  %40 = insertelement <8 x i8> poison, i8 %39, i64 0
  %41 = shufflevector <8 x i8> %40, <8 x i8> poison, <8 x i32> zeroinitializer
  %42 = icmp eq i64 %36, %19
  br label %43

43:                                               ; preds = %18, %87
  %44 = phi i32 [ %88, %87 ], [ %9, %18 ]
  %45 = phi i32 [ %89, %87 ], [ 0, %18 ]
  br i1 %20, label %80, label %46

46:                                               ; preds = %43
  br i1 %21, label %65, label %47

47:                                               ; preds = %46, %47
  %48 = phi i64 [ %59, %47 ], [ 0, %46 ]
  %49 = phi <16 x i8> [ %57, %47 ], [ zeroinitializer, %46 ]
  %50 = phi <16 x i8> [ %58, %47 ], [ zeroinitializer, %46 ]
  %51 = getelementptr inbounds i8, ptr %0, i64 %48
  %52 = load <16 x i8>, ptr %51, align 1, !tbaa !29
  %53 = getelementptr inbounds i8, ptr %51, i64 16
  %54 = load <16 x i8>, ptr %53, align 1, !tbaa !29
  %55 = and <16 x i8> %29, %52
  %56 = and <16 x i8> %32, %54
  %57 = add <16 x i8> %55, %49
  %58 = add <16 x i8> %56, %50
  %59 = add nuw i64 %48, 32
  %60 = icmp eq i64 %59, %22
  br i1 %60, label %61, label %47, !llvm.loop !92

61:                                               ; preds = %47
  %62 = add <16 x i8> %58, %57
  %63 = tail call i8 @llvm.vector.reduce.add.v16i8(<16 x i8> %62)
  br i1 %33, label %103, label %64

64:                                               ; preds = %61
  br i1 %35, label %80, label %65

65:                                               ; preds = %46, %64
  %66 = phi i8 [ 0, %46 ], [ %63, %64 ]
  %67 = phi i64 [ 0, %46 ], [ %22, %64 ]
  %68 = insertelement <8 x i8> <i8 poison, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0>, i8 %66, i64 0
  br label %69

69:                                               ; preds = %69, %65
  %70 = phi i64 [ %67, %65 ], [ %76, %69 ]
  %71 = phi <8 x i8> [ %68, %65 ], [ %75, %69 ]
  %72 = getelementptr inbounds i8, ptr %0, i64 %70
  %73 = load <8 x i8>, ptr %72, align 1, !tbaa !29
  %74 = and <8 x i8> %41, %73
  %75 = add <8 x i8> %74, %71
  %76 = add nuw i64 %70, 8
  %77 = icmp eq i64 %76, %36
  br i1 %77, label %78, label %69, !llvm.loop !93

78:                                               ; preds = %69
  %79 = tail call i8 @llvm.vector.reduce.add.v8i8(<8 x i8> %75)
  br i1 %42, label %103, label %80

80:                                               ; preds = %43, %64, %78
  %81 = phi i64 [ 0, %43 ], [ %22, %64 ], [ %36, %78 ]
  %82 = phi i8 [ 0, %43 ], [ %63, %64 ], [ %79, %78 ]
  br label %91

83:                                               ; preds = %103
  %84 = load i32, ptr @current_test, align 4, !tbaa !9
  %85 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %84)
  %86 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %87

87:                                               ; preds = %83, %103
  %88 = phi i32 [ %86, %83 ], [ %44, %103 ]
  %89 = add nuw nsw i32 %45, 1
  %90 = icmp slt i32 %89, %88
  br i1 %90, label %43, label %128, !llvm.loop !94

91:                                               ; preds = %80, %91
  %92 = phi i64 [ %101, %91 ], [ %81, %80 ]
  %93 = phi i8 [ %100, %91 ], [ %82, %80 ]
  %94 = getelementptr inbounds i8, ptr %0, i64 %92
  %95 = load i8, ptr %94, align 1, !tbaa !29
  %96 = and i8 %95, %2
  %97 = and i8 %96, %3
  %98 = and i8 %97, %4
  %99 = and i8 %98, %5
  %100 = add i8 %99, %93
  %101 = add nuw nsw i64 %92, 1
  %102 = icmp eq i64 %101, %19
  br i1 %102, label %103, label %91, !llvm.loop !95

103:                                              ; preds = %91, %78, %61
  %104 = phi i8 [ %63, %61 ], [ %79, %78 ], [ %100, %91 ]
  %105 = load double, ptr @init_value, align 8, !tbaa !28
  %106 = fptosi double %105 to i8
  %107 = and i8 %15, %106
  %108 = shl i8 %107, 6
  %109 = icmp eq i8 %108, %104
  br i1 %109, label %87, label %83

110:                                              ; preds = %16, %123
  %111 = phi i32 [ %124, %123 ], [ %9, %16 ]
  %112 = phi double [ %125, %123 ], [ %17, %16 ]
  %113 = phi i32 [ %126, %123 ], [ 0, %16 ]
  %114 = fptosi double %112 to i8
  %115 = and i8 %15, %114
  %116 = and i8 %115, 3
  %117 = icmp eq i8 %116, 0
  br i1 %117, label %123, label %118

118:                                              ; preds = %110
  %119 = load i32, ptr @current_test, align 4, !tbaa !9
  %120 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %119)
  %121 = load double, ptr @init_value, align 8, !tbaa !28
  %122 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %123

123:                                              ; preds = %110, %118
  %124 = phi i32 [ %111, %110 ], [ %122, %118 ]
  %125 = phi double [ %112, %110 ], [ %121, %118 ]
  %126 = add nuw nsw i32 %113, 1
  %127 = icmp slt i32 %126, %124
  br i1 %127, label %110, label %128, !llvm.loop !94

128:                                              ; preds = %123, %87, %7
  %129 = tail call i64 @clock() #17
  store i64 %129, ptr @end_time, align 8, !tbaa !26
  %130 = load i64, ptr @start_time, align 8, !tbaa !26
  %131 = load ptr, ptr @results, align 8, !tbaa !5
  %132 = icmp eq ptr %131, null
  br i1 %132, label %133, label %135

133:                                              ; preds = %128
  %134 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %139

135:                                              ; preds = %128
  %136 = load i32, ptr @current_test, align 4, !tbaa !9
  %137 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %138 = icmp slt i32 %136, %137
  br i1 %138, label %151, label %139

139:                                              ; preds = %135, %133
  %140 = phi i32 [ %134, %133 ], [ %137, %135 ]
  %141 = add nsw i32 %140, 10
  store i32 %141, ptr @allocated_results, align 4, !tbaa !9
  %142 = sext i32 %141 to i64
  %143 = shl nsw i64 %142, 4
  %144 = tail call ptr @realloc(ptr noundef %131, i64 noundef %143) #14
  store ptr %144, ptr @results, align 8, !tbaa !5
  %145 = icmp eq ptr %144, null
  br i1 %145, label %148, label %146

146:                                              ; preds = %139
  %147 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %151

148:                                              ; preds = %139
  %149 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %150 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %149)
  tail call void @exit(i32 noundef -1) #15
  unreachable

151:                                              ; preds = %135, %146
  %152 = phi i32 [ %147, %146 ], [ %136, %135 ]
  %153 = phi ptr [ %144, %146 ], [ %131, %135 ]
  %154 = sub nsw i64 %129, %130
  %155 = sitofp i64 %154 to double
  %156 = fdiv double %155, 1.000000e+06
  %157 = sext i32 %152 to i64
  %158 = getelementptr inbounds %struct.one_result, ptr %153, i64 %157
  store double %156, ptr %158, align 8, !tbaa !11
  %159 = getelementptr inbounds %struct.one_result, ptr %153, i64 %157, i32 1
  store ptr %6, ptr %159, align 8, !tbaa !14
  %160 = add nsw i32 %152, 1
  store i32 %160, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1Ia18custom_variable_orIaEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i8 noundef signext %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !26
  %6 = load i32, ptr @iterations, align 4, !tbaa !9
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %110

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  br i1 %9, label %12, label %10

10:                                               ; preds = %8
  %11 = load double, ptr @init_value, align 8, !tbaa !28
  br label %92

12:                                               ; preds = %8
  %13 = zext i32 %1 to i64
  %14 = icmp ult i32 %1, 8
  %15 = icmp ult i32 %1, 32
  %16 = and i64 %13, 4294967264
  %17 = insertelement <16 x i8> poison, i8 %2, i64 0
  %18 = shufflevector <16 x i8> %17, <16 x i8> poison, <16 x i32> zeroinitializer
  %19 = insertelement <16 x i8> poison, i8 %2, i64 0
  %20 = shufflevector <16 x i8> %19, <16 x i8> poison, <16 x i32> zeroinitializer
  %21 = icmp eq i64 %16, %13
  %22 = and i64 %13, 24
  %23 = icmp eq i64 %22, 0
  %24 = and i64 %13, 4294967288
  %25 = insertelement <8 x i8> poison, i8 %2, i64 0
  %26 = shufflevector <8 x i8> %25, <8 x i8> poison, <8 x i32> zeroinitializer
  %27 = icmp eq i64 %24, %13
  br label %28

28:                                               ; preds = %12, %72
  %29 = phi i32 [ %73, %72 ], [ %6, %12 ]
  %30 = phi i32 [ %74, %72 ], [ 0, %12 ]
  br i1 %14, label %65, label %31

31:                                               ; preds = %28
  br i1 %15, label %50, label %32

32:                                               ; preds = %31, %32
  %33 = phi i64 [ %44, %32 ], [ 0, %31 ]
  %34 = phi <16 x i8> [ %42, %32 ], [ zeroinitializer, %31 ]
  %35 = phi <16 x i8> [ %43, %32 ], [ zeroinitializer, %31 ]
  %36 = getelementptr inbounds i8, ptr %0, i64 %33
  %37 = load <16 x i8>, ptr %36, align 1, !tbaa !29
  %38 = getelementptr inbounds i8, ptr %36, i64 16
  %39 = load <16 x i8>, ptr %38, align 1, !tbaa !29
  %40 = or <16 x i8> %37, %18
  %41 = or <16 x i8> %39, %20
  %42 = add <16 x i8> %40, %34
  %43 = add <16 x i8> %41, %35
  %44 = add nuw i64 %33, 32
  %45 = icmp eq i64 %44, %16
  br i1 %45, label %46, label %32, !llvm.loop !96

46:                                               ; preds = %32
  %47 = add <16 x i8> %43, %42
  %48 = tail call i8 @llvm.vector.reduce.add.v16i8(<16 x i8> %47)
  br i1 %21, label %85, label %49

49:                                               ; preds = %46
  br i1 %23, label %65, label %50

50:                                               ; preds = %31, %49
  %51 = phi i8 [ 0, %31 ], [ %48, %49 ]
  %52 = phi i64 [ 0, %31 ], [ %16, %49 ]
  %53 = insertelement <8 x i8> <i8 poison, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0>, i8 %51, i64 0
  br label %54

54:                                               ; preds = %54, %50
  %55 = phi i64 [ %52, %50 ], [ %61, %54 ]
  %56 = phi <8 x i8> [ %53, %50 ], [ %60, %54 ]
  %57 = getelementptr inbounds i8, ptr %0, i64 %55
  %58 = load <8 x i8>, ptr %57, align 1, !tbaa !29
  %59 = or <8 x i8> %58, %26
  %60 = add <8 x i8> %59, %56
  %61 = add nuw i64 %55, 8
  %62 = icmp eq i64 %61, %24
  br i1 %62, label %63, label %54, !llvm.loop !97

63:                                               ; preds = %54
  %64 = tail call i8 @llvm.vector.reduce.add.v8i8(<8 x i8> %60)
  br i1 %27, label %85, label %65

65:                                               ; preds = %28, %49, %63
  %66 = phi i64 [ 0, %28 ], [ %16, %49 ], [ %24, %63 ]
  %67 = phi i8 [ 0, %28 ], [ %48, %49 ], [ %64, %63 ]
  br label %76

68:                                               ; preds = %85
  %69 = load i32, ptr @current_test, align 4, !tbaa !9
  %70 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %69)
  %71 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %72

72:                                               ; preds = %68, %85
  %73 = phi i32 [ %71, %68 ], [ %29, %85 ]
  %74 = add nuw nsw i32 %30, 1
  %75 = icmp slt i32 %74, %73
  br i1 %75, label %28, label %110, !llvm.loop !98

76:                                               ; preds = %65, %76
  %77 = phi i64 [ %83, %76 ], [ %66, %65 ]
  %78 = phi i8 [ %82, %76 ], [ %67, %65 ]
  %79 = getelementptr inbounds i8, ptr %0, i64 %77
  %80 = load i8, ptr %79, align 1, !tbaa !29
  %81 = or i8 %80, %2
  %82 = add i8 %81, %78
  %83 = add nuw nsw i64 %77, 1
  %84 = icmp eq i64 %83, %13
  br i1 %84, label %85, label %76, !llvm.loop !99

85:                                               ; preds = %76, %63, %46
  %86 = phi i8 [ %48, %46 ], [ %64, %63 ], [ %82, %76 ]
  %87 = load double, ptr @init_value, align 8, !tbaa !28
  %88 = fptosi double %87 to i8
  %89 = or i8 %88, %2
  %90 = shl i8 %89, 6
  %91 = icmp eq i8 %90, %86
  br i1 %91, label %72, label %68

92:                                               ; preds = %10, %105
  %93 = phi i32 [ %106, %105 ], [ %6, %10 ]
  %94 = phi double [ %107, %105 ], [ %11, %10 ]
  %95 = phi i32 [ %108, %105 ], [ 0, %10 ]
  %96 = fptosi double %94 to i8
  %97 = or i8 %96, %2
  %98 = and i8 %97, 3
  %99 = icmp eq i8 %98, 0
  br i1 %99, label %105, label %100

100:                                              ; preds = %92
  %101 = load i32, ptr @current_test, align 4, !tbaa !9
  %102 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %101)
  %103 = load double, ptr @init_value, align 8, !tbaa !28
  %104 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %105

105:                                              ; preds = %92, %100
  %106 = phi i32 [ %93, %92 ], [ %104, %100 ]
  %107 = phi double [ %94, %92 ], [ %103, %100 ]
  %108 = add nuw nsw i32 %95, 1
  %109 = icmp slt i32 %108, %106
  br i1 %109, label %92, label %110, !llvm.loop !98

110:                                              ; preds = %105, %72, %4
  %111 = tail call i64 @clock() #17
  store i64 %111, ptr @end_time, align 8, !tbaa !26
  %112 = load i64, ptr @start_time, align 8, !tbaa !26
  %113 = load ptr, ptr @results, align 8, !tbaa !5
  %114 = icmp eq ptr %113, null
  br i1 %114, label %115, label %117

115:                                              ; preds = %110
  %116 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %121

117:                                              ; preds = %110
  %118 = load i32, ptr @current_test, align 4, !tbaa !9
  %119 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %120 = icmp slt i32 %118, %119
  br i1 %120, label %133, label %121

121:                                              ; preds = %117, %115
  %122 = phi i32 [ %116, %115 ], [ %119, %117 ]
  %123 = add nsw i32 %122, 10
  store i32 %123, ptr @allocated_results, align 4, !tbaa !9
  %124 = sext i32 %123 to i64
  %125 = shl nsw i64 %124, 4
  %126 = tail call ptr @realloc(ptr noundef %113, i64 noundef %125) #14
  store ptr %126, ptr @results, align 8, !tbaa !5
  %127 = icmp eq ptr %126, null
  br i1 %127, label %130, label %128

128:                                              ; preds = %121
  %129 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %133

130:                                              ; preds = %121
  %131 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %132 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %131)
  tail call void @exit(i32 noundef -1) #15
  unreachable

133:                                              ; preds = %117, %128
  %134 = phi i32 [ %129, %128 ], [ %118, %117 ]
  %135 = phi ptr [ %126, %128 ], [ %113, %117 ]
  %136 = sub nsw i64 %111, %112
  %137 = sitofp i64 %136 to double
  %138 = fdiv double %137, 1.000000e+06
  %139 = sext i32 %134 to i64
  %140 = getelementptr inbounds %struct.one_result, ptr %135, i64 %139
  store double %138, ptr %140, align 8, !tbaa !11
  %141 = getelementptr inbounds %struct.one_result, ptr %135, i64 %139, i32 1
  store ptr %3, ptr %141, align 8, !tbaa !14
  %142 = add nsw i32 %134, 1
  store i32 %142, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Ia27custom_multiple_variable_orIaEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i8 noundef signext %2, i8 noundef signext %3, i8 noundef signext %4, i8 noundef signext %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !26
  %9 = load i32, ptr @iterations, align 4, !tbaa !9
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %128

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  %13 = or i8 %3, %2
  %14 = or i8 %13, %4
  %15 = or i8 %14, %5
  br i1 %12, label %18, label %16

16:                                               ; preds = %11
  %17 = load double, ptr @init_value, align 8, !tbaa !28
  br label %110

18:                                               ; preds = %11
  %19 = zext i32 %1 to i64
  %20 = icmp ult i32 %1, 8
  %21 = icmp ult i32 %1, 32
  %22 = and i64 %19, 4294967264
  %23 = or i8 %3, %2
  %24 = or i8 %3, %2
  %25 = or i8 %23, %4
  %26 = or i8 %24, %4
  %27 = or i8 %25, %5
  %28 = insertelement <16 x i8> poison, i8 %27, i64 0
  %29 = shufflevector <16 x i8> %28, <16 x i8> poison, <16 x i32> zeroinitializer
  %30 = or i8 %26, %5
  %31 = insertelement <16 x i8> poison, i8 %30, i64 0
  %32 = shufflevector <16 x i8> %31, <16 x i8> poison, <16 x i32> zeroinitializer
  %33 = icmp eq i64 %22, %19
  %34 = and i64 %19, 24
  %35 = icmp eq i64 %34, 0
  %36 = and i64 %19, 4294967288
  %37 = or i8 %3, %2
  %38 = or i8 %37, %4
  %39 = or i8 %38, %5
  %40 = insertelement <8 x i8> poison, i8 %39, i64 0
  %41 = shufflevector <8 x i8> %40, <8 x i8> poison, <8 x i32> zeroinitializer
  %42 = icmp eq i64 %36, %19
  br label %43

43:                                               ; preds = %18, %87
  %44 = phi i32 [ %88, %87 ], [ %9, %18 ]
  %45 = phi i32 [ %89, %87 ], [ 0, %18 ]
  br i1 %20, label %80, label %46

46:                                               ; preds = %43
  br i1 %21, label %65, label %47

47:                                               ; preds = %46, %47
  %48 = phi i64 [ %59, %47 ], [ 0, %46 ]
  %49 = phi <16 x i8> [ %57, %47 ], [ zeroinitializer, %46 ]
  %50 = phi <16 x i8> [ %58, %47 ], [ zeroinitializer, %46 ]
  %51 = getelementptr inbounds i8, ptr %0, i64 %48
  %52 = load <16 x i8>, ptr %51, align 1, !tbaa !29
  %53 = getelementptr inbounds i8, ptr %51, i64 16
  %54 = load <16 x i8>, ptr %53, align 1, !tbaa !29
  %55 = or <16 x i8> %29, %52
  %56 = or <16 x i8> %32, %54
  %57 = add <16 x i8> %55, %49
  %58 = add <16 x i8> %56, %50
  %59 = add nuw i64 %48, 32
  %60 = icmp eq i64 %59, %22
  br i1 %60, label %61, label %47, !llvm.loop !100

61:                                               ; preds = %47
  %62 = add <16 x i8> %58, %57
  %63 = tail call i8 @llvm.vector.reduce.add.v16i8(<16 x i8> %62)
  br i1 %33, label %103, label %64

64:                                               ; preds = %61
  br i1 %35, label %80, label %65

65:                                               ; preds = %46, %64
  %66 = phi i8 [ 0, %46 ], [ %63, %64 ]
  %67 = phi i64 [ 0, %46 ], [ %22, %64 ]
  %68 = insertelement <8 x i8> <i8 poison, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0>, i8 %66, i64 0
  br label %69

69:                                               ; preds = %69, %65
  %70 = phi i64 [ %67, %65 ], [ %76, %69 ]
  %71 = phi <8 x i8> [ %68, %65 ], [ %75, %69 ]
  %72 = getelementptr inbounds i8, ptr %0, i64 %70
  %73 = load <8 x i8>, ptr %72, align 1, !tbaa !29
  %74 = or <8 x i8> %41, %73
  %75 = add <8 x i8> %74, %71
  %76 = add nuw i64 %70, 8
  %77 = icmp eq i64 %76, %36
  br i1 %77, label %78, label %69, !llvm.loop !101

78:                                               ; preds = %69
  %79 = tail call i8 @llvm.vector.reduce.add.v8i8(<8 x i8> %75)
  br i1 %42, label %103, label %80

80:                                               ; preds = %43, %64, %78
  %81 = phi i64 [ 0, %43 ], [ %22, %64 ], [ %36, %78 ]
  %82 = phi i8 [ 0, %43 ], [ %63, %64 ], [ %79, %78 ]
  br label %91

83:                                               ; preds = %103
  %84 = load i32, ptr @current_test, align 4, !tbaa !9
  %85 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %84)
  %86 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %87

87:                                               ; preds = %83, %103
  %88 = phi i32 [ %86, %83 ], [ %44, %103 ]
  %89 = add nuw nsw i32 %45, 1
  %90 = icmp slt i32 %89, %88
  br i1 %90, label %43, label %128, !llvm.loop !102

91:                                               ; preds = %80, %91
  %92 = phi i64 [ %101, %91 ], [ %81, %80 ]
  %93 = phi i8 [ %100, %91 ], [ %82, %80 ]
  %94 = getelementptr inbounds i8, ptr %0, i64 %92
  %95 = load i8, ptr %94, align 1, !tbaa !29
  %96 = or i8 %95, %2
  %97 = or i8 %96, %3
  %98 = or i8 %97, %4
  %99 = or i8 %98, %5
  %100 = add i8 %99, %93
  %101 = add nuw nsw i64 %92, 1
  %102 = icmp eq i64 %101, %19
  br i1 %102, label %103, label %91, !llvm.loop !103

103:                                              ; preds = %91, %78, %61
  %104 = phi i8 [ %63, %61 ], [ %79, %78 ], [ %100, %91 ]
  %105 = load double, ptr @init_value, align 8, !tbaa !28
  %106 = fptosi double %105 to i8
  %107 = or i8 %15, %106
  %108 = shl i8 %107, 6
  %109 = icmp eq i8 %108, %104
  br i1 %109, label %87, label %83

110:                                              ; preds = %16, %123
  %111 = phi i32 [ %124, %123 ], [ %9, %16 ]
  %112 = phi double [ %125, %123 ], [ %17, %16 ]
  %113 = phi i32 [ %126, %123 ], [ 0, %16 ]
  %114 = fptosi double %112 to i8
  %115 = or i8 %15, %114
  %116 = and i8 %115, 3
  %117 = icmp eq i8 %116, 0
  br i1 %117, label %123, label %118

118:                                              ; preds = %110
  %119 = load i32, ptr @current_test, align 4, !tbaa !9
  %120 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %119)
  %121 = load double, ptr @init_value, align 8, !tbaa !28
  %122 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %123

123:                                              ; preds = %110, %118
  %124 = phi i32 [ %111, %110 ], [ %122, %118 ]
  %125 = phi double [ %112, %110 ], [ %121, %118 ]
  %126 = add nuw nsw i32 %113, 1
  %127 = icmp slt i32 %126, %124
  br i1 %127, label %110, label %128, !llvm.loop !102

128:                                              ; preds = %123, %87, %7
  %129 = tail call i64 @clock() #17
  store i64 %129, ptr @end_time, align 8, !tbaa !26
  %130 = load i64, ptr @start_time, align 8, !tbaa !26
  %131 = load ptr, ptr @results, align 8, !tbaa !5
  %132 = icmp eq ptr %131, null
  br i1 %132, label %133, label %135

133:                                              ; preds = %128
  %134 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %139

135:                                              ; preds = %128
  %136 = load i32, ptr @current_test, align 4, !tbaa !9
  %137 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %138 = icmp slt i32 %136, %137
  br i1 %138, label %151, label %139

139:                                              ; preds = %135, %133
  %140 = phi i32 [ %134, %133 ], [ %137, %135 ]
  %141 = add nsw i32 %140, 10
  store i32 %141, ptr @allocated_results, align 4, !tbaa !9
  %142 = sext i32 %141 to i64
  %143 = shl nsw i64 %142, 4
  %144 = tail call ptr @realloc(ptr noundef %131, i64 noundef %143) #14
  store ptr %144, ptr @results, align 8, !tbaa !5
  %145 = icmp eq ptr %144, null
  br i1 %145, label %148, label %146

146:                                              ; preds = %139
  %147 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %151

148:                                              ; preds = %139
  %149 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %150 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %149)
  tail call void @exit(i32 noundef -1) #15
  unreachable

151:                                              ; preds = %135, %146
  %152 = phi i32 [ %147, %146 ], [ %136, %135 ]
  %153 = phi ptr [ %144, %146 ], [ %131, %135 ]
  %154 = sub nsw i64 %129, %130
  %155 = sitofp i64 %154 to double
  %156 = fdiv double %155, 1.000000e+06
  %157 = sext i32 %152 to i64
  %158 = getelementptr inbounds %struct.one_result, ptr %153, i64 %157
  store double %156, ptr %158, align 8, !tbaa !11
  %159 = getelementptr inbounds %struct.one_result, ptr %153, i64 %157, i32 1
  store ptr %6, ptr %159, align 8, !tbaa !14
  %160 = add nsw i32 %152, 1
  store i32 %160, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1Ia19custom_variable_xorIaEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i8 noundef signext %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !26
  %6 = load i32, ptr @iterations, align 4, !tbaa !9
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %110

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  br i1 %9, label %12, label %10

10:                                               ; preds = %8
  %11 = load double, ptr @init_value, align 8, !tbaa !28
  br label %92

12:                                               ; preds = %8
  %13 = zext i32 %1 to i64
  %14 = icmp ult i32 %1, 8
  %15 = icmp ult i32 %1, 32
  %16 = and i64 %13, 4294967264
  %17 = insertelement <16 x i8> poison, i8 %2, i64 0
  %18 = shufflevector <16 x i8> %17, <16 x i8> poison, <16 x i32> zeroinitializer
  %19 = insertelement <16 x i8> poison, i8 %2, i64 0
  %20 = shufflevector <16 x i8> %19, <16 x i8> poison, <16 x i32> zeroinitializer
  %21 = icmp eq i64 %16, %13
  %22 = and i64 %13, 24
  %23 = icmp eq i64 %22, 0
  %24 = and i64 %13, 4294967288
  %25 = insertelement <8 x i8> poison, i8 %2, i64 0
  %26 = shufflevector <8 x i8> %25, <8 x i8> poison, <8 x i32> zeroinitializer
  %27 = icmp eq i64 %24, %13
  br label %28

28:                                               ; preds = %12, %72
  %29 = phi i32 [ %73, %72 ], [ %6, %12 ]
  %30 = phi i32 [ %74, %72 ], [ 0, %12 ]
  br i1 %14, label %65, label %31

31:                                               ; preds = %28
  br i1 %15, label %50, label %32

32:                                               ; preds = %31, %32
  %33 = phi i64 [ %44, %32 ], [ 0, %31 ]
  %34 = phi <16 x i8> [ %42, %32 ], [ zeroinitializer, %31 ]
  %35 = phi <16 x i8> [ %43, %32 ], [ zeroinitializer, %31 ]
  %36 = getelementptr inbounds i8, ptr %0, i64 %33
  %37 = load <16 x i8>, ptr %36, align 1, !tbaa !29
  %38 = getelementptr inbounds i8, ptr %36, i64 16
  %39 = load <16 x i8>, ptr %38, align 1, !tbaa !29
  %40 = xor <16 x i8> %37, %18
  %41 = xor <16 x i8> %39, %20
  %42 = add <16 x i8> %40, %34
  %43 = add <16 x i8> %41, %35
  %44 = add nuw i64 %33, 32
  %45 = icmp eq i64 %44, %16
  br i1 %45, label %46, label %32, !llvm.loop !104

46:                                               ; preds = %32
  %47 = add <16 x i8> %43, %42
  %48 = tail call i8 @llvm.vector.reduce.add.v16i8(<16 x i8> %47)
  br i1 %21, label %85, label %49

49:                                               ; preds = %46
  br i1 %23, label %65, label %50

50:                                               ; preds = %31, %49
  %51 = phi i8 [ 0, %31 ], [ %48, %49 ]
  %52 = phi i64 [ 0, %31 ], [ %16, %49 ]
  %53 = insertelement <8 x i8> <i8 poison, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0>, i8 %51, i64 0
  br label %54

54:                                               ; preds = %54, %50
  %55 = phi i64 [ %52, %50 ], [ %61, %54 ]
  %56 = phi <8 x i8> [ %53, %50 ], [ %60, %54 ]
  %57 = getelementptr inbounds i8, ptr %0, i64 %55
  %58 = load <8 x i8>, ptr %57, align 1, !tbaa !29
  %59 = xor <8 x i8> %58, %26
  %60 = add <8 x i8> %59, %56
  %61 = add nuw i64 %55, 8
  %62 = icmp eq i64 %61, %24
  br i1 %62, label %63, label %54, !llvm.loop !105

63:                                               ; preds = %54
  %64 = tail call i8 @llvm.vector.reduce.add.v8i8(<8 x i8> %60)
  br i1 %27, label %85, label %65

65:                                               ; preds = %28, %49, %63
  %66 = phi i64 [ 0, %28 ], [ %16, %49 ], [ %24, %63 ]
  %67 = phi i8 [ 0, %28 ], [ %48, %49 ], [ %64, %63 ]
  br label %76

68:                                               ; preds = %85
  %69 = load i32, ptr @current_test, align 4, !tbaa !9
  %70 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %69)
  %71 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %72

72:                                               ; preds = %68, %85
  %73 = phi i32 [ %71, %68 ], [ %29, %85 ]
  %74 = add nuw nsw i32 %30, 1
  %75 = icmp slt i32 %74, %73
  br i1 %75, label %28, label %110, !llvm.loop !106

76:                                               ; preds = %65, %76
  %77 = phi i64 [ %83, %76 ], [ %66, %65 ]
  %78 = phi i8 [ %82, %76 ], [ %67, %65 ]
  %79 = getelementptr inbounds i8, ptr %0, i64 %77
  %80 = load i8, ptr %79, align 1, !tbaa !29
  %81 = xor i8 %80, %2
  %82 = add i8 %81, %78
  %83 = add nuw nsw i64 %77, 1
  %84 = icmp eq i64 %83, %13
  br i1 %84, label %85, label %76, !llvm.loop !107

85:                                               ; preds = %76, %63, %46
  %86 = phi i8 [ %48, %46 ], [ %64, %63 ], [ %82, %76 ]
  %87 = load double, ptr @init_value, align 8, !tbaa !28
  %88 = fptosi double %87 to i8
  %89 = xor i8 %88, %2
  %90 = shl i8 %89, 6
  %91 = icmp eq i8 %90, %86
  br i1 %91, label %72, label %68

92:                                               ; preds = %10, %105
  %93 = phi i32 [ %106, %105 ], [ %6, %10 ]
  %94 = phi double [ %107, %105 ], [ %11, %10 ]
  %95 = phi i32 [ %108, %105 ], [ 0, %10 ]
  %96 = fptosi double %94 to i8
  %97 = xor i8 %96, %2
  %98 = and i8 %97, 3
  %99 = icmp eq i8 %98, 0
  br i1 %99, label %105, label %100

100:                                              ; preds = %92
  %101 = load i32, ptr @current_test, align 4, !tbaa !9
  %102 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %101)
  %103 = load double, ptr @init_value, align 8, !tbaa !28
  %104 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %105

105:                                              ; preds = %92, %100
  %106 = phi i32 [ %93, %92 ], [ %104, %100 ]
  %107 = phi double [ %94, %92 ], [ %103, %100 ]
  %108 = add nuw nsw i32 %95, 1
  %109 = icmp slt i32 %108, %106
  br i1 %109, label %92, label %110, !llvm.loop !106

110:                                              ; preds = %105, %72, %4
  %111 = tail call i64 @clock() #17
  store i64 %111, ptr @end_time, align 8, !tbaa !26
  %112 = load i64, ptr @start_time, align 8, !tbaa !26
  %113 = load ptr, ptr @results, align 8, !tbaa !5
  %114 = icmp eq ptr %113, null
  br i1 %114, label %115, label %117

115:                                              ; preds = %110
  %116 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %121

117:                                              ; preds = %110
  %118 = load i32, ptr @current_test, align 4, !tbaa !9
  %119 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %120 = icmp slt i32 %118, %119
  br i1 %120, label %133, label %121

121:                                              ; preds = %117, %115
  %122 = phi i32 [ %116, %115 ], [ %119, %117 ]
  %123 = add nsw i32 %122, 10
  store i32 %123, ptr @allocated_results, align 4, !tbaa !9
  %124 = sext i32 %123 to i64
  %125 = shl nsw i64 %124, 4
  %126 = tail call ptr @realloc(ptr noundef %113, i64 noundef %125) #14
  store ptr %126, ptr @results, align 8, !tbaa !5
  %127 = icmp eq ptr %126, null
  br i1 %127, label %130, label %128

128:                                              ; preds = %121
  %129 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %133

130:                                              ; preds = %121
  %131 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %132 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %131)
  tail call void @exit(i32 noundef -1) #15
  unreachable

133:                                              ; preds = %117, %128
  %134 = phi i32 [ %129, %128 ], [ %118, %117 ]
  %135 = phi ptr [ %126, %128 ], [ %113, %117 ]
  %136 = sub nsw i64 %111, %112
  %137 = sitofp i64 %136 to double
  %138 = fdiv double %137, 1.000000e+06
  %139 = sext i32 %134 to i64
  %140 = getelementptr inbounds %struct.one_result, ptr %135, i64 %139
  store double %138, ptr %140, align 8, !tbaa !11
  %141 = getelementptr inbounds %struct.one_result, ptr %135, i64 %139, i32 1
  store ptr %3, ptr %141, align 8, !tbaa !14
  %142 = add nsw i32 %134, 1
  store i32 %142, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Ia28custom_multiple_variable_xorIaEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i8 noundef signext %2, i8 noundef signext %3, i8 noundef signext %4, i8 noundef signext %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !26
  %9 = load i32, ptr @iterations, align 4, !tbaa !9
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %128

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  %13 = xor i8 %3, %2
  %14 = xor i8 %13, %4
  %15 = xor i8 %14, %5
  br i1 %12, label %18, label %16

16:                                               ; preds = %11
  %17 = load double, ptr @init_value, align 8, !tbaa !28
  br label %110

18:                                               ; preds = %11
  %19 = zext i32 %1 to i64
  %20 = icmp ult i32 %1, 8
  %21 = icmp ult i32 %1, 32
  %22 = and i64 %19, 4294967264
  %23 = xor i8 %3, %2
  %24 = xor i8 %3, %2
  %25 = xor i8 %23, %4
  %26 = xor i8 %24, %4
  %27 = xor i8 %25, %5
  %28 = insertelement <16 x i8> poison, i8 %27, i64 0
  %29 = shufflevector <16 x i8> %28, <16 x i8> poison, <16 x i32> zeroinitializer
  %30 = xor i8 %26, %5
  %31 = insertelement <16 x i8> poison, i8 %30, i64 0
  %32 = shufflevector <16 x i8> %31, <16 x i8> poison, <16 x i32> zeroinitializer
  %33 = icmp eq i64 %22, %19
  %34 = and i64 %19, 24
  %35 = icmp eq i64 %34, 0
  %36 = and i64 %19, 4294967288
  %37 = xor i8 %3, %2
  %38 = xor i8 %37, %4
  %39 = xor i8 %38, %5
  %40 = insertelement <8 x i8> poison, i8 %39, i64 0
  %41 = shufflevector <8 x i8> %40, <8 x i8> poison, <8 x i32> zeroinitializer
  %42 = icmp eq i64 %36, %19
  br label %43

43:                                               ; preds = %18, %87
  %44 = phi i32 [ %88, %87 ], [ %9, %18 ]
  %45 = phi i32 [ %89, %87 ], [ 0, %18 ]
  br i1 %20, label %80, label %46

46:                                               ; preds = %43
  br i1 %21, label %65, label %47

47:                                               ; preds = %46, %47
  %48 = phi i64 [ %59, %47 ], [ 0, %46 ]
  %49 = phi <16 x i8> [ %57, %47 ], [ zeroinitializer, %46 ]
  %50 = phi <16 x i8> [ %58, %47 ], [ zeroinitializer, %46 ]
  %51 = getelementptr inbounds i8, ptr %0, i64 %48
  %52 = load <16 x i8>, ptr %51, align 1, !tbaa !29
  %53 = getelementptr inbounds i8, ptr %51, i64 16
  %54 = load <16 x i8>, ptr %53, align 1, !tbaa !29
  %55 = xor <16 x i8> %29, %52
  %56 = xor <16 x i8> %32, %54
  %57 = add <16 x i8> %55, %49
  %58 = add <16 x i8> %56, %50
  %59 = add nuw i64 %48, 32
  %60 = icmp eq i64 %59, %22
  br i1 %60, label %61, label %47, !llvm.loop !108

61:                                               ; preds = %47
  %62 = add <16 x i8> %58, %57
  %63 = tail call i8 @llvm.vector.reduce.add.v16i8(<16 x i8> %62)
  br i1 %33, label %103, label %64

64:                                               ; preds = %61
  br i1 %35, label %80, label %65

65:                                               ; preds = %46, %64
  %66 = phi i8 [ 0, %46 ], [ %63, %64 ]
  %67 = phi i64 [ 0, %46 ], [ %22, %64 ]
  %68 = insertelement <8 x i8> <i8 poison, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0>, i8 %66, i64 0
  br label %69

69:                                               ; preds = %69, %65
  %70 = phi i64 [ %67, %65 ], [ %76, %69 ]
  %71 = phi <8 x i8> [ %68, %65 ], [ %75, %69 ]
  %72 = getelementptr inbounds i8, ptr %0, i64 %70
  %73 = load <8 x i8>, ptr %72, align 1, !tbaa !29
  %74 = xor <8 x i8> %41, %73
  %75 = add <8 x i8> %74, %71
  %76 = add nuw i64 %70, 8
  %77 = icmp eq i64 %76, %36
  br i1 %77, label %78, label %69, !llvm.loop !109

78:                                               ; preds = %69
  %79 = tail call i8 @llvm.vector.reduce.add.v8i8(<8 x i8> %75)
  br i1 %42, label %103, label %80

80:                                               ; preds = %43, %64, %78
  %81 = phi i64 [ 0, %43 ], [ %22, %64 ], [ %36, %78 ]
  %82 = phi i8 [ 0, %43 ], [ %63, %64 ], [ %79, %78 ]
  br label %91

83:                                               ; preds = %103
  %84 = load i32, ptr @current_test, align 4, !tbaa !9
  %85 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %84)
  %86 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %87

87:                                               ; preds = %83, %103
  %88 = phi i32 [ %86, %83 ], [ %44, %103 ]
  %89 = add nuw nsw i32 %45, 1
  %90 = icmp slt i32 %89, %88
  br i1 %90, label %43, label %128, !llvm.loop !110

91:                                               ; preds = %80, %91
  %92 = phi i64 [ %101, %91 ], [ %81, %80 ]
  %93 = phi i8 [ %100, %91 ], [ %82, %80 ]
  %94 = getelementptr inbounds i8, ptr %0, i64 %92
  %95 = load i8, ptr %94, align 1, !tbaa !29
  %96 = xor i8 %95, %2
  %97 = xor i8 %96, %3
  %98 = xor i8 %97, %4
  %99 = xor i8 %98, %5
  %100 = add i8 %99, %93
  %101 = add nuw nsw i64 %92, 1
  %102 = icmp eq i64 %101, %19
  br i1 %102, label %103, label %91, !llvm.loop !111

103:                                              ; preds = %91, %78, %61
  %104 = phi i8 [ %63, %61 ], [ %79, %78 ], [ %100, %91 ]
  %105 = load double, ptr @init_value, align 8, !tbaa !28
  %106 = fptosi double %105 to i8
  %107 = xor i8 %15, %106
  %108 = shl i8 %107, 6
  %109 = icmp eq i8 %108, %104
  br i1 %109, label %87, label %83

110:                                              ; preds = %16, %123
  %111 = phi i32 [ %124, %123 ], [ %9, %16 ]
  %112 = phi double [ %125, %123 ], [ %17, %16 ]
  %113 = phi i32 [ %126, %123 ], [ 0, %16 ]
  %114 = fptosi double %112 to i8
  %115 = xor i8 %15, %114
  %116 = and i8 %115, 3
  %117 = icmp eq i8 %116, 0
  br i1 %117, label %123, label %118

118:                                              ; preds = %110
  %119 = load i32, ptr @current_test, align 4, !tbaa !9
  %120 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %119)
  %121 = load double, ptr @init_value, align 8, !tbaa !28
  %122 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %123

123:                                              ; preds = %110, %118
  %124 = phi i32 [ %111, %110 ], [ %122, %118 ]
  %125 = phi double [ %112, %110 ], [ %121, %118 ]
  %126 = add nuw nsw i32 %113, 1
  %127 = icmp slt i32 %126, %124
  br i1 %127, label %110, label %128, !llvm.loop !110

128:                                              ; preds = %123, %87, %7
  %129 = tail call i64 @clock() #17
  store i64 %129, ptr @end_time, align 8, !tbaa !26
  %130 = load i64, ptr @start_time, align 8, !tbaa !26
  %131 = load ptr, ptr @results, align 8, !tbaa !5
  %132 = icmp eq ptr %131, null
  br i1 %132, label %133, label %135

133:                                              ; preds = %128
  %134 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %139

135:                                              ; preds = %128
  %136 = load i32, ptr @current_test, align 4, !tbaa !9
  %137 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %138 = icmp slt i32 %136, %137
  br i1 %138, label %151, label %139

139:                                              ; preds = %135, %133
  %140 = phi i32 [ %134, %133 ], [ %137, %135 ]
  %141 = add nsw i32 %140, 10
  store i32 %141, ptr @allocated_results, align 4, !tbaa !9
  %142 = sext i32 %141 to i64
  %143 = shl nsw i64 %142, 4
  %144 = tail call ptr @realloc(ptr noundef %131, i64 noundef %143) #14
  store ptr %144, ptr @results, align 8, !tbaa !5
  %145 = icmp eq ptr %144, null
  br i1 %145, label %148, label %146

146:                                              ; preds = %139
  %147 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %151

148:                                              ; preds = %139
  %149 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %150 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %149)
  tail call void @exit(i32 noundef -1) #15
  unreachable

151:                                              ; preds = %135, %146
  %152 = phi i32 [ %147, %146 ], [ %136, %135 ]
  %153 = phi ptr [ %144, %146 ], [ %131, %135 ]
  %154 = sub nsw i64 %129, %130
  %155 = sitofp i64 %154 to double
  %156 = fdiv double %155, 1.000000e+06
  %157 = sext i32 %152 to i64
  %158 = getelementptr inbounds %struct.one_result, ptr %153, i64 %157
  store double %156, ptr %158, align 8, !tbaa !11
  %159 = getelementptr inbounds %struct.one_result, ptr %153, i64 %157, i32 1
  store ptr %6, ptr %159, align 8, !tbaa !14
  %160 = add nsw i32 %152, 1
  store i32 %160, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1Ih19custom_add_variableIhEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i8 noundef zeroext %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !26
  %6 = load i32, ptr @iterations, align 4, !tbaa !9
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %110

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  br i1 %9, label %12, label %10

10:                                               ; preds = %8
  %11 = load double, ptr @init_value, align 8, !tbaa !28
  br label %92

12:                                               ; preds = %8
  %13 = zext i32 %1 to i64
  %14 = icmp ult i32 %1, 8
  %15 = icmp ult i32 %1, 32
  %16 = and i64 %13, 4294967264
  %17 = insertelement <16 x i8> poison, i8 %2, i64 0
  %18 = shufflevector <16 x i8> %17, <16 x i8> poison, <16 x i32> zeroinitializer
  %19 = insertelement <16 x i8> poison, i8 %2, i64 0
  %20 = shufflevector <16 x i8> %19, <16 x i8> poison, <16 x i32> zeroinitializer
  %21 = icmp eq i64 %16, %13
  %22 = and i64 %13, 24
  %23 = icmp eq i64 %22, 0
  %24 = and i64 %13, 4294967288
  %25 = insertelement <8 x i8> poison, i8 %2, i64 0
  %26 = shufflevector <8 x i8> %25, <8 x i8> poison, <8 x i32> zeroinitializer
  %27 = icmp eq i64 %24, %13
  br label %28

28:                                               ; preds = %12, %72
  %29 = phi i32 [ %73, %72 ], [ %6, %12 ]
  %30 = phi i32 [ %74, %72 ], [ 0, %12 ]
  br i1 %14, label %65, label %31

31:                                               ; preds = %28
  br i1 %15, label %50, label %32

32:                                               ; preds = %31, %32
  %33 = phi i64 [ %44, %32 ], [ 0, %31 ]
  %34 = phi <16 x i8> [ %42, %32 ], [ zeroinitializer, %31 ]
  %35 = phi <16 x i8> [ %43, %32 ], [ zeroinitializer, %31 ]
  %36 = getelementptr inbounds i8, ptr %0, i64 %33
  %37 = load <16 x i8>, ptr %36, align 1, !tbaa !29
  %38 = getelementptr inbounds i8, ptr %36, i64 16
  %39 = load <16 x i8>, ptr %38, align 1, !tbaa !29
  %40 = add <16 x i8> %34, %18
  %41 = add <16 x i8> %35, %20
  %42 = add <16 x i8> %40, %37
  %43 = add <16 x i8> %41, %39
  %44 = add nuw i64 %33, 32
  %45 = icmp eq i64 %44, %16
  br i1 %45, label %46, label %32, !llvm.loop !112

46:                                               ; preds = %32
  %47 = add <16 x i8> %43, %42
  %48 = tail call i8 @llvm.vector.reduce.add.v16i8(<16 x i8> %47)
  br i1 %21, label %85, label %49

49:                                               ; preds = %46
  br i1 %23, label %65, label %50

50:                                               ; preds = %31, %49
  %51 = phi i8 [ 0, %31 ], [ %48, %49 ]
  %52 = phi i64 [ 0, %31 ], [ %16, %49 ]
  %53 = insertelement <8 x i8> <i8 poison, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0>, i8 %51, i64 0
  br label %54

54:                                               ; preds = %54, %50
  %55 = phi i64 [ %52, %50 ], [ %61, %54 ]
  %56 = phi <8 x i8> [ %53, %50 ], [ %60, %54 ]
  %57 = getelementptr inbounds i8, ptr %0, i64 %55
  %58 = load <8 x i8>, ptr %57, align 1, !tbaa !29
  %59 = add <8 x i8> %56, %26
  %60 = add <8 x i8> %59, %58
  %61 = add nuw i64 %55, 8
  %62 = icmp eq i64 %61, %24
  br i1 %62, label %63, label %54, !llvm.loop !113

63:                                               ; preds = %54
  %64 = tail call i8 @llvm.vector.reduce.add.v8i8(<8 x i8> %60)
  br i1 %27, label %85, label %65

65:                                               ; preds = %28, %49, %63
  %66 = phi i64 [ 0, %28 ], [ %16, %49 ], [ %24, %63 ]
  %67 = phi i8 [ 0, %28 ], [ %48, %49 ], [ %64, %63 ]
  br label %76

68:                                               ; preds = %85
  %69 = load i32, ptr @current_test, align 4, !tbaa !9
  %70 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %69)
  %71 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %72

72:                                               ; preds = %68, %85
  %73 = phi i32 [ %71, %68 ], [ %29, %85 ]
  %74 = add nuw nsw i32 %30, 1
  %75 = icmp slt i32 %74, %73
  br i1 %75, label %28, label %110, !llvm.loop !114

76:                                               ; preds = %65, %76
  %77 = phi i64 [ %83, %76 ], [ %66, %65 ]
  %78 = phi i8 [ %82, %76 ], [ %67, %65 ]
  %79 = getelementptr inbounds i8, ptr %0, i64 %77
  %80 = load i8, ptr %79, align 1, !tbaa !29
  %81 = add i8 %78, %2
  %82 = add i8 %81, %80
  %83 = add nuw nsw i64 %77, 1
  %84 = icmp eq i64 %83, %13
  br i1 %84, label %85, label %76, !llvm.loop !115

85:                                               ; preds = %76, %63, %46
  %86 = phi i8 [ %48, %46 ], [ %64, %63 ], [ %82, %76 ]
  %87 = load double, ptr @init_value, align 8, !tbaa !28
  %88 = fptoui double %87 to i8
  %89 = add i8 %88, %2
  %90 = shl i8 %89, 6
  %91 = icmp eq i8 %90, %86
  br i1 %91, label %72, label %68

92:                                               ; preds = %10, %105
  %93 = phi i32 [ %106, %105 ], [ %6, %10 ]
  %94 = phi double [ %107, %105 ], [ %11, %10 ]
  %95 = phi i32 [ %108, %105 ], [ 0, %10 ]
  %96 = fptoui double %94 to i8
  %97 = add i8 %96, %2
  %98 = and i8 %97, 3
  %99 = icmp eq i8 %98, 0
  br i1 %99, label %105, label %100

100:                                              ; preds = %92
  %101 = load i32, ptr @current_test, align 4, !tbaa !9
  %102 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %101)
  %103 = load double, ptr @init_value, align 8, !tbaa !28
  %104 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %105

105:                                              ; preds = %92, %100
  %106 = phi i32 [ %93, %92 ], [ %104, %100 ]
  %107 = phi double [ %94, %92 ], [ %103, %100 ]
  %108 = add nuw nsw i32 %95, 1
  %109 = icmp slt i32 %108, %106
  br i1 %109, label %92, label %110, !llvm.loop !114

110:                                              ; preds = %105, %72, %4
  %111 = tail call i64 @clock() #17
  store i64 %111, ptr @end_time, align 8, !tbaa !26
  %112 = load i64, ptr @start_time, align 8, !tbaa !26
  %113 = load ptr, ptr @results, align 8, !tbaa !5
  %114 = icmp eq ptr %113, null
  br i1 %114, label %115, label %117

115:                                              ; preds = %110
  %116 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %121

117:                                              ; preds = %110
  %118 = load i32, ptr @current_test, align 4, !tbaa !9
  %119 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %120 = icmp slt i32 %118, %119
  br i1 %120, label %133, label %121

121:                                              ; preds = %117, %115
  %122 = phi i32 [ %116, %115 ], [ %119, %117 ]
  %123 = add nsw i32 %122, 10
  store i32 %123, ptr @allocated_results, align 4, !tbaa !9
  %124 = sext i32 %123 to i64
  %125 = shl nsw i64 %124, 4
  %126 = tail call ptr @realloc(ptr noundef %113, i64 noundef %125) #14
  store ptr %126, ptr @results, align 8, !tbaa !5
  %127 = icmp eq ptr %126, null
  br i1 %127, label %130, label %128

128:                                              ; preds = %121
  %129 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %133

130:                                              ; preds = %121
  %131 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %132 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %131)
  tail call void @exit(i32 noundef -1) #15
  unreachable

133:                                              ; preds = %117, %128
  %134 = phi i32 [ %129, %128 ], [ %118, %117 ]
  %135 = phi ptr [ %126, %128 ], [ %113, %117 ]
  %136 = sub nsw i64 %111, %112
  %137 = sitofp i64 %136 to double
  %138 = fdiv double %137, 1.000000e+06
  %139 = sext i32 %134 to i64
  %140 = getelementptr inbounds %struct.one_result, ptr %135, i64 %139
  store double %138, ptr %140, align 8, !tbaa !11
  %141 = getelementptr inbounds %struct.one_result, ptr %135, i64 %139, i32 1
  store ptr %3, ptr %141, align 8, !tbaa !14
  %142 = add nsw i32 %134, 1
  store i32 %142, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z22test_hoisted_variable1Ih19custom_add_variableIhEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i8 noundef zeroext %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !26
  %6 = load i32, ptr @iterations, align 4, !tbaa !9
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %103

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  %10 = trunc i32 %1 to i8
  %11 = mul i8 %10, %2
  br i1 %9, label %14, label %12

12:                                               ; preds = %8
  %13 = load double, ptr @init_value, align 8, !tbaa !28
  br label %85

14:                                               ; preds = %8
  %15 = zext i32 %1 to i64
  %16 = icmp ult i32 %1, 8
  %17 = icmp ult i32 %1, 32
  %18 = and i64 %15, 4294967264
  %19 = icmp eq i64 %18, %15
  %20 = and i64 %15, 24
  %21 = icmp eq i64 %20, 0
  %22 = and i64 %15, 4294967288
  %23 = icmp eq i64 %22, %15
  br label %24

24:                                               ; preds = %14, %65
  %25 = phi i32 [ %66, %65 ], [ %6, %14 ]
  %26 = phi i32 [ %67, %65 ], [ 0, %14 ]
  br i1 %16, label %58, label %27

27:                                               ; preds = %24
  br i1 %17, label %44, label %28

28:                                               ; preds = %27, %28
  %29 = phi i64 [ %38, %28 ], [ 0, %27 ]
  %30 = phi <16 x i8> [ %36, %28 ], [ zeroinitializer, %27 ]
  %31 = phi <16 x i8> [ %37, %28 ], [ zeroinitializer, %27 ]
  %32 = getelementptr inbounds i8, ptr %0, i64 %29
  %33 = load <16 x i8>, ptr %32, align 1, !tbaa !29
  %34 = getelementptr inbounds i8, ptr %32, i64 16
  %35 = load <16 x i8>, ptr %34, align 1, !tbaa !29
  %36 = add <16 x i8> %33, %30
  %37 = add <16 x i8> %35, %31
  %38 = add nuw i64 %29, 32
  %39 = icmp eq i64 %38, %18
  br i1 %39, label %40, label %28, !llvm.loop !116

40:                                               ; preds = %28
  %41 = add <16 x i8> %37, %36
  %42 = tail call i8 @llvm.vector.reduce.add.v16i8(<16 x i8> %41)
  br i1 %19, label %77, label %43

43:                                               ; preds = %40
  br i1 %21, label %58, label %44

44:                                               ; preds = %27, %43
  %45 = phi i8 [ 0, %27 ], [ %42, %43 ]
  %46 = phi i64 [ 0, %27 ], [ %18, %43 ]
  %47 = insertelement <8 x i8> <i8 poison, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0>, i8 %45, i64 0
  br label %48

48:                                               ; preds = %48, %44
  %49 = phi i64 [ %46, %44 ], [ %54, %48 ]
  %50 = phi <8 x i8> [ %47, %44 ], [ %53, %48 ]
  %51 = getelementptr inbounds i8, ptr %0, i64 %49
  %52 = load <8 x i8>, ptr %51, align 1, !tbaa !29
  %53 = add <8 x i8> %52, %50
  %54 = add nuw i64 %49, 8
  %55 = icmp eq i64 %54, %22
  br i1 %55, label %56, label %48, !llvm.loop !117

56:                                               ; preds = %48
  %57 = tail call i8 @llvm.vector.reduce.add.v8i8(<8 x i8> %53)
  br i1 %23, label %77, label %58

58:                                               ; preds = %24, %43, %56
  %59 = phi i64 [ 0, %24 ], [ %18, %43 ], [ %22, %56 ]
  %60 = phi i8 [ 0, %24 ], [ %42, %43 ], [ %57, %56 ]
  br label %69

61:                                               ; preds = %77
  %62 = load i32, ptr @current_test, align 4, !tbaa !9
  %63 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %62)
  %64 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %65

65:                                               ; preds = %61, %77
  %66 = phi i32 [ %64, %61 ], [ %25, %77 ]
  %67 = add nuw nsw i32 %26, 1
  %68 = icmp slt i32 %67, %66
  br i1 %68, label %24, label %103, !llvm.loop !118

69:                                               ; preds = %58, %69
  %70 = phi i64 [ %75, %69 ], [ %59, %58 ]
  %71 = phi i8 [ %74, %69 ], [ %60, %58 ]
  %72 = getelementptr inbounds i8, ptr %0, i64 %70
  %73 = load i8, ptr %72, align 1, !tbaa !29
  %74 = add i8 %73, %71
  %75 = add nuw nsw i64 %70, 1
  %76 = icmp eq i64 %75, %15
  br i1 %76, label %77, label %69, !llvm.loop !119

77:                                               ; preds = %69, %56, %40
  %78 = phi i8 [ %42, %40 ], [ %57, %56 ], [ %74, %69 ]
  %79 = add i8 %78, %11
  %80 = load double, ptr @init_value, align 8, !tbaa !28
  %81 = fptoui double %80 to i8
  %82 = add i8 %81, %2
  %83 = shl i8 %82, 6
  %84 = icmp eq i8 %83, %79
  br i1 %84, label %65, label %61

85:                                               ; preds = %12, %98
  %86 = phi i32 [ %99, %98 ], [ %6, %12 ]
  %87 = phi double [ %100, %98 ], [ %13, %12 ]
  %88 = phi i32 [ %101, %98 ], [ 0, %12 ]
  %89 = fptoui double %87 to i8
  %90 = add i8 %89, %2
  %91 = shl i8 %90, 6
  %92 = icmp eq i8 %91, %11
  br i1 %92, label %98, label %93

93:                                               ; preds = %85
  %94 = load i32, ptr @current_test, align 4, !tbaa !9
  %95 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %94)
  %96 = load double, ptr @init_value, align 8, !tbaa !28
  %97 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %98

98:                                               ; preds = %85, %93
  %99 = phi i32 [ %86, %85 ], [ %97, %93 ]
  %100 = phi double [ %87, %85 ], [ %96, %93 ]
  %101 = add nuw nsw i32 %88, 1
  %102 = icmp slt i32 %101, %99
  br i1 %102, label %85, label %103, !llvm.loop !118

103:                                              ; preds = %98, %65, %4
  %104 = tail call i64 @clock() #17
  store i64 %104, ptr @end_time, align 8, !tbaa !26
  %105 = load i64, ptr @start_time, align 8, !tbaa !26
  %106 = load ptr, ptr @results, align 8, !tbaa !5
  %107 = icmp eq ptr %106, null
  br i1 %107, label %108, label %110

108:                                              ; preds = %103
  %109 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %114

110:                                              ; preds = %103
  %111 = load i32, ptr @current_test, align 4, !tbaa !9
  %112 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %113 = icmp slt i32 %111, %112
  br i1 %113, label %126, label %114

114:                                              ; preds = %110, %108
  %115 = phi i32 [ %109, %108 ], [ %112, %110 ]
  %116 = add nsw i32 %115, 10
  store i32 %116, ptr @allocated_results, align 4, !tbaa !9
  %117 = sext i32 %116 to i64
  %118 = shl nsw i64 %117, 4
  %119 = tail call ptr @realloc(ptr noundef %106, i64 noundef %118) #14
  store ptr %119, ptr @results, align 8, !tbaa !5
  %120 = icmp eq ptr %119, null
  br i1 %120, label %123, label %121

121:                                              ; preds = %114
  %122 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %126

123:                                              ; preds = %114
  %124 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %125 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %124)
  tail call void @exit(i32 noundef -1) #15
  unreachable

126:                                              ; preds = %110, %121
  %127 = phi i32 [ %122, %121 ], [ %111, %110 ]
  %128 = phi ptr [ %119, %121 ], [ %106, %110 ]
  %129 = sub nsw i64 %104, %105
  %130 = sitofp i64 %129 to double
  %131 = fdiv double %130, 1.000000e+06
  %132 = sext i32 %127 to i64
  %133 = getelementptr inbounds %struct.one_result, ptr %128, i64 %132
  store double %131, ptr %133, align 8, !tbaa !11
  %134 = getelementptr inbounds %struct.one_result, ptr %128, i64 %132, i32 1
  store ptr %3, ptr %134, align 8, !tbaa !14
  %135 = add nsw i32 %127, 1
  store i32 %135, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Ih28custom_add_multiple_variableIhEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i8 noundef zeroext %2, i8 noundef zeroext %3, i8 noundef zeroext %4, i8 noundef zeroext %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !26
  %9 = load i32, ptr @iterations, align 4, !tbaa !9
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %116

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  %13 = add i8 %3, %2
  %14 = add i8 %13, %4
  %15 = add i8 %14, %5
  br i1 %12, label %18, label %16

16:                                               ; preds = %11
  %17 = load double, ptr @init_value, align 8, !tbaa !28
  br label %98

18:                                               ; preds = %11
  %19 = zext i32 %1 to i64
  %20 = icmp ult i32 %1, 8
  %21 = icmp ult i32 %1, 32
  %22 = and i64 %19, 4294967264
  %23 = insertelement <16 x i8> poison, i8 %15, i64 0
  %24 = shufflevector <16 x i8> %23, <16 x i8> poison, <16 x i32> zeroinitializer
  %25 = insertelement <16 x i8> poison, i8 %15, i64 0
  %26 = shufflevector <16 x i8> %25, <16 x i8> poison, <16 x i32> zeroinitializer
  %27 = icmp eq i64 %22, %19
  %28 = and i64 %19, 24
  %29 = icmp eq i64 %28, 0
  %30 = and i64 %19, 4294967288
  %31 = insertelement <8 x i8> poison, i8 %15, i64 0
  %32 = shufflevector <8 x i8> %31, <8 x i8> poison, <8 x i32> zeroinitializer
  %33 = icmp eq i64 %30, %19
  br label %34

34:                                               ; preds = %18, %78
  %35 = phi i32 [ %79, %78 ], [ %9, %18 ]
  %36 = phi i32 [ %80, %78 ], [ 0, %18 ]
  br i1 %20, label %71, label %37

37:                                               ; preds = %34
  br i1 %21, label %56, label %38

38:                                               ; preds = %37, %38
  %39 = phi i64 [ %50, %38 ], [ 0, %37 ]
  %40 = phi <16 x i8> [ %48, %38 ], [ zeroinitializer, %37 ]
  %41 = phi <16 x i8> [ %49, %38 ], [ zeroinitializer, %37 ]
  %42 = getelementptr inbounds i8, ptr %0, i64 %39
  %43 = load <16 x i8>, ptr %42, align 1, !tbaa !29
  %44 = getelementptr inbounds i8, ptr %42, i64 16
  %45 = load <16 x i8>, ptr %44, align 1, !tbaa !29
  %46 = add <16 x i8> %24, %40
  %47 = add <16 x i8> %26, %41
  %48 = add <16 x i8> %46, %43
  %49 = add <16 x i8> %47, %45
  %50 = add nuw i64 %39, 32
  %51 = icmp eq i64 %50, %22
  br i1 %51, label %52, label %38, !llvm.loop !120

52:                                               ; preds = %38
  %53 = add <16 x i8> %49, %48
  %54 = tail call i8 @llvm.vector.reduce.add.v16i8(<16 x i8> %53)
  br i1 %27, label %91, label %55

55:                                               ; preds = %52
  br i1 %29, label %71, label %56

56:                                               ; preds = %37, %55
  %57 = phi i8 [ 0, %37 ], [ %54, %55 ]
  %58 = phi i64 [ 0, %37 ], [ %22, %55 ]
  %59 = insertelement <8 x i8> <i8 poison, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0>, i8 %57, i64 0
  br label %60

60:                                               ; preds = %60, %56
  %61 = phi i64 [ %58, %56 ], [ %67, %60 ]
  %62 = phi <8 x i8> [ %59, %56 ], [ %66, %60 ]
  %63 = getelementptr inbounds i8, ptr %0, i64 %61
  %64 = load <8 x i8>, ptr %63, align 1, !tbaa !29
  %65 = add <8 x i8> %32, %62
  %66 = add <8 x i8> %65, %64
  %67 = add nuw i64 %61, 8
  %68 = icmp eq i64 %67, %30
  br i1 %68, label %69, label %60, !llvm.loop !121

69:                                               ; preds = %60
  %70 = tail call i8 @llvm.vector.reduce.add.v8i8(<8 x i8> %66)
  br i1 %33, label %91, label %71

71:                                               ; preds = %34, %55, %69
  %72 = phi i64 [ 0, %34 ], [ %22, %55 ], [ %30, %69 ]
  %73 = phi i8 [ 0, %34 ], [ %54, %55 ], [ %70, %69 ]
  br label %82

74:                                               ; preds = %91
  %75 = load i32, ptr @current_test, align 4, !tbaa !9
  %76 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %75)
  %77 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %78

78:                                               ; preds = %74, %91
  %79 = phi i32 [ %77, %74 ], [ %35, %91 ]
  %80 = add nuw nsw i32 %36, 1
  %81 = icmp slt i32 %80, %79
  br i1 %81, label %34, label %116, !llvm.loop !122

82:                                               ; preds = %71, %82
  %83 = phi i64 [ %89, %82 ], [ %72, %71 ]
  %84 = phi i8 [ %88, %82 ], [ %73, %71 ]
  %85 = getelementptr inbounds i8, ptr %0, i64 %83
  %86 = load i8, ptr %85, align 1, !tbaa !29
  %87 = add i8 %15, %84
  %88 = add i8 %87, %86
  %89 = add nuw nsw i64 %83, 1
  %90 = icmp eq i64 %89, %19
  br i1 %90, label %91, label %82, !llvm.loop !123

91:                                               ; preds = %82, %69, %52
  %92 = phi i8 [ %54, %52 ], [ %70, %69 ], [ %88, %82 ]
  %93 = load double, ptr @init_value, align 8, !tbaa !28
  %94 = fptoui double %93 to i8
  %95 = add i8 %15, %94
  %96 = shl i8 %95, 6
  %97 = icmp eq i8 %96, %92
  br i1 %97, label %78, label %74

98:                                               ; preds = %16, %111
  %99 = phi i32 [ %112, %111 ], [ %9, %16 ]
  %100 = phi double [ %113, %111 ], [ %17, %16 ]
  %101 = phi i32 [ %114, %111 ], [ 0, %16 ]
  %102 = fptoui double %100 to i8
  %103 = add i8 %15, %102
  %104 = and i8 %103, 3
  %105 = icmp eq i8 %104, 0
  br i1 %105, label %111, label %106

106:                                              ; preds = %98
  %107 = load i32, ptr @current_test, align 4, !tbaa !9
  %108 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %107)
  %109 = load double, ptr @init_value, align 8, !tbaa !28
  %110 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %111

111:                                              ; preds = %98, %106
  %112 = phi i32 [ %99, %98 ], [ %110, %106 ]
  %113 = phi double [ %100, %98 ], [ %109, %106 ]
  %114 = add nuw nsw i32 %101, 1
  %115 = icmp slt i32 %114, %112
  br i1 %115, label %98, label %116, !llvm.loop !122

116:                                              ; preds = %111, %78, %7
  %117 = tail call i64 @clock() #17
  store i64 %117, ptr @end_time, align 8, !tbaa !26
  %118 = load i64, ptr @start_time, align 8, !tbaa !26
  %119 = load ptr, ptr @results, align 8, !tbaa !5
  %120 = icmp eq ptr %119, null
  br i1 %120, label %121, label %123

121:                                              ; preds = %116
  %122 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %127

123:                                              ; preds = %116
  %124 = load i32, ptr @current_test, align 4, !tbaa !9
  %125 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %126 = icmp slt i32 %124, %125
  br i1 %126, label %139, label %127

127:                                              ; preds = %123, %121
  %128 = phi i32 [ %122, %121 ], [ %125, %123 ]
  %129 = add nsw i32 %128, 10
  store i32 %129, ptr @allocated_results, align 4, !tbaa !9
  %130 = sext i32 %129 to i64
  %131 = shl nsw i64 %130, 4
  %132 = tail call ptr @realloc(ptr noundef %119, i64 noundef %131) #14
  store ptr %132, ptr @results, align 8, !tbaa !5
  %133 = icmp eq ptr %132, null
  br i1 %133, label %136, label %134

134:                                              ; preds = %127
  %135 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %139

136:                                              ; preds = %127
  %137 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %138 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %137)
  tail call void @exit(i32 noundef -1) #15
  unreachable

139:                                              ; preds = %123, %134
  %140 = phi i32 [ %135, %134 ], [ %124, %123 ]
  %141 = phi ptr [ %132, %134 ], [ %119, %123 ]
  %142 = sub nsw i64 %117, %118
  %143 = sitofp i64 %142 to double
  %144 = fdiv double %143, 1.000000e+06
  %145 = sext i32 %140 to i64
  %146 = getelementptr inbounds %struct.one_result, ptr %141, i64 %145
  store double %144, ptr %146, align 8, !tbaa !11
  %147 = getelementptr inbounds %struct.one_result, ptr %141, i64 %145, i32 1
  store ptr %6, ptr %147, align 8, !tbaa !14
  %148 = add nsw i32 %140, 1
  store i32 %148, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1Ih19custom_sub_variableIhEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i8 noundef zeroext %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !26
  %6 = load i32, ptr @iterations, align 4, !tbaa !9
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %110

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  br i1 %9, label %12, label %10

10:                                               ; preds = %8
  %11 = load double, ptr @init_value, align 8, !tbaa !28
  br label %92

12:                                               ; preds = %8
  %13 = zext i32 %1 to i64
  %14 = icmp ult i32 %1, 8
  %15 = icmp ult i32 %1, 32
  %16 = and i64 %13, 4294967264
  %17 = insertelement <16 x i8> poison, i8 %2, i64 0
  %18 = shufflevector <16 x i8> %17, <16 x i8> poison, <16 x i32> zeroinitializer
  %19 = insertelement <16 x i8> poison, i8 %2, i64 0
  %20 = shufflevector <16 x i8> %19, <16 x i8> poison, <16 x i32> zeroinitializer
  %21 = icmp eq i64 %16, %13
  %22 = and i64 %13, 24
  %23 = icmp eq i64 %22, 0
  %24 = and i64 %13, 4294967288
  %25 = insertelement <8 x i8> poison, i8 %2, i64 0
  %26 = shufflevector <8 x i8> %25, <8 x i8> poison, <8 x i32> zeroinitializer
  %27 = icmp eq i64 %24, %13
  br label %28

28:                                               ; preds = %12, %72
  %29 = phi i32 [ %73, %72 ], [ %6, %12 ]
  %30 = phi i32 [ %74, %72 ], [ 0, %12 ]
  br i1 %14, label %65, label %31

31:                                               ; preds = %28
  br i1 %15, label %50, label %32

32:                                               ; preds = %31, %32
  %33 = phi i64 [ %44, %32 ], [ 0, %31 ]
  %34 = phi <16 x i8> [ %42, %32 ], [ zeroinitializer, %31 ]
  %35 = phi <16 x i8> [ %43, %32 ], [ zeroinitializer, %31 ]
  %36 = getelementptr inbounds i8, ptr %0, i64 %33
  %37 = load <16 x i8>, ptr %36, align 1, !tbaa !29
  %38 = getelementptr inbounds i8, ptr %36, i64 16
  %39 = load <16 x i8>, ptr %38, align 1, !tbaa !29
  %40 = sub <16 x i8> %34, %18
  %41 = sub <16 x i8> %35, %20
  %42 = add <16 x i8> %40, %37
  %43 = add <16 x i8> %41, %39
  %44 = add nuw i64 %33, 32
  %45 = icmp eq i64 %44, %16
  br i1 %45, label %46, label %32, !llvm.loop !124

46:                                               ; preds = %32
  %47 = add <16 x i8> %43, %42
  %48 = tail call i8 @llvm.vector.reduce.add.v16i8(<16 x i8> %47)
  br i1 %21, label %85, label %49

49:                                               ; preds = %46
  br i1 %23, label %65, label %50

50:                                               ; preds = %31, %49
  %51 = phi i8 [ 0, %31 ], [ %48, %49 ]
  %52 = phi i64 [ 0, %31 ], [ %16, %49 ]
  %53 = insertelement <8 x i8> <i8 poison, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0>, i8 %51, i64 0
  br label %54

54:                                               ; preds = %54, %50
  %55 = phi i64 [ %52, %50 ], [ %61, %54 ]
  %56 = phi <8 x i8> [ %53, %50 ], [ %60, %54 ]
  %57 = getelementptr inbounds i8, ptr %0, i64 %55
  %58 = load <8 x i8>, ptr %57, align 1, !tbaa !29
  %59 = sub <8 x i8> %56, %26
  %60 = add <8 x i8> %59, %58
  %61 = add nuw i64 %55, 8
  %62 = icmp eq i64 %61, %24
  br i1 %62, label %63, label %54, !llvm.loop !125

63:                                               ; preds = %54
  %64 = tail call i8 @llvm.vector.reduce.add.v8i8(<8 x i8> %60)
  br i1 %27, label %85, label %65

65:                                               ; preds = %28, %49, %63
  %66 = phi i64 [ 0, %28 ], [ %16, %49 ], [ %24, %63 ]
  %67 = phi i8 [ 0, %28 ], [ %48, %49 ], [ %64, %63 ]
  br label %76

68:                                               ; preds = %85
  %69 = load i32, ptr @current_test, align 4, !tbaa !9
  %70 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %69)
  %71 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %72

72:                                               ; preds = %68, %85
  %73 = phi i32 [ %71, %68 ], [ %29, %85 ]
  %74 = add nuw nsw i32 %30, 1
  %75 = icmp slt i32 %74, %73
  br i1 %75, label %28, label %110, !llvm.loop !126

76:                                               ; preds = %65, %76
  %77 = phi i64 [ %83, %76 ], [ %66, %65 ]
  %78 = phi i8 [ %82, %76 ], [ %67, %65 ]
  %79 = getelementptr inbounds i8, ptr %0, i64 %77
  %80 = load i8, ptr %79, align 1, !tbaa !29
  %81 = sub i8 %78, %2
  %82 = add i8 %81, %80
  %83 = add nuw nsw i64 %77, 1
  %84 = icmp eq i64 %83, %13
  br i1 %84, label %85, label %76, !llvm.loop !127

85:                                               ; preds = %76, %63, %46
  %86 = phi i8 [ %48, %46 ], [ %64, %63 ], [ %82, %76 ]
  %87 = load double, ptr @init_value, align 8, !tbaa !28
  %88 = fptoui double %87 to i8
  %89 = sub i8 %88, %2
  %90 = shl i8 %89, 6
  %91 = icmp eq i8 %90, %86
  br i1 %91, label %72, label %68

92:                                               ; preds = %10, %105
  %93 = phi i32 [ %106, %105 ], [ %6, %10 ]
  %94 = phi double [ %107, %105 ], [ %11, %10 ]
  %95 = phi i32 [ %108, %105 ], [ 0, %10 ]
  %96 = fptoui double %94 to i8
  %97 = sub i8 %96, %2
  %98 = and i8 %97, 3
  %99 = icmp eq i8 %98, 0
  br i1 %99, label %105, label %100

100:                                              ; preds = %92
  %101 = load i32, ptr @current_test, align 4, !tbaa !9
  %102 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %101)
  %103 = load double, ptr @init_value, align 8, !tbaa !28
  %104 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %105

105:                                              ; preds = %92, %100
  %106 = phi i32 [ %93, %92 ], [ %104, %100 ]
  %107 = phi double [ %94, %92 ], [ %103, %100 ]
  %108 = add nuw nsw i32 %95, 1
  %109 = icmp slt i32 %108, %106
  br i1 %109, label %92, label %110, !llvm.loop !126

110:                                              ; preds = %105, %72, %4
  %111 = tail call i64 @clock() #17
  store i64 %111, ptr @end_time, align 8, !tbaa !26
  %112 = load i64, ptr @start_time, align 8, !tbaa !26
  %113 = load ptr, ptr @results, align 8, !tbaa !5
  %114 = icmp eq ptr %113, null
  br i1 %114, label %115, label %117

115:                                              ; preds = %110
  %116 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %121

117:                                              ; preds = %110
  %118 = load i32, ptr @current_test, align 4, !tbaa !9
  %119 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %120 = icmp slt i32 %118, %119
  br i1 %120, label %133, label %121

121:                                              ; preds = %117, %115
  %122 = phi i32 [ %116, %115 ], [ %119, %117 ]
  %123 = add nsw i32 %122, 10
  store i32 %123, ptr @allocated_results, align 4, !tbaa !9
  %124 = sext i32 %123 to i64
  %125 = shl nsw i64 %124, 4
  %126 = tail call ptr @realloc(ptr noundef %113, i64 noundef %125) #14
  store ptr %126, ptr @results, align 8, !tbaa !5
  %127 = icmp eq ptr %126, null
  br i1 %127, label %130, label %128

128:                                              ; preds = %121
  %129 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %133

130:                                              ; preds = %121
  %131 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %132 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %131)
  tail call void @exit(i32 noundef -1) #15
  unreachable

133:                                              ; preds = %117, %128
  %134 = phi i32 [ %129, %128 ], [ %118, %117 ]
  %135 = phi ptr [ %126, %128 ], [ %113, %117 ]
  %136 = sub nsw i64 %111, %112
  %137 = sitofp i64 %136 to double
  %138 = fdiv double %137, 1.000000e+06
  %139 = sext i32 %134 to i64
  %140 = getelementptr inbounds %struct.one_result, ptr %135, i64 %139
  store double %138, ptr %140, align 8, !tbaa !11
  %141 = getelementptr inbounds %struct.one_result, ptr %135, i64 %139, i32 1
  store ptr %3, ptr %141, align 8, !tbaa !14
  %142 = add nsw i32 %134, 1
  store i32 %142, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Ih28custom_sub_multiple_variableIhEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i8 noundef zeroext %2, i8 noundef zeroext %3, i8 noundef zeroext %4, i8 noundef zeroext %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !26
  %9 = load i32, ptr @iterations, align 4, !tbaa !9
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %116

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  %13 = add i8 %3, %2
  %14 = add i8 %13, %4
  %15 = add i8 %14, %5
  br i1 %12, label %18, label %16

16:                                               ; preds = %11
  %17 = load double, ptr @init_value, align 8, !tbaa !28
  br label %98

18:                                               ; preds = %11
  %19 = zext i32 %1 to i64
  %20 = icmp ult i32 %1, 8
  %21 = icmp ult i32 %1, 32
  %22 = and i64 %19, 4294967264
  %23 = insertelement <16 x i8> poison, i8 %15, i64 0
  %24 = shufflevector <16 x i8> %23, <16 x i8> poison, <16 x i32> zeroinitializer
  %25 = insertelement <16 x i8> poison, i8 %15, i64 0
  %26 = shufflevector <16 x i8> %25, <16 x i8> poison, <16 x i32> zeroinitializer
  %27 = icmp eq i64 %22, %19
  %28 = and i64 %19, 24
  %29 = icmp eq i64 %28, 0
  %30 = and i64 %19, 4294967288
  %31 = insertelement <8 x i8> poison, i8 %15, i64 0
  %32 = shufflevector <8 x i8> %31, <8 x i8> poison, <8 x i32> zeroinitializer
  %33 = icmp eq i64 %30, %19
  br label %34

34:                                               ; preds = %18, %78
  %35 = phi i32 [ %79, %78 ], [ %9, %18 ]
  %36 = phi i32 [ %80, %78 ], [ 0, %18 ]
  br i1 %20, label %71, label %37

37:                                               ; preds = %34
  br i1 %21, label %56, label %38

38:                                               ; preds = %37, %38
  %39 = phi i64 [ %50, %38 ], [ 0, %37 ]
  %40 = phi <16 x i8> [ %48, %38 ], [ zeroinitializer, %37 ]
  %41 = phi <16 x i8> [ %49, %38 ], [ zeroinitializer, %37 ]
  %42 = getelementptr inbounds i8, ptr %0, i64 %39
  %43 = load <16 x i8>, ptr %42, align 1, !tbaa !29
  %44 = getelementptr inbounds i8, ptr %42, i64 16
  %45 = load <16 x i8>, ptr %44, align 1, !tbaa !29
  %46 = sub <16 x i8> %40, %24
  %47 = sub <16 x i8> %41, %26
  %48 = add <16 x i8> %46, %43
  %49 = add <16 x i8> %47, %45
  %50 = add nuw i64 %39, 32
  %51 = icmp eq i64 %50, %22
  br i1 %51, label %52, label %38, !llvm.loop !128

52:                                               ; preds = %38
  %53 = add <16 x i8> %49, %48
  %54 = tail call i8 @llvm.vector.reduce.add.v16i8(<16 x i8> %53)
  br i1 %27, label %91, label %55

55:                                               ; preds = %52
  br i1 %29, label %71, label %56

56:                                               ; preds = %37, %55
  %57 = phi i8 [ 0, %37 ], [ %54, %55 ]
  %58 = phi i64 [ 0, %37 ], [ %22, %55 ]
  %59 = insertelement <8 x i8> <i8 poison, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0>, i8 %57, i64 0
  br label %60

60:                                               ; preds = %60, %56
  %61 = phi i64 [ %58, %56 ], [ %67, %60 ]
  %62 = phi <8 x i8> [ %59, %56 ], [ %66, %60 ]
  %63 = getelementptr inbounds i8, ptr %0, i64 %61
  %64 = load <8 x i8>, ptr %63, align 1, !tbaa !29
  %65 = sub <8 x i8> %62, %32
  %66 = add <8 x i8> %65, %64
  %67 = add nuw i64 %61, 8
  %68 = icmp eq i64 %67, %30
  br i1 %68, label %69, label %60, !llvm.loop !129

69:                                               ; preds = %60
  %70 = tail call i8 @llvm.vector.reduce.add.v8i8(<8 x i8> %66)
  br i1 %33, label %91, label %71

71:                                               ; preds = %34, %55, %69
  %72 = phi i64 [ 0, %34 ], [ %22, %55 ], [ %30, %69 ]
  %73 = phi i8 [ 0, %34 ], [ %54, %55 ], [ %70, %69 ]
  br label %82

74:                                               ; preds = %91
  %75 = load i32, ptr @current_test, align 4, !tbaa !9
  %76 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %75)
  %77 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %78

78:                                               ; preds = %74, %91
  %79 = phi i32 [ %77, %74 ], [ %35, %91 ]
  %80 = add nuw nsw i32 %36, 1
  %81 = icmp slt i32 %80, %79
  br i1 %81, label %34, label %116, !llvm.loop !130

82:                                               ; preds = %71, %82
  %83 = phi i64 [ %89, %82 ], [ %72, %71 ]
  %84 = phi i8 [ %88, %82 ], [ %73, %71 ]
  %85 = getelementptr inbounds i8, ptr %0, i64 %83
  %86 = load i8, ptr %85, align 1, !tbaa !29
  %87 = sub i8 %84, %15
  %88 = add i8 %87, %86
  %89 = add nuw nsw i64 %83, 1
  %90 = icmp eq i64 %89, %19
  br i1 %90, label %91, label %82, !llvm.loop !131

91:                                               ; preds = %82, %69, %52
  %92 = phi i8 [ %54, %52 ], [ %70, %69 ], [ %88, %82 ]
  %93 = load double, ptr @init_value, align 8, !tbaa !28
  %94 = fptoui double %93 to i8
  %95 = sub i8 %94, %15
  %96 = shl i8 %95, 6
  %97 = icmp eq i8 %96, %92
  br i1 %97, label %78, label %74

98:                                               ; preds = %16, %111
  %99 = phi i32 [ %112, %111 ], [ %9, %16 ]
  %100 = phi double [ %113, %111 ], [ %17, %16 ]
  %101 = phi i32 [ %114, %111 ], [ 0, %16 ]
  %102 = fptoui double %100 to i8
  %103 = sub i8 %102, %15
  %104 = and i8 %103, 3
  %105 = icmp eq i8 %104, 0
  br i1 %105, label %111, label %106

106:                                              ; preds = %98
  %107 = load i32, ptr @current_test, align 4, !tbaa !9
  %108 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %107)
  %109 = load double, ptr @init_value, align 8, !tbaa !28
  %110 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %111

111:                                              ; preds = %98, %106
  %112 = phi i32 [ %99, %98 ], [ %110, %106 ]
  %113 = phi double [ %100, %98 ], [ %109, %106 ]
  %114 = add nuw nsw i32 %101, 1
  %115 = icmp slt i32 %114, %112
  br i1 %115, label %98, label %116, !llvm.loop !130

116:                                              ; preds = %111, %78, %7
  %117 = tail call i64 @clock() #17
  store i64 %117, ptr @end_time, align 8, !tbaa !26
  %118 = load i64, ptr @start_time, align 8, !tbaa !26
  %119 = load ptr, ptr @results, align 8, !tbaa !5
  %120 = icmp eq ptr %119, null
  br i1 %120, label %121, label %123

121:                                              ; preds = %116
  %122 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %127

123:                                              ; preds = %116
  %124 = load i32, ptr @current_test, align 4, !tbaa !9
  %125 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %126 = icmp slt i32 %124, %125
  br i1 %126, label %139, label %127

127:                                              ; preds = %123, %121
  %128 = phi i32 [ %122, %121 ], [ %125, %123 ]
  %129 = add nsw i32 %128, 10
  store i32 %129, ptr @allocated_results, align 4, !tbaa !9
  %130 = sext i32 %129 to i64
  %131 = shl nsw i64 %130, 4
  %132 = tail call ptr @realloc(ptr noundef %119, i64 noundef %131) #14
  store ptr %132, ptr @results, align 8, !tbaa !5
  %133 = icmp eq ptr %132, null
  br i1 %133, label %136, label %134

134:                                              ; preds = %127
  %135 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %139

136:                                              ; preds = %127
  %137 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %138 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %137)
  tail call void @exit(i32 noundef -1) #15
  unreachable

139:                                              ; preds = %123, %134
  %140 = phi i32 [ %135, %134 ], [ %124, %123 ]
  %141 = phi ptr [ %132, %134 ], [ %119, %123 ]
  %142 = sub nsw i64 %117, %118
  %143 = sitofp i64 %142 to double
  %144 = fdiv double %143, 1.000000e+06
  %145 = sext i32 %140 to i64
  %146 = getelementptr inbounds %struct.one_result, ptr %141, i64 %145
  store double %144, ptr %146, align 8, !tbaa !11
  %147 = getelementptr inbounds %struct.one_result, ptr %141, i64 %145, i32 1
  store ptr %6, ptr %147, align 8, !tbaa !14
  %148 = add nsw i32 %140, 1
  store i32 %148, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1Ih24custom_multiply_variableIhEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i8 noundef zeroext %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !26
  %6 = load i32, ptr @iterations, align 4, !tbaa !9
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %109

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  %10 = shl i8 %2, 6
  br i1 %9, label %13, label %11

11:                                               ; preds = %8
  %12 = load double, ptr @init_value, align 8, !tbaa !28
  br label %92

13:                                               ; preds = %8
  %14 = zext i32 %1 to i64
  %15 = icmp ult i32 %1, 8
  %16 = icmp ult i32 %1, 32
  %17 = and i64 %14, 4294967264
  %18 = insertelement <16 x i8> poison, i8 %2, i64 0
  %19 = shufflevector <16 x i8> %18, <16 x i8> poison, <16 x i32> zeroinitializer
  %20 = insertelement <16 x i8> poison, i8 %2, i64 0
  %21 = shufflevector <16 x i8> %20, <16 x i8> poison, <16 x i32> zeroinitializer
  %22 = icmp eq i64 %17, %14
  %23 = and i64 %14, 24
  %24 = icmp eq i64 %23, 0
  %25 = and i64 %14, 4294967288
  %26 = insertelement <8 x i8> poison, i8 %2, i64 0
  %27 = shufflevector <8 x i8> %26, <8 x i8> poison, <8 x i32> zeroinitializer
  %28 = icmp eq i64 %25, %14
  br label %29

29:                                               ; preds = %13, %73
  %30 = phi i32 [ %74, %73 ], [ %6, %13 ]
  %31 = phi i32 [ %75, %73 ], [ 0, %13 ]
  br i1 %15, label %66, label %32

32:                                               ; preds = %29
  br i1 %16, label %51, label %33

33:                                               ; preds = %32, %33
  %34 = phi i64 [ %45, %33 ], [ 0, %32 ]
  %35 = phi <16 x i8> [ %43, %33 ], [ zeroinitializer, %32 ]
  %36 = phi <16 x i8> [ %44, %33 ], [ zeroinitializer, %32 ]
  %37 = getelementptr inbounds i8, ptr %0, i64 %34
  %38 = load <16 x i8>, ptr %37, align 1, !tbaa !29
  %39 = getelementptr inbounds i8, ptr %37, i64 16
  %40 = load <16 x i8>, ptr %39, align 1, !tbaa !29
  %41 = mul <16 x i8> %38, %19
  %42 = mul <16 x i8> %40, %21
  %43 = add <16 x i8> %41, %35
  %44 = add <16 x i8> %42, %36
  %45 = add nuw i64 %34, 32
  %46 = icmp eq i64 %45, %17
  br i1 %46, label %47, label %33, !llvm.loop !132

47:                                               ; preds = %33
  %48 = add <16 x i8> %44, %43
  %49 = tail call i8 @llvm.vector.reduce.add.v16i8(<16 x i8> %48)
  br i1 %22, label %86, label %50

50:                                               ; preds = %47
  br i1 %24, label %66, label %51

51:                                               ; preds = %32, %50
  %52 = phi i8 [ 0, %32 ], [ %49, %50 ]
  %53 = phi i64 [ 0, %32 ], [ %17, %50 ]
  %54 = insertelement <8 x i8> <i8 poison, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0>, i8 %52, i64 0
  br label %55

55:                                               ; preds = %55, %51
  %56 = phi i64 [ %53, %51 ], [ %62, %55 ]
  %57 = phi <8 x i8> [ %54, %51 ], [ %61, %55 ]
  %58 = getelementptr inbounds i8, ptr %0, i64 %56
  %59 = load <8 x i8>, ptr %58, align 1, !tbaa !29
  %60 = mul <8 x i8> %59, %27
  %61 = add <8 x i8> %60, %57
  %62 = add nuw i64 %56, 8
  %63 = icmp eq i64 %62, %25
  br i1 %63, label %64, label %55, !llvm.loop !133

64:                                               ; preds = %55
  %65 = tail call i8 @llvm.vector.reduce.add.v8i8(<8 x i8> %61)
  br i1 %28, label %86, label %66

66:                                               ; preds = %29, %50, %64
  %67 = phi i64 [ 0, %29 ], [ %17, %50 ], [ %25, %64 ]
  %68 = phi i8 [ 0, %29 ], [ %49, %50 ], [ %65, %64 ]
  br label %77

69:                                               ; preds = %86
  %70 = load i32, ptr @current_test, align 4, !tbaa !9
  %71 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %70)
  %72 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %73

73:                                               ; preds = %69, %86
  %74 = phi i32 [ %72, %69 ], [ %30, %86 ]
  %75 = add nuw nsw i32 %31, 1
  %76 = icmp slt i32 %75, %74
  br i1 %76, label %29, label %109, !llvm.loop !134

77:                                               ; preds = %66, %77
  %78 = phi i64 [ %84, %77 ], [ %67, %66 ]
  %79 = phi i8 [ %83, %77 ], [ %68, %66 ]
  %80 = getelementptr inbounds i8, ptr %0, i64 %78
  %81 = load i8, ptr %80, align 1, !tbaa !29
  %82 = mul i8 %81, %2
  %83 = add i8 %82, %79
  %84 = add nuw nsw i64 %78, 1
  %85 = icmp eq i64 %84, %14
  br i1 %85, label %86, label %77, !llvm.loop !135

86:                                               ; preds = %77, %64, %47
  %87 = phi i8 [ %49, %47 ], [ %65, %64 ], [ %83, %77 ]
  %88 = load double, ptr @init_value, align 8, !tbaa !28
  %89 = fptoui double %88 to i8
  %90 = mul i8 %10, %89
  %91 = icmp eq i8 %90, %87
  br i1 %91, label %73, label %69

92:                                               ; preds = %11, %104
  %93 = phi i32 [ %105, %104 ], [ %6, %11 ]
  %94 = phi double [ %106, %104 ], [ %12, %11 ]
  %95 = phi i32 [ %107, %104 ], [ 0, %11 ]
  %96 = fptoui double %94 to i8
  %97 = mul i8 %10, %96
  %98 = icmp eq i8 %97, 0
  br i1 %98, label %104, label %99

99:                                               ; preds = %92
  %100 = load i32, ptr @current_test, align 4, !tbaa !9
  %101 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %100)
  %102 = load double, ptr @init_value, align 8, !tbaa !28
  %103 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %104

104:                                              ; preds = %92, %99
  %105 = phi i32 [ %93, %92 ], [ %103, %99 ]
  %106 = phi double [ %94, %92 ], [ %102, %99 ]
  %107 = add nuw nsw i32 %95, 1
  %108 = icmp slt i32 %107, %105
  br i1 %108, label %92, label %109, !llvm.loop !134

109:                                              ; preds = %104, %73, %4
  %110 = tail call i64 @clock() #17
  store i64 %110, ptr @end_time, align 8, !tbaa !26
  %111 = load i64, ptr @start_time, align 8, !tbaa !26
  %112 = load ptr, ptr @results, align 8, !tbaa !5
  %113 = icmp eq ptr %112, null
  br i1 %113, label %114, label %116

114:                                              ; preds = %109
  %115 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %120

116:                                              ; preds = %109
  %117 = load i32, ptr @current_test, align 4, !tbaa !9
  %118 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %119 = icmp slt i32 %117, %118
  br i1 %119, label %132, label %120

120:                                              ; preds = %116, %114
  %121 = phi i32 [ %115, %114 ], [ %118, %116 ]
  %122 = add nsw i32 %121, 10
  store i32 %122, ptr @allocated_results, align 4, !tbaa !9
  %123 = sext i32 %122 to i64
  %124 = shl nsw i64 %123, 4
  %125 = tail call ptr @realloc(ptr noundef %112, i64 noundef %124) #14
  store ptr %125, ptr @results, align 8, !tbaa !5
  %126 = icmp eq ptr %125, null
  br i1 %126, label %129, label %127

127:                                              ; preds = %120
  %128 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %132

129:                                              ; preds = %120
  %130 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %131 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %130)
  tail call void @exit(i32 noundef -1) #15
  unreachable

132:                                              ; preds = %116, %127
  %133 = phi i32 [ %128, %127 ], [ %117, %116 ]
  %134 = phi ptr [ %125, %127 ], [ %112, %116 ]
  %135 = sub nsw i64 %110, %111
  %136 = sitofp i64 %135 to double
  %137 = fdiv double %136, 1.000000e+06
  %138 = sext i32 %133 to i64
  %139 = getelementptr inbounds %struct.one_result, ptr %134, i64 %138
  store double %137, ptr %139, align 8, !tbaa !11
  %140 = getelementptr inbounds %struct.one_result, ptr %134, i64 %138, i32 1
  store ptr %3, ptr %140, align 8, !tbaa !14
  %141 = add nsw i32 %133, 1
  store i32 %141, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Ih33custom_multiply_multiple_variableIhEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i8 noundef zeroext %2, i8 noundef zeroext %3, i8 noundef zeroext %4, i8 noundef zeroext %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !26
  %9 = load i32, ptr @iterations, align 4, !tbaa !9
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %117

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  %13 = mul i8 %4, %3
  %14 = mul i8 %13, %2
  %15 = mul i8 %14, %5
  %16 = shl i8 %13, 6
  %17 = mul i8 %16, %2
  %18 = mul i8 %17, %5
  br i1 %12, label %21, label %19

19:                                               ; preds = %11
  %20 = load double, ptr @init_value, align 8, !tbaa !28
  br label %100

21:                                               ; preds = %11
  %22 = zext i32 %1 to i64
  %23 = icmp ult i32 %1, 8
  %24 = icmp ult i32 %1, 32
  %25 = and i64 %22, 4294967264
  %26 = insertelement <16 x i8> poison, i8 %15, i64 0
  %27 = shufflevector <16 x i8> %26, <16 x i8> poison, <16 x i32> zeroinitializer
  %28 = insertelement <16 x i8> poison, i8 %15, i64 0
  %29 = shufflevector <16 x i8> %28, <16 x i8> poison, <16 x i32> zeroinitializer
  %30 = icmp eq i64 %25, %22
  %31 = and i64 %22, 24
  %32 = icmp eq i64 %31, 0
  %33 = and i64 %22, 4294967288
  %34 = insertelement <8 x i8> poison, i8 %15, i64 0
  %35 = shufflevector <8 x i8> %34, <8 x i8> poison, <8 x i32> zeroinitializer
  %36 = icmp eq i64 %33, %22
  br label %37

37:                                               ; preds = %21, %81
  %38 = phi i32 [ %82, %81 ], [ %9, %21 ]
  %39 = phi i32 [ %83, %81 ], [ 0, %21 ]
  br i1 %23, label %74, label %40

40:                                               ; preds = %37
  br i1 %24, label %59, label %41

41:                                               ; preds = %40, %41
  %42 = phi i64 [ %53, %41 ], [ 0, %40 ]
  %43 = phi <16 x i8> [ %51, %41 ], [ zeroinitializer, %40 ]
  %44 = phi <16 x i8> [ %52, %41 ], [ zeroinitializer, %40 ]
  %45 = getelementptr inbounds i8, ptr %0, i64 %42
  %46 = load <16 x i8>, ptr %45, align 1, !tbaa !29
  %47 = getelementptr inbounds i8, ptr %45, i64 16
  %48 = load <16 x i8>, ptr %47, align 1, !tbaa !29
  %49 = mul <16 x i8> %27, %46
  %50 = mul <16 x i8> %29, %48
  %51 = add <16 x i8> %49, %43
  %52 = add <16 x i8> %50, %44
  %53 = add nuw i64 %42, 32
  %54 = icmp eq i64 %53, %25
  br i1 %54, label %55, label %41, !llvm.loop !136

55:                                               ; preds = %41
  %56 = add <16 x i8> %52, %51
  %57 = tail call i8 @llvm.vector.reduce.add.v16i8(<16 x i8> %56)
  br i1 %30, label %94, label %58

58:                                               ; preds = %55
  br i1 %32, label %74, label %59

59:                                               ; preds = %40, %58
  %60 = phi i8 [ 0, %40 ], [ %57, %58 ]
  %61 = phi i64 [ 0, %40 ], [ %25, %58 ]
  %62 = insertelement <8 x i8> <i8 poison, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0>, i8 %60, i64 0
  br label %63

63:                                               ; preds = %63, %59
  %64 = phi i64 [ %61, %59 ], [ %70, %63 ]
  %65 = phi <8 x i8> [ %62, %59 ], [ %69, %63 ]
  %66 = getelementptr inbounds i8, ptr %0, i64 %64
  %67 = load <8 x i8>, ptr %66, align 1, !tbaa !29
  %68 = mul <8 x i8> %35, %67
  %69 = add <8 x i8> %68, %65
  %70 = add nuw i64 %64, 8
  %71 = icmp eq i64 %70, %33
  br i1 %71, label %72, label %63, !llvm.loop !137

72:                                               ; preds = %63
  %73 = tail call i8 @llvm.vector.reduce.add.v8i8(<8 x i8> %69)
  br i1 %36, label %94, label %74

74:                                               ; preds = %37, %58, %72
  %75 = phi i64 [ 0, %37 ], [ %25, %58 ], [ %33, %72 ]
  %76 = phi i8 [ 0, %37 ], [ %57, %58 ], [ %73, %72 ]
  br label %85

77:                                               ; preds = %94
  %78 = load i32, ptr @current_test, align 4, !tbaa !9
  %79 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %78)
  %80 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %81

81:                                               ; preds = %77, %94
  %82 = phi i32 [ %80, %77 ], [ %38, %94 ]
  %83 = add nuw nsw i32 %39, 1
  %84 = icmp slt i32 %83, %82
  br i1 %84, label %37, label %117, !llvm.loop !138

85:                                               ; preds = %74, %85
  %86 = phi i64 [ %92, %85 ], [ %75, %74 ]
  %87 = phi i8 [ %91, %85 ], [ %76, %74 ]
  %88 = getelementptr inbounds i8, ptr %0, i64 %86
  %89 = load i8, ptr %88, align 1, !tbaa !29
  %90 = mul i8 %15, %89
  %91 = add i8 %90, %87
  %92 = add nuw nsw i64 %86, 1
  %93 = icmp eq i64 %92, %22
  br i1 %93, label %94, label %85, !llvm.loop !139

94:                                               ; preds = %85, %72, %55
  %95 = phi i8 [ %57, %55 ], [ %73, %72 ], [ %91, %85 ]
  %96 = load double, ptr @init_value, align 8, !tbaa !28
  %97 = fptoui double %96 to i8
  %98 = mul i8 %18, %97
  %99 = icmp eq i8 %98, %95
  br i1 %99, label %81, label %77

100:                                              ; preds = %19, %112
  %101 = phi i32 [ %113, %112 ], [ %9, %19 ]
  %102 = phi double [ %114, %112 ], [ %20, %19 ]
  %103 = phi i32 [ %115, %112 ], [ 0, %19 ]
  %104 = fptoui double %102 to i8
  %105 = mul i8 %18, %104
  %106 = icmp eq i8 %105, 0
  br i1 %106, label %112, label %107

107:                                              ; preds = %100
  %108 = load i32, ptr @current_test, align 4, !tbaa !9
  %109 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %108)
  %110 = load double, ptr @init_value, align 8, !tbaa !28
  %111 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %112

112:                                              ; preds = %100, %107
  %113 = phi i32 [ %101, %100 ], [ %111, %107 ]
  %114 = phi double [ %102, %100 ], [ %110, %107 ]
  %115 = add nuw nsw i32 %103, 1
  %116 = icmp slt i32 %115, %113
  br i1 %116, label %100, label %117, !llvm.loop !138

117:                                              ; preds = %112, %81, %7
  %118 = tail call i64 @clock() #17
  store i64 %118, ptr @end_time, align 8, !tbaa !26
  %119 = load i64, ptr @start_time, align 8, !tbaa !26
  %120 = load ptr, ptr @results, align 8, !tbaa !5
  %121 = icmp eq ptr %120, null
  br i1 %121, label %122, label %124

122:                                              ; preds = %117
  %123 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %128

124:                                              ; preds = %117
  %125 = load i32, ptr @current_test, align 4, !tbaa !9
  %126 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %127 = icmp slt i32 %125, %126
  br i1 %127, label %140, label %128

128:                                              ; preds = %124, %122
  %129 = phi i32 [ %123, %122 ], [ %126, %124 ]
  %130 = add nsw i32 %129, 10
  store i32 %130, ptr @allocated_results, align 4, !tbaa !9
  %131 = sext i32 %130 to i64
  %132 = shl nsw i64 %131, 4
  %133 = tail call ptr @realloc(ptr noundef %120, i64 noundef %132) #14
  store ptr %133, ptr @results, align 8, !tbaa !5
  %134 = icmp eq ptr %133, null
  br i1 %134, label %137, label %135

135:                                              ; preds = %128
  %136 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %140

137:                                              ; preds = %128
  %138 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %139 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %138)
  tail call void @exit(i32 noundef -1) #15
  unreachable

140:                                              ; preds = %124, %135
  %141 = phi i32 [ %136, %135 ], [ %125, %124 ]
  %142 = phi ptr [ %133, %135 ], [ %120, %124 ]
  %143 = sub nsw i64 %118, %119
  %144 = sitofp i64 %143 to double
  %145 = fdiv double %144, 1.000000e+06
  %146 = sext i32 %141 to i64
  %147 = getelementptr inbounds %struct.one_result, ptr %142, i64 %146
  store double %145, ptr %147, align 8, !tbaa !11
  %148 = getelementptr inbounds %struct.one_result, ptr %142, i64 %146, i32 1
  store ptr %6, ptr %148, align 8, !tbaa !14
  %149 = add nsw i32 %141, 1
  store i32 %149, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Ih34custom_multiply_multiple_variable2IhEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i8 noundef zeroext %2, i8 noundef zeroext %3, i8 noundef zeroext %4, i8 noundef zeroext %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !26
  %9 = load i32, ptr @iterations, align 4, !tbaa !9
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %116

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  %13 = mul i8 %3, %2
  %14 = mul i8 %13, %4
  %15 = mul i8 %14, %5
  br i1 %12, label %18, label %16

16:                                               ; preds = %11
  %17 = load double, ptr @init_value, align 8, !tbaa !28
  br label %98

18:                                               ; preds = %11
  %19 = zext i32 %1 to i64
  %20 = icmp ult i32 %1, 8
  %21 = icmp ult i32 %1, 32
  %22 = and i64 %19, 4294967264
  %23 = insertelement <16 x i8> poison, i8 %15, i64 0
  %24 = shufflevector <16 x i8> %23, <16 x i8> poison, <16 x i32> zeroinitializer
  %25 = insertelement <16 x i8> poison, i8 %15, i64 0
  %26 = shufflevector <16 x i8> %25, <16 x i8> poison, <16 x i32> zeroinitializer
  %27 = icmp eq i64 %22, %19
  %28 = and i64 %19, 24
  %29 = icmp eq i64 %28, 0
  %30 = and i64 %19, 4294967288
  %31 = insertelement <8 x i8> poison, i8 %15, i64 0
  %32 = shufflevector <8 x i8> %31, <8 x i8> poison, <8 x i32> zeroinitializer
  %33 = icmp eq i64 %30, %19
  br label %34

34:                                               ; preds = %18, %78
  %35 = phi i32 [ %79, %78 ], [ %9, %18 ]
  %36 = phi i32 [ %80, %78 ], [ 0, %18 ]
  br i1 %20, label %71, label %37

37:                                               ; preds = %34
  br i1 %21, label %56, label %38

38:                                               ; preds = %37, %38
  %39 = phi i64 [ %50, %38 ], [ 0, %37 ]
  %40 = phi <16 x i8> [ %48, %38 ], [ zeroinitializer, %37 ]
  %41 = phi <16 x i8> [ %49, %38 ], [ zeroinitializer, %37 ]
  %42 = getelementptr inbounds i8, ptr %0, i64 %39
  %43 = load <16 x i8>, ptr %42, align 1, !tbaa !29
  %44 = getelementptr inbounds i8, ptr %42, i64 16
  %45 = load <16 x i8>, ptr %44, align 1, !tbaa !29
  %46 = add <16 x i8> %40, %24
  %47 = add <16 x i8> %41, %26
  %48 = add <16 x i8> %46, %43
  %49 = add <16 x i8> %47, %45
  %50 = add nuw i64 %39, 32
  %51 = icmp eq i64 %50, %22
  br i1 %51, label %52, label %38, !llvm.loop !140

52:                                               ; preds = %38
  %53 = add <16 x i8> %49, %48
  %54 = tail call i8 @llvm.vector.reduce.add.v16i8(<16 x i8> %53)
  br i1 %27, label %91, label %55

55:                                               ; preds = %52
  br i1 %29, label %71, label %56

56:                                               ; preds = %37, %55
  %57 = phi i8 [ 0, %37 ], [ %54, %55 ]
  %58 = phi i64 [ 0, %37 ], [ %22, %55 ]
  %59 = insertelement <8 x i8> <i8 poison, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0>, i8 %57, i64 0
  br label %60

60:                                               ; preds = %60, %56
  %61 = phi i64 [ %58, %56 ], [ %67, %60 ]
  %62 = phi <8 x i8> [ %59, %56 ], [ %66, %60 ]
  %63 = getelementptr inbounds i8, ptr %0, i64 %61
  %64 = load <8 x i8>, ptr %63, align 1, !tbaa !29
  %65 = add <8 x i8> %62, %32
  %66 = add <8 x i8> %65, %64
  %67 = add nuw i64 %61, 8
  %68 = icmp eq i64 %67, %30
  br i1 %68, label %69, label %60, !llvm.loop !141

69:                                               ; preds = %60
  %70 = tail call i8 @llvm.vector.reduce.add.v8i8(<8 x i8> %66)
  br i1 %33, label %91, label %71

71:                                               ; preds = %34, %55, %69
  %72 = phi i64 [ 0, %34 ], [ %22, %55 ], [ %30, %69 ]
  %73 = phi i8 [ 0, %34 ], [ %54, %55 ], [ %70, %69 ]
  br label %82

74:                                               ; preds = %91
  %75 = load i32, ptr @current_test, align 4, !tbaa !9
  %76 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %75)
  %77 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %78

78:                                               ; preds = %74, %91
  %79 = phi i32 [ %77, %74 ], [ %35, %91 ]
  %80 = add nuw nsw i32 %36, 1
  %81 = icmp slt i32 %80, %79
  br i1 %81, label %34, label %116, !llvm.loop !142

82:                                               ; preds = %71, %82
  %83 = phi i64 [ %89, %82 ], [ %72, %71 ]
  %84 = phi i8 [ %88, %82 ], [ %73, %71 ]
  %85 = getelementptr inbounds i8, ptr %0, i64 %83
  %86 = load i8, ptr %85, align 1, !tbaa !29
  %87 = add i8 %84, %15
  %88 = add i8 %87, %86
  %89 = add nuw nsw i64 %83, 1
  %90 = icmp eq i64 %89, %19
  br i1 %90, label %91, label %82, !llvm.loop !143

91:                                               ; preds = %82, %69, %52
  %92 = phi i8 [ %54, %52 ], [ %70, %69 ], [ %88, %82 ]
  %93 = load double, ptr @init_value, align 8, !tbaa !28
  %94 = fptoui double %93 to i8
  %95 = add i8 %15, %94
  %96 = shl i8 %95, 6
  %97 = icmp eq i8 %96, %92
  br i1 %97, label %78, label %74

98:                                               ; preds = %16, %111
  %99 = phi i32 [ %112, %111 ], [ %9, %16 ]
  %100 = phi double [ %113, %111 ], [ %17, %16 ]
  %101 = phi i32 [ %114, %111 ], [ 0, %16 ]
  %102 = fptoui double %100 to i8
  %103 = add i8 %15, %102
  %104 = and i8 %103, 3
  %105 = icmp eq i8 %104, 0
  br i1 %105, label %111, label %106

106:                                              ; preds = %98
  %107 = load i32, ptr @current_test, align 4, !tbaa !9
  %108 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %107)
  %109 = load double, ptr @init_value, align 8, !tbaa !28
  %110 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %111

111:                                              ; preds = %98, %106
  %112 = phi i32 [ %99, %98 ], [ %110, %106 ]
  %113 = phi double [ %100, %98 ], [ %109, %106 ]
  %114 = add nuw nsw i32 %101, 1
  %115 = icmp slt i32 %114, %112
  br i1 %115, label %98, label %116, !llvm.loop !142

116:                                              ; preds = %111, %78, %7
  %117 = tail call i64 @clock() #17
  store i64 %117, ptr @end_time, align 8, !tbaa !26
  %118 = load i64, ptr @start_time, align 8, !tbaa !26
  %119 = load ptr, ptr @results, align 8, !tbaa !5
  %120 = icmp eq ptr %119, null
  br i1 %120, label %121, label %123

121:                                              ; preds = %116
  %122 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %127

123:                                              ; preds = %116
  %124 = load i32, ptr @current_test, align 4, !tbaa !9
  %125 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %126 = icmp slt i32 %124, %125
  br i1 %126, label %139, label %127

127:                                              ; preds = %123, %121
  %128 = phi i32 [ %122, %121 ], [ %125, %123 ]
  %129 = add nsw i32 %128, 10
  store i32 %129, ptr @allocated_results, align 4, !tbaa !9
  %130 = sext i32 %129 to i64
  %131 = shl nsw i64 %130, 4
  %132 = tail call ptr @realloc(ptr noundef %119, i64 noundef %131) #14
  store ptr %132, ptr @results, align 8, !tbaa !5
  %133 = icmp eq ptr %132, null
  br i1 %133, label %136, label %134

134:                                              ; preds = %127
  %135 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %139

136:                                              ; preds = %127
  %137 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %138 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %137)
  tail call void @exit(i32 noundef -1) #15
  unreachable

139:                                              ; preds = %123, %134
  %140 = phi i32 [ %135, %134 ], [ %124, %123 ]
  %141 = phi ptr [ %132, %134 ], [ %119, %123 ]
  %142 = sub nsw i64 %117, %118
  %143 = sitofp i64 %142 to double
  %144 = fdiv double %143, 1.000000e+06
  %145 = sext i32 %140 to i64
  %146 = getelementptr inbounds %struct.one_result, ptr %141, i64 %145
  store double %144, ptr %146, align 8, !tbaa !11
  %147 = getelementptr inbounds %struct.one_result, ptr %141, i64 %145, i32 1
  store ptr %6, ptr %147, align 8, !tbaa !14
  %148 = add nsw i32 %140, 1
  store i32 %148, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1Ih22custom_divide_variableIhEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i8 noundef zeroext %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !26
  %6 = load i32, ptr @iterations, align 4, !tbaa !9
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %79

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  br i1 %9, label %12, label %10

10:                                               ; preds = %8
  %11 = load double, ptr @init_value, align 8, !tbaa !28
  br label %61

12:                                               ; preds = %8
  %13 = zext i32 %1 to i64
  %14 = and i64 %13, 1
  %15 = icmp eq i32 %1, 1
  %16 = and i64 %13, 4294967294
  %17 = icmp eq i64 %14, 0
  br label %18

18:                                               ; preds = %12, %25
  %19 = phi i32 [ %26, %25 ], [ %6, %12 ]
  %20 = phi i32 [ %27, %25 ], [ 0, %12 ]
  br i1 %15, label %45, label %29

21:                                               ; preds = %54
  %22 = load i32, ptr @current_test, align 4, !tbaa !9
  %23 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %22)
  %24 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %25

25:                                               ; preds = %21, %54
  %26 = phi i32 [ %24, %21 ], [ %19, %54 ]
  %27 = add nuw nsw i32 %20, 1
  %28 = icmp slt i32 %27, %26
  br i1 %28, label %18, label %79, !llvm.loop !144

29:                                               ; preds = %18, %29
  %30 = phi i64 [ %42, %29 ], [ 0, %18 ]
  %31 = phi i8 [ %41, %29 ], [ 0, %18 ]
  %32 = phi i64 [ %43, %29 ], [ 0, %18 ]
  %33 = getelementptr inbounds i8, ptr %0, i64 %30
  %34 = load i8, ptr %33, align 1, !tbaa !29
  %35 = udiv i8 %34, %2
  %36 = add i8 %35, %31
  %37 = or i64 %30, 1
  %38 = getelementptr inbounds i8, ptr %0, i64 %37
  %39 = load i8, ptr %38, align 1, !tbaa !29
  %40 = udiv i8 %39, %2
  %41 = add i8 %40, %36
  %42 = add nuw nsw i64 %30, 2
  %43 = add i64 %32, 2
  %44 = icmp eq i64 %43, %16
  br i1 %44, label %45, label %29, !llvm.loop !145

45:                                               ; preds = %29, %18
  %46 = phi i8 [ undef, %18 ], [ %41, %29 ]
  %47 = phi i64 [ 0, %18 ], [ %42, %29 ]
  %48 = phi i8 [ 0, %18 ], [ %41, %29 ]
  br i1 %17, label %54, label %49

49:                                               ; preds = %45
  %50 = getelementptr inbounds i8, ptr %0, i64 %47
  %51 = load i8, ptr %50, align 1, !tbaa !29
  %52 = udiv i8 %51, %2
  %53 = add i8 %52, %48
  br label %54

54:                                               ; preds = %45, %49
  %55 = phi i8 [ %46, %45 ], [ %53, %49 ]
  %56 = load double, ptr @init_value, align 8, !tbaa !28
  %57 = fptoui double %56 to i8
  %58 = udiv i8 %57, %2
  %59 = shl i8 %58, 6
  %60 = icmp eq i8 %59, %55
  br i1 %60, label %25, label %21

61:                                               ; preds = %10, %74
  %62 = phi i32 [ %75, %74 ], [ %6, %10 ]
  %63 = phi double [ %76, %74 ], [ %11, %10 ]
  %64 = phi i32 [ %77, %74 ], [ 0, %10 ]
  %65 = fptoui double %63 to i8
  %66 = udiv i8 %65, %2
  %67 = and i8 %66, 3
  %68 = icmp eq i8 %67, 0
  br i1 %68, label %74, label %69

69:                                               ; preds = %61
  %70 = load i32, ptr @current_test, align 4, !tbaa !9
  %71 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %70)
  %72 = load double, ptr @init_value, align 8, !tbaa !28
  %73 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %74

74:                                               ; preds = %61, %69
  %75 = phi i32 [ %62, %61 ], [ %73, %69 ]
  %76 = phi double [ %63, %61 ], [ %72, %69 ]
  %77 = add nuw nsw i32 %64, 1
  %78 = icmp slt i32 %77, %75
  br i1 %78, label %61, label %79, !llvm.loop !144

79:                                               ; preds = %74, %25, %4
  %80 = tail call i64 @clock() #17
  store i64 %80, ptr @end_time, align 8, !tbaa !26
  %81 = load i64, ptr @start_time, align 8, !tbaa !26
  %82 = load ptr, ptr @results, align 8, !tbaa !5
  %83 = icmp eq ptr %82, null
  br i1 %83, label %84, label %86

84:                                               ; preds = %79
  %85 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %90

86:                                               ; preds = %79
  %87 = load i32, ptr @current_test, align 4, !tbaa !9
  %88 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %89 = icmp slt i32 %87, %88
  br i1 %89, label %102, label %90

90:                                               ; preds = %86, %84
  %91 = phi i32 [ %85, %84 ], [ %88, %86 ]
  %92 = add nsw i32 %91, 10
  store i32 %92, ptr @allocated_results, align 4, !tbaa !9
  %93 = sext i32 %92 to i64
  %94 = shl nsw i64 %93, 4
  %95 = tail call ptr @realloc(ptr noundef %82, i64 noundef %94) #14
  store ptr %95, ptr @results, align 8, !tbaa !5
  %96 = icmp eq ptr %95, null
  br i1 %96, label %99, label %97

97:                                               ; preds = %90
  %98 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %102

99:                                               ; preds = %90
  %100 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %101 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %100)
  tail call void @exit(i32 noundef -1) #15
  unreachable

102:                                              ; preds = %86, %97
  %103 = phi i32 [ %98, %97 ], [ %87, %86 ]
  %104 = phi ptr [ %95, %97 ], [ %82, %86 ]
  %105 = sub nsw i64 %80, %81
  %106 = sitofp i64 %105 to double
  %107 = fdiv double %106, 1.000000e+06
  %108 = sext i32 %103 to i64
  %109 = getelementptr inbounds %struct.one_result, ptr %104, i64 %108
  store double %107, ptr %109, align 8, !tbaa !11
  %110 = getelementptr inbounds %struct.one_result, ptr %104, i64 %108, i32 1
  store ptr %3, ptr %110, align 8, !tbaa !14
  %111 = add nsw i32 %103, 1
  store i32 %111, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Ih31custom_divide_multiple_variableIhEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i8 noundef zeroext %2, i8 noundef zeroext %3, i8 noundef zeroext %4, i8 noundef zeroext %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !26
  %9 = load i32, ptr @iterations, align 4, !tbaa !9
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %70

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  br i1 %12, label %15, label %13

13:                                               ; preds = %11
  %14 = load double, ptr @init_value, align 8, !tbaa !28
  br label %49

15:                                               ; preds = %11
  %16 = zext i32 %1 to i64
  br label %17

17:                                               ; preds = %15, %24
  %18 = phi i32 [ %25, %24 ], [ %9, %15 ]
  %19 = phi i32 [ %26, %24 ], [ 0, %15 ]
  br label %28

20:                                               ; preds = %40
  %21 = load i32, ptr @current_test, align 4, !tbaa !9
  %22 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %21)
  %23 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %24

24:                                               ; preds = %20, %40
  %25 = phi i32 [ %23, %20 ], [ %18, %40 ]
  %26 = add nuw nsw i32 %19, 1
  %27 = icmp slt i32 %26, %25
  br i1 %27, label %17, label %70, !llvm.loop !146

28:                                               ; preds = %17, %28
  %29 = phi i64 [ 0, %17 ], [ %38, %28 ]
  %30 = phi i8 [ 0, %17 ], [ %37, %28 ]
  %31 = getelementptr inbounds i8, ptr %0, i64 %29
  %32 = load i8, ptr %31, align 1, !tbaa !29
  %33 = udiv i8 %32, %2
  %34 = udiv i8 %33, %3
  %35 = udiv i8 %34, %4
  %36 = udiv i8 %35, %5
  %37 = add i8 %36, %30
  %38 = add nuw nsw i64 %29, 1
  %39 = icmp eq i64 %38, %16
  br i1 %39, label %40, label %28, !llvm.loop !147

40:                                               ; preds = %28
  %41 = load double, ptr @init_value, align 8, !tbaa !28
  %42 = fptoui double %41 to i8
  %43 = udiv i8 %42, %2
  %44 = udiv i8 %43, %3
  %45 = udiv i8 %44, %4
  %46 = udiv i8 %45, %5
  %47 = shl i8 %46, 6
  %48 = icmp eq i8 %47, %37
  br i1 %48, label %24, label %20

49:                                               ; preds = %13, %65
  %50 = phi i32 [ %66, %65 ], [ %9, %13 ]
  %51 = phi double [ %67, %65 ], [ %14, %13 ]
  %52 = phi i32 [ %68, %65 ], [ 0, %13 ]
  %53 = fptoui double %51 to i8
  %54 = udiv i8 %53, %2
  %55 = udiv i8 %54, %3
  %56 = udiv i8 %55, %4
  %57 = udiv i8 %56, %5
  %58 = and i8 %57, 3
  %59 = icmp eq i8 %58, 0
  br i1 %59, label %65, label %60

60:                                               ; preds = %49
  %61 = load i32, ptr @current_test, align 4, !tbaa !9
  %62 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %61)
  %63 = load double, ptr @init_value, align 8, !tbaa !28
  %64 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %65

65:                                               ; preds = %49, %60
  %66 = phi i32 [ %50, %49 ], [ %64, %60 ]
  %67 = phi double [ %51, %49 ], [ %63, %60 ]
  %68 = add nuw nsw i32 %52, 1
  %69 = icmp slt i32 %68, %66
  br i1 %69, label %49, label %70, !llvm.loop !146

70:                                               ; preds = %65, %24, %7
  %71 = tail call i64 @clock() #17
  store i64 %71, ptr @end_time, align 8, !tbaa !26
  %72 = load i64, ptr @start_time, align 8, !tbaa !26
  %73 = load ptr, ptr @results, align 8, !tbaa !5
  %74 = icmp eq ptr %73, null
  br i1 %74, label %75, label %77

75:                                               ; preds = %70
  %76 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %81

77:                                               ; preds = %70
  %78 = load i32, ptr @current_test, align 4, !tbaa !9
  %79 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %80 = icmp slt i32 %78, %79
  br i1 %80, label %93, label %81

81:                                               ; preds = %77, %75
  %82 = phi i32 [ %76, %75 ], [ %79, %77 ]
  %83 = add nsw i32 %82, 10
  store i32 %83, ptr @allocated_results, align 4, !tbaa !9
  %84 = sext i32 %83 to i64
  %85 = shl nsw i64 %84, 4
  %86 = tail call ptr @realloc(ptr noundef %73, i64 noundef %85) #14
  store ptr %86, ptr @results, align 8, !tbaa !5
  %87 = icmp eq ptr %86, null
  br i1 %87, label %90, label %88

88:                                               ; preds = %81
  %89 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %93

90:                                               ; preds = %81
  %91 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %92 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %91)
  tail call void @exit(i32 noundef -1) #15
  unreachable

93:                                               ; preds = %77, %88
  %94 = phi i32 [ %89, %88 ], [ %78, %77 ]
  %95 = phi ptr [ %86, %88 ], [ %73, %77 ]
  %96 = sub nsw i64 %71, %72
  %97 = sitofp i64 %96 to double
  %98 = fdiv double %97, 1.000000e+06
  %99 = sext i32 %94 to i64
  %100 = getelementptr inbounds %struct.one_result, ptr %95, i64 %99
  store double %98, ptr %100, align 8, !tbaa !11
  %101 = getelementptr inbounds %struct.one_result, ptr %95, i64 %99, i32 1
  store ptr %6, ptr %101, align 8, !tbaa !14
  %102 = add nsw i32 %94, 1
  store i32 %102, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Ih32custom_divide_multiple_variable2IhEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i8 noundef zeroext %2, i8 noundef zeroext %3, i8 noundef zeroext %4, i8 noundef zeroext %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !26
  %9 = load i32, ptr @iterations, align 4, !tbaa !9
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %116

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  %13 = udiv i8 %2, %3
  %14 = udiv i8 %13, %4
  %15 = udiv i8 %14, %5
  br i1 %12, label %18, label %16

16:                                               ; preds = %11
  %17 = load double, ptr @init_value, align 8, !tbaa !28
  br label %98

18:                                               ; preds = %11
  %19 = zext i32 %1 to i64
  %20 = icmp ult i32 %1, 8
  %21 = icmp ult i32 %1, 32
  %22 = and i64 %19, 4294967264
  %23 = insertelement <16 x i8> poison, i8 %15, i64 0
  %24 = shufflevector <16 x i8> %23, <16 x i8> poison, <16 x i32> zeroinitializer
  %25 = insertelement <16 x i8> poison, i8 %15, i64 0
  %26 = shufflevector <16 x i8> %25, <16 x i8> poison, <16 x i32> zeroinitializer
  %27 = icmp eq i64 %22, %19
  %28 = and i64 %19, 24
  %29 = icmp eq i64 %28, 0
  %30 = and i64 %19, 4294967288
  %31 = insertelement <8 x i8> poison, i8 %15, i64 0
  %32 = shufflevector <8 x i8> %31, <8 x i8> poison, <8 x i32> zeroinitializer
  %33 = icmp eq i64 %30, %19
  br label %34

34:                                               ; preds = %78, %18
  %35 = phi i32 [ %9, %18 ], [ %79, %78 ]
  %36 = phi i32 [ 0, %18 ], [ %80, %78 ]
  br i1 %20, label %71, label %37

37:                                               ; preds = %34
  br i1 %21, label %56, label %38

38:                                               ; preds = %37, %38
  %39 = phi i64 [ %50, %38 ], [ 0, %37 ]
  %40 = phi <16 x i8> [ %48, %38 ], [ zeroinitializer, %37 ]
  %41 = phi <16 x i8> [ %49, %38 ], [ zeroinitializer, %37 ]
  %42 = getelementptr inbounds i8, ptr %0, i64 %39
  %43 = load <16 x i8>, ptr %42, align 1, !tbaa !29
  %44 = getelementptr inbounds i8, ptr %42, i64 16
  %45 = load <16 x i8>, ptr %44, align 1, !tbaa !29
  %46 = add <16 x i8> %43, %40
  %47 = add <16 x i8> %45, %41
  %48 = add <16 x i8> %46, %24
  %49 = add <16 x i8> %47, %26
  %50 = add nuw i64 %39, 32
  %51 = icmp eq i64 %50, %22
  br i1 %51, label %52, label %38, !llvm.loop !148

52:                                               ; preds = %38
  %53 = add <16 x i8> %49, %48
  %54 = tail call i8 @llvm.vector.reduce.add.v16i8(<16 x i8> %53)
  br i1 %27, label %91, label %55

55:                                               ; preds = %52
  br i1 %29, label %71, label %56

56:                                               ; preds = %37, %55
  %57 = phi i8 [ 0, %37 ], [ %54, %55 ]
  %58 = phi i64 [ 0, %37 ], [ %22, %55 ]
  %59 = insertelement <8 x i8> <i8 poison, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0>, i8 %57, i64 0
  br label %60

60:                                               ; preds = %60, %56
  %61 = phi i64 [ %58, %56 ], [ %67, %60 ]
  %62 = phi <8 x i8> [ %59, %56 ], [ %66, %60 ]
  %63 = getelementptr inbounds i8, ptr %0, i64 %61
  %64 = load <8 x i8>, ptr %63, align 1, !tbaa !29
  %65 = add <8 x i8> %64, %62
  %66 = add <8 x i8> %65, %32
  %67 = add nuw i64 %61, 8
  %68 = icmp eq i64 %67, %30
  br i1 %68, label %69, label %60, !llvm.loop !149

69:                                               ; preds = %60
  %70 = tail call i8 @llvm.vector.reduce.add.v8i8(<8 x i8> %66)
  br i1 %33, label %91, label %71

71:                                               ; preds = %34, %55, %69
  %72 = phi i64 [ 0, %34 ], [ %22, %55 ], [ %30, %69 ]
  %73 = phi i8 [ 0, %34 ], [ %54, %55 ], [ %70, %69 ]
  br label %82

74:                                               ; preds = %91
  %75 = load i32, ptr @current_test, align 4, !tbaa !9
  %76 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %75)
  %77 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %78

78:                                               ; preds = %74, %91
  %79 = phi i32 [ %77, %74 ], [ %35, %91 ]
  %80 = add nuw nsw i32 %36, 1
  %81 = icmp slt i32 %80, %79
  br i1 %81, label %34, label %116, !llvm.loop !150

82:                                               ; preds = %71, %82
  %83 = phi i64 [ %89, %82 ], [ %72, %71 ]
  %84 = phi i8 [ %88, %82 ], [ %73, %71 ]
  %85 = getelementptr inbounds i8, ptr %0, i64 %83
  %86 = load i8, ptr %85, align 1, !tbaa !29
  %87 = add i8 %86, %84
  %88 = add i8 %87, %15
  %89 = add nuw nsw i64 %83, 1
  %90 = icmp eq i64 %89, %19
  br i1 %90, label %91, label %82, !llvm.loop !151

91:                                               ; preds = %82, %69, %52
  %92 = phi i8 [ %54, %52 ], [ %70, %69 ], [ %88, %82 ]
  %93 = load double, ptr @init_value, align 8, !tbaa !28
  %94 = fptoui double %93 to i8
  %95 = add i8 %15, %94
  %96 = shl i8 %95, 6
  %97 = icmp eq i8 %96, %92
  br i1 %97, label %78, label %74

98:                                               ; preds = %16, %111
  %99 = phi i32 [ %112, %111 ], [ %9, %16 ]
  %100 = phi double [ %113, %111 ], [ %17, %16 ]
  %101 = phi i32 [ %114, %111 ], [ 0, %16 ]
  %102 = fptoui double %100 to i8
  %103 = add i8 %15, %102
  %104 = and i8 %103, 3
  %105 = icmp eq i8 %104, 0
  br i1 %105, label %111, label %106

106:                                              ; preds = %98
  %107 = load i32, ptr @current_test, align 4, !tbaa !9
  %108 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %107)
  %109 = load double, ptr @init_value, align 8, !tbaa !28
  %110 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %111

111:                                              ; preds = %98, %106
  %112 = phi i32 [ %99, %98 ], [ %110, %106 ]
  %113 = phi double [ %100, %98 ], [ %109, %106 ]
  %114 = add nuw nsw i32 %101, 1
  %115 = icmp slt i32 %114, %112
  br i1 %115, label %98, label %116, !llvm.loop !150

116:                                              ; preds = %111, %78, %7
  %117 = tail call i64 @clock() #17
  store i64 %117, ptr @end_time, align 8, !tbaa !26
  %118 = load i64, ptr @start_time, align 8, !tbaa !26
  %119 = load ptr, ptr @results, align 8, !tbaa !5
  %120 = icmp eq ptr %119, null
  br i1 %120, label %121, label %123

121:                                              ; preds = %116
  %122 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %127

123:                                              ; preds = %116
  %124 = load i32, ptr @current_test, align 4, !tbaa !9
  %125 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %126 = icmp slt i32 %124, %125
  br i1 %126, label %139, label %127

127:                                              ; preds = %123, %121
  %128 = phi i32 [ %122, %121 ], [ %125, %123 ]
  %129 = add nsw i32 %128, 10
  store i32 %129, ptr @allocated_results, align 4, !tbaa !9
  %130 = sext i32 %129 to i64
  %131 = shl nsw i64 %130, 4
  %132 = tail call ptr @realloc(ptr noundef %119, i64 noundef %131) #14
  store ptr %132, ptr @results, align 8, !tbaa !5
  %133 = icmp eq ptr %132, null
  br i1 %133, label %136, label %134

134:                                              ; preds = %127
  %135 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %139

136:                                              ; preds = %127
  %137 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %138 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %137)
  tail call void @exit(i32 noundef -1) #15
  unreachable

139:                                              ; preds = %123, %134
  %140 = phi i32 [ %135, %134 ], [ %124, %123 ]
  %141 = phi ptr [ %132, %134 ], [ %119, %123 ]
  %142 = sub nsw i64 %117, %118
  %143 = sitofp i64 %142 to double
  %144 = fdiv double %143, 1.000000e+06
  %145 = sext i32 %140 to i64
  %146 = getelementptr inbounds %struct.one_result, ptr %141, i64 %145
  store double %144, ptr %146, align 8, !tbaa !11
  %147 = getelementptr inbounds %struct.one_result, ptr %141, i64 %145, i32 1
  store ptr %6, ptr %147, align 8, !tbaa !14
  %148 = add nsw i32 %140, 1
  store i32 %148, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Ih30custom_mixed_multiple_variableIhEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i8 noundef zeroext %2, i8 noundef zeroext %3, i8 noundef zeroext %4, i8 noundef zeroext %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !26
  %9 = load i32, ptr @iterations, align 4, !tbaa !9
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %140

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  %13 = zext i8 %2 to i16
  %14 = zext i8 %3 to i16
  %15 = zext i8 %4 to i16
  %16 = mul nuw i16 %15, %14
  %17 = zext i8 %5 to i16
  %18 = udiv i16 %16, %17
  %19 = trunc i16 %18 to i8
  br i1 %12, label %22, label %20

20:                                               ; preds = %11
  %21 = load double, ptr @init_value, align 8, !tbaa !28
  br label %121

22:                                               ; preds = %11
  %23 = zext i32 %1 to i64
  %24 = icmp ult i32 %1, 8
  %25 = icmp ult i32 %1, 32
  %26 = and i64 %23, 4294967264
  %27 = insertelement <16 x i16> poison, i16 %13, i64 0
  %28 = shufflevector <16 x i16> %27, <16 x i16> poison, <16 x i32> zeroinitializer
  %29 = insertelement <16 x i16> poison, i16 %13, i64 0
  %30 = shufflevector <16 x i16> %29, <16 x i16> poison, <16 x i32> zeroinitializer
  %31 = insertelement <16 x i16> poison, i16 %18, i64 0
  %32 = shufflevector <16 x i16> %31, <16 x i16> poison, <16 x i32> zeroinitializer
  %33 = insertelement <16 x i16> poison, i16 %18, i64 0
  %34 = shufflevector <16 x i16> %33, <16 x i16> poison, <16 x i32> zeroinitializer
  %35 = icmp eq i64 %26, %23
  %36 = and i64 %23, 24
  %37 = icmp eq i64 %36, 0
  %38 = and i64 %23, 4294967288
  %39 = insertelement <8 x i16> poison, i16 %13, i64 0
  %40 = shufflevector <8 x i16> %39, <8 x i16> poison, <8 x i32> zeroinitializer
  %41 = insertelement <8 x i16> poison, i16 %18, i64 0
  %42 = shufflevector <8 x i16> %41, <8 x i16> poison, <8 x i32> zeroinitializer
  %43 = icmp eq i64 %38, %23
  br label %44

44:                                               ; preds = %97, %22
  %45 = phi i32 [ %9, %22 ], [ %98, %97 ]
  %46 = phi i32 [ 0, %22 ], [ %99, %97 ]
  br i1 %24, label %90, label %47

47:                                               ; preds = %44
  br i1 %25, label %72, label %48

48:                                               ; preds = %47, %48
  %49 = phi i64 [ %66, %48 ], [ 0, %47 ]
  %50 = phi <16 x i8> [ %64, %48 ], [ zeroinitializer, %47 ]
  %51 = phi <16 x i8> [ %65, %48 ], [ zeroinitializer, %47 ]
  %52 = getelementptr inbounds i8, ptr %0, i64 %49
  %53 = load <16 x i8>, ptr %52, align 1, !tbaa !29
  %54 = getelementptr inbounds i8, ptr %52, i64 16
  %55 = load <16 x i8>, ptr %54, align 1, !tbaa !29
  %56 = zext <16 x i8> %53 to <16 x i16>
  %57 = zext <16 x i8> %55 to <16 x i16>
  %58 = add nuw nsw <16 x i16> %28, %56
  %59 = add nuw nsw <16 x i16> %30, %57
  %60 = sub <16 x i16> %58, %32
  %61 = sub <16 x i16> %59, %34
  %62 = trunc <16 x i16> %60 to <16 x i8>
  %63 = trunc <16 x i16> %61 to <16 x i8>
  %64 = add <16 x i8> %50, %62
  %65 = add <16 x i8> %51, %63
  %66 = add nuw i64 %49, 32
  %67 = icmp eq i64 %66, %26
  br i1 %67, label %68, label %48, !llvm.loop !152

68:                                               ; preds = %48
  %69 = add <16 x i8> %65, %64
  %70 = tail call i8 @llvm.vector.reduce.add.v16i8(<16 x i8> %69)
  br i1 %35, label %113, label %71

71:                                               ; preds = %68
  br i1 %37, label %90, label %72

72:                                               ; preds = %47, %71
  %73 = phi i8 [ 0, %47 ], [ %70, %71 ]
  %74 = phi i64 [ 0, %47 ], [ %26, %71 ]
  %75 = insertelement <8 x i8> <i8 poison, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0>, i8 %73, i64 0
  br label %76

76:                                               ; preds = %76, %72
  %77 = phi i64 [ %74, %72 ], [ %86, %76 ]
  %78 = phi <8 x i8> [ %75, %72 ], [ %85, %76 ]
  %79 = getelementptr inbounds i8, ptr %0, i64 %77
  %80 = load <8 x i8>, ptr %79, align 1, !tbaa !29
  %81 = zext <8 x i8> %80 to <8 x i16>
  %82 = add nuw nsw <8 x i16> %40, %81
  %83 = sub <8 x i16> %82, %42
  %84 = trunc <8 x i16> %83 to <8 x i8>
  %85 = add <8 x i8> %78, %84
  %86 = add nuw i64 %77, 8
  %87 = icmp eq i64 %86, %38
  br i1 %87, label %88, label %76, !llvm.loop !153

88:                                               ; preds = %76
  %89 = tail call i8 @llvm.vector.reduce.add.v8i8(<8 x i8> %85)
  br i1 %43, label %113, label %90

90:                                               ; preds = %44, %71, %88
  %91 = phi i64 [ 0, %44 ], [ %26, %71 ], [ %38, %88 ]
  %92 = phi i8 [ 0, %44 ], [ %70, %71 ], [ %89, %88 ]
  br label %101

93:                                               ; preds = %113
  %94 = load i32, ptr @current_test, align 4, !tbaa !9
  %95 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %94)
  %96 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %97

97:                                               ; preds = %93, %113
  %98 = phi i32 [ %96, %93 ], [ %45, %113 ]
  %99 = add nuw nsw i32 %46, 1
  %100 = icmp slt i32 %99, %98
  br i1 %100, label %44, label %140, !llvm.loop !154

101:                                              ; preds = %90, %101
  %102 = phi i64 [ %111, %101 ], [ %91, %90 ]
  %103 = phi i8 [ %110, %101 ], [ %92, %90 ]
  %104 = getelementptr inbounds i8, ptr %0, i64 %102
  %105 = load i8, ptr %104, align 1, !tbaa !29
  %106 = zext i8 %105 to i16
  %107 = add nuw nsw i16 %106, %13
  %108 = sub i16 %107, %18
  %109 = trunc i16 %108 to i8
  %110 = add i8 %103, %109
  %111 = add nuw nsw i64 %102, 1
  %112 = icmp eq i64 %111, %23
  br i1 %112, label %113, label %101, !llvm.loop !155

113:                                              ; preds = %101, %88, %68
  %114 = phi i8 [ %70, %68 ], [ %89, %88 ], [ %110, %101 ]
  %115 = load double, ptr @init_value, align 8, !tbaa !28
  %116 = fptoui double %115 to i8
  %117 = add i8 %116, %2
  %118 = sub i8 %117, %19
  %119 = shl i8 %118, 6
  %120 = icmp eq i8 %119, %114
  br i1 %120, label %97, label %93

121:                                              ; preds = %20, %135
  %122 = phi i32 [ %136, %135 ], [ %9, %20 ]
  %123 = phi double [ %137, %135 ], [ %21, %20 ]
  %124 = phi i32 [ %138, %135 ], [ 0, %20 ]
  %125 = fptoui double %123 to i8
  %126 = add i8 %125, %2
  %127 = sub i8 %126, %19
  %128 = and i8 %127, 3
  %129 = icmp eq i8 %128, 0
  br i1 %129, label %135, label %130

130:                                              ; preds = %121
  %131 = load i32, ptr @current_test, align 4, !tbaa !9
  %132 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %131)
  %133 = load double, ptr @init_value, align 8, !tbaa !28
  %134 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %135

135:                                              ; preds = %121, %130
  %136 = phi i32 [ %122, %121 ], [ %134, %130 ]
  %137 = phi double [ %123, %121 ], [ %133, %130 ]
  %138 = add nuw nsw i32 %124, 1
  %139 = icmp slt i32 %138, %136
  br i1 %139, label %121, label %140, !llvm.loop !154

140:                                              ; preds = %135, %97, %7
  %141 = tail call i64 @clock() #17
  store i64 %141, ptr @end_time, align 8, !tbaa !26
  %142 = load i64, ptr @start_time, align 8, !tbaa !26
  %143 = load ptr, ptr @results, align 8, !tbaa !5
  %144 = icmp eq ptr %143, null
  br i1 %144, label %145, label %147

145:                                              ; preds = %140
  %146 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %151

147:                                              ; preds = %140
  %148 = load i32, ptr @current_test, align 4, !tbaa !9
  %149 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %150 = icmp slt i32 %148, %149
  br i1 %150, label %163, label %151

151:                                              ; preds = %147, %145
  %152 = phi i32 [ %146, %145 ], [ %149, %147 ]
  %153 = add nsw i32 %152, 10
  store i32 %153, ptr @allocated_results, align 4, !tbaa !9
  %154 = sext i32 %153 to i64
  %155 = shl nsw i64 %154, 4
  %156 = tail call ptr @realloc(ptr noundef %143, i64 noundef %155) #14
  store ptr %156, ptr @results, align 8, !tbaa !5
  %157 = icmp eq ptr %156, null
  br i1 %157, label %160, label %158

158:                                              ; preds = %151
  %159 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %163

160:                                              ; preds = %151
  %161 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %162 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %161)
  tail call void @exit(i32 noundef -1) #15
  unreachable

163:                                              ; preds = %147, %158
  %164 = phi i32 [ %159, %158 ], [ %148, %147 ]
  %165 = phi ptr [ %156, %158 ], [ %143, %147 ]
  %166 = sub nsw i64 %141, %142
  %167 = sitofp i64 %166 to double
  %168 = fdiv double %167, 1.000000e+06
  %169 = sext i32 %164 to i64
  %170 = getelementptr inbounds %struct.one_result, ptr %165, i64 %169
  store double %168, ptr %170, align 8, !tbaa !11
  %171 = getelementptr inbounds %struct.one_result, ptr %165, i64 %169, i32 1
  store ptr %6, ptr %171, align 8, !tbaa !14
  %172 = add nsw i32 %164, 1
  store i32 %172, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1Ih19custom_variable_andIhEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i8 noundef zeroext %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !26
  %6 = load i32, ptr @iterations, align 4, !tbaa !9
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %110

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  br i1 %9, label %12, label %10

10:                                               ; preds = %8
  %11 = load double, ptr @init_value, align 8, !tbaa !28
  br label %92

12:                                               ; preds = %8
  %13 = zext i32 %1 to i64
  %14 = icmp ult i32 %1, 8
  %15 = icmp ult i32 %1, 32
  %16 = and i64 %13, 4294967264
  %17 = insertelement <16 x i8> poison, i8 %2, i64 0
  %18 = shufflevector <16 x i8> %17, <16 x i8> poison, <16 x i32> zeroinitializer
  %19 = insertelement <16 x i8> poison, i8 %2, i64 0
  %20 = shufflevector <16 x i8> %19, <16 x i8> poison, <16 x i32> zeroinitializer
  %21 = icmp eq i64 %16, %13
  %22 = and i64 %13, 24
  %23 = icmp eq i64 %22, 0
  %24 = and i64 %13, 4294967288
  %25 = insertelement <8 x i8> poison, i8 %2, i64 0
  %26 = shufflevector <8 x i8> %25, <8 x i8> poison, <8 x i32> zeroinitializer
  %27 = icmp eq i64 %24, %13
  br label %28

28:                                               ; preds = %12, %72
  %29 = phi i32 [ %73, %72 ], [ %6, %12 ]
  %30 = phi i32 [ %74, %72 ], [ 0, %12 ]
  br i1 %14, label %65, label %31

31:                                               ; preds = %28
  br i1 %15, label %50, label %32

32:                                               ; preds = %31, %32
  %33 = phi i64 [ %44, %32 ], [ 0, %31 ]
  %34 = phi <16 x i8> [ %42, %32 ], [ zeroinitializer, %31 ]
  %35 = phi <16 x i8> [ %43, %32 ], [ zeroinitializer, %31 ]
  %36 = getelementptr inbounds i8, ptr %0, i64 %33
  %37 = load <16 x i8>, ptr %36, align 1, !tbaa !29
  %38 = getelementptr inbounds i8, ptr %36, i64 16
  %39 = load <16 x i8>, ptr %38, align 1, !tbaa !29
  %40 = and <16 x i8> %37, %18
  %41 = and <16 x i8> %39, %20
  %42 = add <16 x i8> %40, %34
  %43 = add <16 x i8> %41, %35
  %44 = add nuw i64 %33, 32
  %45 = icmp eq i64 %44, %16
  br i1 %45, label %46, label %32, !llvm.loop !156

46:                                               ; preds = %32
  %47 = add <16 x i8> %43, %42
  %48 = tail call i8 @llvm.vector.reduce.add.v16i8(<16 x i8> %47)
  br i1 %21, label %85, label %49

49:                                               ; preds = %46
  br i1 %23, label %65, label %50

50:                                               ; preds = %31, %49
  %51 = phi i8 [ 0, %31 ], [ %48, %49 ]
  %52 = phi i64 [ 0, %31 ], [ %16, %49 ]
  %53 = insertelement <8 x i8> <i8 poison, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0>, i8 %51, i64 0
  br label %54

54:                                               ; preds = %54, %50
  %55 = phi i64 [ %52, %50 ], [ %61, %54 ]
  %56 = phi <8 x i8> [ %53, %50 ], [ %60, %54 ]
  %57 = getelementptr inbounds i8, ptr %0, i64 %55
  %58 = load <8 x i8>, ptr %57, align 1, !tbaa !29
  %59 = and <8 x i8> %58, %26
  %60 = add <8 x i8> %59, %56
  %61 = add nuw i64 %55, 8
  %62 = icmp eq i64 %61, %24
  br i1 %62, label %63, label %54, !llvm.loop !157

63:                                               ; preds = %54
  %64 = tail call i8 @llvm.vector.reduce.add.v8i8(<8 x i8> %60)
  br i1 %27, label %85, label %65

65:                                               ; preds = %28, %49, %63
  %66 = phi i64 [ 0, %28 ], [ %16, %49 ], [ %24, %63 ]
  %67 = phi i8 [ 0, %28 ], [ %48, %49 ], [ %64, %63 ]
  br label %76

68:                                               ; preds = %85
  %69 = load i32, ptr @current_test, align 4, !tbaa !9
  %70 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %69)
  %71 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %72

72:                                               ; preds = %68, %85
  %73 = phi i32 [ %71, %68 ], [ %29, %85 ]
  %74 = add nuw nsw i32 %30, 1
  %75 = icmp slt i32 %74, %73
  br i1 %75, label %28, label %110, !llvm.loop !158

76:                                               ; preds = %65, %76
  %77 = phi i64 [ %83, %76 ], [ %66, %65 ]
  %78 = phi i8 [ %82, %76 ], [ %67, %65 ]
  %79 = getelementptr inbounds i8, ptr %0, i64 %77
  %80 = load i8, ptr %79, align 1, !tbaa !29
  %81 = and i8 %80, %2
  %82 = add i8 %81, %78
  %83 = add nuw nsw i64 %77, 1
  %84 = icmp eq i64 %83, %13
  br i1 %84, label %85, label %76, !llvm.loop !159

85:                                               ; preds = %76, %63, %46
  %86 = phi i8 [ %48, %46 ], [ %64, %63 ], [ %82, %76 ]
  %87 = load double, ptr @init_value, align 8, !tbaa !28
  %88 = fptoui double %87 to i8
  %89 = and i8 %88, %2
  %90 = shl i8 %89, 6
  %91 = icmp eq i8 %90, %86
  br i1 %91, label %72, label %68

92:                                               ; preds = %10, %105
  %93 = phi i32 [ %106, %105 ], [ %6, %10 ]
  %94 = phi double [ %107, %105 ], [ %11, %10 ]
  %95 = phi i32 [ %108, %105 ], [ 0, %10 ]
  %96 = fptoui double %94 to i8
  %97 = and i8 %96, %2
  %98 = and i8 %97, 3
  %99 = icmp eq i8 %98, 0
  br i1 %99, label %105, label %100

100:                                              ; preds = %92
  %101 = load i32, ptr @current_test, align 4, !tbaa !9
  %102 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %101)
  %103 = load double, ptr @init_value, align 8, !tbaa !28
  %104 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %105

105:                                              ; preds = %92, %100
  %106 = phi i32 [ %93, %92 ], [ %104, %100 ]
  %107 = phi double [ %94, %92 ], [ %103, %100 ]
  %108 = add nuw nsw i32 %95, 1
  %109 = icmp slt i32 %108, %106
  br i1 %109, label %92, label %110, !llvm.loop !158

110:                                              ; preds = %105, %72, %4
  %111 = tail call i64 @clock() #17
  store i64 %111, ptr @end_time, align 8, !tbaa !26
  %112 = load i64, ptr @start_time, align 8, !tbaa !26
  %113 = load ptr, ptr @results, align 8, !tbaa !5
  %114 = icmp eq ptr %113, null
  br i1 %114, label %115, label %117

115:                                              ; preds = %110
  %116 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %121

117:                                              ; preds = %110
  %118 = load i32, ptr @current_test, align 4, !tbaa !9
  %119 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %120 = icmp slt i32 %118, %119
  br i1 %120, label %133, label %121

121:                                              ; preds = %117, %115
  %122 = phi i32 [ %116, %115 ], [ %119, %117 ]
  %123 = add nsw i32 %122, 10
  store i32 %123, ptr @allocated_results, align 4, !tbaa !9
  %124 = sext i32 %123 to i64
  %125 = shl nsw i64 %124, 4
  %126 = tail call ptr @realloc(ptr noundef %113, i64 noundef %125) #14
  store ptr %126, ptr @results, align 8, !tbaa !5
  %127 = icmp eq ptr %126, null
  br i1 %127, label %130, label %128

128:                                              ; preds = %121
  %129 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %133

130:                                              ; preds = %121
  %131 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %132 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %131)
  tail call void @exit(i32 noundef -1) #15
  unreachable

133:                                              ; preds = %117, %128
  %134 = phi i32 [ %129, %128 ], [ %118, %117 ]
  %135 = phi ptr [ %126, %128 ], [ %113, %117 ]
  %136 = sub nsw i64 %111, %112
  %137 = sitofp i64 %136 to double
  %138 = fdiv double %137, 1.000000e+06
  %139 = sext i32 %134 to i64
  %140 = getelementptr inbounds %struct.one_result, ptr %135, i64 %139
  store double %138, ptr %140, align 8, !tbaa !11
  %141 = getelementptr inbounds %struct.one_result, ptr %135, i64 %139, i32 1
  store ptr %3, ptr %141, align 8, !tbaa !14
  %142 = add nsw i32 %134, 1
  store i32 %142, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Ih28custom_multiple_variable_andIhEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i8 noundef zeroext %2, i8 noundef zeroext %3, i8 noundef zeroext %4, i8 noundef zeroext %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !26
  %9 = load i32, ptr @iterations, align 4, !tbaa !9
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %128

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  %13 = and i8 %3, %2
  %14 = and i8 %13, %4
  %15 = and i8 %14, %5
  br i1 %12, label %18, label %16

16:                                               ; preds = %11
  %17 = load double, ptr @init_value, align 8, !tbaa !28
  br label %110

18:                                               ; preds = %11
  %19 = zext i32 %1 to i64
  %20 = icmp ult i32 %1, 8
  %21 = icmp ult i32 %1, 32
  %22 = and i64 %19, 4294967264
  %23 = and i8 %3, %2
  %24 = and i8 %3, %2
  %25 = and i8 %23, %4
  %26 = and i8 %24, %4
  %27 = and i8 %25, %5
  %28 = insertelement <16 x i8> poison, i8 %27, i64 0
  %29 = shufflevector <16 x i8> %28, <16 x i8> poison, <16 x i32> zeroinitializer
  %30 = and i8 %26, %5
  %31 = insertelement <16 x i8> poison, i8 %30, i64 0
  %32 = shufflevector <16 x i8> %31, <16 x i8> poison, <16 x i32> zeroinitializer
  %33 = icmp eq i64 %22, %19
  %34 = and i64 %19, 24
  %35 = icmp eq i64 %34, 0
  %36 = and i64 %19, 4294967288
  %37 = and i8 %3, %2
  %38 = and i8 %37, %4
  %39 = and i8 %38, %5
  %40 = insertelement <8 x i8> poison, i8 %39, i64 0
  %41 = shufflevector <8 x i8> %40, <8 x i8> poison, <8 x i32> zeroinitializer
  %42 = icmp eq i64 %36, %19
  br label %43

43:                                               ; preds = %18, %87
  %44 = phi i32 [ %88, %87 ], [ %9, %18 ]
  %45 = phi i32 [ %89, %87 ], [ 0, %18 ]
  br i1 %20, label %80, label %46

46:                                               ; preds = %43
  br i1 %21, label %65, label %47

47:                                               ; preds = %46, %47
  %48 = phi i64 [ %59, %47 ], [ 0, %46 ]
  %49 = phi <16 x i8> [ %57, %47 ], [ zeroinitializer, %46 ]
  %50 = phi <16 x i8> [ %58, %47 ], [ zeroinitializer, %46 ]
  %51 = getelementptr inbounds i8, ptr %0, i64 %48
  %52 = load <16 x i8>, ptr %51, align 1, !tbaa !29
  %53 = getelementptr inbounds i8, ptr %51, i64 16
  %54 = load <16 x i8>, ptr %53, align 1, !tbaa !29
  %55 = and <16 x i8> %29, %52
  %56 = and <16 x i8> %32, %54
  %57 = add <16 x i8> %55, %49
  %58 = add <16 x i8> %56, %50
  %59 = add nuw i64 %48, 32
  %60 = icmp eq i64 %59, %22
  br i1 %60, label %61, label %47, !llvm.loop !160

61:                                               ; preds = %47
  %62 = add <16 x i8> %58, %57
  %63 = tail call i8 @llvm.vector.reduce.add.v16i8(<16 x i8> %62)
  br i1 %33, label %103, label %64

64:                                               ; preds = %61
  br i1 %35, label %80, label %65

65:                                               ; preds = %46, %64
  %66 = phi i8 [ 0, %46 ], [ %63, %64 ]
  %67 = phi i64 [ 0, %46 ], [ %22, %64 ]
  %68 = insertelement <8 x i8> <i8 poison, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0>, i8 %66, i64 0
  br label %69

69:                                               ; preds = %69, %65
  %70 = phi i64 [ %67, %65 ], [ %76, %69 ]
  %71 = phi <8 x i8> [ %68, %65 ], [ %75, %69 ]
  %72 = getelementptr inbounds i8, ptr %0, i64 %70
  %73 = load <8 x i8>, ptr %72, align 1, !tbaa !29
  %74 = and <8 x i8> %41, %73
  %75 = add <8 x i8> %74, %71
  %76 = add nuw i64 %70, 8
  %77 = icmp eq i64 %76, %36
  br i1 %77, label %78, label %69, !llvm.loop !161

78:                                               ; preds = %69
  %79 = tail call i8 @llvm.vector.reduce.add.v8i8(<8 x i8> %75)
  br i1 %42, label %103, label %80

80:                                               ; preds = %43, %64, %78
  %81 = phi i64 [ 0, %43 ], [ %22, %64 ], [ %36, %78 ]
  %82 = phi i8 [ 0, %43 ], [ %63, %64 ], [ %79, %78 ]
  br label %91

83:                                               ; preds = %103
  %84 = load i32, ptr @current_test, align 4, !tbaa !9
  %85 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %84)
  %86 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %87

87:                                               ; preds = %83, %103
  %88 = phi i32 [ %86, %83 ], [ %44, %103 ]
  %89 = add nuw nsw i32 %45, 1
  %90 = icmp slt i32 %89, %88
  br i1 %90, label %43, label %128, !llvm.loop !162

91:                                               ; preds = %80, %91
  %92 = phi i64 [ %101, %91 ], [ %81, %80 ]
  %93 = phi i8 [ %100, %91 ], [ %82, %80 ]
  %94 = getelementptr inbounds i8, ptr %0, i64 %92
  %95 = load i8, ptr %94, align 1, !tbaa !29
  %96 = and i8 %95, %2
  %97 = and i8 %96, %3
  %98 = and i8 %97, %4
  %99 = and i8 %98, %5
  %100 = add i8 %99, %93
  %101 = add nuw nsw i64 %92, 1
  %102 = icmp eq i64 %101, %19
  br i1 %102, label %103, label %91, !llvm.loop !163

103:                                              ; preds = %91, %78, %61
  %104 = phi i8 [ %63, %61 ], [ %79, %78 ], [ %100, %91 ]
  %105 = load double, ptr @init_value, align 8, !tbaa !28
  %106 = fptoui double %105 to i8
  %107 = and i8 %15, %106
  %108 = shl i8 %107, 6
  %109 = icmp eq i8 %108, %104
  br i1 %109, label %87, label %83

110:                                              ; preds = %16, %123
  %111 = phi i32 [ %124, %123 ], [ %9, %16 ]
  %112 = phi double [ %125, %123 ], [ %17, %16 ]
  %113 = phi i32 [ %126, %123 ], [ 0, %16 ]
  %114 = fptoui double %112 to i8
  %115 = and i8 %15, %114
  %116 = and i8 %115, 3
  %117 = icmp eq i8 %116, 0
  br i1 %117, label %123, label %118

118:                                              ; preds = %110
  %119 = load i32, ptr @current_test, align 4, !tbaa !9
  %120 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %119)
  %121 = load double, ptr @init_value, align 8, !tbaa !28
  %122 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %123

123:                                              ; preds = %110, %118
  %124 = phi i32 [ %111, %110 ], [ %122, %118 ]
  %125 = phi double [ %112, %110 ], [ %121, %118 ]
  %126 = add nuw nsw i32 %113, 1
  %127 = icmp slt i32 %126, %124
  br i1 %127, label %110, label %128, !llvm.loop !162

128:                                              ; preds = %123, %87, %7
  %129 = tail call i64 @clock() #17
  store i64 %129, ptr @end_time, align 8, !tbaa !26
  %130 = load i64, ptr @start_time, align 8, !tbaa !26
  %131 = load ptr, ptr @results, align 8, !tbaa !5
  %132 = icmp eq ptr %131, null
  br i1 %132, label %133, label %135

133:                                              ; preds = %128
  %134 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %139

135:                                              ; preds = %128
  %136 = load i32, ptr @current_test, align 4, !tbaa !9
  %137 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %138 = icmp slt i32 %136, %137
  br i1 %138, label %151, label %139

139:                                              ; preds = %135, %133
  %140 = phi i32 [ %134, %133 ], [ %137, %135 ]
  %141 = add nsw i32 %140, 10
  store i32 %141, ptr @allocated_results, align 4, !tbaa !9
  %142 = sext i32 %141 to i64
  %143 = shl nsw i64 %142, 4
  %144 = tail call ptr @realloc(ptr noundef %131, i64 noundef %143) #14
  store ptr %144, ptr @results, align 8, !tbaa !5
  %145 = icmp eq ptr %144, null
  br i1 %145, label %148, label %146

146:                                              ; preds = %139
  %147 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %151

148:                                              ; preds = %139
  %149 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %150 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %149)
  tail call void @exit(i32 noundef -1) #15
  unreachable

151:                                              ; preds = %135, %146
  %152 = phi i32 [ %147, %146 ], [ %136, %135 ]
  %153 = phi ptr [ %144, %146 ], [ %131, %135 ]
  %154 = sub nsw i64 %129, %130
  %155 = sitofp i64 %154 to double
  %156 = fdiv double %155, 1.000000e+06
  %157 = sext i32 %152 to i64
  %158 = getelementptr inbounds %struct.one_result, ptr %153, i64 %157
  store double %156, ptr %158, align 8, !tbaa !11
  %159 = getelementptr inbounds %struct.one_result, ptr %153, i64 %157, i32 1
  store ptr %6, ptr %159, align 8, !tbaa !14
  %160 = add nsw i32 %152, 1
  store i32 %160, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1Ih18custom_variable_orIhEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i8 noundef zeroext %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !26
  %6 = load i32, ptr @iterations, align 4, !tbaa !9
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %110

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  br i1 %9, label %12, label %10

10:                                               ; preds = %8
  %11 = load double, ptr @init_value, align 8, !tbaa !28
  br label %92

12:                                               ; preds = %8
  %13 = zext i32 %1 to i64
  %14 = icmp ult i32 %1, 8
  %15 = icmp ult i32 %1, 32
  %16 = and i64 %13, 4294967264
  %17 = insertelement <16 x i8> poison, i8 %2, i64 0
  %18 = shufflevector <16 x i8> %17, <16 x i8> poison, <16 x i32> zeroinitializer
  %19 = insertelement <16 x i8> poison, i8 %2, i64 0
  %20 = shufflevector <16 x i8> %19, <16 x i8> poison, <16 x i32> zeroinitializer
  %21 = icmp eq i64 %16, %13
  %22 = and i64 %13, 24
  %23 = icmp eq i64 %22, 0
  %24 = and i64 %13, 4294967288
  %25 = insertelement <8 x i8> poison, i8 %2, i64 0
  %26 = shufflevector <8 x i8> %25, <8 x i8> poison, <8 x i32> zeroinitializer
  %27 = icmp eq i64 %24, %13
  br label %28

28:                                               ; preds = %12, %72
  %29 = phi i32 [ %73, %72 ], [ %6, %12 ]
  %30 = phi i32 [ %74, %72 ], [ 0, %12 ]
  br i1 %14, label %65, label %31

31:                                               ; preds = %28
  br i1 %15, label %50, label %32

32:                                               ; preds = %31, %32
  %33 = phi i64 [ %44, %32 ], [ 0, %31 ]
  %34 = phi <16 x i8> [ %42, %32 ], [ zeroinitializer, %31 ]
  %35 = phi <16 x i8> [ %43, %32 ], [ zeroinitializer, %31 ]
  %36 = getelementptr inbounds i8, ptr %0, i64 %33
  %37 = load <16 x i8>, ptr %36, align 1, !tbaa !29
  %38 = getelementptr inbounds i8, ptr %36, i64 16
  %39 = load <16 x i8>, ptr %38, align 1, !tbaa !29
  %40 = or <16 x i8> %37, %18
  %41 = or <16 x i8> %39, %20
  %42 = add <16 x i8> %40, %34
  %43 = add <16 x i8> %41, %35
  %44 = add nuw i64 %33, 32
  %45 = icmp eq i64 %44, %16
  br i1 %45, label %46, label %32, !llvm.loop !164

46:                                               ; preds = %32
  %47 = add <16 x i8> %43, %42
  %48 = tail call i8 @llvm.vector.reduce.add.v16i8(<16 x i8> %47)
  br i1 %21, label %85, label %49

49:                                               ; preds = %46
  br i1 %23, label %65, label %50

50:                                               ; preds = %31, %49
  %51 = phi i8 [ 0, %31 ], [ %48, %49 ]
  %52 = phi i64 [ 0, %31 ], [ %16, %49 ]
  %53 = insertelement <8 x i8> <i8 poison, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0>, i8 %51, i64 0
  br label %54

54:                                               ; preds = %54, %50
  %55 = phi i64 [ %52, %50 ], [ %61, %54 ]
  %56 = phi <8 x i8> [ %53, %50 ], [ %60, %54 ]
  %57 = getelementptr inbounds i8, ptr %0, i64 %55
  %58 = load <8 x i8>, ptr %57, align 1, !tbaa !29
  %59 = or <8 x i8> %58, %26
  %60 = add <8 x i8> %59, %56
  %61 = add nuw i64 %55, 8
  %62 = icmp eq i64 %61, %24
  br i1 %62, label %63, label %54, !llvm.loop !165

63:                                               ; preds = %54
  %64 = tail call i8 @llvm.vector.reduce.add.v8i8(<8 x i8> %60)
  br i1 %27, label %85, label %65

65:                                               ; preds = %28, %49, %63
  %66 = phi i64 [ 0, %28 ], [ %16, %49 ], [ %24, %63 ]
  %67 = phi i8 [ 0, %28 ], [ %48, %49 ], [ %64, %63 ]
  br label %76

68:                                               ; preds = %85
  %69 = load i32, ptr @current_test, align 4, !tbaa !9
  %70 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %69)
  %71 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %72

72:                                               ; preds = %68, %85
  %73 = phi i32 [ %71, %68 ], [ %29, %85 ]
  %74 = add nuw nsw i32 %30, 1
  %75 = icmp slt i32 %74, %73
  br i1 %75, label %28, label %110, !llvm.loop !166

76:                                               ; preds = %65, %76
  %77 = phi i64 [ %83, %76 ], [ %66, %65 ]
  %78 = phi i8 [ %82, %76 ], [ %67, %65 ]
  %79 = getelementptr inbounds i8, ptr %0, i64 %77
  %80 = load i8, ptr %79, align 1, !tbaa !29
  %81 = or i8 %80, %2
  %82 = add i8 %81, %78
  %83 = add nuw nsw i64 %77, 1
  %84 = icmp eq i64 %83, %13
  br i1 %84, label %85, label %76, !llvm.loop !167

85:                                               ; preds = %76, %63, %46
  %86 = phi i8 [ %48, %46 ], [ %64, %63 ], [ %82, %76 ]
  %87 = load double, ptr @init_value, align 8, !tbaa !28
  %88 = fptoui double %87 to i8
  %89 = or i8 %88, %2
  %90 = shl i8 %89, 6
  %91 = icmp eq i8 %90, %86
  br i1 %91, label %72, label %68

92:                                               ; preds = %10, %105
  %93 = phi i32 [ %106, %105 ], [ %6, %10 ]
  %94 = phi double [ %107, %105 ], [ %11, %10 ]
  %95 = phi i32 [ %108, %105 ], [ 0, %10 ]
  %96 = fptoui double %94 to i8
  %97 = or i8 %96, %2
  %98 = and i8 %97, 3
  %99 = icmp eq i8 %98, 0
  br i1 %99, label %105, label %100

100:                                              ; preds = %92
  %101 = load i32, ptr @current_test, align 4, !tbaa !9
  %102 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %101)
  %103 = load double, ptr @init_value, align 8, !tbaa !28
  %104 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %105

105:                                              ; preds = %92, %100
  %106 = phi i32 [ %93, %92 ], [ %104, %100 ]
  %107 = phi double [ %94, %92 ], [ %103, %100 ]
  %108 = add nuw nsw i32 %95, 1
  %109 = icmp slt i32 %108, %106
  br i1 %109, label %92, label %110, !llvm.loop !166

110:                                              ; preds = %105, %72, %4
  %111 = tail call i64 @clock() #17
  store i64 %111, ptr @end_time, align 8, !tbaa !26
  %112 = load i64, ptr @start_time, align 8, !tbaa !26
  %113 = load ptr, ptr @results, align 8, !tbaa !5
  %114 = icmp eq ptr %113, null
  br i1 %114, label %115, label %117

115:                                              ; preds = %110
  %116 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %121

117:                                              ; preds = %110
  %118 = load i32, ptr @current_test, align 4, !tbaa !9
  %119 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %120 = icmp slt i32 %118, %119
  br i1 %120, label %133, label %121

121:                                              ; preds = %117, %115
  %122 = phi i32 [ %116, %115 ], [ %119, %117 ]
  %123 = add nsw i32 %122, 10
  store i32 %123, ptr @allocated_results, align 4, !tbaa !9
  %124 = sext i32 %123 to i64
  %125 = shl nsw i64 %124, 4
  %126 = tail call ptr @realloc(ptr noundef %113, i64 noundef %125) #14
  store ptr %126, ptr @results, align 8, !tbaa !5
  %127 = icmp eq ptr %126, null
  br i1 %127, label %130, label %128

128:                                              ; preds = %121
  %129 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %133

130:                                              ; preds = %121
  %131 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %132 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %131)
  tail call void @exit(i32 noundef -1) #15
  unreachable

133:                                              ; preds = %117, %128
  %134 = phi i32 [ %129, %128 ], [ %118, %117 ]
  %135 = phi ptr [ %126, %128 ], [ %113, %117 ]
  %136 = sub nsw i64 %111, %112
  %137 = sitofp i64 %136 to double
  %138 = fdiv double %137, 1.000000e+06
  %139 = sext i32 %134 to i64
  %140 = getelementptr inbounds %struct.one_result, ptr %135, i64 %139
  store double %138, ptr %140, align 8, !tbaa !11
  %141 = getelementptr inbounds %struct.one_result, ptr %135, i64 %139, i32 1
  store ptr %3, ptr %141, align 8, !tbaa !14
  %142 = add nsw i32 %134, 1
  store i32 %142, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Ih27custom_multiple_variable_orIhEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i8 noundef zeroext %2, i8 noundef zeroext %3, i8 noundef zeroext %4, i8 noundef zeroext %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !26
  %9 = load i32, ptr @iterations, align 4, !tbaa !9
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %128

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  %13 = or i8 %3, %2
  %14 = or i8 %13, %4
  %15 = or i8 %14, %5
  br i1 %12, label %18, label %16

16:                                               ; preds = %11
  %17 = load double, ptr @init_value, align 8, !tbaa !28
  br label %110

18:                                               ; preds = %11
  %19 = zext i32 %1 to i64
  %20 = icmp ult i32 %1, 8
  %21 = icmp ult i32 %1, 32
  %22 = and i64 %19, 4294967264
  %23 = or i8 %3, %2
  %24 = or i8 %3, %2
  %25 = or i8 %23, %4
  %26 = or i8 %24, %4
  %27 = or i8 %25, %5
  %28 = insertelement <16 x i8> poison, i8 %27, i64 0
  %29 = shufflevector <16 x i8> %28, <16 x i8> poison, <16 x i32> zeroinitializer
  %30 = or i8 %26, %5
  %31 = insertelement <16 x i8> poison, i8 %30, i64 0
  %32 = shufflevector <16 x i8> %31, <16 x i8> poison, <16 x i32> zeroinitializer
  %33 = icmp eq i64 %22, %19
  %34 = and i64 %19, 24
  %35 = icmp eq i64 %34, 0
  %36 = and i64 %19, 4294967288
  %37 = or i8 %3, %2
  %38 = or i8 %37, %4
  %39 = or i8 %38, %5
  %40 = insertelement <8 x i8> poison, i8 %39, i64 0
  %41 = shufflevector <8 x i8> %40, <8 x i8> poison, <8 x i32> zeroinitializer
  %42 = icmp eq i64 %36, %19
  br label %43

43:                                               ; preds = %18, %87
  %44 = phi i32 [ %88, %87 ], [ %9, %18 ]
  %45 = phi i32 [ %89, %87 ], [ 0, %18 ]
  br i1 %20, label %80, label %46

46:                                               ; preds = %43
  br i1 %21, label %65, label %47

47:                                               ; preds = %46, %47
  %48 = phi i64 [ %59, %47 ], [ 0, %46 ]
  %49 = phi <16 x i8> [ %57, %47 ], [ zeroinitializer, %46 ]
  %50 = phi <16 x i8> [ %58, %47 ], [ zeroinitializer, %46 ]
  %51 = getelementptr inbounds i8, ptr %0, i64 %48
  %52 = load <16 x i8>, ptr %51, align 1, !tbaa !29
  %53 = getelementptr inbounds i8, ptr %51, i64 16
  %54 = load <16 x i8>, ptr %53, align 1, !tbaa !29
  %55 = or <16 x i8> %29, %52
  %56 = or <16 x i8> %32, %54
  %57 = add <16 x i8> %55, %49
  %58 = add <16 x i8> %56, %50
  %59 = add nuw i64 %48, 32
  %60 = icmp eq i64 %59, %22
  br i1 %60, label %61, label %47, !llvm.loop !168

61:                                               ; preds = %47
  %62 = add <16 x i8> %58, %57
  %63 = tail call i8 @llvm.vector.reduce.add.v16i8(<16 x i8> %62)
  br i1 %33, label %103, label %64

64:                                               ; preds = %61
  br i1 %35, label %80, label %65

65:                                               ; preds = %46, %64
  %66 = phi i8 [ 0, %46 ], [ %63, %64 ]
  %67 = phi i64 [ 0, %46 ], [ %22, %64 ]
  %68 = insertelement <8 x i8> <i8 poison, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0>, i8 %66, i64 0
  br label %69

69:                                               ; preds = %69, %65
  %70 = phi i64 [ %67, %65 ], [ %76, %69 ]
  %71 = phi <8 x i8> [ %68, %65 ], [ %75, %69 ]
  %72 = getelementptr inbounds i8, ptr %0, i64 %70
  %73 = load <8 x i8>, ptr %72, align 1, !tbaa !29
  %74 = or <8 x i8> %41, %73
  %75 = add <8 x i8> %74, %71
  %76 = add nuw i64 %70, 8
  %77 = icmp eq i64 %76, %36
  br i1 %77, label %78, label %69, !llvm.loop !169

78:                                               ; preds = %69
  %79 = tail call i8 @llvm.vector.reduce.add.v8i8(<8 x i8> %75)
  br i1 %42, label %103, label %80

80:                                               ; preds = %43, %64, %78
  %81 = phi i64 [ 0, %43 ], [ %22, %64 ], [ %36, %78 ]
  %82 = phi i8 [ 0, %43 ], [ %63, %64 ], [ %79, %78 ]
  br label %91

83:                                               ; preds = %103
  %84 = load i32, ptr @current_test, align 4, !tbaa !9
  %85 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %84)
  %86 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %87

87:                                               ; preds = %83, %103
  %88 = phi i32 [ %86, %83 ], [ %44, %103 ]
  %89 = add nuw nsw i32 %45, 1
  %90 = icmp slt i32 %89, %88
  br i1 %90, label %43, label %128, !llvm.loop !170

91:                                               ; preds = %80, %91
  %92 = phi i64 [ %101, %91 ], [ %81, %80 ]
  %93 = phi i8 [ %100, %91 ], [ %82, %80 ]
  %94 = getelementptr inbounds i8, ptr %0, i64 %92
  %95 = load i8, ptr %94, align 1, !tbaa !29
  %96 = or i8 %95, %2
  %97 = or i8 %96, %3
  %98 = or i8 %97, %4
  %99 = or i8 %98, %5
  %100 = add i8 %99, %93
  %101 = add nuw nsw i64 %92, 1
  %102 = icmp eq i64 %101, %19
  br i1 %102, label %103, label %91, !llvm.loop !171

103:                                              ; preds = %91, %78, %61
  %104 = phi i8 [ %63, %61 ], [ %79, %78 ], [ %100, %91 ]
  %105 = load double, ptr @init_value, align 8, !tbaa !28
  %106 = fptoui double %105 to i8
  %107 = or i8 %15, %106
  %108 = shl i8 %107, 6
  %109 = icmp eq i8 %108, %104
  br i1 %109, label %87, label %83

110:                                              ; preds = %16, %123
  %111 = phi i32 [ %124, %123 ], [ %9, %16 ]
  %112 = phi double [ %125, %123 ], [ %17, %16 ]
  %113 = phi i32 [ %126, %123 ], [ 0, %16 ]
  %114 = fptoui double %112 to i8
  %115 = or i8 %15, %114
  %116 = and i8 %115, 3
  %117 = icmp eq i8 %116, 0
  br i1 %117, label %123, label %118

118:                                              ; preds = %110
  %119 = load i32, ptr @current_test, align 4, !tbaa !9
  %120 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %119)
  %121 = load double, ptr @init_value, align 8, !tbaa !28
  %122 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %123

123:                                              ; preds = %110, %118
  %124 = phi i32 [ %111, %110 ], [ %122, %118 ]
  %125 = phi double [ %112, %110 ], [ %121, %118 ]
  %126 = add nuw nsw i32 %113, 1
  %127 = icmp slt i32 %126, %124
  br i1 %127, label %110, label %128, !llvm.loop !170

128:                                              ; preds = %123, %87, %7
  %129 = tail call i64 @clock() #17
  store i64 %129, ptr @end_time, align 8, !tbaa !26
  %130 = load i64, ptr @start_time, align 8, !tbaa !26
  %131 = load ptr, ptr @results, align 8, !tbaa !5
  %132 = icmp eq ptr %131, null
  br i1 %132, label %133, label %135

133:                                              ; preds = %128
  %134 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %139

135:                                              ; preds = %128
  %136 = load i32, ptr @current_test, align 4, !tbaa !9
  %137 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %138 = icmp slt i32 %136, %137
  br i1 %138, label %151, label %139

139:                                              ; preds = %135, %133
  %140 = phi i32 [ %134, %133 ], [ %137, %135 ]
  %141 = add nsw i32 %140, 10
  store i32 %141, ptr @allocated_results, align 4, !tbaa !9
  %142 = sext i32 %141 to i64
  %143 = shl nsw i64 %142, 4
  %144 = tail call ptr @realloc(ptr noundef %131, i64 noundef %143) #14
  store ptr %144, ptr @results, align 8, !tbaa !5
  %145 = icmp eq ptr %144, null
  br i1 %145, label %148, label %146

146:                                              ; preds = %139
  %147 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %151

148:                                              ; preds = %139
  %149 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %150 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %149)
  tail call void @exit(i32 noundef -1) #15
  unreachable

151:                                              ; preds = %135, %146
  %152 = phi i32 [ %147, %146 ], [ %136, %135 ]
  %153 = phi ptr [ %144, %146 ], [ %131, %135 ]
  %154 = sub nsw i64 %129, %130
  %155 = sitofp i64 %154 to double
  %156 = fdiv double %155, 1.000000e+06
  %157 = sext i32 %152 to i64
  %158 = getelementptr inbounds %struct.one_result, ptr %153, i64 %157
  store double %156, ptr %158, align 8, !tbaa !11
  %159 = getelementptr inbounds %struct.one_result, ptr %153, i64 %157, i32 1
  store ptr %6, ptr %159, align 8, !tbaa !14
  %160 = add nsw i32 %152, 1
  store i32 %160, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1Ih19custom_variable_xorIhEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i8 noundef zeroext %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !26
  %6 = load i32, ptr @iterations, align 4, !tbaa !9
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %110

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  br i1 %9, label %12, label %10

10:                                               ; preds = %8
  %11 = load double, ptr @init_value, align 8, !tbaa !28
  br label %92

12:                                               ; preds = %8
  %13 = zext i32 %1 to i64
  %14 = icmp ult i32 %1, 8
  %15 = icmp ult i32 %1, 32
  %16 = and i64 %13, 4294967264
  %17 = insertelement <16 x i8> poison, i8 %2, i64 0
  %18 = shufflevector <16 x i8> %17, <16 x i8> poison, <16 x i32> zeroinitializer
  %19 = insertelement <16 x i8> poison, i8 %2, i64 0
  %20 = shufflevector <16 x i8> %19, <16 x i8> poison, <16 x i32> zeroinitializer
  %21 = icmp eq i64 %16, %13
  %22 = and i64 %13, 24
  %23 = icmp eq i64 %22, 0
  %24 = and i64 %13, 4294967288
  %25 = insertelement <8 x i8> poison, i8 %2, i64 0
  %26 = shufflevector <8 x i8> %25, <8 x i8> poison, <8 x i32> zeroinitializer
  %27 = icmp eq i64 %24, %13
  br label %28

28:                                               ; preds = %12, %72
  %29 = phi i32 [ %73, %72 ], [ %6, %12 ]
  %30 = phi i32 [ %74, %72 ], [ 0, %12 ]
  br i1 %14, label %65, label %31

31:                                               ; preds = %28
  br i1 %15, label %50, label %32

32:                                               ; preds = %31, %32
  %33 = phi i64 [ %44, %32 ], [ 0, %31 ]
  %34 = phi <16 x i8> [ %42, %32 ], [ zeroinitializer, %31 ]
  %35 = phi <16 x i8> [ %43, %32 ], [ zeroinitializer, %31 ]
  %36 = getelementptr inbounds i8, ptr %0, i64 %33
  %37 = load <16 x i8>, ptr %36, align 1, !tbaa !29
  %38 = getelementptr inbounds i8, ptr %36, i64 16
  %39 = load <16 x i8>, ptr %38, align 1, !tbaa !29
  %40 = xor <16 x i8> %37, %18
  %41 = xor <16 x i8> %39, %20
  %42 = add <16 x i8> %40, %34
  %43 = add <16 x i8> %41, %35
  %44 = add nuw i64 %33, 32
  %45 = icmp eq i64 %44, %16
  br i1 %45, label %46, label %32, !llvm.loop !172

46:                                               ; preds = %32
  %47 = add <16 x i8> %43, %42
  %48 = tail call i8 @llvm.vector.reduce.add.v16i8(<16 x i8> %47)
  br i1 %21, label %85, label %49

49:                                               ; preds = %46
  br i1 %23, label %65, label %50

50:                                               ; preds = %31, %49
  %51 = phi i8 [ 0, %31 ], [ %48, %49 ]
  %52 = phi i64 [ 0, %31 ], [ %16, %49 ]
  %53 = insertelement <8 x i8> <i8 poison, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0>, i8 %51, i64 0
  br label %54

54:                                               ; preds = %54, %50
  %55 = phi i64 [ %52, %50 ], [ %61, %54 ]
  %56 = phi <8 x i8> [ %53, %50 ], [ %60, %54 ]
  %57 = getelementptr inbounds i8, ptr %0, i64 %55
  %58 = load <8 x i8>, ptr %57, align 1, !tbaa !29
  %59 = xor <8 x i8> %58, %26
  %60 = add <8 x i8> %59, %56
  %61 = add nuw i64 %55, 8
  %62 = icmp eq i64 %61, %24
  br i1 %62, label %63, label %54, !llvm.loop !173

63:                                               ; preds = %54
  %64 = tail call i8 @llvm.vector.reduce.add.v8i8(<8 x i8> %60)
  br i1 %27, label %85, label %65

65:                                               ; preds = %28, %49, %63
  %66 = phi i64 [ 0, %28 ], [ %16, %49 ], [ %24, %63 ]
  %67 = phi i8 [ 0, %28 ], [ %48, %49 ], [ %64, %63 ]
  br label %76

68:                                               ; preds = %85
  %69 = load i32, ptr @current_test, align 4, !tbaa !9
  %70 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %69)
  %71 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %72

72:                                               ; preds = %68, %85
  %73 = phi i32 [ %71, %68 ], [ %29, %85 ]
  %74 = add nuw nsw i32 %30, 1
  %75 = icmp slt i32 %74, %73
  br i1 %75, label %28, label %110, !llvm.loop !174

76:                                               ; preds = %65, %76
  %77 = phi i64 [ %83, %76 ], [ %66, %65 ]
  %78 = phi i8 [ %82, %76 ], [ %67, %65 ]
  %79 = getelementptr inbounds i8, ptr %0, i64 %77
  %80 = load i8, ptr %79, align 1, !tbaa !29
  %81 = xor i8 %80, %2
  %82 = add i8 %81, %78
  %83 = add nuw nsw i64 %77, 1
  %84 = icmp eq i64 %83, %13
  br i1 %84, label %85, label %76, !llvm.loop !175

85:                                               ; preds = %76, %63, %46
  %86 = phi i8 [ %48, %46 ], [ %64, %63 ], [ %82, %76 ]
  %87 = load double, ptr @init_value, align 8, !tbaa !28
  %88 = fptoui double %87 to i8
  %89 = xor i8 %88, %2
  %90 = shl i8 %89, 6
  %91 = icmp eq i8 %90, %86
  br i1 %91, label %72, label %68

92:                                               ; preds = %10, %105
  %93 = phi i32 [ %106, %105 ], [ %6, %10 ]
  %94 = phi double [ %107, %105 ], [ %11, %10 ]
  %95 = phi i32 [ %108, %105 ], [ 0, %10 ]
  %96 = fptoui double %94 to i8
  %97 = xor i8 %96, %2
  %98 = and i8 %97, 3
  %99 = icmp eq i8 %98, 0
  br i1 %99, label %105, label %100

100:                                              ; preds = %92
  %101 = load i32, ptr @current_test, align 4, !tbaa !9
  %102 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %101)
  %103 = load double, ptr @init_value, align 8, !tbaa !28
  %104 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %105

105:                                              ; preds = %92, %100
  %106 = phi i32 [ %93, %92 ], [ %104, %100 ]
  %107 = phi double [ %94, %92 ], [ %103, %100 ]
  %108 = add nuw nsw i32 %95, 1
  %109 = icmp slt i32 %108, %106
  br i1 %109, label %92, label %110, !llvm.loop !174

110:                                              ; preds = %105, %72, %4
  %111 = tail call i64 @clock() #17
  store i64 %111, ptr @end_time, align 8, !tbaa !26
  %112 = load i64, ptr @start_time, align 8, !tbaa !26
  %113 = load ptr, ptr @results, align 8, !tbaa !5
  %114 = icmp eq ptr %113, null
  br i1 %114, label %115, label %117

115:                                              ; preds = %110
  %116 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %121

117:                                              ; preds = %110
  %118 = load i32, ptr @current_test, align 4, !tbaa !9
  %119 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %120 = icmp slt i32 %118, %119
  br i1 %120, label %133, label %121

121:                                              ; preds = %117, %115
  %122 = phi i32 [ %116, %115 ], [ %119, %117 ]
  %123 = add nsw i32 %122, 10
  store i32 %123, ptr @allocated_results, align 4, !tbaa !9
  %124 = sext i32 %123 to i64
  %125 = shl nsw i64 %124, 4
  %126 = tail call ptr @realloc(ptr noundef %113, i64 noundef %125) #14
  store ptr %126, ptr @results, align 8, !tbaa !5
  %127 = icmp eq ptr %126, null
  br i1 %127, label %130, label %128

128:                                              ; preds = %121
  %129 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %133

130:                                              ; preds = %121
  %131 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %132 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %131)
  tail call void @exit(i32 noundef -1) #15
  unreachable

133:                                              ; preds = %117, %128
  %134 = phi i32 [ %129, %128 ], [ %118, %117 ]
  %135 = phi ptr [ %126, %128 ], [ %113, %117 ]
  %136 = sub nsw i64 %111, %112
  %137 = sitofp i64 %136 to double
  %138 = fdiv double %137, 1.000000e+06
  %139 = sext i32 %134 to i64
  %140 = getelementptr inbounds %struct.one_result, ptr %135, i64 %139
  store double %138, ptr %140, align 8, !tbaa !11
  %141 = getelementptr inbounds %struct.one_result, ptr %135, i64 %139, i32 1
  store ptr %3, ptr %141, align 8, !tbaa !14
  %142 = add nsw i32 %134, 1
  store i32 %142, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Ih28custom_multiple_variable_xorIhEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i8 noundef zeroext %2, i8 noundef zeroext %3, i8 noundef zeroext %4, i8 noundef zeroext %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !26
  %9 = load i32, ptr @iterations, align 4, !tbaa !9
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %128

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  %13 = xor i8 %3, %2
  %14 = xor i8 %13, %4
  %15 = xor i8 %14, %5
  br i1 %12, label %18, label %16

16:                                               ; preds = %11
  %17 = load double, ptr @init_value, align 8, !tbaa !28
  br label %110

18:                                               ; preds = %11
  %19 = zext i32 %1 to i64
  %20 = icmp ult i32 %1, 8
  %21 = icmp ult i32 %1, 32
  %22 = and i64 %19, 4294967264
  %23 = xor i8 %3, %2
  %24 = xor i8 %3, %2
  %25 = xor i8 %23, %4
  %26 = xor i8 %24, %4
  %27 = xor i8 %25, %5
  %28 = insertelement <16 x i8> poison, i8 %27, i64 0
  %29 = shufflevector <16 x i8> %28, <16 x i8> poison, <16 x i32> zeroinitializer
  %30 = xor i8 %26, %5
  %31 = insertelement <16 x i8> poison, i8 %30, i64 0
  %32 = shufflevector <16 x i8> %31, <16 x i8> poison, <16 x i32> zeroinitializer
  %33 = icmp eq i64 %22, %19
  %34 = and i64 %19, 24
  %35 = icmp eq i64 %34, 0
  %36 = and i64 %19, 4294967288
  %37 = xor i8 %3, %2
  %38 = xor i8 %37, %4
  %39 = xor i8 %38, %5
  %40 = insertelement <8 x i8> poison, i8 %39, i64 0
  %41 = shufflevector <8 x i8> %40, <8 x i8> poison, <8 x i32> zeroinitializer
  %42 = icmp eq i64 %36, %19
  br label %43

43:                                               ; preds = %18, %87
  %44 = phi i32 [ %88, %87 ], [ %9, %18 ]
  %45 = phi i32 [ %89, %87 ], [ 0, %18 ]
  br i1 %20, label %80, label %46

46:                                               ; preds = %43
  br i1 %21, label %65, label %47

47:                                               ; preds = %46, %47
  %48 = phi i64 [ %59, %47 ], [ 0, %46 ]
  %49 = phi <16 x i8> [ %57, %47 ], [ zeroinitializer, %46 ]
  %50 = phi <16 x i8> [ %58, %47 ], [ zeroinitializer, %46 ]
  %51 = getelementptr inbounds i8, ptr %0, i64 %48
  %52 = load <16 x i8>, ptr %51, align 1, !tbaa !29
  %53 = getelementptr inbounds i8, ptr %51, i64 16
  %54 = load <16 x i8>, ptr %53, align 1, !tbaa !29
  %55 = xor <16 x i8> %29, %52
  %56 = xor <16 x i8> %32, %54
  %57 = add <16 x i8> %55, %49
  %58 = add <16 x i8> %56, %50
  %59 = add nuw i64 %48, 32
  %60 = icmp eq i64 %59, %22
  br i1 %60, label %61, label %47, !llvm.loop !176

61:                                               ; preds = %47
  %62 = add <16 x i8> %58, %57
  %63 = tail call i8 @llvm.vector.reduce.add.v16i8(<16 x i8> %62)
  br i1 %33, label %103, label %64

64:                                               ; preds = %61
  br i1 %35, label %80, label %65

65:                                               ; preds = %46, %64
  %66 = phi i8 [ 0, %46 ], [ %63, %64 ]
  %67 = phi i64 [ 0, %46 ], [ %22, %64 ]
  %68 = insertelement <8 x i8> <i8 poison, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0>, i8 %66, i64 0
  br label %69

69:                                               ; preds = %69, %65
  %70 = phi i64 [ %67, %65 ], [ %76, %69 ]
  %71 = phi <8 x i8> [ %68, %65 ], [ %75, %69 ]
  %72 = getelementptr inbounds i8, ptr %0, i64 %70
  %73 = load <8 x i8>, ptr %72, align 1, !tbaa !29
  %74 = xor <8 x i8> %41, %73
  %75 = add <8 x i8> %74, %71
  %76 = add nuw i64 %70, 8
  %77 = icmp eq i64 %76, %36
  br i1 %77, label %78, label %69, !llvm.loop !177

78:                                               ; preds = %69
  %79 = tail call i8 @llvm.vector.reduce.add.v8i8(<8 x i8> %75)
  br i1 %42, label %103, label %80

80:                                               ; preds = %43, %64, %78
  %81 = phi i64 [ 0, %43 ], [ %22, %64 ], [ %36, %78 ]
  %82 = phi i8 [ 0, %43 ], [ %63, %64 ], [ %79, %78 ]
  br label %91

83:                                               ; preds = %103
  %84 = load i32, ptr @current_test, align 4, !tbaa !9
  %85 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %84)
  %86 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %87

87:                                               ; preds = %83, %103
  %88 = phi i32 [ %86, %83 ], [ %44, %103 ]
  %89 = add nuw nsw i32 %45, 1
  %90 = icmp slt i32 %89, %88
  br i1 %90, label %43, label %128, !llvm.loop !178

91:                                               ; preds = %80, %91
  %92 = phi i64 [ %101, %91 ], [ %81, %80 ]
  %93 = phi i8 [ %100, %91 ], [ %82, %80 ]
  %94 = getelementptr inbounds i8, ptr %0, i64 %92
  %95 = load i8, ptr %94, align 1, !tbaa !29
  %96 = xor i8 %95, %2
  %97 = xor i8 %96, %3
  %98 = xor i8 %97, %4
  %99 = xor i8 %98, %5
  %100 = add i8 %99, %93
  %101 = add nuw nsw i64 %92, 1
  %102 = icmp eq i64 %101, %19
  br i1 %102, label %103, label %91, !llvm.loop !179

103:                                              ; preds = %91, %78, %61
  %104 = phi i8 [ %63, %61 ], [ %79, %78 ], [ %100, %91 ]
  %105 = load double, ptr @init_value, align 8, !tbaa !28
  %106 = fptoui double %105 to i8
  %107 = xor i8 %15, %106
  %108 = shl i8 %107, 6
  %109 = icmp eq i8 %108, %104
  br i1 %109, label %87, label %83

110:                                              ; preds = %16, %123
  %111 = phi i32 [ %124, %123 ], [ %9, %16 ]
  %112 = phi double [ %125, %123 ], [ %17, %16 ]
  %113 = phi i32 [ %126, %123 ], [ 0, %16 ]
  %114 = fptoui double %112 to i8
  %115 = xor i8 %15, %114
  %116 = and i8 %115, 3
  %117 = icmp eq i8 %116, 0
  br i1 %117, label %123, label %118

118:                                              ; preds = %110
  %119 = load i32, ptr @current_test, align 4, !tbaa !9
  %120 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %119)
  %121 = load double, ptr @init_value, align 8, !tbaa !28
  %122 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %123

123:                                              ; preds = %110, %118
  %124 = phi i32 [ %111, %110 ], [ %122, %118 ]
  %125 = phi double [ %112, %110 ], [ %121, %118 ]
  %126 = add nuw nsw i32 %113, 1
  %127 = icmp slt i32 %126, %124
  br i1 %127, label %110, label %128, !llvm.loop !178

128:                                              ; preds = %123, %87, %7
  %129 = tail call i64 @clock() #17
  store i64 %129, ptr @end_time, align 8, !tbaa !26
  %130 = load i64, ptr @start_time, align 8, !tbaa !26
  %131 = load ptr, ptr @results, align 8, !tbaa !5
  %132 = icmp eq ptr %131, null
  br i1 %132, label %133, label %135

133:                                              ; preds = %128
  %134 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %139

135:                                              ; preds = %128
  %136 = load i32, ptr @current_test, align 4, !tbaa !9
  %137 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %138 = icmp slt i32 %136, %137
  br i1 %138, label %151, label %139

139:                                              ; preds = %135, %133
  %140 = phi i32 [ %134, %133 ], [ %137, %135 ]
  %141 = add nsw i32 %140, 10
  store i32 %141, ptr @allocated_results, align 4, !tbaa !9
  %142 = sext i32 %141 to i64
  %143 = shl nsw i64 %142, 4
  %144 = tail call ptr @realloc(ptr noundef %131, i64 noundef %143) #14
  store ptr %144, ptr @results, align 8, !tbaa !5
  %145 = icmp eq ptr %144, null
  br i1 %145, label %148, label %146

146:                                              ; preds = %139
  %147 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %151

148:                                              ; preds = %139
  %149 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %150 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %149)
  tail call void @exit(i32 noundef -1) #15
  unreachable

151:                                              ; preds = %135, %146
  %152 = phi i32 [ %147, %146 ], [ %136, %135 ]
  %153 = phi ptr [ %144, %146 ], [ %131, %135 ]
  %154 = sub nsw i64 %129, %130
  %155 = sitofp i64 %154 to double
  %156 = fdiv double %155, 1.000000e+06
  %157 = sext i32 %152 to i64
  %158 = getelementptr inbounds %struct.one_result, ptr %153, i64 %157
  store double %156, ptr %158, align 8, !tbaa !11
  %159 = getelementptr inbounds %struct.one_result, ptr %153, i64 %157, i32 1
  store ptr %6, ptr %159, align 8, !tbaa !14
  %160 = add nsw i32 %152, 1
  store i32 %160, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1Is19custom_add_variableIsEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i16 noundef signext %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !26
  %6 = load i32, ptr @iterations, align 4, !tbaa !9
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %86

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  br i1 %9, label %12, label %10

10:                                               ; preds = %8
  %11 = load double, ptr @init_value, align 8, !tbaa !28
  br label %68

12:                                               ; preds = %8
  %13 = zext i32 %1 to i64
  %14 = icmp ult i32 %1, 16
  %15 = and i64 %13, 4294967280
  %16 = insertelement <8 x i16> poison, i16 %2, i64 0
  %17 = shufflevector <8 x i16> %16, <8 x i16> poison, <8 x i32> zeroinitializer
  %18 = insertelement <8 x i16> poison, i16 %2, i64 0
  %19 = shufflevector <8 x i16> %18, <8 x i16> poison, <8 x i32> zeroinitializer
  %20 = icmp eq i64 %15, %13
  br label %21

21:                                               ; preds = %12, %48
  %22 = phi i32 [ %49, %48 ], [ %6, %12 ]
  %23 = phi i32 [ %50, %48 ], [ 0, %12 ]
  br i1 %14, label %41, label %24

24:                                               ; preds = %21, %24
  %25 = phi i64 [ %36, %24 ], [ 0, %21 ]
  %26 = phi <8 x i16> [ %34, %24 ], [ zeroinitializer, %21 ]
  %27 = phi <8 x i16> [ %35, %24 ], [ zeroinitializer, %21 ]
  %28 = getelementptr inbounds i16, ptr %0, i64 %25
  %29 = load <8 x i16>, ptr %28, align 2, !tbaa !30
  %30 = getelementptr inbounds i16, ptr %28, i64 8
  %31 = load <8 x i16>, ptr %30, align 2, !tbaa !30
  %32 = add <8 x i16> %26, %17
  %33 = add <8 x i16> %27, %19
  %34 = add <8 x i16> %32, %29
  %35 = add <8 x i16> %33, %31
  %36 = add nuw i64 %25, 16
  %37 = icmp eq i64 %36, %15
  br i1 %37, label %38, label %24, !llvm.loop !180

38:                                               ; preds = %24
  %39 = add <8 x i16> %35, %34
  %40 = tail call i16 @llvm.vector.reduce.add.v8i16(<8 x i16> %39)
  br i1 %20, label %61, label %41

41:                                               ; preds = %21, %38
  %42 = phi i64 [ 0, %21 ], [ %15, %38 ]
  %43 = phi i16 [ 0, %21 ], [ %40, %38 ]
  br label %52

44:                                               ; preds = %61
  %45 = load i32, ptr @current_test, align 4, !tbaa !9
  %46 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %45)
  %47 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %48

48:                                               ; preds = %44, %61
  %49 = phi i32 [ %47, %44 ], [ %22, %61 ]
  %50 = add nuw nsw i32 %23, 1
  %51 = icmp slt i32 %50, %49
  br i1 %51, label %21, label %86, !llvm.loop !181

52:                                               ; preds = %41, %52
  %53 = phi i64 [ %59, %52 ], [ %42, %41 ]
  %54 = phi i16 [ %58, %52 ], [ %43, %41 ]
  %55 = getelementptr inbounds i16, ptr %0, i64 %53
  %56 = load i16, ptr %55, align 2, !tbaa !30
  %57 = add i16 %54, %2
  %58 = add i16 %57, %56
  %59 = add nuw nsw i64 %53, 1
  %60 = icmp eq i64 %59, %13
  br i1 %60, label %61, label %52, !llvm.loop !182

61:                                               ; preds = %52, %38
  %62 = phi i16 [ %40, %38 ], [ %58, %52 ]
  %63 = load double, ptr @init_value, align 8, !tbaa !28
  %64 = fptosi double %63 to i16
  %65 = add i16 %64, %2
  %66 = mul i16 %65, 8000
  %67 = icmp eq i16 %66, %62
  br i1 %67, label %48, label %44

68:                                               ; preds = %10, %81
  %69 = phi i32 [ %82, %81 ], [ %6, %10 ]
  %70 = phi double [ %83, %81 ], [ %11, %10 ]
  %71 = phi i32 [ %84, %81 ], [ 0, %10 ]
  %72 = fptosi double %70 to i16
  %73 = add i16 %72, %2
  %74 = mul i16 %73, 8000
  %75 = icmp eq i16 %74, 0
  br i1 %75, label %81, label %76

76:                                               ; preds = %68
  %77 = load i32, ptr @current_test, align 4, !tbaa !9
  %78 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %77)
  %79 = load double, ptr @init_value, align 8, !tbaa !28
  %80 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %81

81:                                               ; preds = %68, %76
  %82 = phi i32 [ %69, %68 ], [ %80, %76 ]
  %83 = phi double [ %70, %68 ], [ %79, %76 ]
  %84 = add nuw nsw i32 %71, 1
  %85 = icmp slt i32 %84, %82
  br i1 %85, label %68, label %86, !llvm.loop !181

86:                                               ; preds = %81, %48, %4
  %87 = tail call i64 @clock() #17
  store i64 %87, ptr @end_time, align 8, !tbaa !26
  %88 = load i64, ptr @start_time, align 8, !tbaa !26
  %89 = load ptr, ptr @results, align 8, !tbaa !5
  %90 = icmp eq ptr %89, null
  br i1 %90, label %91, label %93

91:                                               ; preds = %86
  %92 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %97

93:                                               ; preds = %86
  %94 = load i32, ptr @current_test, align 4, !tbaa !9
  %95 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %96 = icmp slt i32 %94, %95
  br i1 %96, label %109, label %97

97:                                               ; preds = %93, %91
  %98 = phi i32 [ %92, %91 ], [ %95, %93 ]
  %99 = add nsw i32 %98, 10
  store i32 %99, ptr @allocated_results, align 4, !tbaa !9
  %100 = sext i32 %99 to i64
  %101 = shl nsw i64 %100, 4
  %102 = tail call ptr @realloc(ptr noundef %89, i64 noundef %101) #14
  store ptr %102, ptr @results, align 8, !tbaa !5
  %103 = icmp eq ptr %102, null
  br i1 %103, label %106, label %104

104:                                              ; preds = %97
  %105 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %109

106:                                              ; preds = %97
  %107 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %108 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %107)
  tail call void @exit(i32 noundef -1) #15
  unreachable

109:                                              ; preds = %93, %104
  %110 = phi i32 [ %105, %104 ], [ %94, %93 ]
  %111 = phi ptr [ %102, %104 ], [ %89, %93 ]
  %112 = sub nsw i64 %87, %88
  %113 = sitofp i64 %112 to double
  %114 = fdiv double %113, 1.000000e+06
  %115 = sext i32 %110 to i64
  %116 = getelementptr inbounds %struct.one_result, ptr %111, i64 %115
  store double %114, ptr %116, align 8, !tbaa !11
  %117 = getelementptr inbounds %struct.one_result, ptr %111, i64 %115, i32 1
  store ptr %3, ptr %117, align 8, !tbaa !14
  %118 = add nsw i32 %110, 1
  store i32 %118, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z22test_hoisted_variable1Is19custom_add_variableIsEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i16 noundef signext %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !26
  %6 = load i32, ptr @iterations, align 4, !tbaa !9
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %82

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  %10 = trunc i32 %1 to i16
  %11 = mul i16 %10, %2
  br i1 %9, label %14, label %12

12:                                               ; preds = %8
  %13 = load double, ptr @init_value, align 8, !tbaa !28
  br label %64

14:                                               ; preds = %8
  %15 = zext i32 %1 to i64
  %16 = icmp ult i32 %1, 16
  %17 = and i64 %15, 4294967280
  %18 = icmp eq i64 %17, %15
  br label %19

19:                                               ; preds = %14, %44
  %20 = phi i32 [ %45, %44 ], [ %6, %14 ]
  %21 = phi i32 [ %46, %44 ], [ 0, %14 ]
  br i1 %16, label %37, label %22

22:                                               ; preds = %19, %22
  %23 = phi i64 [ %32, %22 ], [ 0, %19 ]
  %24 = phi <8 x i16> [ %30, %22 ], [ zeroinitializer, %19 ]
  %25 = phi <8 x i16> [ %31, %22 ], [ zeroinitializer, %19 ]
  %26 = getelementptr inbounds i16, ptr %0, i64 %23
  %27 = load <8 x i16>, ptr %26, align 2, !tbaa !30
  %28 = getelementptr inbounds i16, ptr %26, i64 8
  %29 = load <8 x i16>, ptr %28, align 2, !tbaa !30
  %30 = add <8 x i16> %27, %24
  %31 = add <8 x i16> %29, %25
  %32 = add nuw i64 %23, 16
  %33 = icmp eq i64 %32, %17
  br i1 %33, label %34, label %22, !llvm.loop !183

34:                                               ; preds = %22
  %35 = add <8 x i16> %31, %30
  %36 = tail call i16 @llvm.vector.reduce.add.v8i16(<8 x i16> %35)
  br i1 %18, label %56, label %37

37:                                               ; preds = %19, %34
  %38 = phi i64 [ 0, %19 ], [ %17, %34 ]
  %39 = phi i16 [ 0, %19 ], [ %36, %34 ]
  br label %48

40:                                               ; preds = %56
  %41 = load i32, ptr @current_test, align 4, !tbaa !9
  %42 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %41)
  %43 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %44

44:                                               ; preds = %40, %56
  %45 = phi i32 [ %43, %40 ], [ %20, %56 ]
  %46 = add nuw nsw i32 %21, 1
  %47 = icmp slt i32 %46, %45
  br i1 %47, label %19, label %82, !llvm.loop !184

48:                                               ; preds = %37, %48
  %49 = phi i64 [ %54, %48 ], [ %38, %37 ]
  %50 = phi i16 [ %53, %48 ], [ %39, %37 ]
  %51 = getelementptr inbounds i16, ptr %0, i64 %49
  %52 = load i16, ptr %51, align 2, !tbaa !30
  %53 = add i16 %52, %50
  %54 = add nuw nsw i64 %49, 1
  %55 = icmp eq i64 %54, %15
  br i1 %55, label %56, label %48, !llvm.loop !185

56:                                               ; preds = %48, %34
  %57 = phi i16 [ %36, %34 ], [ %53, %48 ]
  %58 = add i16 %57, %11
  %59 = load double, ptr @init_value, align 8, !tbaa !28
  %60 = fptosi double %59 to i16
  %61 = add i16 %60, %2
  %62 = mul i16 %61, 8000
  %63 = icmp eq i16 %62, %58
  br i1 %63, label %44, label %40

64:                                               ; preds = %12, %77
  %65 = phi i32 [ %78, %77 ], [ %6, %12 ]
  %66 = phi double [ %79, %77 ], [ %13, %12 ]
  %67 = phi i32 [ %80, %77 ], [ 0, %12 ]
  %68 = fptosi double %66 to i16
  %69 = add i16 %68, %2
  %70 = mul i16 %69, 8000
  %71 = icmp eq i16 %70, %11
  br i1 %71, label %77, label %72

72:                                               ; preds = %64
  %73 = load i32, ptr @current_test, align 4, !tbaa !9
  %74 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %73)
  %75 = load double, ptr @init_value, align 8, !tbaa !28
  %76 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %77

77:                                               ; preds = %64, %72
  %78 = phi i32 [ %65, %64 ], [ %76, %72 ]
  %79 = phi double [ %66, %64 ], [ %75, %72 ]
  %80 = add nuw nsw i32 %67, 1
  %81 = icmp slt i32 %80, %78
  br i1 %81, label %64, label %82, !llvm.loop !184

82:                                               ; preds = %77, %44, %4
  %83 = tail call i64 @clock() #17
  store i64 %83, ptr @end_time, align 8, !tbaa !26
  %84 = load i64, ptr @start_time, align 8, !tbaa !26
  %85 = load ptr, ptr @results, align 8, !tbaa !5
  %86 = icmp eq ptr %85, null
  br i1 %86, label %87, label %89

87:                                               ; preds = %82
  %88 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %93

89:                                               ; preds = %82
  %90 = load i32, ptr @current_test, align 4, !tbaa !9
  %91 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %92 = icmp slt i32 %90, %91
  br i1 %92, label %105, label %93

93:                                               ; preds = %89, %87
  %94 = phi i32 [ %88, %87 ], [ %91, %89 ]
  %95 = add nsw i32 %94, 10
  store i32 %95, ptr @allocated_results, align 4, !tbaa !9
  %96 = sext i32 %95 to i64
  %97 = shl nsw i64 %96, 4
  %98 = tail call ptr @realloc(ptr noundef %85, i64 noundef %97) #14
  store ptr %98, ptr @results, align 8, !tbaa !5
  %99 = icmp eq ptr %98, null
  br i1 %99, label %102, label %100

100:                                              ; preds = %93
  %101 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %105

102:                                              ; preds = %93
  %103 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %104 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %103)
  tail call void @exit(i32 noundef -1) #15
  unreachable

105:                                              ; preds = %89, %100
  %106 = phi i32 [ %101, %100 ], [ %90, %89 ]
  %107 = phi ptr [ %98, %100 ], [ %85, %89 ]
  %108 = sub nsw i64 %83, %84
  %109 = sitofp i64 %108 to double
  %110 = fdiv double %109, 1.000000e+06
  %111 = sext i32 %106 to i64
  %112 = getelementptr inbounds %struct.one_result, ptr %107, i64 %111
  store double %110, ptr %112, align 8, !tbaa !11
  %113 = getelementptr inbounds %struct.one_result, ptr %107, i64 %111, i32 1
  store ptr %3, ptr %113, align 8, !tbaa !14
  %114 = add nsw i32 %106, 1
  store i32 %114, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Is28custom_add_multiple_variableIsEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i16 noundef signext %2, i16 noundef signext %3, i16 noundef signext %4, i16 noundef signext %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !26
  %9 = load i32, ptr @iterations, align 4, !tbaa !9
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %92

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  %13 = add i16 %3, %2
  %14 = add i16 %13, %4
  %15 = add i16 %14, %5
  br i1 %12, label %18, label %16

16:                                               ; preds = %11
  %17 = load double, ptr @init_value, align 8, !tbaa !28
  br label %74

18:                                               ; preds = %11
  %19 = zext i32 %1 to i64
  %20 = icmp ult i32 %1, 16
  %21 = and i64 %19, 4294967280
  %22 = insertelement <8 x i16> poison, i16 %15, i64 0
  %23 = shufflevector <8 x i16> %22, <8 x i16> poison, <8 x i32> zeroinitializer
  %24 = insertelement <8 x i16> poison, i16 %15, i64 0
  %25 = shufflevector <8 x i16> %24, <8 x i16> poison, <8 x i32> zeroinitializer
  %26 = icmp eq i64 %21, %19
  br label %27

27:                                               ; preds = %18, %54
  %28 = phi i32 [ %55, %54 ], [ %9, %18 ]
  %29 = phi i32 [ %56, %54 ], [ 0, %18 ]
  br i1 %20, label %47, label %30

30:                                               ; preds = %27, %30
  %31 = phi i64 [ %42, %30 ], [ 0, %27 ]
  %32 = phi <8 x i16> [ %40, %30 ], [ zeroinitializer, %27 ]
  %33 = phi <8 x i16> [ %41, %30 ], [ zeroinitializer, %27 ]
  %34 = getelementptr inbounds i16, ptr %0, i64 %31
  %35 = load <8 x i16>, ptr %34, align 2, !tbaa !30
  %36 = getelementptr inbounds i16, ptr %34, i64 8
  %37 = load <8 x i16>, ptr %36, align 2, !tbaa !30
  %38 = add <8 x i16> %23, %32
  %39 = add <8 x i16> %25, %33
  %40 = add <8 x i16> %38, %35
  %41 = add <8 x i16> %39, %37
  %42 = add nuw i64 %31, 16
  %43 = icmp eq i64 %42, %21
  br i1 %43, label %44, label %30, !llvm.loop !186

44:                                               ; preds = %30
  %45 = add <8 x i16> %41, %40
  %46 = tail call i16 @llvm.vector.reduce.add.v8i16(<8 x i16> %45)
  br i1 %26, label %67, label %47

47:                                               ; preds = %27, %44
  %48 = phi i64 [ 0, %27 ], [ %21, %44 ]
  %49 = phi i16 [ 0, %27 ], [ %46, %44 ]
  br label %58

50:                                               ; preds = %67
  %51 = load i32, ptr @current_test, align 4, !tbaa !9
  %52 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %51)
  %53 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %54

54:                                               ; preds = %50, %67
  %55 = phi i32 [ %53, %50 ], [ %28, %67 ]
  %56 = add nuw nsw i32 %29, 1
  %57 = icmp slt i32 %56, %55
  br i1 %57, label %27, label %92, !llvm.loop !187

58:                                               ; preds = %47, %58
  %59 = phi i64 [ %65, %58 ], [ %48, %47 ]
  %60 = phi i16 [ %64, %58 ], [ %49, %47 ]
  %61 = getelementptr inbounds i16, ptr %0, i64 %59
  %62 = load i16, ptr %61, align 2, !tbaa !30
  %63 = add i16 %15, %60
  %64 = add i16 %63, %62
  %65 = add nuw nsw i64 %59, 1
  %66 = icmp eq i64 %65, %19
  br i1 %66, label %67, label %58, !llvm.loop !188

67:                                               ; preds = %58, %44
  %68 = phi i16 [ %46, %44 ], [ %64, %58 ]
  %69 = load double, ptr @init_value, align 8, !tbaa !28
  %70 = fptosi double %69 to i16
  %71 = add i16 %15, %70
  %72 = mul i16 %71, 8000
  %73 = icmp eq i16 %72, %68
  br i1 %73, label %54, label %50

74:                                               ; preds = %16, %87
  %75 = phi i32 [ %88, %87 ], [ %9, %16 ]
  %76 = phi double [ %89, %87 ], [ %17, %16 ]
  %77 = phi i32 [ %90, %87 ], [ 0, %16 ]
  %78 = fptosi double %76 to i16
  %79 = add i16 %15, %78
  %80 = mul i16 %79, 8000
  %81 = icmp eq i16 %80, 0
  br i1 %81, label %87, label %82

82:                                               ; preds = %74
  %83 = load i32, ptr @current_test, align 4, !tbaa !9
  %84 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %83)
  %85 = load double, ptr @init_value, align 8, !tbaa !28
  %86 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %87

87:                                               ; preds = %74, %82
  %88 = phi i32 [ %75, %74 ], [ %86, %82 ]
  %89 = phi double [ %76, %74 ], [ %85, %82 ]
  %90 = add nuw nsw i32 %77, 1
  %91 = icmp slt i32 %90, %88
  br i1 %91, label %74, label %92, !llvm.loop !187

92:                                               ; preds = %87, %54, %7
  %93 = tail call i64 @clock() #17
  store i64 %93, ptr @end_time, align 8, !tbaa !26
  %94 = load i64, ptr @start_time, align 8, !tbaa !26
  %95 = load ptr, ptr @results, align 8, !tbaa !5
  %96 = icmp eq ptr %95, null
  br i1 %96, label %97, label %99

97:                                               ; preds = %92
  %98 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %103

99:                                               ; preds = %92
  %100 = load i32, ptr @current_test, align 4, !tbaa !9
  %101 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %102 = icmp slt i32 %100, %101
  br i1 %102, label %115, label %103

103:                                              ; preds = %99, %97
  %104 = phi i32 [ %98, %97 ], [ %101, %99 ]
  %105 = add nsw i32 %104, 10
  store i32 %105, ptr @allocated_results, align 4, !tbaa !9
  %106 = sext i32 %105 to i64
  %107 = shl nsw i64 %106, 4
  %108 = tail call ptr @realloc(ptr noundef %95, i64 noundef %107) #14
  store ptr %108, ptr @results, align 8, !tbaa !5
  %109 = icmp eq ptr %108, null
  br i1 %109, label %112, label %110

110:                                              ; preds = %103
  %111 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %115

112:                                              ; preds = %103
  %113 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %114 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %113)
  tail call void @exit(i32 noundef -1) #15
  unreachable

115:                                              ; preds = %99, %110
  %116 = phi i32 [ %111, %110 ], [ %100, %99 ]
  %117 = phi ptr [ %108, %110 ], [ %95, %99 ]
  %118 = sub nsw i64 %93, %94
  %119 = sitofp i64 %118 to double
  %120 = fdiv double %119, 1.000000e+06
  %121 = sext i32 %116 to i64
  %122 = getelementptr inbounds %struct.one_result, ptr %117, i64 %121
  store double %120, ptr %122, align 8, !tbaa !11
  %123 = getelementptr inbounds %struct.one_result, ptr %117, i64 %121, i32 1
  store ptr %6, ptr %123, align 8, !tbaa !14
  %124 = add nsw i32 %116, 1
  store i32 %124, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1Is19custom_sub_variableIsEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i16 noundef signext %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !26
  %6 = load i32, ptr @iterations, align 4, !tbaa !9
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %86

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  br i1 %9, label %12, label %10

10:                                               ; preds = %8
  %11 = load double, ptr @init_value, align 8, !tbaa !28
  br label %68

12:                                               ; preds = %8
  %13 = zext i32 %1 to i64
  %14 = icmp ult i32 %1, 16
  %15 = and i64 %13, 4294967280
  %16 = insertelement <8 x i16> poison, i16 %2, i64 0
  %17 = shufflevector <8 x i16> %16, <8 x i16> poison, <8 x i32> zeroinitializer
  %18 = insertelement <8 x i16> poison, i16 %2, i64 0
  %19 = shufflevector <8 x i16> %18, <8 x i16> poison, <8 x i32> zeroinitializer
  %20 = icmp eq i64 %15, %13
  br label %21

21:                                               ; preds = %12, %48
  %22 = phi i32 [ %49, %48 ], [ %6, %12 ]
  %23 = phi i32 [ %50, %48 ], [ 0, %12 ]
  br i1 %14, label %41, label %24

24:                                               ; preds = %21, %24
  %25 = phi i64 [ %36, %24 ], [ 0, %21 ]
  %26 = phi <8 x i16> [ %34, %24 ], [ zeroinitializer, %21 ]
  %27 = phi <8 x i16> [ %35, %24 ], [ zeroinitializer, %21 ]
  %28 = getelementptr inbounds i16, ptr %0, i64 %25
  %29 = load <8 x i16>, ptr %28, align 2, !tbaa !30
  %30 = getelementptr inbounds i16, ptr %28, i64 8
  %31 = load <8 x i16>, ptr %30, align 2, !tbaa !30
  %32 = sub <8 x i16> %26, %17
  %33 = sub <8 x i16> %27, %19
  %34 = add <8 x i16> %32, %29
  %35 = add <8 x i16> %33, %31
  %36 = add nuw i64 %25, 16
  %37 = icmp eq i64 %36, %15
  br i1 %37, label %38, label %24, !llvm.loop !189

38:                                               ; preds = %24
  %39 = add <8 x i16> %35, %34
  %40 = tail call i16 @llvm.vector.reduce.add.v8i16(<8 x i16> %39)
  br i1 %20, label %61, label %41

41:                                               ; preds = %21, %38
  %42 = phi i64 [ 0, %21 ], [ %15, %38 ]
  %43 = phi i16 [ 0, %21 ], [ %40, %38 ]
  br label %52

44:                                               ; preds = %61
  %45 = load i32, ptr @current_test, align 4, !tbaa !9
  %46 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %45)
  %47 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %48

48:                                               ; preds = %44, %61
  %49 = phi i32 [ %47, %44 ], [ %22, %61 ]
  %50 = add nuw nsw i32 %23, 1
  %51 = icmp slt i32 %50, %49
  br i1 %51, label %21, label %86, !llvm.loop !190

52:                                               ; preds = %41, %52
  %53 = phi i64 [ %59, %52 ], [ %42, %41 ]
  %54 = phi i16 [ %58, %52 ], [ %43, %41 ]
  %55 = getelementptr inbounds i16, ptr %0, i64 %53
  %56 = load i16, ptr %55, align 2, !tbaa !30
  %57 = sub i16 %54, %2
  %58 = add i16 %57, %56
  %59 = add nuw nsw i64 %53, 1
  %60 = icmp eq i64 %59, %13
  br i1 %60, label %61, label %52, !llvm.loop !191

61:                                               ; preds = %52, %38
  %62 = phi i16 [ %40, %38 ], [ %58, %52 ]
  %63 = load double, ptr @init_value, align 8, !tbaa !28
  %64 = fptosi double %63 to i16
  %65 = sub i16 %64, %2
  %66 = mul i16 %65, 8000
  %67 = icmp eq i16 %66, %62
  br i1 %67, label %48, label %44

68:                                               ; preds = %10, %81
  %69 = phi i32 [ %82, %81 ], [ %6, %10 ]
  %70 = phi double [ %83, %81 ], [ %11, %10 ]
  %71 = phi i32 [ %84, %81 ], [ 0, %10 ]
  %72 = fptosi double %70 to i16
  %73 = sub i16 %72, %2
  %74 = mul i16 %73, 8000
  %75 = icmp eq i16 %74, 0
  br i1 %75, label %81, label %76

76:                                               ; preds = %68
  %77 = load i32, ptr @current_test, align 4, !tbaa !9
  %78 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %77)
  %79 = load double, ptr @init_value, align 8, !tbaa !28
  %80 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %81

81:                                               ; preds = %68, %76
  %82 = phi i32 [ %69, %68 ], [ %80, %76 ]
  %83 = phi double [ %70, %68 ], [ %79, %76 ]
  %84 = add nuw nsw i32 %71, 1
  %85 = icmp slt i32 %84, %82
  br i1 %85, label %68, label %86, !llvm.loop !190

86:                                               ; preds = %81, %48, %4
  %87 = tail call i64 @clock() #17
  store i64 %87, ptr @end_time, align 8, !tbaa !26
  %88 = load i64, ptr @start_time, align 8, !tbaa !26
  %89 = load ptr, ptr @results, align 8, !tbaa !5
  %90 = icmp eq ptr %89, null
  br i1 %90, label %91, label %93

91:                                               ; preds = %86
  %92 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %97

93:                                               ; preds = %86
  %94 = load i32, ptr @current_test, align 4, !tbaa !9
  %95 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %96 = icmp slt i32 %94, %95
  br i1 %96, label %109, label %97

97:                                               ; preds = %93, %91
  %98 = phi i32 [ %92, %91 ], [ %95, %93 ]
  %99 = add nsw i32 %98, 10
  store i32 %99, ptr @allocated_results, align 4, !tbaa !9
  %100 = sext i32 %99 to i64
  %101 = shl nsw i64 %100, 4
  %102 = tail call ptr @realloc(ptr noundef %89, i64 noundef %101) #14
  store ptr %102, ptr @results, align 8, !tbaa !5
  %103 = icmp eq ptr %102, null
  br i1 %103, label %106, label %104

104:                                              ; preds = %97
  %105 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %109

106:                                              ; preds = %97
  %107 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %108 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %107)
  tail call void @exit(i32 noundef -1) #15
  unreachable

109:                                              ; preds = %93, %104
  %110 = phi i32 [ %105, %104 ], [ %94, %93 ]
  %111 = phi ptr [ %102, %104 ], [ %89, %93 ]
  %112 = sub nsw i64 %87, %88
  %113 = sitofp i64 %112 to double
  %114 = fdiv double %113, 1.000000e+06
  %115 = sext i32 %110 to i64
  %116 = getelementptr inbounds %struct.one_result, ptr %111, i64 %115
  store double %114, ptr %116, align 8, !tbaa !11
  %117 = getelementptr inbounds %struct.one_result, ptr %111, i64 %115, i32 1
  store ptr %3, ptr %117, align 8, !tbaa !14
  %118 = add nsw i32 %110, 1
  store i32 %118, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Is28custom_sub_multiple_variableIsEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i16 noundef signext %2, i16 noundef signext %3, i16 noundef signext %4, i16 noundef signext %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !26
  %9 = load i32, ptr @iterations, align 4, !tbaa !9
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %92

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  %13 = add i16 %3, %2
  %14 = add i16 %13, %4
  %15 = add i16 %14, %5
  br i1 %12, label %18, label %16

16:                                               ; preds = %11
  %17 = load double, ptr @init_value, align 8, !tbaa !28
  br label %74

18:                                               ; preds = %11
  %19 = zext i32 %1 to i64
  %20 = icmp ult i32 %1, 16
  %21 = and i64 %19, 4294967280
  %22 = insertelement <8 x i16> poison, i16 %15, i64 0
  %23 = shufflevector <8 x i16> %22, <8 x i16> poison, <8 x i32> zeroinitializer
  %24 = insertelement <8 x i16> poison, i16 %15, i64 0
  %25 = shufflevector <8 x i16> %24, <8 x i16> poison, <8 x i32> zeroinitializer
  %26 = icmp eq i64 %21, %19
  br label %27

27:                                               ; preds = %18, %54
  %28 = phi i32 [ %55, %54 ], [ %9, %18 ]
  %29 = phi i32 [ %56, %54 ], [ 0, %18 ]
  br i1 %20, label %47, label %30

30:                                               ; preds = %27, %30
  %31 = phi i64 [ %42, %30 ], [ 0, %27 ]
  %32 = phi <8 x i16> [ %40, %30 ], [ zeroinitializer, %27 ]
  %33 = phi <8 x i16> [ %41, %30 ], [ zeroinitializer, %27 ]
  %34 = getelementptr inbounds i16, ptr %0, i64 %31
  %35 = load <8 x i16>, ptr %34, align 2, !tbaa !30
  %36 = getelementptr inbounds i16, ptr %34, i64 8
  %37 = load <8 x i16>, ptr %36, align 2, !tbaa !30
  %38 = sub <8 x i16> %32, %23
  %39 = sub <8 x i16> %33, %25
  %40 = add <8 x i16> %38, %35
  %41 = add <8 x i16> %39, %37
  %42 = add nuw i64 %31, 16
  %43 = icmp eq i64 %42, %21
  br i1 %43, label %44, label %30, !llvm.loop !192

44:                                               ; preds = %30
  %45 = add <8 x i16> %41, %40
  %46 = tail call i16 @llvm.vector.reduce.add.v8i16(<8 x i16> %45)
  br i1 %26, label %67, label %47

47:                                               ; preds = %27, %44
  %48 = phi i64 [ 0, %27 ], [ %21, %44 ]
  %49 = phi i16 [ 0, %27 ], [ %46, %44 ]
  br label %58

50:                                               ; preds = %67
  %51 = load i32, ptr @current_test, align 4, !tbaa !9
  %52 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %51)
  %53 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %54

54:                                               ; preds = %50, %67
  %55 = phi i32 [ %53, %50 ], [ %28, %67 ]
  %56 = add nuw nsw i32 %29, 1
  %57 = icmp slt i32 %56, %55
  br i1 %57, label %27, label %92, !llvm.loop !193

58:                                               ; preds = %47, %58
  %59 = phi i64 [ %65, %58 ], [ %48, %47 ]
  %60 = phi i16 [ %64, %58 ], [ %49, %47 ]
  %61 = getelementptr inbounds i16, ptr %0, i64 %59
  %62 = load i16, ptr %61, align 2, !tbaa !30
  %63 = sub i16 %60, %15
  %64 = add i16 %63, %62
  %65 = add nuw nsw i64 %59, 1
  %66 = icmp eq i64 %65, %19
  br i1 %66, label %67, label %58, !llvm.loop !194

67:                                               ; preds = %58, %44
  %68 = phi i16 [ %46, %44 ], [ %64, %58 ]
  %69 = load double, ptr @init_value, align 8, !tbaa !28
  %70 = fptosi double %69 to i16
  %71 = sub i16 %70, %15
  %72 = mul i16 %71, 8000
  %73 = icmp eq i16 %72, %68
  br i1 %73, label %54, label %50

74:                                               ; preds = %16, %87
  %75 = phi i32 [ %88, %87 ], [ %9, %16 ]
  %76 = phi double [ %89, %87 ], [ %17, %16 ]
  %77 = phi i32 [ %90, %87 ], [ 0, %16 ]
  %78 = fptosi double %76 to i16
  %79 = sub i16 %78, %15
  %80 = mul i16 %79, 8000
  %81 = icmp eq i16 %80, 0
  br i1 %81, label %87, label %82

82:                                               ; preds = %74
  %83 = load i32, ptr @current_test, align 4, !tbaa !9
  %84 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %83)
  %85 = load double, ptr @init_value, align 8, !tbaa !28
  %86 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %87

87:                                               ; preds = %74, %82
  %88 = phi i32 [ %75, %74 ], [ %86, %82 ]
  %89 = phi double [ %76, %74 ], [ %85, %82 ]
  %90 = add nuw nsw i32 %77, 1
  %91 = icmp slt i32 %90, %88
  br i1 %91, label %74, label %92, !llvm.loop !193

92:                                               ; preds = %87, %54, %7
  %93 = tail call i64 @clock() #17
  store i64 %93, ptr @end_time, align 8, !tbaa !26
  %94 = load i64, ptr @start_time, align 8, !tbaa !26
  %95 = load ptr, ptr @results, align 8, !tbaa !5
  %96 = icmp eq ptr %95, null
  br i1 %96, label %97, label %99

97:                                               ; preds = %92
  %98 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %103

99:                                               ; preds = %92
  %100 = load i32, ptr @current_test, align 4, !tbaa !9
  %101 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %102 = icmp slt i32 %100, %101
  br i1 %102, label %115, label %103

103:                                              ; preds = %99, %97
  %104 = phi i32 [ %98, %97 ], [ %101, %99 ]
  %105 = add nsw i32 %104, 10
  store i32 %105, ptr @allocated_results, align 4, !tbaa !9
  %106 = sext i32 %105 to i64
  %107 = shl nsw i64 %106, 4
  %108 = tail call ptr @realloc(ptr noundef %95, i64 noundef %107) #14
  store ptr %108, ptr @results, align 8, !tbaa !5
  %109 = icmp eq ptr %108, null
  br i1 %109, label %112, label %110

110:                                              ; preds = %103
  %111 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %115

112:                                              ; preds = %103
  %113 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %114 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %113)
  tail call void @exit(i32 noundef -1) #15
  unreachable

115:                                              ; preds = %99, %110
  %116 = phi i32 [ %111, %110 ], [ %100, %99 ]
  %117 = phi ptr [ %108, %110 ], [ %95, %99 ]
  %118 = sub nsw i64 %93, %94
  %119 = sitofp i64 %118 to double
  %120 = fdiv double %119, 1.000000e+06
  %121 = sext i32 %116 to i64
  %122 = getelementptr inbounds %struct.one_result, ptr %117, i64 %121
  store double %120, ptr %122, align 8, !tbaa !11
  %123 = getelementptr inbounds %struct.one_result, ptr %117, i64 %121, i32 1
  store ptr %6, ptr %123, align 8, !tbaa !14
  %124 = add nsw i32 %116, 1
  store i32 %124, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1Is24custom_multiply_variableIsEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i16 noundef signext %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !26
  %6 = load i32, ptr @iterations, align 4, !tbaa !9
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %85

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  %10 = mul i16 %2, 8000
  br i1 %9, label %13, label %11

11:                                               ; preds = %8
  %12 = load double, ptr @init_value, align 8, !tbaa !28
  br label %68

13:                                               ; preds = %8
  %14 = zext i32 %1 to i64
  %15 = icmp ult i32 %1, 16
  %16 = and i64 %14, 4294967280
  %17 = insertelement <8 x i16> poison, i16 %2, i64 0
  %18 = shufflevector <8 x i16> %17, <8 x i16> poison, <8 x i32> zeroinitializer
  %19 = insertelement <8 x i16> poison, i16 %2, i64 0
  %20 = shufflevector <8 x i16> %19, <8 x i16> poison, <8 x i32> zeroinitializer
  %21 = icmp eq i64 %16, %14
  br label %22

22:                                               ; preds = %13, %49
  %23 = phi i32 [ %50, %49 ], [ %6, %13 ]
  %24 = phi i32 [ %51, %49 ], [ 0, %13 ]
  br i1 %15, label %42, label %25

25:                                               ; preds = %22, %25
  %26 = phi i64 [ %37, %25 ], [ 0, %22 ]
  %27 = phi <8 x i16> [ %35, %25 ], [ zeroinitializer, %22 ]
  %28 = phi <8 x i16> [ %36, %25 ], [ zeroinitializer, %22 ]
  %29 = getelementptr inbounds i16, ptr %0, i64 %26
  %30 = load <8 x i16>, ptr %29, align 2, !tbaa !30
  %31 = getelementptr inbounds i16, ptr %29, i64 8
  %32 = load <8 x i16>, ptr %31, align 2, !tbaa !30
  %33 = mul <8 x i16> %30, %18
  %34 = mul <8 x i16> %32, %20
  %35 = add <8 x i16> %33, %27
  %36 = add <8 x i16> %34, %28
  %37 = add nuw i64 %26, 16
  %38 = icmp eq i64 %37, %16
  br i1 %38, label %39, label %25, !llvm.loop !195

39:                                               ; preds = %25
  %40 = add <8 x i16> %36, %35
  %41 = tail call i16 @llvm.vector.reduce.add.v8i16(<8 x i16> %40)
  br i1 %21, label %62, label %42

42:                                               ; preds = %22, %39
  %43 = phi i64 [ 0, %22 ], [ %16, %39 ]
  %44 = phi i16 [ 0, %22 ], [ %41, %39 ]
  br label %53

45:                                               ; preds = %62
  %46 = load i32, ptr @current_test, align 4, !tbaa !9
  %47 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %46)
  %48 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %49

49:                                               ; preds = %45, %62
  %50 = phi i32 [ %48, %45 ], [ %23, %62 ]
  %51 = add nuw nsw i32 %24, 1
  %52 = icmp slt i32 %51, %50
  br i1 %52, label %22, label %85, !llvm.loop !196

53:                                               ; preds = %42, %53
  %54 = phi i64 [ %60, %53 ], [ %43, %42 ]
  %55 = phi i16 [ %59, %53 ], [ %44, %42 ]
  %56 = getelementptr inbounds i16, ptr %0, i64 %54
  %57 = load i16, ptr %56, align 2, !tbaa !30
  %58 = mul i16 %57, %2
  %59 = add i16 %58, %55
  %60 = add nuw nsw i64 %54, 1
  %61 = icmp eq i64 %60, %14
  br i1 %61, label %62, label %53, !llvm.loop !197

62:                                               ; preds = %53, %39
  %63 = phi i16 [ %41, %39 ], [ %59, %53 ]
  %64 = load double, ptr @init_value, align 8, !tbaa !28
  %65 = fptosi double %64 to i16
  %66 = mul i16 %10, %65
  %67 = icmp eq i16 %66, %63
  br i1 %67, label %49, label %45

68:                                               ; preds = %11, %80
  %69 = phi i32 [ %81, %80 ], [ %6, %11 ]
  %70 = phi double [ %82, %80 ], [ %12, %11 ]
  %71 = phi i32 [ %83, %80 ], [ 0, %11 ]
  %72 = fptosi double %70 to i16
  %73 = mul i16 %10, %72
  %74 = icmp eq i16 %73, 0
  br i1 %74, label %80, label %75

75:                                               ; preds = %68
  %76 = load i32, ptr @current_test, align 4, !tbaa !9
  %77 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %76)
  %78 = load double, ptr @init_value, align 8, !tbaa !28
  %79 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %80

80:                                               ; preds = %68, %75
  %81 = phi i32 [ %69, %68 ], [ %79, %75 ]
  %82 = phi double [ %70, %68 ], [ %78, %75 ]
  %83 = add nuw nsw i32 %71, 1
  %84 = icmp slt i32 %83, %81
  br i1 %84, label %68, label %85, !llvm.loop !196

85:                                               ; preds = %80, %49, %4
  %86 = tail call i64 @clock() #17
  store i64 %86, ptr @end_time, align 8, !tbaa !26
  %87 = load i64, ptr @start_time, align 8, !tbaa !26
  %88 = load ptr, ptr @results, align 8, !tbaa !5
  %89 = icmp eq ptr %88, null
  br i1 %89, label %90, label %92

90:                                               ; preds = %85
  %91 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %96

92:                                               ; preds = %85
  %93 = load i32, ptr @current_test, align 4, !tbaa !9
  %94 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %95 = icmp slt i32 %93, %94
  br i1 %95, label %108, label %96

96:                                               ; preds = %92, %90
  %97 = phi i32 [ %91, %90 ], [ %94, %92 ]
  %98 = add nsw i32 %97, 10
  store i32 %98, ptr @allocated_results, align 4, !tbaa !9
  %99 = sext i32 %98 to i64
  %100 = shl nsw i64 %99, 4
  %101 = tail call ptr @realloc(ptr noundef %88, i64 noundef %100) #14
  store ptr %101, ptr @results, align 8, !tbaa !5
  %102 = icmp eq ptr %101, null
  br i1 %102, label %105, label %103

103:                                              ; preds = %96
  %104 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %108

105:                                              ; preds = %96
  %106 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %107 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %106)
  tail call void @exit(i32 noundef -1) #15
  unreachable

108:                                              ; preds = %92, %103
  %109 = phi i32 [ %104, %103 ], [ %93, %92 ]
  %110 = phi ptr [ %101, %103 ], [ %88, %92 ]
  %111 = sub nsw i64 %86, %87
  %112 = sitofp i64 %111 to double
  %113 = fdiv double %112, 1.000000e+06
  %114 = sext i32 %109 to i64
  %115 = getelementptr inbounds %struct.one_result, ptr %110, i64 %114
  store double %113, ptr %115, align 8, !tbaa !11
  %116 = getelementptr inbounds %struct.one_result, ptr %110, i64 %114, i32 1
  store ptr %3, ptr %116, align 8, !tbaa !14
  %117 = add nsw i32 %109, 1
  store i32 %117, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Is33custom_multiply_multiple_variableIsEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i16 noundef signext %2, i16 noundef signext %3, i16 noundef signext %4, i16 noundef signext %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !26
  %9 = load i32, ptr @iterations, align 4, !tbaa !9
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %93

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  %13 = mul i16 %3, %2
  %14 = mul i16 %13, %4
  %15 = mul i16 %14, %5
  %16 = mul i16 %13, 8000
  %17 = mul i16 %16, %4
  %18 = mul i16 %17, %5
  br i1 %12, label %21, label %19

19:                                               ; preds = %11
  %20 = load double, ptr @init_value, align 8, !tbaa !28
  br label %76

21:                                               ; preds = %11
  %22 = zext i32 %1 to i64
  %23 = icmp ult i32 %1, 16
  %24 = and i64 %22, 4294967280
  %25 = insertelement <8 x i16> poison, i16 %15, i64 0
  %26 = shufflevector <8 x i16> %25, <8 x i16> poison, <8 x i32> zeroinitializer
  %27 = insertelement <8 x i16> poison, i16 %15, i64 0
  %28 = shufflevector <8 x i16> %27, <8 x i16> poison, <8 x i32> zeroinitializer
  %29 = icmp eq i64 %24, %22
  br label %30

30:                                               ; preds = %21, %57
  %31 = phi i32 [ %58, %57 ], [ %9, %21 ]
  %32 = phi i32 [ %59, %57 ], [ 0, %21 ]
  br i1 %23, label %50, label %33

33:                                               ; preds = %30, %33
  %34 = phi i64 [ %45, %33 ], [ 0, %30 ]
  %35 = phi <8 x i16> [ %43, %33 ], [ zeroinitializer, %30 ]
  %36 = phi <8 x i16> [ %44, %33 ], [ zeroinitializer, %30 ]
  %37 = getelementptr inbounds i16, ptr %0, i64 %34
  %38 = load <8 x i16>, ptr %37, align 2, !tbaa !30
  %39 = getelementptr inbounds i16, ptr %37, i64 8
  %40 = load <8 x i16>, ptr %39, align 2, !tbaa !30
  %41 = mul <8 x i16> %26, %38
  %42 = mul <8 x i16> %28, %40
  %43 = add <8 x i16> %41, %35
  %44 = add <8 x i16> %42, %36
  %45 = add nuw i64 %34, 16
  %46 = icmp eq i64 %45, %24
  br i1 %46, label %47, label %33, !llvm.loop !198

47:                                               ; preds = %33
  %48 = add <8 x i16> %44, %43
  %49 = tail call i16 @llvm.vector.reduce.add.v8i16(<8 x i16> %48)
  br i1 %29, label %70, label %50

50:                                               ; preds = %30, %47
  %51 = phi i64 [ 0, %30 ], [ %24, %47 ]
  %52 = phi i16 [ 0, %30 ], [ %49, %47 ]
  br label %61

53:                                               ; preds = %70
  %54 = load i32, ptr @current_test, align 4, !tbaa !9
  %55 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %54)
  %56 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %57

57:                                               ; preds = %53, %70
  %58 = phi i32 [ %56, %53 ], [ %31, %70 ]
  %59 = add nuw nsw i32 %32, 1
  %60 = icmp slt i32 %59, %58
  br i1 %60, label %30, label %93, !llvm.loop !199

61:                                               ; preds = %50, %61
  %62 = phi i64 [ %68, %61 ], [ %51, %50 ]
  %63 = phi i16 [ %67, %61 ], [ %52, %50 ]
  %64 = getelementptr inbounds i16, ptr %0, i64 %62
  %65 = load i16, ptr %64, align 2, !tbaa !30
  %66 = mul i16 %15, %65
  %67 = add i16 %66, %63
  %68 = add nuw nsw i64 %62, 1
  %69 = icmp eq i64 %68, %22
  br i1 %69, label %70, label %61, !llvm.loop !200

70:                                               ; preds = %61, %47
  %71 = phi i16 [ %49, %47 ], [ %67, %61 ]
  %72 = load double, ptr @init_value, align 8, !tbaa !28
  %73 = fptosi double %72 to i16
  %74 = mul i16 %18, %73
  %75 = icmp eq i16 %74, %71
  br i1 %75, label %57, label %53

76:                                               ; preds = %19, %88
  %77 = phi i32 [ %89, %88 ], [ %9, %19 ]
  %78 = phi double [ %90, %88 ], [ %20, %19 ]
  %79 = phi i32 [ %91, %88 ], [ 0, %19 ]
  %80 = fptosi double %78 to i16
  %81 = mul i16 %18, %80
  %82 = icmp eq i16 %81, 0
  br i1 %82, label %88, label %83

83:                                               ; preds = %76
  %84 = load i32, ptr @current_test, align 4, !tbaa !9
  %85 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %84)
  %86 = load double, ptr @init_value, align 8, !tbaa !28
  %87 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %88

88:                                               ; preds = %76, %83
  %89 = phi i32 [ %77, %76 ], [ %87, %83 ]
  %90 = phi double [ %78, %76 ], [ %86, %83 ]
  %91 = add nuw nsw i32 %79, 1
  %92 = icmp slt i32 %91, %89
  br i1 %92, label %76, label %93, !llvm.loop !199

93:                                               ; preds = %88, %57, %7
  %94 = tail call i64 @clock() #17
  store i64 %94, ptr @end_time, align 8, !tbaa !26
  %95 = load i64, ptr @start_time, align 8, !tbaa !26
  %96 = load ptr, ptr @results, align 8, !tbaa !5
  %97 = icmp eq ptr %96, null
  br i1 %97, label %98, label %100

98:                                               ; preds = %93
  %99 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %104

100:                                              ; preds = %93
  %101 = load i32, ptr @current_test, align 4, !tbaa !9
  %102 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %103 = icmp slt i32 %101, %102
  br i1 %103, label %116, label %104

104:                                              ; preds = %100, %98
  %105 = phi i32 [ %99, %98 ], [ %102, %100 ]
  %106 = add nsw i32 %105, 10
  store i32 %106, ptr @allocated_results, align 4, !tbaa !9
  %107 = sext i32 %106 to i64
  %108 = shl nsw i64 %107, 4
  %109 = tail call ptr @realloc(ptr noundef %96, i64 noundef %108) #14
  store ptr %109, ptr @results, align 8, !tbaa !5
  %110 = icmp eq ptr %109, null
  br i1 %110, label %113, label %111

111:                                              ; preds = %104
  %112 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %116

113:                                              ; preds = %104
  %114 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %115 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %114)
  tail call void @exit(i32 noundef -1) #15
  unreachable

116:                                              ; preds = %100, %111
  %117 = phi i32 [ %112, %111 ], [ %101, %100 ]
  %118 = phi ptr [ %109, %111 ], [ %96, %100 ]
  %119 = sub nsw i64 %94, %95
  %120 = sitofp i64 %119 to double
  %121 = fdiv double %120, 1.000000e+06
  %122 = sext i32 %117 to i64
  %123 = getelementptr inbounds %struct.one_result, ptr %118, i64 %122
  store double %121, ptr %123, align 8, !tbaa !11
  %124 = getelementptr inbounds %struct.one_result, ptr %118, i64 %122, i32 1
  store ptr %6, ptr %124, align 8, !tbaa !14
  %125 = add nsw i32 %117, 1
  store i32 %125, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Is34custom_multiply_multiple_variable2IsEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i16 noundef signext %2, i16 noundef signext %3, i16 noundef signext %4, i16 noundef signext %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !26
  %9 = load i32, ptr @iterations, align 4, !tbaa !9
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %92

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  %13 = mul i16 %3, %2
  %14 = mul i16 %13, %4
  %15 = mul i16 %14, %5
  br i1 %12, label %18, label %16

16:                                               ; preds = %11
  %17 = load double, ptr @init_value, align 8, !tbaa !28
  br label %74

18:                                               ; preds = %11
  %19 = zext i32 %1 to i64
  %20 = icmp ult i32 %1, 16
  %21 = and i64 %19, 4294967280
  %22 = insertelement <8 x i16> poison, i16 %15, i64 0
  %23 = shufflevector <8 x i16> %22, <8 x i16> poison, <8 x i32> zeroinitializer
  %24 = insertelement <8 x i16> poison, i16 %15, i64 0
  %25 = shufflevector <8 x i16> %24, <8 x i16> poison, <8 x i32> zeroinitializer
  %26 = icmp eq i64 %21, %19
  br label %27

27:                                               ; preds = %18, %54
  %28 = phi i32 [ %55, %54 ], [ %9, %18 ]
  %29 = phi i32 [ %56, %54 ], [ 0, %18 ]
  br i1 %20, label %47, label %30

30:                                               ; preds = %27, %30
  %31 = phi i64 [ %42, %30 ], [ 0, %27 ]
  %32 = phi <8 x i16> [ %40, %30 ], [ zeroinitializer, %27 ]
  %33 = phi <8 x i16> [ %41, %30 ], [ zeroinitializer, %27 ]
  %34 = getelementptr inbounds i16, ptr %0, i64 %31
  %35 = load <8 x i16>, ptr %34, align 2, !tbaa !30
  %36 = getelementptr inbounds i16, ptr %34, i64 8
  %37 = load <8 x i16>, ptr %36, align 2, !tbaa !30
  %38 = add <8 x i16> %32, %23
  %39 = add <8 x i16> %33, %25
  %40 = add <8 x i16> %38, %35
  %41 = add <8 x i16> %39, %37
  %42 = add nuw i64 %31, 16
  %43 = icmp eq i64 %42, %21
  br i1 %43, label %44, label %30, !llvm.loop !201

44:                                               ; preds = %30
  %45 = add <8 x i16> %41, %40
  %46 = tail call i16 @llvm.vector.reduce.add.v8i16(<8 x i16> %45)
  br i1 %26, label %67, label %47

47:                                               ; preds = %27, %44
  %48 = phi i64 [ 0, %27 ], [ %21, %44 ]
  %49 = phi i16 [ 0, %27 ], [ %46, %44 ]
  br label %58

50:                                               ; preds = %67
  %51 = load i32, ptr @current_test, align 4, !tbaa !9
  %52 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %51)
  %53 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %54

54:                                               ; preds = %50, %67
  %55 = phi i32 [ %53, %50 ], [ %28, %67 ]
  %56 = add nuw nsw i32 %29, 1
  %57 = icmp slt i32 %56, %55
  br i1 %57, label %27, label %92, !llvm.loop !202

58:                                               ; preds = %47, %58
  %59 = phi i64 [ %65, %58 ], [ %48, %47 ]
  %60 = phi i16 [ %64, %58 ], [ %49, %47 ]
  %61 = getelementptr inbounds i16, ptr %0, i64 %59
  %62 = load i16, ptr %61, align 2, !tbaa !30
  %63 = add i16 %60, %15
  %64 = add i16 %63, %62
  %65 = add nuw nsw i64 %59, 1
  %66 = icmp eq i64 %65, %19
  br i1 %66, label %67, label %58, !llvm.loop !203

67:                                               ; preds = %58, %44
  %68 = phi i16 [ %46, %44 ], [ %64, %58 ]
  %69 = load double, ptr @init_value, align 8, !tbaa !28
  %70 = fptosi double %69 to i16
  %71 = add i16 %15, %70
  %72 = mul i16 %71, 8000
  %73 = icmp eq i16 %72, %68
  br i1 %73, label %54, label %50

74:                                               ; preds = %16, %87
  %75 = phi i32 [ %88, %87 ], [ %9, %16 ]
  %76 = phi double [ %89, %87 ], [ %17, %16 ]
  %77 = phi i32 [ %90, %87 ], [ 0, %16 ]
  %78 = fptosi double %76 to i16
  %79 = add i16 %15, %78
  %80 = mul i16 %79, 8000
  %81 = icmp eq i16 %80, 0
  br i1 %81, label %87, label %82

82:                                               ; preds = %74
  %83 = load i32, ptr @current_test, align 4, !tbaa !9
  %84 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %83)
  %85 = load double, ptr @init_value, align 8, !tbaa !28
  %86 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %87

87:                                               ; preds = %74, %82
  %88 = phi i32 [ %75, %74 ], [ %86, %82 ]
  %89 = phi double [ %76, %74 ], [ %85, %82 ]
  %90 = add nuw nsw i32 %77, 1
  %91 = icmp slt i32 %90, %88
  br i1 %91, label %74, label %92, !llvm.loop !202

92:                                               ; preds = %87, %54, %7
  %93 = tail call i64 @clock() #17
  store i64 %93, ptr @end_time, align 8, !tbaa !26
  %94 = load i64, ptr @start_time, align 8, !tbaa !26
  %95 = load ptr, ptr @results, align 8, !tbaa !5
  %96 = icmp eq ptr %95, null
  br i1 %96, label %97, label %99

97:                                               ; preds = %92
  %98 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %103

99:                                               ; preds = %92
  %100 = load i32, ptr @current_test, align 4, !tbaa !9
  %101 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %102 = icmp slt i32 %100, %101
  br i1 %102, label %115, label %103

103:                                              ; preds = %99, %97
  %104 = phi i32 [ %98, %97 ], [ %101, %99 ]
  %105 = add nsw i32 %104, 10
  store i32 %105, ptr @allocated_results, align 4, !tbaa !9
  %106 = sext i32 %105 to i64
  %107 = shl nsw i64 %106, 4
  %108 = tail call ptr @realloc(ptr noundef %95, i64 noundef %107) #14
  store ptr %108, ptr @results, align 8, !tbaa !5
  %109 = icmp eq ptr %108, null
  br i1 %109, label %112, label %110

110:                                              ; preds = %103
  %111 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %115

112:                                              ; preds = %103
  %113 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %114 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %113)
  tail call void @exit(i32 noundef -1) #15
  unreachable

115:                                              ; preds = %99, %110
  %116 = phi i32 [ %111, %110 ], [ %100, %99 ]
  %117 = phi ptr [ %108, %110 ], [ %95, %99 ]
  %118 = sub nsw i64 %93, %94
  %119 = sitofp i64 %118 to double
  %120 = fdiv double %119, 1.000000e+06
  %121 = sext i32 %116 to i64
  %122 = getelementptr inbounds %struct.one_result, ptr %117, i64 %121
  store double %120, ptr %122, align 8, !tbaa !11
  %123 = getelementptr inbounds %struct.one_result, ptr %117, i64 %121, i32 1
  store ptr %6, ptr %123, align 8, !tbaa !14
  %124 = add nsw i32 %116, 1
  store i32 %124, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1Is22custom_divide_variableIsEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i16 noundef signext %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !26
  %6 = load i32, ptr @iterations, align 4, !tbaa !9
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %90

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  %10 = sext i16 %2 to i32
  br i1 %9, label %13, label %11

11:                                               ; preds = %8
  %12 = load double, ptr @init_value, align 8, !tbaa !28
  br label %70

13:                                               ; preds = %8
  %14 = zext i32 %1 to i64
  %15 = and i64 %14, 1
  %16 = icmp eq i32 %1, 1
  %17 = and i64 %14, 4294967294
  %18 = icmp eq i64 %15, 0
  br label %19

19:                                               ; preds = %13, %26
  %20 = phi i32 [ %27, %26 ], [ %6, %13 ]
  %21 = phi i32 [ %28, %26 ], [ 0, %13 ]
  br i1 %16, label %50, label %30

22:                                               ; preds = %61
  %23 = load i32, ptr @current_test, align 4, !tbaa !9
  %24 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %23)
  %25 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %26

26:                                               ; preds = %22, %61
  %27 = phi i32 [ %25, %22 ], [ %20, %61 ]
  %28 = add nuw nsw i32 %21, 1
  %29 = icmp slt i32 %28, %27
  br i1 %29, label %19, label %90, !llvm.loop !204

30:                                               ; preds = %19, %30
  %31 = phi i64 [ %47, %30 ], [ 0, %19 ]
  %32 = phi i16 [ %46, %30 ], [ 0, %19 ]
  %33 = phi i64 [ %48, %30 ], [ 0, %19 ]
  %34 = getelementptr inbounds i16, ptr %0, i64 %31
  %35 = load i16, ptr %34, align 2, !tbaa !30
  %36 = sext i16 %35 to i32
  %37 = sdiv i32 %36, %10
  %38 = trunc i32 %37 to i16
  %39 = add i16 %32, %38
  %40 = or i64 %31, 1
  %41 = getelementptr inbounds i16, ptr %0, i64 %40
  %42 = load i16, ptr %41, align 2, !tbaa !30
  %43 = sext i16 %42 to i32
  %44 = sdiv i32 %43, %10
  %45 = trunc i32 %44 to i16
  %46 = add i16 %39, %45
  %47 = add nuw nsw i64 %31, 2
  %48 = add i64 %33, 2
  %49 = icmp eq i64 %48, %17
  br i1 %49, label %50, label %30, !llvm.loop !205

50:                                               ; preds = %30, %19
  %51 = phi i16 [ undef, %19 ], [ %46, %30 ]
  %52 = phi i64 [ 0, %19 ], [ %47, %30 ]
  %53 = phi i16 [ 0, %19 ], [ %46, %30 ]
  br i1 %18, label %61, label %54

54:                                               ; preds = %50
  %55 = getelementptr inbounds i16, ptr %0, i64 %52
  %56 = load i16, ptr %55, align 2, !tbaa !30
  %57 = sext i16 %56 to i32
  %58 = sdiv i32 %57, %10
  %59 = trunc i32 %58 to i16
  %60 = add i16 %53, %59
  br label %61

61:                                               ; preds = %50, %54
  %62 = phi i16 [ %51, %50 ], [ %60, %54 ]
  %63 = load double, ptr @init_value, align 8, !tbaa !28
  %64 = fptosi double %63 to i16
  %65 = sext i16 %64 to i32
  %66 = sdiv i32 %65, %10
  %67 = trunc i32 %66 to i16
  %68 = mul i16 %67, 8000
  %69 = icmp eq i16 %68, %62
  br i1 %69, label %26, label %22

70:                                               ; preds = %11, %85
  %71 = phi i32 [ %86, %85 ], [ %6, %11 ]
  %72 = phi double [ %87, %85 ], [ %12, %11 ]
  %73 = phi i32 [ %88, %85 ], [ 0, %11 ]
  %74 = fptosi double %72 to i16
  %75 = sext i16 %74 to i32
  %76 = sdiv i32 %75, %10
  %77 = trunc i32 %76 to i16
  %78 = mul i16 %77, 8000
  %79 = icmp eq i16 %78, 0
  br i1 %79, label %85, label %80

80:                                               ; preds = %70
  %81 = load i32, ptr @current_test, align 4, !tbaa !9
  %82 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %81)
  %83 = load double, ptr @init_value, align 8, !tbaa !28
  %84 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %85

85:                                               ; preds = %70, %80
  %86 = phi i32 [ %71, %70 ], [ %84, %80 ]
  %87 = phi double [ %72, %70 ], [ %83, %80 ]
  %88 = add nuw nsw i32 %73, 1
  %89 = icmp slt i32 %88, %86
  br i1 %89, label %70, label %90, !llvm.loop !204

90:                                               ; preds = %85, %26, %4
  %91 = tail call i64 @clock() #17
  store i64 %91, ptr @end_time, align 8, !tbaa !26
  %92 = load i64, ptr @start_time, align 8, !tbaa !26
  %93 = load ptr, ptr @results, align 8, !tbaa !5
  %94 = icmp eq ptr %93, null
  br i1 %94, label %95, label %97

95:                                               ; preds = %90
  %96 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %101

97:                                               ; preds = %90
  %98 = load i32, ptr @current_test, align 4, !tbaa !9
  %99 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %100 = icmp slt i32 %98, %99
  br i1 %100, label %113, label %101

101:                                              ; preds = %97, %95
  %102 = phi i32 [ %96, %95 ], [ %99, %97 ]
  %103 = add nsw i32 %102, 10
  store i32 %103, ptr @allocated_results, align 4, !tbaa !9
  %104 = sext i32 %103 to i64
  %105 = shl nsw i64 %104, 4
  %106 = tail call ptr @realloc(ptr noundef %93, i64 noundef %105) #14
  store ptr %106, ptr @results, align 8, !tbaa !5
  %107 = icmp eq ptr %106, null
  br i1 %107, label %110, label %108

108:                                              ; preds = %101
  %109 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %113

110:                                              ; preds = %101
  %111 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %112 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %111)
  tail call void @exit(i32 noundef -1) #15
  unreachable

113:                                              ; preds = %97, %108
  %114 = phi i32 [ %109, %108 ], [ %98, %97 ]
  %115 = phi ptr [ %106, %108 ], [ %93, %97 ]
  %116 = sub nsw i64 %91, %92
  %117 = sitofp i64 %116 to double
  %118 = fdiv double %117, 1.000000e+06
  %119 = sext i32 %114 to i64
  %120 = getelementptr inbounds %struct.one_result, ptr %115, i64 %119
  store double %118, ptr %120, align 8, !tbaa !11
  %121 = getelementptr inbounds %struct.one_result, ptr %115, i64 %119, i32 1
  store ptr %3, ptr %121, align 8, !tbaa !14
  %122 = add nsw i32 %114, 1
  store i32 %122, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Is31custom_divide_multiple_variableIsEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i16 noundef signext %2, i16 noundef signext %3, i16 noundef signext %4, i16 noundef signext %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !26
  %9 = load i32, ptr @iterations, align 4, !tbaa !9
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %80

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  %13 = sext i16 %2 to i32
  %14 = sext i16 %3 to i32
  %15 = sext i16 %4 to i32
  %16 = sext i16 %5 to i32
  br i1 %12, label %19, label %17

17:                                               ; preds = %11
  %18 = load double, ptr @init_value, align 8, !tbaa !28
  br label %57

19:                                               ; preds = %11
  %20 = zext i32 %1 to i64
  br label %21

21:                                               ; preds = %19, %28
  %22 = phi i32 [ %29, %28 ], [ %9, %19 ]
  %23 = phi i32 [ %30, %28 ], [ 0, %19 ]
  br label %32

24:                                               ; preds = %46
  %25 = load i32, ptr @current_test, align 4, !tbaa !9
  %26 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %25)
  %27 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %28

28:                                               ; preds = %24, %46
  %29 = phi i32 [ %27, %24 ], [ %22, %46 ]
  %30 = add nuw nsw i32 %23, 1
  %31 = icmp slt i32 %30, %29
  br i1 %31, label %21, label %80, !llvm.loop !206

32:                                               ; preds = %21, %32
  %33 = phi i64 [ 0, %21 ], [ %44, %32 ]
  %34 = phi i16 [ 0, %21 ], [ %43, %32 ]
  %35 = getelementptr inbounds i16, ptr %0, i64 %33
  %36 = load i16, ptr %35, align 2, !tbaa !30
  %37 = sext i16 %36 to i32
  %38 = sdiv i32 %37, %13
  %39 = sdiv i32 %38, %14
  %40 = sdiv i32 %39, %15
  %41 = sdiv i32 %40, %16
  %42 = trunc i32 %41 to i16
  %43 = add i16 %34, %42
  %44 = add nuw nsw i64 %33, 1
  %45 = icmp eq i64 %44, %20
  br i1 %45, label %46, label %32, !llvm.loop !207

46:                                               ; preds = %32
  %47 = load double, ptr @init_value, align 8, !tbaa !28
  %48 = fptosi double %47 to i16
  %49 = sext i16 %48 to i32
  %50 = sdiv i32 %49, %13
  %51 = sdiv i32 %50, %14
  %52 = sdiv i32 %51, %15
  %53 = sdiv i32 %52, %16
  %54 = trunc i32 %53 to i16
  %55 = mul i16 %54, 8000
  %56 = icmp eq i16 %55, %43
  br i1 %56, label %28, label %24

57:                                               ; preds = %17, %75
  %58 = phi i32 [ %76, %75 ], [ %9, %17 ]
  %59 = phi double [ %77, %75 ], [ %18, %17 ]
  %60 = phi i32 [ %78, %75 ], [ 0, %17 ]
  %61 = fptosi double %59 to i16
  %62 = sext i16 %61 to i32
  %63 = sdiv i32 %62, %13
  %64 = sdiv i32 %63, %14
  %65 = sdiv i32 %64, %15
  %66 = sdiv i32 %65, %16
  %67 = trunc i32 %66 to i16
  %68 = mul i16 %67, 8000
  %69 = icmp eq i16 %68, 0
  br i1 %69, label %75, label %70

70:                                               ; preds = %57
  %71 = load i32, ptr @current_test, align 4, !tbaa !9
  %72 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %71)
  %73 = load double, ptr @init_value, align 8, !tbaa !28
  %74 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %75

75:                                               ; preds = %57, %70
  %76 = phi i32 [ %58, %57 ], [ %74, %70 ]
  %77 = phi double [ %59, %57 ], [ %73, %70 ]
  %78 = add nuw nsw i32 %60, 1
  %79 = icmp slt i32 %78, %76
  br i1 %79, label %57, label %80, !llvm.loop !206

80:                                               ; preds = %75, %28, %7
  %81 = tail call i64 @clock() #17
  store i64 %81, ptr @end_time, align 8, !tbaa !26
  %82 = load i64, ptr @start_time, align 8, !tbaa !26
  %83 = load ptr, ptr @results, align 8, !tbaa !5
  %84 = icmp eq ptr %83, null
  br i1 %84, label %85, label %87

85:                                               ; preds = %80
  %86 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %91

87:                                               ; preds = %80
  %88 = load i32, ptr @current_test, align 4, !tbaa !9
  %89 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %90 = icmp slt i32 %88, %89
  br i1 %90, label %103, label %91

91:                                               ; preds = %87, %85
  %92 = phi i32 [ %86, %85 ], [ %89, %87 ]
  %93 = add nsw i32 %92, 10
  store i32 %93, ptr @allocated_results, align 4, !tbaa !9
  %94 = sext i32 %93 to i64
  %95 = shl nsw i64 %94, 4
  %96 = tail call ptr @realloc(ptr noundef %83, i64 noundef %95) #14
  store ptr %96, ptr @results, align 8, !tbaa !5
  %97 = icmp eq ptr %96, null
  br i1 %97, label %100, label %98

98:                                               ; preds = %91
  %99 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %103

100:                                              ; preds = %91
  %101 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %102 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %101)
  tail call void @exit(i32 noundef -1) #15
  unreachable

103:                                              ; preds = %87, %98
  %104 = phi i32 [ %99, %98 ], [ %88, %87 ]
  %105 = phi ptr [ %96, %98 ], [ %83, %87 ]
  %106 = sub nsw i64 %81, %82
  %107 = sitofp i64 %106 to double
  %108 = fdiv double %107, 1.000000e+06
  %109 = sext i32 %104 to i64
  %110 = getelementptr inbounds %struct.one_result, ptr %105, i64 %109
  store double %108, ptr %110, align 8, !tbaa !11
  %111 = getelementptr inbounds %struct.one_result, ptr %105, i64 %109, i32 1
  store ptr %6, ptr %111, align 8, !tbaa !14
  %112 = add nsw i32 %104, 1
  store i32 %112, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Is32custom_divide_multiple_variable2IsEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i16 noundef signext %2, i16 noundef signext %3, i16 noundef signext %4, i16 noundef signext %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !26
  %9 = load i32, ptr @iterations, align 4, !tbaa !9
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %97

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  %13 = sext i16 %2 to i32
  %14 = sext i16 %3 to i32
  %15 = sdiv i32 %13, %14
  %16 = sext i16 %4 to i32
  %17 = sdiv i32 %15, %16
  %18 = sext i16 %5 to i32
  %19 = sdiv i32 %17, %18
  %20 = trunc i32 %19 to i16
  br i1 %12, label %23, label %21

21:                                               ; preds = %11
  %22 = load double, ptr @init_value, align 8, !tbaa !28
  br label %79

23:                                               ; preds = %11
  %24 = zext i32 %1 to i64
  %25 = icmp ult i32 %1, 16
  %26 = and i64 %24, 4294967280
  %27 = insertelement <8 x i16> poison, i16 %20, i64 0
  %28 = shufflevector <8 x i16> %27, <8 x i16> poison, <8 x i32> zeroinitializer
  %29 = insertelement <8 x i16> poison, i16 %20, i64 0
  %30 = shufflevector <8 x i16> %29, <8 x i16> poison, <8 x i32> zeroinitializer
  %31 = icmp eq i64 %26, %24
  br label %32

32:                                               ; preds = %59, %23
  %33 = phi i32 [ %9, %23 ], [ %60, %59 ]
  %34 = phi i32 [ 0, %23 ], [ %61, %59 ]
  br i1 %25, label %52, label %35

35:                                               ; preds = %32, %35
  %36 = phi i64 [ %47, %35 ], [ 0, %32 ]
  %37 = phi <8 x i16> [ %45, %35 ], [ zeroinitializer, %32 ]
  %38 = phi <8 x i16> [ %46, %35 ], [ zeroinitializer, %32 ]
  %39 = getelementptr inbounds i16, ptr %0, i64 %36
  %40 = load <8 x i16>, ptr %39, align 2, !tbaa !30
  %41 = getelementptr inbounds i16, ptr %39, i64 8
  %42 = load <8 x i16>, ptr %41, align 2, !tbaa !30
  %43 = add <8 x i16> %40, %37
  %44 = add <8 x i16> %42, %38
  %45 = add <8 x i16> %43, %28
  %46 = add <8 x i16> %44, %30
  %47 = add nuw i64 %36, 16
  %48 = icmp eq i64 %47, %26
  br i1 %48, label %49, label %35, !llvm.loop !208

49:                                               ; preds = %35
  %50 = add <8 x i16> %46, %45
  %51 = tail call i16 @llvm.vector.reduce.add.v8i16(<8 x i16> %50)
  br i1 %31, label %72, label %52

52:                                               ; preds = %32, %49
  %53 = phi i64 [ 0, %32 ], [ %26, %49 ]
  %54 = phi i16 [ 0, %32 ], [ %51, %49 ]
  br label %63

55:                                               ; preds = %72
  %56 = load i32, ptr @current_test, align 4, !tbaa !9
  %57 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %56)
  %58 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %59

59:                                               ; preds = %55, %72
  %60 = phi i32 [ %58, %55 ], [ %33, %72 ]
  %61 = add nuw nsw i32 %34, 1
  %62 = icmp slt i32 %61, %60
  br i1 %62, label %32, label %97, !llvm.loop !209

63:                                               ; preds = %52, %63
  %64 = phi i64 [ %70, %63 ], [ %53, %52 ]
  %65 = phi i16 [ %69, %63 ], [ %54, %52 ]
  %66 = getelementptr inbounds i16, ptr %0, i64 %64
  %67 = load i16, ptr %66, align 2, !tbaa !30
  %68 = add i16 %67, %65
  %69 = add i16 %68, %20
  %70 = add nuw nsw i64 %64, 1
  %71 = icmp eq i64 %70, %24
  br i1 %71, label %72, label %63, !llvm.loop !210

72:                                               ; preds = %63, %49
  %73 = phi i16 [ %51, %49 ], [ %69, %63 ]
  %74 = load double, ptr @init_value, align 8, !tbaa !28
  %75 = fptosi double %74 to i16
  %76 = add i16 %20, %75
  %77 = mul i16 %76, 8000
  %78 = icmp eq i16 %77, %73
  br i1 %78, label %59, label %55

79:                                               ; preds = %21, %92
  %80 = phi i32 [ %93, %92 ], [ %9, %21 ]
  %81 = phi double [ %94, %92 ], [ %22, %21 ]
  %82 = phi i32 [ %95, %92 ], [ 0, %21 ]
  %83 = fptosi double %81 to i16
  %84 = add i16 %20, %83
  %85 = mul i16 %84, 8000
  %86 = icmp eq i16 %85, 0
  br i1 %86, label %92, label %87

87:                                               ; preds = %79
  %88 = load i32, ptr @current_test, align 4, !tbaa !9
  %89 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %88)
  %90 = load double, ptr @init_value, align 8, !tbaa !28
  %91 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %92

92:                                               ; preds = %79, %87
  %93 = phi i32 [ %80, %79 ], [ %91, %87 ]
  %94 = phi double [ %81, %79 ], [ %90, %87 ]
  %95 = add nuw nsw i32 %82, 1
  %96 = icmp slt i32 %95, %93
  br i1 %96, label %79, label %97, !llvm.loop !209

97:                                               ; preds = %92, %59, %7
  %98 = tail call i64 @clock() #17
  store i64 %98, ptr @end_time, align 8, !tbaa !26
  %99 = load i64, ptr @start_time, align 8, !tbaa !26
  %100 = load ptr, ptr @results, align 8, !tbaa !5
  %101 = icmp eq ptr %100, null
  br i1 %101, label %102, label %104

102:                                              ; preds = %97
  %103 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %108

104:                                              ; preds = %97
  %105 = load i32, ptr @current_test, align 4, !tbaa !9
  %106 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %107 = icmp slt i32 %105, %106
  br i1 %107, label %120, label %108

108:                                              ; preds = %104, %102
  %109 = phi i32 [ %103, %102 ], [ %106, %104 ]
  %110 = add nsw i32 %109, 10
  store i32 %110, ptr @allocated_results, align 4, !tbaa !9
  %111 = sext i32 %110 to i64
  %112 = shl nsw i64 %111, 4
  %113 = tail call ptr @realloc(ptr noundef %100, i64 noundef %112) #14
  store ptr %113, ptr @results, align 8, !tbaa !5
  %114 = icmp eq ptr %113, null
  br i1 %114, label %117, label %115

115:                                              ; preds = %108
  %116 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %120

117:                                              ; preds = %108
  %118 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %119 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %118)
  tail call void @exit(i32 noundef -1) #15
  unreachable

120:                                              ; preds = %104, %115
  %121 = phi i32 [ %116, %115 ], [ %105, %104 ]
  %122 = phi ptr [ %113, %115 ], [ %100, %104 ]
  %123 = sub nsw i64 %98, %99
  %124 = sitofp i64 %123 to double
  %125 = fdiv double %124, 1.000000e+06
  %126 = sext i32 %121 to i64
  %127 = getelementptr inbounds %struct.one_result, ptr %122, i64 %126
  store double %125, ptr %127, align 8, !tbaa !11
  %128 = getelementptr inbounds %struct.one_result, ptr %122, i64 %126, i32 1
  store ptr %6, ptr %128, align 8, !tbaa !14
  %129 = add nsw i32 %121, 1
  store i32 %129, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Is30custom_mixed_multiple_variableIsEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i16 noundef signext %2, i16 noundef signext %3, i16 noundef signext %4, i16 noundef signext %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !26
  %9 = load i32, ptr @iterations, align 4, !tbaa !9
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %111

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  %13 = zext i16 %2 to i32
  %14 = sext i16 %3 to i32
  %15 = sext i16 %4 to i32
  %16 = mul nsw i32 %15, %14
  %17 = sext i16 %5 to i32
  %18 = sdiv i32 %16, %17
  %19 = trunc i32 %18 to i16
  br i1 %12, label %22, label %20

20:                                               ; preds = %11
  %21 = load double, ptr @init_value, align 8, !tbaa !28
  br label %92

22:                                               ; preds = %11
  %23 = zext i32 %1 to i64
  %24 = icmp ult i32 %1, 16
  %25 = and i64 %23, 4294967280
  %26 = insertelement <8 x i32> poison, i32 %13, i64 0
  %27 = shufflevector <8 x i32> %26, <8 x i32> poison, <8 x i32> zeroinitializer
  %28 = insertelement <8 x i32> poison, i32 %13, i64 0
  %29 = shufflevector <8 x i32> %28, <8 x i32> poison, <8 x i32> zeroinitializer
  %30 = insertelement <8 x i32> poison, i32 %18, i64 0
  %31 = shufflevector <8 x i32> %30, <8 x i32> poison, <8 x i32> zeroinitializer
  %32 = insertelement <8 x i32> poison, i32 %18, i64 0
  %33 = shufflevector <8 x i32> %32, <8 x i32> poison, <8 x i32> zeroinitializer
  %34 = icmp eq i64 %25, %23
  br label %35

35:                                               ; preds = %68, %22
  %36 = phi i32 [ %9, %22 ], [ %69, %68 ]
  %37 = phi i32 [ 0, %22 ], [ %70, %68 ]
  br i1 %24, label %61, label %38

38:                                               ; preds = %35, %38
  %39 = phi i64 [ %56, %38 ], [ 0, %35 ]
  %40 = phi <8 x i16> [ %54, %38 ], [ zeroinitializer, %35 ]
  %41 = phi <8 x i16> [ %55, %38 ], [ zeroinitializer, %35 ]
  %42 = getelementptr inbounds i16, ptr %0, i64 %39
  %43 = load <8 x i16>, ptr %42, align 2, !tbaa !30
  %44 = getelementptr inbounds i16, ptr %42, i64 8
  %45 = load <8 x i16>, ptr %44, align 2, !tbaa !30
  %46 = zext <8 x i16> %43 to <8 x i32>
  %47 = zext <8 x i16> %45 to <8 x i32>
  %48 = add nuw nsw <8 x i32> %27, %46
  %49 = add nuw nsw <8 x i32> %29, %47
  %50 = sub nsw <8 x i32> %48, %31
  %51 = sub nsw <8 x i32> %49, %33
  %52 = trunc <8 x i32> %50 to <8 x i16>
  %53 = trunc <8 x i32> %51 to <8 x i16>
  %54 = add <8 x i16> %40, %52
  %55 = add <8 x i16> %41, %53
  %56 = add nuw i64 %39, 16
  %57 = icmp eq i64 %56, %25
  br i1 %57, label %58, label %38, !llvm.loop !211

58:                                               ; preds = %38
  %59 = add <8 x i16> %55, %54
  %60 = tail call i16 @llvm.vector.reduce.add.v8i16(<8 x i16> %59)
  br i1 %34, label %84, label %61

61:                                               ; preds = %35, %58
  %62 = phi i64 [ 0, %35 ], [ %25, %58 ]
  %63 = phi i16 [ 0, %35 ], [ %60, %58 ]
  br label %72

64:                                               ; preds = %84
  %65 = load i32, ptr @current_test, align 4, !tbaa !9
  %66 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %65)
  %67 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %68

68:                                               ; preds = %64, %84
  %69 = phi i32 [ %67, %64 ], [ %36, %84 ]
  %70 = add nuw nsw i32 %37, 1
  %71 = icmp slt i32 %70, %69
  br i1 %71, label %35, label %111, !llvm.loop !212

72:                                               ; preds = %61, %72
  %73 = phi i64 [ %82, %72 ], [ %62, %61 ]
  %74 = phi i16 [ %81, %72 ], [ %63, %61 ]
  %75 = getelementptr inbounds i16, ptr %0, i64 %73
  %76 = load i16, ptr %75, align 2, !tbaa !30
  %77 = zext i16 %76 to i32
  %78 = add nuw nsw i32 %77, %13
  %79 = sub nsw i32 %78, %18
  %80 = trunc i32 %79 to i16
  %81 = add i16 %74, %80
  %82 = add nuw nsw i64 %73, 1
  %83 = icmp eq i64 %82, %23
  br i1 %83, label %84, label %72, !llvm.loop !213

84:                                               ; preds = %72, %58
  %85 = phi i16 [ %60, %58 ], [ %81, %72 ]
  %86 = load double, ptr @init_value, align 8, !tbaa !28
  %87 = fptosi double %86 to i16
  %88 = add i16 %87, %2
  %89 = sub i16 %88, %19
  %90 = mul i16 %89, 8000
  %91 = icmp eq i16 %90, %85
  br i1 %91, label %68, label %64

92:                                               ; preds = %20, %106
  %93 = phi i32 [ %107, %106 ], [ %9, %20 ]
  %94 = phi double [ %108, %106 ], [ %21, %20 ]
  %95 = phi i32 [ %109, %106 ], [ 0, %20 ]
  %96 = fptosi double %94 to i16
  %97 = add i16 %96, %2
  %98 = sub i16 %97, %19
  %99 = mul i16 %98, 8000
  %100 = icmp eq i16 %99, 0
  br i1 %100, label %106, label %101

101:                                              ; preds = %92
  %102 = load i32, ptr @current_test, align 4, !tbaa !9
  %103 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %102)
  %104 = load double, ptr @init_value, align 8, !tbaa !28
  %105 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %106

106:                                              ; preds = %92, %101
  %107 = phi i32 [ %93, %92 ], [ %105, %101 ]
  %108 = phi double [ %94, %92 ], [ %104, %101 ]
  %109 = add nuw nsw i32 %95, 1
  %110 = icmp slt i32 %109, %107
  br i1 %110, label %92, label %111, !llvm.loop !212

111:                                              ; preds = %106, %68, %7
  %112 = tail call i64 @clock() #17
  store i64 %112, ptr @end_time, align 8, !tbaa !26
  %113 = load i64, ptr @start_time, align 8, !tbaa !26
  %114 = load ptr, ptr @results, align 8, !tbaa !5
  %115 = icmp eq ptr %114, null
  br i1 %115, label %116, label %118

116:                                              ; preds = %111
  %117 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %122

118:                                              ; preds = %111
  %119 = load i32, ptr @current_test, align 4, !tbaa !9
  %120 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %121 = icmp slt i32 %119, %120
  br i1 %121, label %134, label %122

122:                                              ; preds = %118, %116
  %123 = phi i32 [ %117, %116 ], [ %120, %118 ]
  %124 = add nsw i32 %123, 10
  store i32 %124, ptr @allocated_results, align 4, !tbaa !9
  %125 = sext i32 %124 to i64
  %126 = shl nsw i64 %125, 4
  %127 = tail call ptr @realloc(ptr noundef %114, i64 noundef %126) #14
  store ptr %127, ptr @results, align 8, !tbaa !5
  %128 = icmp eq ptr %127, null
  br i1 %128, label %131, label %129

129:                                              ; preds = %122
  %130 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %134

131:                                              ; preds = %122
  %132 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %133 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %132)
  tail call void @exit(i32 noundef -1) #15
  unreachable

134:                                              ; preds = %118, %129
  %135 = phi i32 [ %130, %129 ], [ %119, %118 ]
  %136 = phi ptr [ %127, %129 ], [ %114, %118 ]
  %137 = sub nsw i64 %112, %113
  %138 = sitofp i64 %137 to double
  %139 = fdiv double %138, 1.000000e+06
  %140 = sext i32 %135 to i64
  %141 = getelementptr inbounds %struct.one_result, ptr %136, i64 %140
  store double %139, ptr %141, align 8, !tbaa !11
  %142 = getelementptr inbounds %struct.one_result, ptr %136, i64 %140, i32 1
  store ptr %6, ptr %142, align 8, !tbaa !14
  %143 = add nsw i32 %135, 1
  store i32 %143, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1Is19custom_variable_andIsEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i16 noundef signext %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !26
  %6 = load i32, ptr @iterations, align 4, !tbaa !9
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %86

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  br i1 %9, label %12, label %10

10:                                               ; preds = %8
  %11 = load double, ptr @init_value, align 8, !tbaa !28
  br label %68

12:                                               ; preds = %8
  %13 = zext i32 %1 to i64
  %14 = icmp ult i32 %1, 16
  %15 = and i64 %13, 4294967280
  %16 = insertelement <8 x i16> poison, i16 %2, i64 0
  %17 = shufflevector <8 x i16> %16, <8 x i16> poison, <8 x i32> zeroinitializer
  %18 = insertelement <8 x i16> poison, i16 %2, i64 0
  %19 = shufflevector <8 x i16> %18, <8 x i16> poison, <8 x i32> zeroinitializer
  %20 = icmp eq i64 %15, %13
  br label %21

21:                                               ; preds = %12, %48
  %22 = phi i32 [ %49, %48 ], [ %6, %12 ]
  %23 = phi i32 [ %50, %48 ], [ 0, %12 ]
  br i1 %14, label %41, label %24

24:                                               ; preds = %21, %24
  %25 = phi i64 [ %36, %24 ], [ 0, %21 ]
  %26 = phi <8 x i16> [ %34, %24 ], [ zeroinitializer, %21 ]
  %27 = phi <8 x i16> [ %35, %24 ], [ zeroinitializer, %21 ]
  %28 = getelementptr inbounds i16, ptr %0, i64 %25
  %29 = load <8 x i16>, ptr %28, align 2, !tbaa !30
  %30 = getelementptr inbounds i16, ptr %28, i64 8
  %31 = load <8 x i16>, ptr %30, align 2, !tbaa !30
  %32 = and <8 x i16> %29, %17
  %33 = and <8 x i16> %31, %19
  %34 = add <8 x i16> %32, %26
  %35 = add <8 x i16> %33, %27
  %36 = add nuw i64 %25, 16
  %37 = icmp eq i64 %36, %15
  br i1 %37, label %38, label %24, !llvm.loop !214

38:                                               ; preds = %24
  %39 = add <8 x i16> %35, %34
  %40 = tail call i16 @llvm.vector.reduce.add.v8i16(<8 x i16> %39)
  br i1 %20, label %61, label %41

41:                                               ; preds = %21, %38
  %42 = phi i64 [ 0, %21 ], [ %15, %38 ]
  %43 = phi i16 [ 0, %21 ], [ %40, %38 ]
  br label %52

44:                                               ; preds = %61
  %45 = load i32, ptr @current_test, align 4, !tbaa !9
  %46 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %45)
  %47 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %48

48:                                               ; preds = %44, %61
  %49 = phi i32 [ %47, %44 ], [ %22, %61 ]
  %50 = add nuw nsw i32 %23, 1
  %51 = icmp slt i32 %50, %49
  br i1 %51, label %21, label %86, !llvm.loop !215

52:                                               ; preds = %41, %52
  %53 = phi i64 [ %59, %52 ], [ %42, %41 ]
  %54 = phi i16 [ %58, %52 ], [ %43, %41 ]
  %55 = getelementptr inbounds i16, ptr %0, i64 %53
  %56 = load i16, ptr %55, align 2, !tbaa !30
  %57 = and i16 %56, %2
  %58 = add i16 %57, %54
  %59 = add nuw nsw i64 %53, 1
  %60 = icmp eq i64 %59, %13
  br i1 %60, label %61, label %52, !llvm.loop !216

61:                                               ; preds = %52, %38
  %62 = phi i16 [ %40, %38 ], [ %58, %52 ]
  %63 = load double, ptr @init_value, align 8, !tbaa !28
  %64 = fptosi double %63 to i16
  %65 = and i16 %64, %2
  %66 = mul i16 %65, 8000
  %67 = icmp eq i16 %66, %62
  br i1 %67, label %48, label %44

68:                                               ; preds = %10, %81
  %69 = phi i32 [ %82, %81 ], [ %6, %10 ]
  %70 = phi double [ %83, %81 ], [ %11, %10 ]
  %71 = phi i32 [ %84, %81 ], [ 0, %10 ]
  %72 = fptosi double %70 to i16
  %73 = and i16 %72, %2
  %74 = mul i16 %73, 8000
  %75 = icmp eq i16 %74, 0
  br i1 %75, label %81, label %76

76:                                               ; preds = %68
  %77 = load i32, ptr @current_test, align 4, !tbaa !9
  %78 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %77)
  %79 = load double, ptr @init_value, align 8, !tbaa !28
  %80 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %81

81:                                               ; preds = %68, %76
  %82 = phi i32 [ %69, %68 ], [ %80, %76 ]
  %83 = phi double [ %70, %68 ], [ %79, %76 ]
  %84 = add nuw nsw i32 %71, 1
  %85 = icmp slt i32 %84, %82
  br i1 %85, label %68, label %86, !llvm.loop !215

86:                                               ; preds = %81, %48, %4
  %87 = tail call i64 @clock() #17
  store i64 %87, ptr @end_time, align 8, !tbaa !26
  %88 = load i64, ptr @start_time, align 8, !tbaa !26
  %89 = load ptr, ptr @results, align 8, !tbaa !5
  %90 = icmp eq ptr %89, null
  br i1 %90, label %91, label %93

91:                                               ; preds = %86
  %92 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %97

93:                                               ; preds = %86
  %94 = load i32, ptr @current_test, align 4, !tbaa !9
  %95 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %96 = icmp slt i32 %94, %95
  br i1 %96, label %109, label %97

97:                                               ; preds = %93, %91
  %98 = phi i32 [ %92, %91 ], [ %95, %93 ]
  %99 = add nsw i32 %98, 10
  store i32 %99, ptr @allocated_results, align 4, !tbaa !9
  %100 = sext i32 %99 to i64
  %101 = shl nsw i64 %100, 4
  %102 = tail call ptr @realloc(ptr noundef %89, i64 noundef %101) #14
  store ptr %102, ptr @results, align 8, !tbaa !5
  %103 = icmp eq ptr %102, null
  br i1 %103, label %106, label %104

104:                                              ; preds = %97
  %105 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %109

106:                                              ; preds = %97
  %107 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %108 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %107)
  tail call void @exit(i32 noundef -1) #15
  unreachable

109:                                              ; preds = %93, %104
  %110 = phi i32 [ %105, %104 ], [ %94, %93 ]
  %111 = phi ptr [ %102, %104 ], [ %89, %93 ]
  %112 = sub nsw i64 %87, %88
  %113 = sitofp i64 %112 to double
  %114 = fdiv double %113, 1.000000e+06
  %115 = sext i32 %110 to i64
  %116 = getelementptr inbounds %struct.one_result, ptr %111, i64 %115
  store double %114, ptr %116, align 8, !tbaa !11
  %117 = getelementptr inbounds %struct.one_result, ptr %111, i64 %115, i32 1
  store ptr %3, ptr %117, align 8, !tbaa !14
  %118 = add nsw i32 %110, 1
  store i32 %118, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Is28custom_multiple_variable_andIsEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i16 noundef signext %2, i16 noundef signext %3, i16 noundef signext %4, i16 noundef signext %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !26
  %9 = load i32, ptr @iterations, align 4, !tbaa !9
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %101

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  %13 = and i16 %3, %2
  %14 = and i16 %13, %4
  %15 = and i16 %14, %5
  br i1 %12, label %18, label %16

16:                                               ; preds = %11
  %17 = load double, ptr @init_value, align 8, !tbaa !28
  br label %83

18:                                               ; preds = %11
  %19 = zext i32 %1 to i64
  %20 = icmp ult i32 %1, 16
  %21 = and i64 %19, 4294967280
  %22 = and i16 %3, %2
  %23 = and i16 %3, %2
  %24 = and i16 %22, %4
  %25 = and i16 %23, %4
  %26 = and i16 %24, %5
  %27 = insertelement <8 x i16> poison, i16 %26, i64 0
  %28 = shufflevector <8 x i16> %27, <8 x i16> poison, <8 x i32> zeroinitializer
  %29 = and i16 %25, %5
  %30 = insertelement <8 x i16> poison, i16 %29, i64 0
  %31 = shufflevector <8 x i16> %30, <8 x i16> poison, <8 x i32> zeroinitializer
  %32 = icmp eq i64 %21, %19
  br label %33

33:                                               ; preds = %18, %60
  %34 = phi i32 [ %61, %60 ], [ %9, %18 ]
  %35 = phi i32 [ %62, %60 ], [ 0, %18 ]
  br i1 %20, label %53, label %36

36:                                               ; preds = %33, %36
  %37 = phi i64 [ %48, %36 ], [ 0, %33 ]
  %38 = phi <8 x i16> [ %46, %36 ], [ zeroinitializer, %33 ]
  %39 = phi <8 x i16> [ %47, %36 ], [ zeroinitializer, %33 ]
  %40 = getelementptr inbounds i16, ptr %0, i64 %37
  %41 = load <8 x i16>, ptr %40, align 2, !tbaa !30
  %42 = getelementptr inbounds i16, ptr %40, i64 8
  %43 = load <8 x i16>, ptr %42, align 2, !tbaa !30
  %44 = and <8 x i16> %28, %41
  %45 = and <8 x i16> %31, %43
  %46 = add <8 x i16> %44, %38
  %47 = add <8 x i16> %45, %39
  %48 = add nuw i64 %37, 16
  %49 = icmp eq i64 %48, %21
  br i1 %49, label %50, label %36, !llvm.loop !217

50:                                               ; preds = %36
  %51 = add <8 x i16> %47, %46
  %52 = tail call i16 @llvm.vector.reduce.add.v8i16(<8 x i16> %51)
  br i1 %32, label %76, label %53

53:                                               ; preds = %33, %50
  %54 = phi i64 [ 0, %33 ], [ %21, %50 ]
  %55 = phi i16 [ 0, %33 ], [ %52, %50 ]
  br label %64

56:                                               ; preds = %76
  %57 = load i32, ptr @current_test, align 4, !tbaa !9
  %58 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %57)
  %59 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %60

60:                                               ; preds = %56, %76
  %61 = phi i32 [ %59, %56 ], [ %34, %76 ]
  %62 = add nuw nsw i32 %35, 1
  %63 = icmp slt i32 %62, %61
  br i1 %63, label %33, label %101, !llvm.loop !218

64:                                               ; preds = %53, %64
  %65 = phi i64 [ %74, %64 ], [ %54, %53 ]
  %66 = phi i16 [ %73, %64 ], [ %55, %53 ]
  %67 = getelementptr inbounds i16, ptr %0, i64 %65
  %68 = load i16, ptr %67, align 2, !tbaa !30
  %69 = and i16 %68, %2
  %70 = and i16 %69, %3
  %71 = and i16 %70, %4
  %72 = and i16 %71, %5
  %73 = add i16 %72, %66
  %74 = add nuw nsw i64 %65, 1
  %75 = icmp eq i64 %74, %19
  br i1 %75, label %76, label %64, !llvm.loop !219

76:                                               ; preds = %64, %50
  %77 = phi i16 [ %52, %50 ], [ %73, %64 ]
  %78 = load double, ptr @init_value, align 8, !tbaa !28
  %79 = fptosi double %78 to i16
  %80 = and i16 %15, %79
  %81 = mul i16 %80, 8000
  %82 = icmp eq i16 %81, %77
  br i1 %82, label %60, label %56

83:                                               ; preds = %16, %96
  %84 = phi i32 [ %97, %96 ], [ %9, %16 ]
  %85 = phi double [ %98, %96 ], [ %17, %16 ]
  %86 = phi i32 [ %99, %96 ], [ 0, %16 ]
  %87 = fptosi double %85 to i16
  %88 = and i16 %15, %87
  %89 = mul i16 %88, 8000
  %90 = icmp eq i16 %89, 0
  br i1 %90, label %96, label %91

91:                                               ; preds = %83
  %92 = load i32, ptr @current_test, align 4, !tbaa !9
  %93 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %92)
  %94 = load double, ptr @init_value, align 8, !tbaa !28
  %95 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %96

96:                                               ; preds = %83, %91
  %97 = phi i32 [ %84, %83 ], [ %95, %91 ]
  %98 = phi double [ %85, %83 ], [ %94, %91 ]
  %99 = add nuw nsw i32 %86, 1
  %100 = icmp slt i32 %99, %97
  br i1 %100, label %83, label %101, !llvm.loop !218

101:                                              ; preds = %96, %60, %7
  %102 = tail call i64 @clock() #17
  store i64 %102, ptr @end_time, align 8, !tbaa !26
  %103 = load i64, ptr @start_time, align 8, !tbaa !26
  %104 = load ptr, ptr @results, align 8, !tbaa !5
  %105 = icmp eq ptr %104, null
  br i1 %105, label %106, label %108

106:                                              ; preds = %101
  %107 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %112

108:                                              ; preds = %101
  %109 = load i32, ptr @current_test, align 4, !tbaa !9
  %110 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %111 = icmp slt i32 %109, %110
  br i1 %111, label %124, label %112

112:                                              ; preds = %108, %106
  %113 = phi i32 [ %107, %106 ], [ %110, %108 ]
  %114 = add nsw i32 %113, 10
  store i32 %114, ptr @allocated_results, align 4, !tbaa !9
  %115 = sext i32 %114 to i64
  %116 = shl nsw i64 %115, 4
  %117 = tail call ptr @realloc(ptr noundef %104, i64 noundef %116) #14
  store ptr %117, ptr @results, align 8, !tbaa !5
  %118 = icmp eq ptr %117, null
  br i1 %118, label %121, label %119

119:                                              ; preds = %112
  %120 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %124

121:                                              ; preds = %112
  %122 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %123 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %122)
  tail call void @exit(i32 noundef -1) #15
  unreachable

124:                                              ; preds = %108, %119
  %125 = phi i32 [ %120, %119 ], [ %109, %108 ]
  %126 = phi ptr [ %117, %119 ], [ %104, %108 ]
  %127 = sub nsw i64 %102, %103
  %128 = sitofp i64 %127 to double
  %129 = fdiv double %128, 1.000000e+06
  %130 = sext i32 %125 to i64
  %131 = getelementptr inbounds %struct.one_result, ptr %126, i64 %130
  store double %129, ptr %131, align 8, !tbaa !11
  %132 = getelementptr inbounds %struct.one_result, ptr %126, i64 %130, i32 1
  store ptr %6, ptr %132, align 8, !tbaa !14
  %133 = add nsw i32 %125, 1
  store i32 %133, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1Is18custom_variable_orIsEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i16 noundef signext %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !26
  %6 = load i32, ptr @iterations, align 4, !tbaa !9
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %86

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  br i1 %9, label %12, label %10

10:                                               ; preds = %8
  %11 = load double, ptr @init_value, align 8, !tbaa !28
  br label %68

12:                                               ; preds = %8
  %13 = zext i32 %1 to i64
  %14 = icmp ult i32 %1, 16
  %15 = and i64 %13, 4294967280
  %16 = insertelement <8 x i16> poison, i16 %2, i64 0
  %17 = shufflevector <8 x i16> %16, <8 x i16> poison, <8 x i32> zeroinitializer
  %18 = insertelement <8 x i16> poison, i16 %2, i64 0
  %19 = shufflevector <8 x i16> %18, <8 x i16> poison, <8 x i32> zeroinitializer
  %20 = icmp eq i64 %15, %13
  br label %21

21:                                               ; preds = %12, %48
  %22 = phi i32 [ %49, %48 ], [ %6, %12 ]
  %23 = phi i32 [ %50, %48 ], [ 0, %12 ]
  br i1 %14, label %41, label %24

24:                                               ; preds = %21, %24
  %25 = phi i64 [ %36, %24 ], [ 0, %21 ]
  %26 = phi <8 x i16> [ %34, %24 ], [ zeroinitializer, %21 ]
  %27 = phi <8 x i16> [ %35, %24 ], [ zeroinitializer, %21 ]
  %28 = getelementptr inbounds i16, ptr %0, i64 %25
  %29 = load <8 x i16>, ptr %28, align 2, !tbaa !30
  %30 = getelementptr inbounds i16, ptr %28, i64 8
  %31 = load <8 x i16>, ptr %30, align 2, !tbaa !30
  %32 = or <8 x i16> %29, %17
  %33 = or <8 x i16> %31, %19
  %34 = add <8 x i16> %32, %26
  %35 = add <8 x i16> %33, %27
  %36 = add nuw i64 %25, 16
  %37 = icmp eq i64 %36, %15
  br i1 %37, label %38, label %24, !llvm.loop !220

38:                                               ; preds = %24
  %39 = add <8 x i16> %35, %34
  %40 = tail call i16 @llvm.vector.reduce.add.v8i16(<8 x i16> %39)
  br i1 %20, label %61, label %41

41:                                               ; preds = %21, %38
  %42 = phi i64 [ 0, %21 ], [ %15, %38 ]
  %43 = phi i16 [ 0, %21 ], [ %40, %38 ]
  br label %52

44:                                               ; preds = %61
  %45 = load i32, ptr @current_test, align 4, !tbaa !9
  %46 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %45)
  %47 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %48

48:                                               ; preds = %44, %61
  %49 = phi i32 [ %47, %44 ], [ %22, %61 ]
  %50 = add nuw nsw i32 %23, 1
  %51 = icmp slt i32 %50, %49
  br i1 %51, label %21, label %86, !llvm.loop !221

52:                                               ; preds = %41, %52
  %53 = phi i64 [ %59, %52 ], [ %42, %41 ]
  %54 = phi i16 [ %58, %52 ], [ %43, %41 ]
  %55 = getelementptr inbounds i16, ptr %0, i64 %53
  %56 = load i16, ptr %55, align 2, !tbaa !30
  %57 = or i16 %56, %2
  %58 = add i16 %57, %54
  %59 = add nuw nsw i64 %53, 1
  %60 = icmp eq i64 %59, %13
  br i1 %60, label %61, label %52, !llvm.loop !222

61:                                               ; preds = %52, %38
  %62 = phi i16 [ %40, %38 ], [ %58, %52 ]
  %63 = load double, ptr @init_value, align 8, !tbaa !28
  %64 = fptosi double %63 to i16
  %65 = or i16 %64, %2
  %66 = mul i16 %65, 8000
  %67 = icmp eq i16 %66, %62
  br i1 %67, label %48, label %44

68:                                               ; preds = %10, %81
  %69 = phi i32 [ %82, %81 ], [ %6, %10 ]
  %70 = phi double [ %83, %81 ], [ %11, %10 ]
  %71 = phi i32 [ %84, %81 ], [ 0, %10 ]
  %72 = fptosi double %70 to i16
  %73 = or i16 %72, %2
  %74 = mul i16 %73, 8000
  %75 = icmp eq i16 %74, 0
  br i1 %75, label %81, label %76

76:                                               ; preds = %68
  %77 = load i32, ptr @current_test, align 4, !tbaa !9
  %78 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %77)
  %79 = load double, ptr @init_value, align 8, !tbaa !28
  %80 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %81

81:                                               ; preds = %68, %76
  %82 = phi i32 [ %69, %68 ], [ %80, %76 ]
  %83 = phi double [ %70, %68 ], [ %79, %76 ]
  %84 = add nuw nsw i32 %71, 1
  %85 = icmp slt i32 %84, %82
  br i1 %85, label %68, label %86, !llvm.loop !221

86:                                               ; preds = %81, %48, %4
  %87 = tail call i64 @clock() #17
  store i64 %87, ptr @end_time, align 8, !tbaa !26
  %88 = load i64, ptr @start_time, align 8, !tbaa !26
  %89 = load ptr, ptr @results, align 8, !tbaa !5
  %90 = icmp eq ptr %89, null
  br i1 %90, label %91, label %93

91:                                               ; preds = %86
  %92 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %97

93:                                               ; preds = %86
  %94 = load i32, ptr @current_test, align 4, !tbaa !9
  %95 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %96 = icmp slt i32 %94, %95
  br i1 %96, label %109, label %97

97:                                               ; preds = %93, %91
  %98 = phi i32 [ %92, %91 ], [ %95, %93 ]
  %99 = add nsw i32 %98, 10
  store i32 %99, ptr @allocated_results, align 4, !tbaa !9
  %100 = sext i32 %99 to i64
  %101 = shl nsw i64 %100, 4
  %102 = tail call ptr @realloc(ptr noundef %89, i64 noundef %101) #14
  store ptr %102, ptr @results, align 8, !tbaa !5
  %103 = icmp eq ptr %102, null
  br i1 %103, label %106, label %104

104:                                              ; preds = %97
  %105 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %109

106:                                              ; preds = %97
  %107 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %108 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %107)
  tail call void @exit(i32 noundef -1) #15
  unreachable

109:                                              ; preds = %93, %104
  %110 = phi i32 [ %105, %104 ], [ %94, %93 ]
  %111 = phi ptr [ %102, %104 ], [ %89, %93 ]
  %112 = sub nsw i64 %87, %88
  %113 = sitofp i64 %112 to double
  %114 = fdiv double %113, 1.000000e+06
  %115 = sext i32 %110 to i64
  %116 = getelementptr inbounds %struct.one_result, ptr %111, i64 %115
  store double %114, ptr %116, align 8, !tbaa !11
  %117 = getelementptr inbounds %struct.one_result, ptr %111, i64 %115, i32 1
  store ptr %3, ptr %117, align 8, !tbaa !14
  %118 = add nsw i32 %110, 1
  store i32 %118, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Is27custom_multiple_variable_orIsEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i16 noundef signext %2, i16 noundef signext %3, i16 noundef signext %4, i16 noundef signext %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !26
  %9 = load i32, ptr @iterations, align 4, !tbaa !9
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %101

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  %13 = or i16 %3, %2
  %14 = or i16 %13, %4
  %15 = or i16 %14, %5
  br i1 %12, label %18, label %16

16:                                               ; preds = %11
  %17 = load double, ptr @init_value, align 8, !tbaa !28
  br label %83

18:                                               ; preds = %11
  %19 = zext i32 %1 to i64
  %20 = icmp ult i32 %1, 16
  %21 = and i64 %19, 4294967280
  %22 = or i16 %3, %2
  %23 = or i16 %3, %2
  %24 = or i16 %22, %4
  %25 = or i16 %23, %4
  %26 = or i16 %24, %5
  %27 = insertelement <8 x i16> poison, i16 %26, i64 0
  %28 = shufflevector <8 x i16> %27, <8 x i16> poison, <8 x i32> zeroinitializer
  %29 = or i16 %25, %5
  %30 = insertelement <8 x i16> poison, i16 %29, i64 0
  %31 = shufflevector <8 x i16> %30, <8 x i16> poison, <8 x i32> zeroinitializer
  %32 = icmp eq i64 %21, %19
  br label %33

33:                                               ; preds = %18, %60
  %34 = phi i32 [ %61, %60 ], [ %9, %18 ]
  %35 = phi i32 [ %62, %60 ], [ 0, %18 ]
  br i1 %20, label %53, label %36

36:                                               ; preds = %33, %36
  %37 = phi i64 [ %48, %36 ], [ 0, %33 ]
  %38 = phi <8 x i16> [ %46, %36 ], [ zeroinitializer, %33 ]
  %39 = phi <8 x i16> [ %47, %36 ], [ zeroinitializer, %33 ]
  %40 = getelementptr inbounds i16, ptr %0, i64 %37
  %41 = load <8 x i16>, ptr %40, align 2, !tbaa !30
  %42 = getelementptr inbounds i16, ptr %40, i64 8
  %43 = load <8 x i16>, ptr %42, align 2, !tbaa !30
  %44 = or <8 x i16> %28, %41
  %45 = or <8 x i16> %31, %43
  %46 = add <8 x i16> %44, %38
  %47 = add <8 x i16> %45, %39
  %48 = add nuw i64 %37, 16
  %49 = icmp eq i64 %48, %21
  br i1 %49, label %50, label %36, !llvm.loop !223

50:                                               ; preds = %36
  %51 = add <8 x i16> %47, %46
  %52 = tail call i16 @llvm.vector.reduce.add.v8i16(<8 x i16> %51)
  br i1 %32, label %76, label %53

53:                                               ; preds = %33, %50
  %54 = phi i64 [ 0, %33 ], [ %21, %50 ]
  %55 = phi i16 [ 0, %33 ], [ %52, %50 ]
  br label %64

56:                                               ; preds = %76
  %57 = load i32, ptr @current_test, align 4, !tbaa !9
  %58 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %57)
  %59 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %60

60:                                               ; preds = %56, %76
  %61 = phi i32 [ %59, %56 ], [ %34, %76 ]
  %62 = add nuw nsw i32 %35, 1
  %63 = icmp slt i32 %62, %61
  br i1 %63, label %33, label %101, !llvm.loop !224

64:                                               ; preds = %53, %64
  %65 = phi i64 [ %74, %64 ], [ %54, %53 ]
  %66 = phi i16 [ %73, %64 ], [ %55, %53 ]
  %67 = getelementptr inbounds i16, ptr %0, i64 %65
  %68 = load i16, ptr %67, align 2, !tbaa !30
  %69 = or i16 %68, %2
  %70 = or i16 %69, %3
  %71 = or i16 %70, %4
  %72 = or i16 %71, %5
  %73 = add i16 %72, %66
  %74 = add nuw nsw i64 %65, 1
  %75 = icmp eq i64 %74, %19
  br i1 %75, label %76, label %64, !llvm.loop !225

76:                                               ; preds = %64, %50
  %77 = phi i16 [ %52, %50 ], [ %73, %64 ]
  %78 = load double, ptr @init_value, align 8, !tbaa !28
  %79 = fptosi double %78 to i16
  %80 = or i16 %15, %79
  %81 = mul i16 %80, 8000
  %82 = icmp eq i16 %81, %77
  br i1 %82, label %60, label %56

83:                                               ; preds = %16, %96
  %84 = phi i32 [ %97, %96 ], [ %9, %16 ]
  %85 = phi double [ %98, %96 ], [ %17, %16 ]
  %86 = phi i32 [ %99, %96 ], [ 0, %16 ]
  %87 = fptosi double %85 to i16
  %88 = or i16 %15, %87
  %89 = mul i16 %88, 8000
  %90 = icmp eq i16 %89, 0
  br i1 %90, label %96, label %91

91:                                               ; preds = %83
  %92 = load i32, ptr @current_test, align 4, !tbaa !9
  %93 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %92)
  %94 = load double, ptr @init_value, align 8, !tbaa !28
  %95 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %96

96:                                               ; preds = %83, %91
  %97 = phi i32 [ %84, %83 ], [ %95, %91 ]
  %98 = phi double [ %85, %83 ], [ %94, %91 ]
  %99 = add nuw nsw i32 %86, 1
  %100 = icmp slt i32 %99, %97
  br i1 %100, label %83, label %101, !llvm.loop !224

101:                                              ; preds = %96, %60, %7
  %102 = tail call i64 @clock() #17
  store i64 %102, ptr @end_time, align 8, !tbaa !26
  %103 = load i64, ptr @start_time, align 8, !tbaa !26
  %104 = load ptr, ptr @results, align 8, !tbaa !5
  %105 = icmp eq ptr %104, null
  br i1 %105, label %106, label %108

106:                                              ; preds = %101
  %107 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %112

108:                                              ; preds = %101
  %109 = load i32, ptr @current_test, align 4, !tbaa !9
  %110 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %111 = icmp slt i32 %109, %110
  br i1 %111, label %124, label %112

112:                                              ; preds = %108, %106
  %113 = phi i32 [ %107, %106 ], [ %110, %108 ]
  %114 = add nsw i32 %113, 10
  store i32 %114, ptr @allocated_results, align 4, !tbaa !9
  %115 = sext i32 %114 to i64
  %116 = shl nsw i64 %115, 4
  %117 = tail call ptr @realloc(ptr noundef %104, i64 noundef %116) #14
  store ptr %117, ptr @results, align 8, !tbaa !5
  %118 = icmp eq ptr %117, null
  br i1 %118, label %121, label %119

119:                                              ; preds = %112
  %120 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %124

121:                                              ; preds = %112
  %122 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %123 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %122)
  tail call void @exit(i32 noundef -1) #15
  unreachable

124:                                              ; preds = %108, %119
  %125 = phi i32 [ %120, %119 ], [ %109, %108 ]
  %126 = phi ptr [ %117, %119 ], [ %104, %108 ]
  %127 = sub nsw i64 %102, %103
  %128 = sitofp i64 %127 to double
  %129 = fdiv double %128, 1.000000e+06
  %130 = sext i32 %125 to i64
  %131 = getelementptr inbounds %struct.one_result, ptr %126, i64 %130
  store double %129, ptr %131, align 8, !tbaa !11
  %132 = getelementptr inbounds %struct.one_result, ptr %126, i64 %130, i32 1
  store ptr %6, ptr %132, align 8, !tbaa !14
  %133 = add nsw i32 %125, 1
  store i32 %133, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1Is19custom_variable_xorIsEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i16 noundef signext %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !26
  %6 = load i32, ptr @iterations, align 4, !tbaa !9
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %86

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  br i1 %9, label %12, label %10

10:                                               ; preds = %8
  %11 = load double, ptr @init_value, align 8, !tbaa !28
  br label %68

12:                                               ; preds = %8
  %13 = zext i32 %1 to i64
  %14 = icmp ult i32 %1, 16
  %15 = and i64 %13, 4294967280
  %16 = insertelement <8 x i16> poison, i16 %2, i64 0
  %17 = shufflevector <8 x i16> %16, <8 x i16> poison, <8 x i32> zeroinitializer
  %18 = insertelement <8 x i16> poison, i16 %2, i64 0
  %19 = shufflevector <8 x i16> %18, <8 x i16> poison, <8 x i32> zeroinitializer
  %20 = icmp eq i64 %15, %13
  br label %21

21:                                               ; preds = %12, %48
  %22 = phi i32 [ %49, %48 ], [ %6, %12 ]
  %23 = phi i32 [ %50, %48 ], [ 0, %12 ]
  br i1 %14, label %41, label %24

24:                                               ; preds = %21, %24
  %25 = phi i64 [ %36, %24 ], [ 0, %21 ]
  %26 = phi <8 x i16> [ %34, %24 ], [ zeroinitializer, %21 ]
  %27 = phi <8 x i16> [ %35, %24 ], [ zeroinitializer, %21 ]
  %28 = getelementptr inbounds i16, ptr %0, i64 %25
  %29 = load <8 x i16>, ptr %28, align 2, !tbaa !30
  %30 = getelementptr inbounds i16, ptr %28, i64 8
  %31 = load <8 x i16>, ptr %30, align 2, !tbaa !30
  %32 = xor <8 x i16> %29, %17
  %33 = xor <8 x i16> %31, %19
  %34 = add <8 x i16> %32, %26
  %35 = add <8 x i16> %33, %27
  %36 = add nuw i64 %25, 16
  %37 = icmp eq i64 %36, %15
  br i1 %37, label %38, label %24, !llvm.loop !226

38:                                               ; preds = %24
  %39 = add <8 x i16> %35, %34
  %40 = tail call i16 @llvm.vector.reduce.add.v8i16(<8 x i16> %39)
  br i1 %20, label %61, label %41

41:                                               ; preds = %21, %38
  %42 = phi i64 [ 0, %21 ], [ %15, %38 ]
  %43 = phi i16 [ 0, %21 ], [ %40, %38 ]
  br label %52

44:                                               ; preds = %61
  %45 = load i32, ptr @current_test, align 4, !tbaa !9
  %46 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %45)
  %47 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %48

48:                                               ; preds = %44, %61
  %49 = phi i32 [ %47, %44 ], [ %22, %61 ]
  %50 = add nuw nsw i32 %23, 1
  %51 = icmp slt i32 %50, %49
  br i1 %51, label %21, label %86, !llvm.loop !227

52:                                               ; preds = %41, %52
  %53 = phi i64 [ %59, %52 ], [ %42, %41 ]
  %54 = phi i16 [ %58, %52 ], [ %43, %41 ]
  %55 = getelementptr inbounds i16, ptr %0, i64 %53
  %56 = load i16, ptr %55, align 2, !tbaa !30
  %57 = xor i16 %56, %2
  %58 = add i16 %57, %54
  %59 = add nuw nsw i64 %53, 1
  %60 = icmp eq i64 %59, %13
  br i1 %60, label %61, label %52, !llvm.loop !228

61:                                               ; preds = %52, %38
  %62 = phi i16 [ %40, %38 ], [ %58, %52 ]
  %63 = load double, ptr @init_value, align 8, !tbaa !28
  %64 = fptosi double %63 to i16
  %65 = xor i16 %64, %2
  %66 = mul i16 %65, 8000
  %67 = icmp eq i16 %66, %62
  br i1 %67, label %48, label %44

68:                                               ; preds = %10, %81
  %69 = phi i32 [ %82, %81 ], [ %6, %10 ]
  %70 = phi double [ %83, %81 ], [ %11, %10 ]
  %71 = phi i32 [ %84, %81 ], [ 0, %10 ]
  %72 = fptosi double %70 to i16
  %73 = xor i16 %72, %2
  %74 = mul i16 %73, 8000
  %75 = icmp eq i16 %74, 0
  br i1 %75, label %81, label %76

76:                                               ; preds = %68
  %77 = load i32, ptr @current_test, align 4, !tbaa !9
  %78 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %77)
  %79 = load double, ptr @init_value, align 8, !tbaa !28
  %80 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %81

81:                                               ; preds = %68, %76
  %82 = phi i32 [ %69, %68 ], [ %80, %76 ]
  %83 = phi double [ %70, %68 ], [ %79, %76 ]
  %84 = add nuw nsw i32 %71, 1
  %85 = icmp slt i32 %84, %82
  br i1 %85, label %68, label %86, !llvm.loop !227

86:                                               ; preds = %81, %48, %4
  %87 = tail call i64 @clock() #17
  store i64 %87, ptr @end_time, align 8, !tbaa !26
  %88 = load i64, ptr @start_time, align 8, !tbaa !26
  %89 = load ptr, ptr @results, align 8, !tbaa !5
  %90 = icmp eq ptr %89, null
  br i1 %90, label %91, label %93

91:                                               ; preds = %86
  %92 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %97

93:                                               ; preds = %86
  %94 = load i32, ptr @current_test, align 4, !tbaa !9
  %95 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %96 = icmp slt i32 %94, %95
  br i1 %96, label %109, label %97

97:                                               ; preds = %93, %91
  %98 = phi i32 [ %92, %91 ], [ %95, %93 ]
  %99 = add nsw i32 %98, 10
  store i32 %99, ptr @allocated_results, align 4, !tbaa !9
  %100 = sext i32 %99 to i64
  %101 = shl nsw i64 %100, 4
  %102 = tail call ptr @realloc(ptr noundef %89, i64 noundef %101) #14
  store ptr %102, ptr @results, align 8, !tbaa !5
  %103 = icmp eq ptr %102, null
  br i1 %103, label %106, label %104

104:                                              ; preds = %97
  %105 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %109

106:                                              ; preds = %97
  %107 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %108 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %107)
  tail call void @exit(i32 noundef -1) #15
  unreachable

109:                                              ; preds = %93, %104
  %110 = phi i32 [ %105, %104 ], [ %94, %93 ]
  %111 = phi ptr [ %102, %104 ], [ %89, %93 ]
  %112 = sub nsw i64 %87, %88
  %113 = sitofp i64 %112 to double
  %114 = fdiv double %113, 1.000000e+06
  %115 = sext i32 %110 to i64
  %116 = getelementptr inbounds %struct.one_result, ptr %111, i64 %115
  store double %114, ptr %116, align 8, !tbaa !11
  %117 = getelementptr inbounds %struct.one_result, ptr %111, i64 %115, i32 1
  store ptr %3, ptr %117, align 8, !tbaa !14
  %118 = add nsw i32 %110, 1
  store i32 %118, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Is28custom_multiple_variable_xorIsEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i16 noundef signext %2, i16 noundef signext %3, i16 noundef signext %4, i16 noundef signext %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !26
  %9 = load i32, ptr @iterations, align 4, !tbaa !9
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %101

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  %13 = xor i16 %3, %2
  %14 = xor i16 %13, %4
  %15 = xor i16 %14, %5
  br i1 %12, label %18, label %16

16:                                               ; preds = %11
  %17 = load double, ptr @init_value, align 8, !tbaa !28
  br label %83

18:                                               ; preds = %11
  %19 = zext i32 %1 to i64
  %20 = icmp ult i32 %1, 16
  %21 = and i64 %19, 4294967280
  %22 = xor i16 %3, %2
  %23 = xor i16 %3, %2
  %24 = xor i16 %22, %4
  %25 = xor i16 %23, %4
  %26 = xor i16 %24, %5
  %27 = insertelement <8 x i16> poison, i16 %26, i64 0
  %28 = shufflevector <8 x i16> %27, <8 x i16> poison, <8 x i32> zeroinitializer
  %29 = xor i16 %25, %5
  %30 = insertelement <8 x i16> poison, i16 %29, i64 0
  %31 = shufflevector <8 x i16> %30, <8 x i16> poison, <8 x i32> zeroinitializer
  %32 = icmp eq i64 %21, %19
  br label %33

33:                                               ; preds = %18, %60
  %34 = phi i32 [ %61, %60 ], [ %9, %18 ]
  %35 = phi i32 [ %62, %60 ], [ 0, %18 ]
  br i1 %20, label %53, label %36

36:                                               ; preds = %33, %36
  %37 = phi i64 [ %48, %36 ], [ 0, %33 ]
  %38 = phi <8 x i16> [ %46, %36 ], [ zeroinitializer, %33 ]
  %39 = phi <8 x i16> [ %47, %36 ], [ zeroinitializer, %33 ]
  %40 = getelementptr inbounds i16, ptr %0, i64 %37
  %41 = load <8 x i16>, ptr %40, align 2, !tbaa !30
  %42 = getelementptr inbounds i16, ptr %40, i64 8
  %43 = load <8 x i16>, ptr %42, align 2, !tbaa !30
  %44 = xor <8 x i16> %28, %41
  %45 = xor <8 x i16> %31, %43
  %46 = add <8 x i16> %44, %38
  %47 = add <8 x i16> %45, %39
  %48 = add nuw i64 %37, 16
  %49 = icmp eq i64 %48, %21
  br i1 %49, label %50, label %36, !llvm.loop !229

50:                                               ; preds = %36
  %51 = add <8 x i16> %47, %46
  %52 = tail call i16 @llvm.vector.reduce.add.v8i16(<8 x i16> %51)
  br i1 %32, label %76, label %53

53:                                               ; preds = %33, %50
  %54 = phi i64 [ 0, %33 ], [ %21, %50 ]
  %55 = phi i16 [ 0, %33 ], [ %52, %50 ]
  br label %64

56:                                               ; preds = %76
  %57 = load i32, ptr @current_test, align 4, !tbaa !9
  %58 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %57)
  %59 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %60

60:                                               ; preds = %56, %76
  %61 = phi i32 [ %59, %56 ], [ %34, %76 ]
  %62 = add nuw nsw i32 %35, 1
  %63 = icmp slt i32 %62, %61
  br i1 %63, label %33, label %101, !llvm.loop !230

64:                                               ; preds = %53, %64
  %65 = phi i64 [ %74, %64 ], [ %54, %53 ]
  %66 = phi i16 [ %73, %64 ], [ %55, %53 ]
  %67 = getelementptr inbounds i16, ptr %0, i64 %65
  %68 = load i16, ptr %67, align 2, !tbaa !30
  %69 = xor i16 %68, %2
  %70 = xor i16 %69, %3
  %71 = xor i16 %70, %4
  %72 = xor i16 %71, %5
  %73 = add i16 %72, %66
  %74 = add nuw nsw i64 %65, 1
  %75 = icmp eq i64 %74, %19
  br i1 %75, label %76, label %64, !llvm.loop !231

76:                                               ; preds = %64, %50
  %77 = phi i16 [ %52, %50 ], [ %73, %64 ]
  %78 = load double, ptr @init_value, align 8, !tbaa !28
  %79 = fptosi double %78 to i16
  %80 = xor i16 %15, %79
  %81 = mul i16 %80, 8000
  %82 = icmp eq i16 %81, %77
  br i1 %82, label %60, label %56

83:                                               ; preds = %16, %96
  %84 = phi i32 [ %97, %96 ], [ %9, %16 ]
  %85 = phi double [ %98, %96 ], [ %17, %16 ]
  %86 = phi i32 [ %99, %96 ], [ 0, %16 ]
  %87 = fptosi double %85 to i16
  %88 = xor i16 %15, %87
  %89 = mul i16 %88, 8000
  %90 = icmp eq i16 %89, 0
  br i1 %90, label %96, label %91

91:                                               ; preds = %83
  %92 = load i32, ptr @current_test, align 4, !tbaa !9
  %93 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %92)
  %94 = load double, ptr @init_value, align 8, !tbaa !28
  %95 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %96

96:                                               ; preds = %83, %91
  %97 = phi i32 [ %84, %83 ], [ %95, %91 ]
  %98 = phi double [ %85, %83 ], [ %94, %91 ]
  %99 = add nuw nsw i32 %86, 1
  %100 = icmp slt i32 %99, %97
  br i1 %100, label %83, label %101, !llvm.loop !230

101:                                              ; preds = %96, %60, %7
  %102 = tail call i64 @clock() #17
  store i64 %102, ptr @end_time, align 8, !tbaa !26
  %103 = load i64, ptr @start_time, align 8, !tbaa !26
  %104 = load ptr, ptr @results, align 8, !tbaa !5
  %105 = icmp eq ptr %104, null
  br i1 %105, label %106, label %108

106:                                              ; preds = %101
  %107 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %112

108:                                              ; preds = %101
  %109 = load i32, ptr @current_test, align 4, !tbaa !9
  %110 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %111 = icmp slt i32 %109, %110
  br i1 %111, label %124, label %112

112:                                              ; preds = %108, %106
  %113 = phi i32 [ %107, %106 ], [ %110, %108 ]
  %114 = add nsw i32 %113, 10
  store i32 %114, ptr @allocated_results, align 4, !tbaa !9
  %115 = sext i32 %114 to i64
  %116 = shl nsw i64 %115, 4
  %117 = tail call ptr @realloc(ptr noundef %104, i64 noundef %116) #14
  store ptr %117, ptr @results, align 8, !tbaa !5
  %118 = icmp eq ptr %117, null
  br i1 %118, label %121, label %119

119:                                              ; preds = %112
  %120 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %124

121:                                              ; preds = %112
  %122 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %123 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %122)
  tail call void @exit(i32 noundef -1) #15
  unreachable

124:                                              ; preds = %108, %119
  %125 = phi i32 [ %120, %119 ], [ %109, %108 ]
  %126 = phi ptr [ %117, %119 ], [ %104, %108 ]
  %127 = sub nsw i64 %102, %103
  %128 = sitofp i64 %127 to double
  %129 = fdiv double %128, 1.000000e+06
  %130 = sext i32 %125 to i64
  %131 = getelementptr inbounds %struct.one_result, ptr %126, i64 %130
  store double %129, ptr %131, align 8, !tbaa !11
  %132 = getelementptr inbounds %struct.one_result, ptr %126, i64 %130, i32 1
  store ptr %6, ptr %132, align 8, !tbaa !14
  %133 = add nsw i32 %125, 1
  store i32 %133, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1It19custom_add_variableItEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i16 noundef zeroext %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !26
  %6 = load i32, ptr @iterations, align 4, !tbaa !9
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %86

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  br i1 %9, label %12, label %10

10:                                               ; preds = %8
  %11 = load double, ptr @init_value, align 8, !tbaa !28
  br label %68

12:                                               ; preds = %8
  %13 = zext i32 %1 to i64
  %14 = icmp ult i32 %1, 16
  %15 = and i64 %13, 4294967280
  %16 = insertelement <8 x i16> poison, i16 %2, i64 0
  %17 = shufflevector <8 x i16> %16, <8 x i16> poison, <8 x i32> zeroinitializer
  %18 = insertelement <8 x i16> poison, i16 %2, i64 0
  %19 = shufflevector <8 x i16> %18, <8 x i16> poison, <8 x i32> zeroinitializer
  %20 = icmp eq i64 %15, %13
  br label %21

21:                                               ; preds = %12, %48
  %22 = phi i32 [ %49, %48 ], [ %6, %12 ]
  %23 = phi i32 [ %50, %48 ], [ 0, %12 ]
  br i1 %14, label %41, label %24

24:                                               ; preds = %21, %24
  %25 = phi i64 [ %36, %24 ], [ 0, %21 ]
  %26 = phi <8 x i16> [ %34, %24 ], [ zeroinitializer, %21 ]
  %27 = phi <8 x i16> [ %35, %24 ], [ zeroinitializer, %21 ]
  %28 = getelementptr inbounds i16, ptr %0, i64 %25
  %29 = load <8 x i16>, ptr %28, align 2, !tbaa !30
  %30 = getelementptr inbounds i16, ptr %28, i64 8
  %31 = load <8 x i16>, ptr %30, align 2, !tbaa !30
  %32 = add <8 x i16> %26, %17
  %33 = add <8 x i16> %27, %19
  %34 = add <8 x i16> %32, %29
  %35 = add <8 x i16> %33, %31
  %36 = add nuw i64 %25, 16
  %37 = icmp eq i64 %36, %15
  br i1 %37, label %38, label %24, !llvm.loop !232

38:                                               ; preds = %24
  %39 = add <8 x i16> %35, %34
  %40 = tail call i16 @llvm.vector.reduce.add.v8i16(<8 x i16> %39)
  br i1 %20, label %61, label %41

41:                                               ; preds = %21, %38
  %42 = phi i64 [ 0, %21 ], [ %15, %38 ]
  %43 = phi i16 [ 0, %21 ], [ %40, %38 ]
  br label %52

44:                                               ; preds = %61
  %45 = load i32, ptr @current_test, align 4, !tbaa !9
  %46 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %45)
  %47 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %48

48:                                               ; preds = %44, %61
  %49 = phi i32 [ %47, %44 ], [ %22, %61 ]
  %50 = add nuw nsw i32 %23, 1
  %51 = icmp slt i32 %50, %49
  br i1 %51, label %21, label %86, !llvm.loop !233

52:                                               ; preds = %41, %52
  %53 = phi i64 [ %59, %52 ], [ %42, %41 ]
  %54 = phi i16 [ %58, %52 ], [ %43, %41 ]
  %55 = getelementptr inbounds i16, ptr %0, i64 %53
  %56 = load i16, ptr %55, align 2, !tbaa !30
  %57 = add i16 %54, %2
  %58 = add i16 %57, %56
  %59 = add nuw nsw i64 %53, 1
  %60 = icmp eq i64 %59, %13
  br i1 %60, label %61, label %52, !llvm.loop !234

61:                                               ; preds = %52, %38
  %62 = phi i16 [ %40, %38 ], [ %58, %52 ]
  %63 = load double, ptr @init_value, align 8, !tbaa !28
  %64 = fptoui double %63 to i16
  %65 = add i16 %64, %2
  %66 = mul i16 %65, 8000
  %67 = icmp eq i16 %66, %62
  br i1 %67, label %48, label %44

68:                                               ; preds = %10, %81
  %69 = phi i32 [ %82, %81 ], [ %6, %10 ]
  %70 = phi double [ %83, %81 ], [ %11, %10 ]
  %71 = phi i32 [ %84, %81 ], [ 0, %10 ]
  %72 = fptoui double %70 to i16
  %73 = add i16 %72, %2
  %74 = mul i16 %73, 8000
  %75 = icmp eq i16 %74, 0
  br i1 %75, label %81, label %76

76:                                               ; preds = %68
  %77 = load i32, ptr @current_test, align 4, !tbaa !9
  %78 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %77)
  %79 = load double, ptr @init_value, align 8, !tbaa !28
  %80 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %81

81:                                               ; preds = %68, %76
  %82 = phi i32 [ %69, %68 ], [ %80, %76 ]
  %83 = phi double [ %70, %68 ], [ %79, %76 ]
  %84 = add nuw nsw i32 %71, 1
  %85 = icmp slt i32 %84, %82
  br i1 %85, label %68, label %86, !llvm.loop !233

86:                                               ; preds = %81, %48, %4
  %87 = tail call i64 @clock() #17
  store i64 %87, ptr @end_time, align 8, !tbaa !26
  %88 = load i64, ptr @start_time, align 8, !tbaa !26
  %89 = load ptr, ptr @results, align 8, !tbaa !5
  %90 = icmp eq ptr %89, null
  br i1 %90, label %91, label %93

91:                                               ; preds = %86
  %92 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %97

93:                                               ; preds = %86
  %94 = load i32, ptr @current_test, align 4, !tbaa !9
  %95 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %96 = icmp slt i32 %94, %95
  br i1 %96, label %109, label %97

97:                                               ; preds = %93, %91
  %98 = phi i32 [ %92, %91 ], [ %95, %93 ]
  %99 = add nsw i32 %98, 10
  store i32 %99, ptr @allocated_results, align 4, !tbaa !9
  %100 = sext i32 %99 to i64
  %101 = shl nsw i64 %100, 4
  %102 = tail call ptr @realloc(ptr noundef %89, i64 noundef %101) #14
  store ptr %102, ptr @results, align 8, !tbaa !5
  %103 = icmp eq ptr %102, null
  br i1 %103, label %106, label %104

104:                                              ; preds = %97
  %105 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %109

106:                                              ; preds = %97
  %107 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %108 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %107)
  tail call void @exit(i32 noundef -1) #15
  unreachable

109:                                              ; preds = %93, %104
  %110 = phi i32 [ %105, %104 ], [ %94, %93 ]
  %111 = phi ptr [ %102, %104 ], [ %89, %93 ]
  %112 = sub nsw i64 %87, %88
  %113 = sitofp i64 %112 to double
  %114 = fdiv double %113, 1.000000e+06
  %115 = sext i32 %110 to i64
  %116 = getelementptr inbounds %struct.one_result, ptr %111, i64 %115
  store double %114, ptr %116, align 8, !tbaa !11
  %117 = getelementptr inbounds %struct.one_result, ptr %111, i64 %115, i32 1
  store ptr %3, ptr %117, align 8, !tbaa !14
  %118 = add nsw i32 %110, 1
  store i32 %118, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z22test_hoisted_variable1It19custom_add_variableItEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i16 noundef zeroext %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !26
  %6 = load i32, ptr @iterations, align 4, !tbaa !9
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %82

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  %10 = trunc i32 %1 to i16
  %11 = mul i16 %10, %2
  br i1 %9, label %14, label %12

12:                                               ; preds = %8
  %13 = load double, ptr @init_value, align 8, !tbaa !28
  br label %64

14:                                               ; preds = %8
  %15 = zext i32 %1 to i64
  %16 = icmp ult i32 %1, 16
  %17 = and i64 %15, 4294967280
  %18 = icmp eq i64 %17, %15
  br label %19

19:                                               ; preds = %14, %44
  %20 = phi i32 [ %45, %44 ], [ %6, %14 ]
  %21 = phi i32 [ %46, %44 ], [ 0, %14 ]
  br i1 %16, label %37, label %22

22:                                               ; preds = %19, %22
  %23 = phi i64 [ %32, %22 ], [ 0, %19 ]
  %24 = phi <8 x i16> [ %30, %22 ], [ zeroinitializer, %19 ]
  %25 = phi <8 x i16> [ %31, %22 ], [ zeroinitializer, %19 ]
  %26 = getelementptr inbounds i16, ptr %0, i64 %23
  %27 = load <8 x i16>, ptr %26, align 2, !tbaa !30
  %28 = getelementptr inbounds i16, ptr %26, i64 8
  %29 = load <8 x i16>, ptr %28, align 2, !tbaa !30
  %30 = add <8 x i16> %27, %24
  %31 = add <8 x i16> %29, %25
  %32 = add nuw i64 %23, 16
  %33 = icmp eq i64 %32, %17
  br i1 %33, label %34, label %22, !llvm.loop !235

34:                                               ; preds = %22
  %35 = add <8 x i16> %31, %30
  %36 = tail call i16 @llvm.vector.reduce.add.v8i16(<8 x i16> %35)
  br i1 %18, label %56, label %37

37:                                               ; preds = %19, %34
  %38 = phi i64 [ 0, %19 ], [ %17, %34 ]
  %39 = phi i16 [ 0, %19 ], [ %36, %34 ]
  br label %48

40:                                               ; preds = %56
  %41 = load i32, ptr @current_test, align 4, !tbaa !9
  %42 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %41)
  %43 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %44

44:                                               ; preds = %40, %56
  %45 = phi i32 [ %43, %40 ], [ %20, %56 ]
  %46 = add nuw nsw i32 %21, 1
  %47 = icmp slt i32 %46, %45
  br i1 %47, label %19, label %82, !llvm.loop !236

48:                                               ; preds = %37, %48
  %49 = phi i64 [ %54, %48 ], [ %38, %37 ]
  %50 = phi i16 [ %53, %48 ], [ %39, %37 ]
  %51 = getelementptr inbounds i16, ptr %0, i64 %49
  %52 = load i16, ptr %51, align 2, !tbaa !30
  %53 = add i16 %52, %50
  %54 = add nuw nsw i64 %49, 1
  %55 = icmp eq i64 %54, %15
  br i1 %55, label %56, label %48, !llvm.loop !237

56:                                               ; preds = %48, %34
  %57 = phi i16 [ %36, %34 ], [ %53, %48 ]
  %58 = add i16 %57, %11
  %59 = load double, ptr @init_value, align 8, !tbaa !28
  %60 = fptoui double %59 to i16
  %61 = add i16 %60, %2
  %62 = mul i16 %61, 8000
  %63 = icmp eq i16 %62, %58
  br i1 %63, label %44, label %40

64:                                               ; preds = %12, %77
  %65 = phi i32 [ %78, %77 ], [ %6, %12 ]
  %66 = phi double [ %79, %77 ], [ %13, %12 ]
  %67 = phi i32 [ %80, %77 ], [ 0, %12 ]
  %68 = fptoui double %66 to i16
  %69 = add i16 %68, %2
  %70 = mul i16 %69, 8000
  %71 = icmp eq i16 %70, %11
  br i1 %71, label %77, label %72

72:                                               ; preds = %64
  %73 = load i32, ptr @current_test, align 4, !tbaa !9
  %74 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %73)
  %75 = load double, ptr @init_value, align 8, !tbaa !28
  %76 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %77

77:                                               ; preds = %64, %72
  %78 = phi i32 [ %65, %64 ], [ %76, %72 ]
  %79 = phi double [ %66, %64 ], [ %75, %72 ]
  %80 = add nuw nsw i32 %67, 1
  %81 = icmp slt i32 %80, %78
  br i1 %81, label %64, label %82, !llvm.loop !236

82:                                               ; preds = %77, %44, %4
  %83 = tail call i64 @clock() #17
  store i64 %83, ptr @end_time, align 8, !tbaa !26
  %84 = load i64, ptr @start_time, align 8, !tbaa !26
  %85 = load ptr, ptr @results, align 8, !tbaa !5
  %86 = icmp eq ptr %85, null
  br i1 %86, label %87, label %89

87:                                               ; preds = %82
  %88 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %93

89:                                               ; preds = %82
  %90 = load i32, ptr @current_test, align 4, !tbaa !9
  %91 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %92 = icmp slt i32 %90, %91
  br i1 %92, label %105, label %93

93:                                               ; preds = %89, %87
  %94 = phi i32 [ %88, %87 ], [ %91, %89 ]
  %95 = add nsw i32 %94, 10
  store i32 %95, ptr @allocated_results, align 4, !tbaa !9
  %96 = sext i32 %95 to i64
  %97 = shl nsw i64 %96, 4
  %98 = tail call ptr @realloc(ptr noundef %85, i64 noundef %97) #14
  store ptr %98, ptr @results, align 8, !tbaa !5
  %99 = icmp eq ptr %98, null
  br i1 %99, label %102, label %100

100:                                              ; preds = %93
  %101 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %105

102:                                              ; preds = %93
  %103 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %104 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %103)
  tail call void @exit(i32 noundef -1) #15
  unreachable

105:                                              ; preds = %89, %100
  %106 = phi i32 [ %101, %100 ], [ %90, %89 ]
  %107 = phi ptr [ %98, %100 ], [ %85, %89 ]
  %108 = sub nsw i64 %83, %84
  %109 = sitofp i64 %108 to double
  %110 = fdiv double %109, 1.000000e+06
  %111 = sext i32 %106 to i64
  %112 = getelementptr inbounds %struct.one_result, ptr %107, i64 %111
  store double %110, ptr %112, align 8, !tbaa !11
  %113 = getelementptr inbounds %struct.one_result, ptr %107, i64 %111, i32 1
  store ptr %3, ptr %113, align 8, !tbaa !14
  %114 = add nsw i32 %106, 1
  store i32 %114, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4It28custom_add_multiple_variableItEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i16 noundef zeroext %2, i16 noundef zeroext %3, i16 noundef zeroext %4, i16 noundef zeroext %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !26
  %9 = load i32, ptr @iterations, align 4, !tbaa !9
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %92

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  %13 = add i16 %3, %2
  %14 = add i16 %13, %4
  %15 = add i16 %14, %5
  br i1 %12, label %18, label %16

16:                                               ; preds = %11
  %17 = load double, ptr @init_value, align 8, !tbaa !28
  br label %74

18:                                               ; preds = %11
  %19 = zext i32 %1 to i64
  %20 = icmp ult i32 %1, 16
  %21 = and i64 %19, 4294967280
  %22 = insertelement <8 x i16> poison, i16 %15, i64 0
  %23 = shufflevector <8 x i16> %22, <8 x i16> poison, <8 x i32> zeroinitializer
  %24 = insertelement <8 x i16> poison, i16 %15, i64 0
  %25 = shufflevector <8 x i16> %24, <8 x i16> poison, <8 x i32> zeroinitializer
  %26 = icmp eq i64 %21, %19
  br label %27

27:                                               ; preds = %18, %54
  %28 = phi i32 [ %55, %54 ], [ %9, %18 ]
  %29 = phi i32 [ %56, %54 ], [ 0, %18 ]
  br i1 %20, label %47, label %30

30:                                               ; preds = %27, %30
  %31 = phi i64 [ %42, %30 ], [ 0, %27 ]
  %32 = phi <8 x i16> [ %40, %30 ], [ zeroinitializer, %27 ]
  %33 = phi <8 x i16> [ %41, %30 ], [ zeroinitializer, %27 ]
  %34 = getelementptr inbounds i16, ptr %0, i64 %31
  %35 = load <8 x i16>, ptr %34, align 2, !tbaa !30
  %36 = getelementptr inbounds i16, ptr %34, i64 8
  %37 = load <8 x i16>, ptr %36, align 2, !tbaa !30
  %38 = add <8 x i16> %23, %32
  %39 = add <8 x i16> %25, %33
  %40 = add <8 x i16> %38, %35
  %41 = add <8 x i16> %39, %37
  %42 = add nuw i64 %31, 16
  %43 = icmp eq i64 %42, %21
  br i1 %43, label %44, label %30, !llvm.loop !238

44:                                               ; preds = %30
  %45 = add <8 x i16> %41, %40
  %46 = tail call i16 @llvm.vector.reduce.add.v8i16(<8 x i16> %45)
  br i1 %26, label %67, label %47

47:                                               ; preds = %27, %44
  %48 = phi i64 [ 0, %27 ], [ %21, %44 ]
  %49 = phi i16 [ 0, %27 ], [ %46, %44 ]
  br label %58

50:                                               ; preds = %67
  %51 = load i32, ptr @current_test, align 4, !tbaa !9
  %52 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %51)
  %53 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %54

54:                                               ; preds = %50, %67
  %55 = phi i32 [ %53, %50 ], [ %28, %67 ]
  %56 = add nuw nsw i32 %29, 1
  %57 = icmp slt i32 %56, %55
  br i1 %57, label %27, label %92, !llvm.loop !239

58:                                               ; preds = %47, %58
  %59 = phi i64 [ %65, %58 ], [ %48, %47 ]
  %60 = phi i16 [ %64, %58 ], [ %49, %47 ]
  %61 = getelementptr inbounds i16, ptr %0, i64 %59
  %62 = load i16, ptr %61, align 2, !tbaa !30
  %63 = add i16 %15, %60
  %64 = add i16 %63, %62
  %65 = add nuw nsw i64 %59, 1
  %66 = icmp eq i64 %65, %19
  br i1 %66, label %67, label %58, !llvm.loop !240

67:                                               ; preds = %58, %44
  %68 = phi i16 [ %46, %44 ], [ %64, %58 ]
  %69 = load double, ptr @init_value, align 8, !tbaa !28
  %70 = fptoui double %69 to i16
  %71 = add i16 %15, %70
  %72 = mul i16 %71, 8000
  %73 = icmp eq i16 %72, %68
  br i1 %73, label %54, label %50

74:                                               ; preds = %16, %87
  %75 = phi i32 [ %88, %87 ], [ %9, %16 ]
  %76 = phi double [ %89, %87 ], [ %17, %16 ]
  %77 = phi i32 [ %90, %87 ], [ 0, %16 ]
  %78 = fptoui double %76 to i16
  %79 = add i16 %15, %78
  %80 = mul i16 %79, 8000
  %81 = icmp eq i16 %80, 0
  br i1 %81, label %87, label %82

82:                                               ; preds = %74
  %83 = load i32, ptr @current_test, align 4, !tbaa !9
  %84 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %83)
  %85 = load double, ptr @init_value, align 8, !tbaa !28
  %86 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %87

87:                                               ; preds = %74, %82
  %88 = phi i32 [ %75, %74 ], [ %86, %82 ]
  %89 = phi double [ %76, %74 ], [ %85, %82 ]
  %90 = add nuw nsw i32 %77, 1
  %91 = icmp slt i32 %90, %88
  br i1 %91, label %74, label %92, !llvm.loop !239

92:                                               ; preds = %87, %54, %7
  %93 = tail call i64 @clock() #17
  store i64 %93, ptr @end_time, align 8, !tbaa !26
  %94 = load i64, ptr @start_time, align 8, !tbaa !26
  %95 = load ptr, ptr @results, align 8, !tbaa !5
  %96 = icmp eq ptr %95, null
  br i1 %96, label %97, label %99

97:                                               ; preds = %92
  %98 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %103

99:                                               ; preds = %92
  %100 = load i32, ptr @current_test, align 4, !tbaa !9
  %101 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %102 = icmp slt i32 %100, %101
  br i1 %102, label %115, label %103

103:                                              ; preds = %99, %97
  %104 = phi i32 [ %98, %97 ], [ %101, %99 ]
  %105 = add nsw i32 %104, 10
  store i32 %105, ptr @allocated_results, align 4, !tbaa !9
  %106 = sext i32 %105 to i64
  %107 = shl nsw i64 %106, 4
  %108 = tail call ptr @realloc(ptr noundef %95, i64 noundef %107) #14
  store ptr %108, ptr @results, align 8, !tbaa !5
  %109 = icmp eq ptr %108, null
  br i1 %109, label %112, label %110

110:                                              ; preds = %103
  %111 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %115

112:                                              ; preds = %103
  %113 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %114 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %113)
  tail call void @exit(i32 noundef -1) #15
  unreachable

115:                                              ; preds = %99, %110
  %116 = phi i32 [ %111, %110 ], [ %100, %99 ]
  %117 = phi ptr [ %108, %110 ], [ %95, %99 ]
  %118 = sub nsw i64 %93, %94
  %119 = sitofp i64 %118 to double
  %120 = fdiv double %119, 1.000000e+06
  %121 = sext i32 %116 to i64
  %122 = getelementptr inbounds %struct.one_result, ptr %117, i64 %121
  store double %120, ptr %122, align 8, !tbaa !11
  %123 = getelementptr inbounds %struct.one_result, ptr %117, i64 %121, i32 1
  store ptr %6, ptr %123, align 8, !tbaa !14
  %124 = add nsw i32 %116, 1
  store i32 %124, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1It19custom_sub_variableItEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i16 noundef zeroext %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !26
  %6 = load i32, ptr @iterations, align 4, !tbaa !9
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %86

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  br i1 %9, label %12, label %10

10:                                               ; preds = %8
  %11 = load double, ptr @init_value, align 8, !tbaa !28
  br label %68

12:                                               ; preds = %8
  %13 = zext i32 %1 to i64
  %14 = icmp ult i32 %1, 16
  %15 = and i64 %13, 4294967280
  %16 = insertelement <8 x i16> poison, i16 %2, i64 0
  %17 = shufflevector <8 x i16> %16, <8 x i16> poison, <8 x i32> zeroinitializer
  %18 = insertelement <8 x i16> poison, i16 %2, i64 0
  %19 = shufflevector <8 x i16> %18, <8 x i16> poison, <8 x i32> zeroinitializer
  %20 = icmp eq i64 %15, %13
  br label %21

21:                                               ; preds = %12, %48
  %22 = phi i32 [ %49, %48 ], [ %6, %12 ]
  %23 = phi i32 [ %50, %48 ], [ 0, %12 ]
  br i1 %14, label %41, label %24

24:                                               ; preds = %21, %24
  %25 = phi i64 [ %36, %24 ], [ 0, %21 ]
  %26 = phi <8 x i16> [ %34, %24 ], [ zeroinitializer, %21 ]
  %27 = phi <8 x i16> [ %35, %24 ], [ zeroinitializer, %21 ]
  %28 = getelementptr inbounds i16, ptr %0, i64 %25
  %29 = load <8 x i16>, ptr %28, align 2, !tbaa !30
  %30 = getelementptr inbounds i16, ptr %28, i64 8
  %31 = load <8 x i16>, ptr %30, align 2, !tbaa !30
  %32 = sub <8 x i16> %26, %17
  %33 = sub <8 x i16> %27, %19
  %34 = add <8 x i16> %32, %29
  %35 = add <8 x i16> %33, %31
  %36 = add nuw i64 %25, 16
  %37 = icmp eq i64 %36, %15
  br i1 %37, label %38, label %24, !llvm.loop !241

38:                                               ; preds = %24
  %39 = add <8 x i16> %35, %34
  %40 = tail call i16 @llvm.vector.reduce.add.v8i16(<8 x i16> %39)
  br i1 %20, label %61, label %41

41:                                               ; preds = %21, %38
  %42 = phi i64 [ 0, %21 ], [ %15, %38 ]
  %43 = phi i16 [ 0, %21 ], [ %40, %38 ]
  br label %52

44:                                               ; preds = %61
  %45 = load i32, ptr @current_test, align 4, !tbaa !9
  %46 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %45)
  %47 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %48

48:                                               ; preds = %44, %61
  %49 = phi i32 [ %47, %44 ], [ %22, %61 ]
  %50 = add nuw nsw i32 %23, 1
  %51 = icmp slt i32 %50, %49
  br i1 %51, label %21, label %86, !llvm.loop !242

52:                                               ; preds = %41, %52
  %53 = phi i64 [ %59, %52 ], [ %42, %41 ]
  %54 = phi i16 [ %58, %52 ], [ %43, %41 ]
  %55 = getelementptr inbounds i16, ptr %0, i64 %53
  %56 = load i16, ptr %55, align 2, !tbaa !30
  %57 = sub i16 %54, %2
  %58 = add i16 %57, %56
  %59 = add nuw nsw i64 %53, 1
  %60 = icmp eq i64 %59, %13
  br i1 %60, label %61, label %52, !llvm.loop !243

61:                                               ; preds = %52, %38
  %62 = phi i16 [ %40, %38 ], [ %58, %52 ]
  %63 = load double, ptr @init_value, align 8, !tbaa !28
  %64 = fptoui double %63 to i16
  %65 = sub i16 %64, %2
  %66 = mul i16 %65, 8000
  %67 = icmp eq i16 %66, %62
  br i1 %67, label %48, label %44

68:                                               ; preds = %10, %81
  %69 = phi i32 [ %82, %81 ], [ %6, %10 ]
  %70 = phi double [ %83, %81 ], [ %11, %10 ]
  %71 = phi i32 [ %84, %81 ], [ 0, %10 ]
  %72 = fptoui double %70 to i16
  %73 = sub i16 %72, %2
  %74 = mul i16 %73, 8000
  %75 = icmp eq i16 %74, 0
  br i1 %75, label %81, label %76

76:                                               ; preds = %68
  %77 = load i32, ptr @current_test, align 4, !tbaa !9
  %78 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %77)
  %79 = load double, ptr @init_value, align 8, !tbaa !28
  %80 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %81

81:                                               ; preds = %68, %76
  %82 = phi i32 [ %69, %68 ], [ %80, %76 ]
  %83 = phi double [ %70, %68 ], [ %79, %76 ]
  %84 = add nuw nsw i32 %71, 1
  %85 = icmp slt i32 %84, %82
  br i1 %85, label %68, label %86, !llvm.loop !242

86:                                               ; preds = %81, %48, %4
  %87 = tail call i64 @clock() #17
  store i64 %87, ptr @end_time, align 8, !tbaa !26
  %88 = load i64, ptr @start_time, align 8, !tbaa !26
  %89 = load ptr, ptr @results, align 8, !tbaa !5
  %90 = icmp eq ptr %89, null
  br i1 %90, label %91, label %93

91:                                               ; preds = %86
  %92 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %97

93:                                               ; preds = %86
  %94 = load i32, ptr @current_test, align 4, !tbaa !9
  %95 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %96 = icmp slt i32 %94, %95
  br i1 %96, label %109, label %97

97:                                               ; preds = %93, %91
  %98 = phi i32 [ %92, %91 ], [ %95, %93 ]
  %99 = add nsw i32 %98, 10
  store i32 %99, ptr @allocated_results, align 4, !tbaa !9
  %100 = sext i32 %99 to i64
  %101 = shl nsw i64 %100, 4
  %102 = tail call ptr @realloc(ptr noundef %89, i64 noundef %101) #14
  store ptr %102, ptr @results, align 8, !tbaa !5
  %103 = icmp eq ptr %102, null
  br i1 %103, label %106, label %104

104:                                              ; preds = %97
  %105 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %109

106:                                              ; preds = %97
  %107 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %108 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %107)
  tail call void @exit(i32 noundef -1) #15
  unreachable

109:                                              ; preds = %93, %104
  %110 = phi i32 [ %105, %104 ], [ %94, %93 ]
  %111 = phi ptr [ %102, %104 ], [ %89, %93 ]
  %112 = sub nsw i64 %87, %88
  %113 = sitofp i64 %112 to double
  %114 = fdiv double %113, 1.000000e+06
  %115 = sext i32 %110 to i64
  %116 = getelementptr inbounds %struct.one_result, ptr %111, i64 %115
  store double %114, ptr %116, align 8, !tbaa !11
  %117 = getelementptr inbounds %struct.one_result, ptr %111, i64 %115, i32 1
  store ptr %3, ptr %117, align 8, !tbaa !14
  %118 = add nsw i32 %110, 1
  store i32 %118, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4It28custom_sub_multiple_variableItEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i16 noundef zeroext %2, i16 noundef zeroext %3, i16 noundef zeroext %4, i16 noundef zeroext %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !26
  %9 = load i32, ptr @iterations, align 4, !tbaa !9
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %92

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  %13 = add i16 %3, %2
  %14 = add i16 %13, %4
  %15 = add i16 %14, %5
  br i1 %12, label %18, label %16

16:                                               ; preds = %11
  %17 = load double, ptr @init_value, align 8, !tbaa !28
  br label %74

18:                                               ; preds = %11
  %19 = zext i32 %1 to i64
  %20 = icmp ult i32 %1, 16
  %21 = and i64 %19, 4294967280
  %22 = insertelement <8 x i16> poison, i16 %15, i64 0
  %23 = shufflevector <8 x i16> %22, <8 x i16> poison, <8 x i32> zeroinitializer
  %24 = insertelement <8 x i16> poison, i16 %15, i64 0
  %25 = shufflevector <8 x i16> %24, <8 x i16> poison, <8 x i32> zeroinitializer
  %26 = icmp eq i64 %21, %19
  br label %27

27:                                               ; preds = %18, %54
  %28 = phi i32 [ %55, %54 ], [ %9, %18 ]
  %29 = phi i32 [ %56, %54 ], [ 0, %18 ]
  br i1 %20, label %47, label %30

30:                                               ; preds = %27, %30
  %31 = phi i64 [ %42, %30 ], [ 0, %27 ]
  %32 = phi <8 x i16> [ %40, %30 ], [ zeroinitializer, %27 ]
  %33 = phi <8 x i16> [ %41, %30 ], [ zeroinitializer, %27 ]
  %34 = getelementptr inbounds i16, ptr %0, i64 %31
  %35 = load <8 x i16>, ptr %34, align 2, !tbaa !30
  %36 = getelementptr inbounds i16, ptr %34, i64 8
  %37 = load <8 x i16>, ptr %36, align 2, !tbaa !30
  %38 = sub <8 x i16> %32, %23
  %39 = sub <8 x i16> %33, %25
  %40 = add <8 x i16> %38, %35
  %41 = add <8 x i16> %39, %37
  %42 = add nuw i64 %31, 16
  %43 = icmp eq i64 %42, %21
  br i1 %43, label %44, label %30, !llvm.loop !244

44:                                               ; preds = %30
  %45 = add <8 x i16> %41, %40
  %46 = tail call i16 @llvm.vector.reduce.add.v8i16(<8 x i16> %45)
  br i1 %26, label %67, label %47

47:                                               ; preds = %27, %44
  %48 = phi i64 [ 0, %27 ], [ %21, %44 ]
  %49 = phi i16 [ 0, %27 ], [ %46, %44 ]
  br label %58

50:                                               ; preds = %67
  %51 = load i32, ptr @current_test, align 4, !tbaa !9
  %52 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %51)
  %53 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %54

54:                                               ; preds = %50, %67
  %55 = phi i32 [ %53, %50 ], [ %28, %67 ]
  %56 = add nuw nsw i32 %29, 1
  %57 = icmp slt i32 %56, %55
  br i1 %57, label %27, label %92, !llvm.loop !245

58:                                               ; preds = %47, %58
  %59 = phi i64 [ %65, %58 ], [ %48, %47 ]
  %60 = phi i16 [ %64, %58 ], [ %49, %47 ]
  %61 = getelementptr inbounds i16, ptr %0, i64 %59
  %62 = load i16, ptr %61, align 2, !tbaa !30
  %63 = sub i16 %60, %15
  %64 = add i16 %63, %62
  %65 = add nuw nsw i64 %59, 1
  %66 = icmp eq i64 %65, %19
  br i1 %66, label %67, label %58, !llvm.loop !246

67:                                               ; preds = %58, %44
  %68 = phi i16 [ %46, %44 ], [ %64, %58 ]
  %69 = load double, ptr @init_value, align 8, !tbaa !28
  %70 = fptoui double %69 to i16
  %71 = sub i16 %70, %15
  %72 = mul i16 %71, 8000
  %73 = icmp eq i16 %72, %68
  br i1 %73, label %54, label %50

74:                                               ; preds = %16, %87
  %75 = phi i32 [ %88, %87 ], [ %9, %16 ]
  %76 = phi double [ %89, %87 ], [ %17, %16 ]
  %77 = phi i32 [ %90, %87 ], [ 0, %16 ]
  %78 = fptoui double %76 to i16
  %79 = sub i16 %78, %15
  %80 = mul i16 %79, 8000
  %81 = icmp eq i16 %80, 0
  br i1 %81, label %87, label %82

82:                                               ; preds = %74
  %83 = load i32, ptr @current_test, align 4, !tbaa !9
  %84 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %83)
  %85 = load double, ptr @init_value, align 8, !tbaa !28
  %86 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %87

87:                                               ; preds = %74, %82
  %88 = phi i32 [ %75, %74 ], [ %86, %82 ]
  %89 = phi double [ %76, %74 ], [ %85, %82 ]
  %90 = add nuw nsw i32 %77, 1
  %91 = icmp slt i32 %90, %88
  br i1 %91, label %74, label %92, !llvm.loop !245

92:                                               ; preds = %87, %54, %7
  %93 = tail call i64 @clock() #17
  store i64 %93, ptr @end_time, align 8, !tbaa !26
  %94 = load i64, ptr @start_time, align 8, !tbaa !26
  %95 = load ptr, ptr @results, align 8, !tbaa !5
  %96 = icmp eq ptr %95, null
  br i1 %96, label %97, label %99

97:                                               ; preds = %92
  %98 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %103

99:                                               ; preds = %92
  %100 = load i32, ptr @current_test, align 4, !tbaa !9
  %101 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %102 = icmp slt i32 %100, %101
  br i1 %102, label %115, label %103

103:                                              ; preds = %99, %97
  %104 = phi i32 [ %98, %97 ], [ %101, %99 ]
  %105 = add nsw i32 %104, 10
  store i32 %105, ptr @allocated_results, align 4, !tbaa !9
  %106 = sext i32 %105 to i64
  %107 = shl nsw i64 %106, 4
  %108 = tail call ptr @realloc(ptr noundef %95, i64 noundef %107) #14
  store ptr %108, ptr @results, align 8, !tbaa !5
  %109 = icmp eq ptr %108, null
  br i1 %109, label %112, label %110

110:                                              ; preds = %103
  %111 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %115

112:                                              ; preds = %103
  %113 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %114 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %113)
  tail call void @exit(i32 noundef -1) #15
  unreachable

115:                                              ; preds = %99, %110
  %116 = phi i32 [ %111, %110 ], [ %100, %99 ]
  %117 = phi ptr [ %108, %110 ], [ %95, %99 ]
  %118 = sub nsw i64 %93, %94
  %119 = sitofp i64 %118 to double
  %120 = fdiv double %119, 1.000000e+06
  %121 = sext i32 %116 to i64
  %122 = getelementptr inbounds %struct.one_result, ptr %117, i64 %121
  store double %120, ptr %122, align 8, !tbaa !11
  %123 = getelementptr inbounds %struct.one_result, ptr %117, i64 %121, i32 1
  store ptr %6, ptr %123, align 8, !tbaa !14
  %124 = add nsw i32 %116, 1
  store i32 %124, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1It24custom_multiply_variableItEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i16 noundef zeroext %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !26
  %6 = load i32, ptr @iterations, align 4, !tbaa !9
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %85

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  %10 = mul i16 %2, 8000
  br i1 %9, label %13, label %11

11:                                               ; preds = %8
  %12 = load double, ptr @init_value, align 8, !tbaa !28
  br label %68

13:                                               ; preds = %8
  %14 = zext i32 %1 to i64
  %15 = icmp ult i32 %1, 16
  %16 = and i64 %14, 4294967280
  %17 = insertelement <8 x i16> poison, i16 %2, i64 0
  %18 = shufflevector <8 x i16> %17, <8 x i16> poison, <8 x i32> zeroinitializer
  %19 = insertelement <8 x i16> poison, i16 %2, i64 0
  %20 = shufflevector <8 x i16> %19, <8 x i16> poison, <8 x i32> zeroinitializer
  %21 = icmp eq i64 %16, %14
  br label %22

22:                                               ; preds = %13, %49
  %23 = phi i32 [ %50, %49 ], [ %6, %13 ]
  %24 = phi i32 [ %51, %49 ], [ 0, %13 ]
  br i1 %15, label %42, label %25

25:                                               ; preds = %22, %25
  %26 = phi i64 [ %37, %25 ], [ 0, %22 ]
  %27 = phi <8 x i16> [ %35, %25 ], [ zeroinitializer, %22 ]
  %28 = phi <8 x i16> [ %36, %25 ], [ zeroinitializer, %22 ]
  %29 = getelementptr inbounds i16, ptr %0, i64 %26
  %30 = load <8 x i16>, ptr %29, align 2, !tbaa !30
  %31 = getelementptr inbounds i16, ptr %29, i64 8
  %32 = load <8 x i16>, ptr %31, align 2, !tbaa !30
  %33 = mul <8 x i16> %30, %18
  %34 = mul <8 x i16> %32, %20
  %35 = add <8 x i16> %33, %27
  %36 = add <8 x i16> %34, %28
  %37 = add nuw i64 %26, 16
  %38 = icmp eq i64 %37, %16
  br i1 %38, label %39, label %25, !llvm.loop !247

39:                                               ; preds = %25
  %40 = add <8 x i16> %36, %35
  %41 = tail call i16 @llvm.vector.reduce.add.v8i16(<8 x i16> %40)
  br i1 %21, label %62, label %42

42:                                               ; preds = %22, %39
  %43 = phi i64 [ 0, %22 ], [ %16, %39 ]
  %44 = phi i16 [ 0, %22 ], [ %41, %39 ]
  br label %53

45:                                               ; preds = %62
  %46 = load i32, ptr @current_test, align 4, !tbaa !9
  %47 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %46)
  %48 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %49

49:                                               ; preds = %45, %62
  %50 = phi i32 [ %48, %45 ], [ %23, %62 ]
  %51 = add nuw nsw i32 %24, 1
  %52 = icmp slt i32 %51, %50
  br i1 %52, label %22, label %85, !llvm.loop !248

53:                                               ; preds = %42, %53
  %54 = phi i64 [ %60, %53 ], [ %43, %42 ]
  %55 = phi i16 [ %59, %53 ], [ %44, %42 ]
  %56 = getelementptr inbounds i16, ptr %0, i64 %54
  %57 = load i16, ptr %56, align 2, !tbaa !30
  %58 = mul i16 %57, %2
  %59 = add i16 %58, %55
  %60 = add nuw nsw i64 %54, 1
  %61 = icmp eq i64 %60, %14
  br i1 %61, label %62, label %53, !llvm.loop !249

62:                                               ; preds = %53, %39
  %63 = phi i16 [ %41, %39 ], [ %59, %53 ]
  %64 = load double, ptr @init_value, align 8, !tbaa !28
  %65 = fptoui double %64 to i16
  %66 = mul i16 %10, %65
  %67 = icmp eq i16 %66, %63
  br i1 %67, label %49, label %45

68:                                               ; preds = %11, %80
  %69 = phi i32 [ %81, %80 ], [ %6, %11 ]
  %70 = phi double [ %82, %80 ], [ %12, %11 ]
  %71 = phi i32 [ %83, %80 ], [ 0, %11 ]
  %72 = fptoui double %70 to i16
  %73 = mul i16 %10, %72
  %74 = icmp eq i16 %73, 0
  br i1 %74, label %80, label %75

75:                                               ; preds = %68
  %76 = load i32, ptr @current_test, align 4, !tbaa !9
  %77 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %76)
  %78 = load double, ptr @init_value, align 8, !tbaa !28
  %79 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %80

80:                                               ; preds = %68, %75
  %81 = phi i32 [ %69, %68 ], [ %79, %75 ]
  %82 = phi double [ %70, %68 ], [ %78, %75 ]
  %83 = add nuw nsw i32 %71, 1
  %84 = icmp slt i32 %83, %81
  br i1 %84, label %68, label %85, !llvm.loop !248

85:                                               ; preds = %80, %49, %4
  %86 = tail call i64 @clock() #17
  store i64 %86, ptr @end_time, align 8, !tbaa !26
  %87 = load i64, ptr @start_time, align 8, !tbaa !26
  %88 = load ptr, ptr @results, align 8, !tbaa !5
  %89 = icmp eq ptr %88, null
  br i1 %89, label %90, label %92

90:                                               ; preds = %85
  %91 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %96

92:                                               ; preds = %85
  %93 = load i32, ptr @current_test, align 4, !tbaa !9
  %94 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %95 = icmp slt i32 %93, %94
  br i1 %95, label %108, label %96

96:                                               ; preds = %92, %90
  %97 = phi i32 [ %91, %90 ], [ %94, %92 ]
  %98 = add nsw i32 %97, 10
  store i32 %98, ptr @allocated_results, align 4, !tbaa !9
  %99 = sext i32 %98 to i64
  %100 = shl nsw i64 %99, 4
  %101 = tail call ptr @realloc(ptr noundef %88, i64 noundef %100) #14
  store ptr %101, ptr @results, align 8, !tbaa !5
  %102 = icmp eq ptr %101, null
  br i1 %102, label %105, label %103

103:                                              ; preds = %96
  %104 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %108

105:                                              ; preds = %96
  %106 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %107 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %106)
  tail call void @exit(i32 noundef -1) #15
  unreachable

108:                                              ; preds = %92, %103
  %109 = phi i32 [ %104, %103 ], [ %93, %92 ]
  %110 = phi ptr [ %101, %103 ], [ %88, %92 ]
  %111 = sub nsw i64 %86, %87
  %112 = sitofp i64 %111 to double
  %113 = fdiv double %112, 1.000000e+06
  %114 = sext i32 %109 to i64
  %115 = getelementptr inbounds %struct.one_result, ptr %110, i64 %114
  store double %113, ptr %115, align 8, !tbaa !11
  %116 = getelementptr inbounds %struct.one_result, ptr %110, i64 %114, i32 1
  store ptr %3, ptr %116, align 8, !tbaa !14
  %117 = add nsw i32 %109, 1
  store i32 %117, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4It33custom_multiply_multiple_variableItEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i16 noundef zeroext %2, i16 noundef zeroext %3, i16 noundef zeroext %4, i16 noundef zeroext %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !26
  %9 = load i32, ptr @iterations, align 4, !tbaa !9
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %93

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  %13 = mul i16 %3, %2
  %14 = mul i16 %13, %4
  %15 = mul i16 %14, %5
  %16 = mul i16 %13, 8000
  %17 = mul i16 %16, %4
  %18 = mul i16 %17, %5
  br i1 %12, label %21, label %19

19:                                               ; preds = %11
  %20 = load double, ptr @init_value, align 8, !tbaa !28
  br label %76

21:                                               ; preds = %11
  %22 = zext i32 %1 to i64
  %23 = icmp ult i32 %1, 16
  %24 = and i64 %22, 4294967280
  %25 = insertelement <8 x i16> poison, i16 %15, i64 0
  %26 = shufflevector <8 x i16> %25, <8 x i16> poison, <8 x i32> zeroinitializer
  %27 = insertelement <8 x i16> poison, i16 %15, i64 0
  %28 = shufflevector <8 x i16> %27, <8 x i16> poison, <8 x i32> zeroinitializer
  %29 = icmp eq i64 %24, %22
  br label %30

30:                                               ; preds = %21, %57
  %31 = phi i32 [ %58, %57 ], [ %9, %21 ]
  %32 = phi i32 [ %59, %57 ], [ 0, %21 ]
  br i1 %23, label %50, label %33

33:                                               ; preds = %30, %33
  %34 = phi i64 [ %45, %33 ], [ 0, %30 ]
  %35 = phi <8 x i16> [ %43, %33 ], [ zeroinitializer, %30 ]
  %36 = phi <8 x i16> [ %44, %33 ], [ zeroinitializer, %30 ]
  %37 = getelementptr inbounds i16, ptr %0, i64 %34
  %38 = load <8 x i16>, ptr %37, align 2, !tbaa !30
  %39 = getelementptr inbounds i16, ptr %37, i64 8
  %40 = load <8 x i16>, ptr %39, align 2, !tbaa !30
  %41 = mul <8 x i16> %26, %38
  %42 = mul <8 x i16> %28, %40
  %43 = add <8 x i16> %41, %35
  %44 = add <8 x i16> %42, %36
  %45 = add nuw i64 %34, 16
  %46 = icmp eq i64 %45, %24
  br i1 %46, label %47, label %33, !llvm.loop !250

47:                                               ; preds = %33
  %48 = add <8 x i16> %44, %43
  %49 = tail call i16 @llvm.vector.reduce.add.v8i16(<8 x i16> %48)
  br i1 %29, label %70, label %50

50:                                               ; preds = %30, %47
  %51 = phi i64 [ 0, %30 ], [ %24, %47 ]
  %52 = phi i16 [ 0, %30 ], [ %49, %47 ]
  br label %61

53:                                               ; preds = %70
  %54 = load i32, ptr @current_test, align 4, !tbaa !9
  %55 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %54)
  %56 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %57

57:                                               ; preds = %53, %70
  %58 = phi i32 [ %56, %53 ], [ %31, %70 ]
  %59 = add nuw nsw i32 %32, 1
  %60 = icmp slt i32 %59, %58
  br i1 %60, label %30, label %93, !llvm.loop !251

61:                                               ; preds = %50, %61
  %62 = phi i64 [ %68, %61 ], [ %51, %50 ]
  %63 = phi i16 [ %67, %61 ], [ %52, %50 ]
  %64 = getelementptr inbounds i16, ptr %0, i64 %62
  %65 = load i16, ptr %64, align 2, !tbaa !30
  %66 = mul i16 %15, %65
  %67 = add i16 %66, %63
  %68 = add nuw nsw i64 %62, 1
  %69 = icmp eq i64 %68, %22
  br i1 %69, label %70, label %61, !llvm.loop !252

70:                                               ; preds = %61, %47
  %71 = phi i16 [ %49, %47 ], [ %67, %61 ]
  %72 = load double, ptr @init_value, align 8, !tbaa !28
  %73 = fptoui double %72 to i16
  %74 = mul i16 %18, %73
  %75 = icmp eq i16 %74, %71
  br i1 %75, label %57, label %53

76:                                               ; preds = %19, %88
  %77 = phi i32 [ %89, %88 ], [ %9, %19 ]
  %78 = phi double [ %90, %88 ], [ %20, %19 ]
  %79 = phi i32 [ %91, %88 ], [ 0, %19 ]
  %80 = fptoui double %78 to i16
  %81 = mul i16 %18, %80
  %82 = icmp eq i16 %81, 0
  br i1 %82, label %88, label %83

83:                                               ; preds = %76
  %84 = load i32, ptr @current_test, align 4, !tbaa !9
  %85 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %84)
  %86 = load double, ptr @init_value, align 8, !tbaa !28
  %87 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %88

88:                                               ; preds = %76, %83
  %89 = phi i32 [ %77, %76 ], [ %87, %83 ]
  %90 = phi double [ %78, %76 ], [ %86, %83 ]
  %91 = add nuw nsw i32 %79, 1
  %92 = icmp slt i32 %91, %89
  br i1 %92, label %76, label %93, !llvm.loop !251

93:                                               ; preds = %88, %57, %7
  %94 = tail call i64 @clock() #17
  store i64 %94, ptr @end_time, align 8, !tbaa !26
  %95 = load i64, ptr @start_time, align 8, !tbaa !26
  %96 = load ptr, ptr @results, align 8, !tbaa !5
  %97 = icmp eq ptr %96, null
  br i1 %97, label %98, label %100

98:                                               ; preds = %93
  %99 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %104

100:                                              ; preds = %93
  %101 = load i32, ptr @current_test, align 4, !tbaa !9
  %102 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %103 = icmp slt i32 %101, %102
  br i1 %103, label %116, label %104

104:                                              ; preds = %100, %98
  %105 = phi i32 [ %99, %98 ], [ %102, %100 ]
  %106 = add nsw i32 %105, 10
  store i32 %106, ptr @allocated_results, align 4, !tbaa !9
  %107 = sext i32 %106 to i64
  %108 = shl nsw i64 %107, 4
  %109 = tail call ptr @realloc(ptr noundef %96, i64 noundef %108) #14
  store ptr %109, ptr @results, align 8, !tbaa !5
  %110 = icmp eq ptr %109, null
  br i1 %110, label %113, label %111

111:                                              ; preds = %104
  %112 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %116

113:                                              ; preds = %104
  %114 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %115 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %114)
  tail call void @exit(i32 noundef -1) #15
  unreachable

116:                                              ; preds = %100, %111
  %117 = phi i32 [ %112, %111 ], [ %101, %100 ]
  %118 = phi ptr [ %109, %111 ], [ %96, %100 ]
  %119 = sub nsw i64 %94, %95
  %120 = sitofp i64 %119 to double
  %121 = fdiv double %120, 1.000000e+06
  %122 = sext i32 %117 to i64
  %123 = getelementptr inbounds %struct.one_result, ptr %118, i64 %122
  store double %121, ptr %123, align 8, !tbaa !11
  %124 = getelementptr inbounds %struct.one_result, ptr %118, i64 %122, i32 1
  store ptr %6, ptr %124, align 8, !tbaa !14
  %125 = add nsw i32 %117, 1
  store i32 %125, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4It34custom_multiply_multiple_variable2ItEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i16 noundef zeroext %2, i16 noundef zeroext %3, i16 noundef zeroext %4, i16 noundef zeroext %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !26
  %9 = load i32, ptr @iterations, align 4, !tbaa !9
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %92

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  %13 = mul i16 %3, %2
  %14 = mul i16 %13, %4
  %15 = mul i16 %14, %5
  br i1 %12, label %18, label %16

16:                                               ; preds = %11
  %17 = load double, ptr @init_value, align 8, !tbaa !28
  br label %74

18:                                               ; preds = %11
  %19 = zext i32 %1 to i64
  %20 = icmp ult i32 %1, 16
  %21 = and i64 %19, 4294967280
  %22 = insertelement <8 x i16> poison, i16 %15, i64 0
  %23 = shufflevector <8 x i16> %22, <8 x i16> poison, <8 x i32> zeroinitializer
  %24 = insertelement <8 x i16> poison, i16 %15, i64 0
  %25 = shufflevector <8 x i16> %24, <8 x i16> poison, <8 x i32> zeroinitializer
  %26 = icmp eq i64 %21, %19
  br label %27

27:                                               ; preds = %18, %54
  %28 = phi i32 [ %55, %54 ], [ %9, %18 ]
  %29 = phi i32 [ %56, %54 ], [ 0, %18 ]
  br i1 %20, label %47, label %30

30:                                               ; preds = %27, %30
  %31 = phi i64 [ %42, %30 ], [ 0, %27 ]
  %32 = phi <8 x i16> [ %40, %30 ], [ zeroinitializer, %27 ]
  %33 = phi <8 x i16> [ %41, %30 ], [ zeroinitializer, %27 ]
  %34 = getelementptr inbounds i16, ptr %0, i64 %31
  %35 = load <8 x i16>, ptr %34, align 2, !tbaa !30
  %36 = getelementptr inbounds i16, ptr %34, i64 8
  %37 = load <8 x i16>, ptr %36, align 2, !tbaa !30
  %38 = add <8 x i16> %32, %23
  %39 = add <8 x i16> %33, %25
  %40 = add <8 x i16> %38, %35
  %41 = add <8 x i16> %39, %37
  %42 = add nuw i64 %31, 16
  %43 = icmp eq i64 %42, %21
  br i1 %43, label %44, label %30, !llvm.loop !253

44:                                               ; preds = %30
  %45 = add <8 x i16> %41, %40
  %46 = tail call i16 @llvm.vector.reduce.add.v8i16(<8 x i16> %45)
  br i1 %26, label %67, label %47

47:                                               ; preds = %27, %44
  %48 = phi i64 [ 0, %27 ], [ %21, %44 ]
  %49 = phi i16 [ 0, %27 ], [ %46, %44 ]
  br label %58

50:                                               ; preds = %67
  %51 = load i32, ptr @current_test, align 4, !tbaa !9
  %52 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %51)
  %53 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %54

54:                                               ; preds = %50, %67
  %55 = phi i32 [ %53, %50 ], [ %28, %67 ]
  %56 = add nuw nsw i32 %29, 1
  %57 = icmp slt i32 %56, %55
  br i1 %57, label %27, label %92, !llvm.loop !254

58:                                               ; preds = %47, %58
  %59 = phi i64 [ %65, %58 ], [ %48, %47 ]
  %60 = phi i16 [ %64, %58 ], [ %49, %47 ]
  %61 = getelementptr inbounds i16, ptr %0, i64 %59
  %62 = load i16, ptr %61, align 2, !tbaa !30
  %63 = add i16 %60, %15
  %64 = add i16 %63, %62
  %65 = add nuw nsw i64 %59, 1
  %66 = icmp eq i64 %65, %19
  br i1 %66, label %67, label %58, !llvm.loop !255

67:                                               ; preds = %58, %44
  %68 = phi i16 [ %46, %44 ], [ %64, %58 ]
  %69 = load double, ptr @init_value, align 8, !tbaa !28
  %70 = fptoui double %69 to i16
  %71 = add i16 %15, %70
  %72 = mul i16 %71, 8000
  %73 = icmp eq i16 %72, %68
  br i1 %73, label %54, label %50

74:                                               ; preds = %16, %87
  %75 = phi i32 [ %88, %87 ], [ %9, %16 ]
  %76 = phi double [ %89, %87 ], [ %17, %16 ]
  %77 = phi i32 [ %90, %87 ], [ 0, %16 ]
  %78 = fptoui double %76 to i16
  %79 = add i16 %15, %78
  %80 = mul i16 %79, 8000
  %81 = icmp eq i16 %80, 0
  br i1 %81, label %87, label %82

82:                                               ; preds = %74
  %83 = load i32, ptr @current_test, align 4, !tbaa !9
  %84 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %83)
  %85 = load double, ptr @init_value, align 8, !tbaa !28
  %86 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %87

87:                                               ; preds = %74, %82
  %88 = phi i32 [ %75, %74 ], [ %86, %82 ]
  %89 = phi double [ %76, %74 ], [ %85, %82 ]
  %90 = add nuw nsw i32 %77, 1
  %91 = icmp slt i32 %90, %88
  br i1 %91, label %74, label %92, !llvm.loop !254

92:                                               ; preds = %87, %54, %7
  %93 = tail call i64 @clock() #17
  store i64 %93, ptr @end_time, align 8, !tbaa !26
  %94 = load i64, ptr @start_time, align 8, !tbaa !26
  %95 = load ptr, ptr @results, align 8, !tbaa !5
  %96 = icmp eq ptr %95, null
  br i1 %96, label %97, label %99

97:                                               ; preds = %92
  %98 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %103

99:                                               ; preds = %92
  %100 = load i32, ptr @current_test, align 4, !tbaa !9
  %101 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %102 = icmp slt i32 %100, %101
  br i1 %102, label %115, label %103

103:                                              ; preds = %99, %97
  %104 = phi i32 [ %98, %97 ], [ %101, %99 ]
  %105 = add nsw i32 %104, 10
  store i32 %105, ptr @allocated_results, align 4, !tbaa !9
  %106 = sext i32 %105 to i64
  %107 = shl nsw i64 %106, 4
  %108 = tail call ptr @realloc(ptr noundef %95, i64 noundef %107) #14
  store ptr %108, ptr @results, align 8, !tbaa !5
  %109 = icmp eq ptr %108, null
  br i1 %109, label %112, label %110

110:                                              ; preds = %103
  %111 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %115

112:                                              ; preds = %103
  %113 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %114 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %113)
  tail call void @exit(i32 noundef -1) #15
  unreachable

115:                                              ; preds = %99, %110
  %116 = phi i32 [ %111, %110 ], [ %100, %99 ]
  %117 = phi ptr [ %108, %110 ], [ %95, %99 ]
  %118 = sub nsw i64 %93, %94
  %119 = sitofp i64 %118 to double
  %120 = fdiv double %119, 1.000000e+06
  %121 = sext i32 %116 to i64
  %122 = getelementptr inbounds %struct.one_result, ptr %117, i64 %121
  store double %120, ptr %122, align 8, !tbaa !11
  %123 = getelementptr inbounds %struct.one_result, ptr %117, i64 %121, i32 1
  store ptr %6, ptr %123, align 8, !tbaa !14
  %124 = add nsw i32 %116, 1
  store i32 %124, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1It22custom_divide_variableItEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i16 noundef zeroext %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !26
  %6 = load i32, ptr @iterations, align 4, !tbaa !9
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %79

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  br i1 %9, label %12, label %10

10:                                               ; preds = %8
  %11 = load double, ptr @init_value, align 8, !tbaa !28
  br label %61

12:                                               ; preds = %8
  %13 = zext i32 %1 to i64
  %14 = and i64 %13, 1
  %15 = icmp eq i32 %1, 1
  %16 = and i64 %13, 4294967294
  %17 = icmp eq i64 %14, 0
  br label %18

18:                                               ; preds = %12, %25
  %19 = phi i32 [ %26, %25 ], [ %6, %12 ]
  %20 = phi i32 [ %27, %25 ], [ 0, %12 ]
  br i1 %15, label %45, label %29

21:                                               ; preds = %54
  %22 = load i32, ptr @current_test, align 4, !tbaa !9
  %23 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %22)
  %24 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %25

25:                                               ; preds = %21, %54
  %26 = phi i32 [ %24, %21 ], [ %19, %54 ]
  %27 = add nuw nsw i32 %20, 1
  %28 = icmp slt i32 %27, %26
  br i1 %28, label %18, label %79, !llvm.loop !256

29:                                               ; preds = %18, %29
  %30 = phi i64 [ %42, %29 ], [ 0, %18 ]
  %31 = phi i16 [ %41, %29 ], [ 0, %18 ]
  %32 = phi i64 [ %43, %29 ], [ 0, %18 ]
  %33 = getelementptr inbounds i16, ptr %0, i64 %30
  %34 = load i16, ptr %33, align 2, !tbaa !30
  %35 = udiv i16 %34, %2
  %36 = add i16 %35, %31
  %37 = or i64 %30, 1
  %38 = getelementptr inbounds i16, ptr %0, i64 %37
  %39 = load i16, ptr %38, align 2, !tbaa !30
  %40 = udiv i16 %39, %2
  %41 = add i16 %40, %36
  %42 = add nuw nsw i64 %30, 2
  %43 = add i64 %32, 2
  %44 = icmp eq i64 %43, %16
  br i1 %44, label %45, label %29, !llvm.loop !257

45:                                               ; preds = %29, %18
  %46 = phi i16 [ undef, %18 ], [ %41, %29 ]
  %47 = phi i64 [ 0, %18 ], [ %42, %29 ]
  %48 = phi i16 [ 0, %18 ], [ %41, %29 ]
  br i1 %17, label %54, label %49

49:                                               ; preds = %45
  %50 = getelementptr inbounds i16, ptr %0, i64 %47
  %51 = load i16, ptr %50, align 2, !tbaa !30
  %52 = udiv i16 %51, %2
  %53 = add i16 %52, %48
  br label %54

54:                                               ; preds = %45, %49
  %55 = phi i16 [ %46, %45 ], [ %53, %49 ]
  %56 = load double, ptr @init_value, align 8, !tbaa !28
  %57 = fptoui double %56 to i16
  %58 = udiv i16 %57, %2
  %59 = mul i16 %58, 8000
  %60 = icmp eq i16 %59, %55
  br i1 %60, label %25, label %21

61:                                               ; preds = %10, %74
  %62 = phi i32 [ %75, %74 ], [ %6, %10 ]
  %63 = phi double [ %76, %74 ], [ %11, %10 ]
  %64 = phi i32 [ %77, %74 ], [ 0, %10 ]
  %65 = fptoui double %63 to i16
  %66 = udiv i16 %65, %2
  %67 = mul i16 %66, 8000
  %68 = icmp eq i16 %67, 0
  br i1 %68, label %74, label %69

69:                                               ; preds = %61
  %70 = load i32, ptr @current_test, align 4, !tbaa !9
  %71 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %70)
  %72 = load double, ptr @init_value, align 8, !tbaa !28
  %73 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %74

74:                                               ; preds = %61, %69
  %75 = phi i32 [ %62, %61 ], [ %73, %69 ]
  %76 = phi double [ %63, %61 ], [ %72, %69 ]
  %77 = add nuw nsw i32 %64, 1
  %78 = icmp slt i32 %77, %75
  br i1 %78, label %61, label %79, !llvm.loop !256

79:                                               ; preds = %74, %25, %4
  %80 = tail call i64 @clock() #17
  store i64 %80, ptr @end_time, align 8, !tbaa !26
  %81 = load i64, ptr @start_time, align 8, !tbaa !26
  %82 = load ptr, ptr @results, align 8, !tbaa !5
  %83 = icmp eq ptr %82, null
  br i1 %83, label %84, label %86

84:                                               ; preds = %79
  %85 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %90

86:                                               ; preds = %79
  %87 = load i32, ptr @current_test, align 4, !tbaa !9
  %88 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %89 = icmp slt i32 %87, %88
  br i1 %89, label %102, label %90

90:                                               ; preds = %86, %84
  %91 = phi i32 [ %85, %84 ], [ %88, %86 ]
  %92 = add nsw i32 %91, 10
  store i32 %92, ptr @allocated_results, align 4, !tbaa !9
  %93 = sext i32 %92 to i64
  %94 = shl nsw i64 %93, 4
  %95 = tail call ptr @realloc(ptr noundef %82, i64 noundef %94) #14
  store ptr %95, ptr @results, align 8, !tbaa !5
  %96 = icmp eq ptr %95, null
  br i1 %96, label %99, label %97

97:                                               ; preds = %90
  %98 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %102

99:                                               ; preds = %90
  %100 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %101 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %100)
  tail call void @exit(i32 noundef -1) #15
  unreachable

102:                                              ; preds = %86, %97
  %103 = phi i32 [ %98, %97 ], [ %87, %86 ]
  %104 = phi ptr [ %95, %97 ], [ %82, %86 ]
  %105 = sub nsw i64 %80, %81
  %106 = sitofp i64 %105 to double
  %107 = fdiv double %106, 1.000000e+06
  %108 = sext i32 %103 to i64
  %109 = getelementptr inbounds %struct.one_result, ptr %104, i64 %108
  store double %107, ptr %109, align 8, !tbaa !11
  %110 = getelementptr inbounds %struct.one_result, ptr %104, i64 %108, i32 1
  store ptr %3, ptr %110, align 8, !tbaa !14
  %111 = add nsw i32 %103, 1
  store i32 %111, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4It31custom_divide_multiple_variableItEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i16 noundef zeroext %2, i16 noundef zeroext %3, i16 noundef zeroext %4, i16 noundef zeroext %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !26
  %9 = load i32, ptr @iterations, align 4, !tbaa !9
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %70

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  br i1 %12, label %15, label %13

13:                                               ; preds = %11
  %14 = load double, ptr @init_value, align 8, !tbaa !28
  br label %49

15:                                               ; preds = %11
  %16 = zext i32 %1 to i64
  br label %17

17:                                               ; preds = %15, %24
  %18 = phi i32 [ %25, %24 ], [ %9, %15 ]
  %19 = phi i32 [ %26, %24 ], [ 0, %15 ]
  br label %28

20:                                               ; preds = %40
  %21 = load i32, ptr @current_test, align 4, !tbaa !9
  %22 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %21)
  %23 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %24

24:                                               ; preds = %20, %40
  %25 = phi i32 [ %23, %20 ], [ %18, %40 ]
  %26 = add nuw nsw i32 %19, 1
  %27 = icmp slt i32 %26, %25
  br i1 %27, label %17, label %70, !llvm.loop !258

28:                                               ; preds = %17, %28
  %29 = phi i64 [ 0, %17 ], [ %38, %28 ]
  %30 = phi i16 [ 0, %17 ], [ %37, %28 ]
  %31 = getelementptr inbounds i16, ptr %0, i64 %29
  %32 = load i16, ptr %31, align 2, !tbaa !30
  %33 = udiv i16 %32, %2
  %34 = udiv i16 %33, %3
  %35 = udiv i16 %34, %4
  %36 = udiv i16 %35, %5
  %37 = add i16 %36, %30
  %38 = add nuw nsw i64 %29, 1
  %39 = icmp eq i64 %38, %16
  br i1 %39, label %40, label %28, !llvm.loop !259

40:                                               ; preds = %28
  %41 = load double, ptr @init_value, align 8, !tbaa !28
  %42 = fptoui double %41 to i16
  %43 = udiv i16 %42, %2
  %44 = udiv i16 %43, %3
  %45 = udiv i16 %44, %4
  %46 = udiv i16 %45, %5
  %47 = mul i16 %46, 8000
  %48 = icmp eq i16 %47, %37
  br i1 %48, label %24, label %20

49:                                               ; preds = %13, %65
  %50 = phi i32 [ %66, %65 ], [ %9, %13 ]
  %51 = phi double [ %67, %65 ], [ %14, %13 ]
  %52 = phi i32 [ %68, %65 ], [ 0, %13 ]
  %53 = fptoui double %51 to i16
  %54 = udiv i16 %53, %2
  %55 = udiv i16 %54, %3
  %56 = udiv i16 %55, %4
  %57 = udiv i16 %56, %5
  %58 = mul i16 %57, 8000
  %59 = icmp eq i16 %58, 0
  br i1 %59, label %65, label %60

60:                                               ; preds = %49
  %61 = load i32, ptr @current_test, align 4, !tbaa !9
  %62 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %61)
  %63 = load double, ptr @init_value, align 8, !tbaa !28
  %64 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %65

65:                                               ; preds = %49, %60
  %66 = phi i32 [ %50, %49 ], [ %64, %60 ]
  %67 = phi double [ %51, %49 ], [ %63, %60 ]
  %68 = add nuw nsw i32 %52, 1
  %69 = icmp slt i32 %68, %66
  br i1 %69, label %49, label %70, !llvm.loop !258

70:                                               ; preds = %65, %24, %7
  %71 = tail call i64 @clock() #17
  store i64 %71, ptr @end_time, align 8, !tbaa !26
  %72 = load i64, ptr @start_time, align 8, !tbaa !26
  %73 = load ptr, ptr @results, align 8, !tbaa !5
  %74 = icmp eq ptr %73, null
  br i1 %74, label %75, label %77

75:                                               ; preds = %70
  %76 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %81

77:                                               ; preds = %70
  %78 = load i32, ptr @current_test, align 4, !tbaa !9
  %79 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %80 = icmp slt i32 %78, %79
  br i1 %80, label %93, label %81

81:                                               ; preds = %77, %75
  %82 = phi i32 [ %76, %75 ], [ %79, %77 ]
  %83 = add nsw i32 %82, 10
  store i32 %83, ptr @allocated_results, align 4, !tbaa !9
  %84 = sext i32 %83 to i64
  %85 = shl nsw i64 %84, 4
  %86 = tail call ptr @realloc(ptr noundef %73, i64 noundef %85) #14
  store ptr %86, ptr @results, align 8, !tbaa !5
  %87 = icmp eq ptr %86, null
  br i1 %87, label %90, label %88

88:                                               ; preds = %81
  %89 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %93

90:                                               ; preds = %81
  %91 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %92 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %91)
  tail call void @exit(i32 noundef -1) #15
  unreachable

93:                                               ; preds = %77, %88
  %94 = phi i32 [ %89, %88 ], [ %78, %77 ]
  %95 = phi ptr [ %86, %88 ], [ %73, %77 ]
  %96 = sub nsw i64 %71, %72
  %97 = sitofp i64 %96 to double
  %98 = fdiv double %97, 1.000000e+06
  %99 = sext i32 %94 to i64
  %100 = getelementptr inbounds %struct.one_result, ptr %95, i64 %99
  store double %98, ptr %100, align 8, !tbaa !11
  %101 = getelementptr inbounds %struct.one_result, ptr %95, i64 %99, i32 1
  store ptr %6, ptr %101, align 8, !tbaa !14
  %102 = add nsw i32 %94, 1
  store i32 %102, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4It32custom_divide_multiple_variable2ItEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i16 noundef zeroext %2, i16 noundef zeroext %3, i16 noundef zeroext %4, i16 noundef zeroext %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !26
  %9 = load i32, ptr @iterations, align 4, !tbaa !9
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %92

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  %13 = udiv i16 %2, %3
  %14 = udiv i16 %13, %4
  %15 = udiv i16 %14, %5
  br i1 %12, label %18, label %16

16:                                               ; preds = %11
  %17 = load double, ptr @init_value, align 8, !tbaa !28
  br label %74

18:                                               ; preds = %11
  %19 = zext i32 %1 to i64
  %20 = icmp ult i32 %1, 16
  %21 = and i64 %19, 4294967280
  %22 = insertelement <8 x i16> poison, i16 %15, i64 0
  %23 = shufflevector <8 x i16> %22, <8 x i16> poison, <8 x i32> zeroinitializer
  %24 = insertelement <8 x i16> poison, i16 %15, i64 0
  %25 = shufflevector <8 x i16> %24, <8 x i16> poison, <8 x i32> zeroinitializer
  %26 = icmp eq i64 %21, %19
  br label %27

27:                                               ; preds = %54, %18
  %28 = phi i32 [ %9, %18 ], [ %55, %54 ]
  %29 = phi i32 [ 0, %18 ], [ %56, %54 ]
  br i1 %20, label %47, label %30

30:                                               ; preds = %27, %30
  %31 = phi i64 [ %42, %30 ], [ 0, %27 ]
  %32 = phi <8 x i16> [ %40, %30 ], [ zeroinitializer, %27 ]
  %33 = phi <8 x i16> [ %41, %30 ], [ zeroinitializer, %27 ]
  %34 = getelementptr inbounds i16, ptr %0, i64 %31
  %35 = load <8 x i16>, ptr %34, align 2, !tbaa !30
  %36 = getelementptr inbounds i16, ptr %34, i64 8
  %37 = load <8 x i16>, ptr %36, align 2, !tbaa !30
  %38 = add <8 x i16> %35, %32
  %39 = add <8 x i16> %37, %33
  %40 = add <8 x i16> %38, %23
  %41 = add <8 x i16> %39, %25
  %42 = add nuw i64 %31, 16
  %43 = icmp eq i64 %42, %21
  br i1 %43, label %44, label %30, !llvm.loop !260

44:                                               ; preds = %30
  %45 = add <8 x i16> %41, %40
  %46 = tail call i16 @llvm.vector.reduce.add.v8i16(<8 x i16> %45)
  br i1 %26, label %67, label %47

47:                                               ; preds = %27, %44
  %48 = phi i64 [ 0, %27 ], [ %21, %44 ]
  %49 = phi i16 [ 0, %27 ], [ %46, %44 ]
  br label %58

50:                                               ; preds = %67
  %51 = load i32, ptr @current_test, align 4, !tbaa !9
  %52 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %51)
  %53 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %54

54:                                               ; preds = %50, %67
  %55 = phi i32 [ %53, %50 ], [ %28, %67 ]
  %56 = add nuw nsw i32 %29, 1
  %57 = icmp slt i32 %56, %55
  br i1 %57, label %27, label %92, !llvm.loop !261

58:                                               ; preds = %47, %58
  %59 = phi i64 [ %65, %58 ], [ %48, %47 ]
  %60 = phi i16 [ %64, %58 ], [ %49, %47 ]
  %61 = getelementptr inbounds i16, ptr %0, i64 %59
  %62 = load i16, ptr %61, align 2, !tbaa !30
  %63 = add i16 %62, %60
  %64 = add i16 %63, %15
  %65 = add nuw nsw i64 %59, 1
  %66 = icmp eq i64 %65, %19
  br i1 %66, label %67, label %58, !llvm.loop !262

67:                                               ; preds = %58, %44
  %68 = phi i16 [ %46, %44 ], [ %64, %58 ]
  %69 = load double, ptr @init_value, align 8, !tbaa !28
  %70 = fptoui double %69 to i16
  %71 = add i16 %15, %70
  %72 = mul i16 %71, 8000
  %73 = icmp eq i16 %72, %68
  br i1 %73, label %54, label %50

74:                                               ; preds = %16, %87
  %75 = phi i32 [ %88, %87 ], [ %9, %16 ]
  %76 = phi double [ %89, %87 ], [ %17, %16 ]
  %77 = phi i32 [ %90, %87 ], [ 0, %16 ]
  %78 = fptoui double %76 to i16
  %79 = add i16 %15, %78
  %80 = mul i16 %79, 8000
  %81 = icmp eq i16 %80, 0
  br i1 %81, label %87, label %82

82:                                               ; preds = %74
  %83 = load i32, ptr @current_test, align 4, !tbaa !9
  %84 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %83)
  %85 = load double, ptr @init_value, align 8, !tbaa !28
  %86 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %87

87:                                               ; preds = %74, %82
  %88 = phi i32 [ %75, %74 ], [ %86, %82 ]
  %89 = phi double [ %76, %74 ], [ %85, %82 ]
  %90 = add nuw nsw i32 %77, 1
  %91 = icmp slt i32 %90, %88
  br i1 %91, label %74, label %92, !llvm.loop !261

92:                                               ; preds = %87, %54, %7
  %93 = tail call i64 @clock() #17
  store i64 %93, ptr @end_time, align 8, !tbaa !26
  %94 = load i64, ptr @start_time, align 8, !tbaa !26
  %95 = load ptr, ptr @results, align 8, !tbaa !5
  %96 = icmp eq ptr %95, null
  br i1 %96, label %97, label %99

97:                                               ; preds = %92
  %98 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %103

99:                                               ; preds = %92
  %100 = load i32, ptr @current_test, align 4, !tbaa !9
  %101 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %102 = icmp slt i32 %100, %101
  br i1 %102, label %115, label %103

103:                                              ; preds = %99, %97
  %104 = phi i32 [ %98, %97 ], [ %101, %99 ]
  %105 = add nsw i32 %104, 10
  store i32 %105, ptr @allocated_results, align 4, !tbaa !9
  %106 = sext i32 %105 to i64
  %107 = shl nsw i64 %106, 4
  %108 = tail call ptr @realloc(ptr noundef %95, i64 noundef %107) #14
  store ptr %108, ptr @results, align 8, !tbaa !5
  %109 = icmp eq ptr %108, null
  br i1 %109, label %112, label %110

110:                                              ; preds = %103
  %111 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %115

112:                                              ; preds = %103
  %113 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %114 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %113)
  tail call void @exit(i32 noundef -1) #15
  unreachable

115:                                              ; preds = %99, %110
  %116 = phi i32 [ %111, %110 ], [ %100, %99 ]
  %117 = phi ptr [ %108, %110 ], [ %95, %99 ]
  %118 = sub nsw i64 %93, %94
  %119 = sitofp i64 %118 to double
  %120 = fdiv double %119, 1.000000e+06
  %121 = sext i32 %116 to i64
  %122 = getelementptr inbounds %struct.one_result, ptr %117, i64 %121
  store double %120, ptr %122, align 8, !tbaa !11
  %123 = getelementptr inbounds %struct.one_result, ptr %117, i64 %121, i32 1
  store ptr %6, ptr %123, align 8, !tbaa !14
  %124 = add nsw i32 %116, 1
  store i32 %124, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4It30custom_mixed_multiple_variableItEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i16 noundef zeroext %2, i16 noundef zeroext %3, i16 noundef zeroext %4, i16 noundef zeroext %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !26
  %9 = load i32, ptr @iterations, align 4, !tbaa !9
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %111

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  %13 = zext i16 %2 to i32
  %14 = zext i16 %3 to i32
  %15 = zext i16 %4 to i32
  %16 = mul nuw nsw i32 %15, %14
  %17 = zext i16 %5 to i32
  %18 = udiv i32 %16, %17
  %19 = trunc i32 %18 to i16
  br i1 %12, label %22, label %20

20:                                               ; preds = %11
  %21 = load double, ptr @init_value, align 8, !tbaa !28
  br label %92

22:                                               ; preds = %11
  %23 = zext i32 %1 to i64
  %24 = icmp ult i32 %1, 16
  %25 = and i64 %23, 4294967280
  %26 = insertelement <8 x i32> poison, i32 %13, i64 0
  %27 = shufflevector <8 x i32> %26, <8 x i32> poison, <8 x i32> zeroinitializer
  %28 = insertelement <8 x i32> poison, i32 %13, i64 0
  %29 = shufflevector <8 x i32> %28, <8 x i32> poison, <8 x i32> zeroinitializer
  %30 = insertelement <8 x i32> poison, i32 %18, i64 0
  %31 = shufflevector <8 x i32> %30, <8 x i32> poison, <8 x i32> zeroinitializer
  %32 = insertelement <8 x i32> poison, i32 %18, i64 0
  %33 = shufflevector <8 x i32> %32, <8 x i32> poison, <8 x i32> zeroinitializer
  %34 = icmp eq i64 %25, %23
  br label %35

35:                                               ; preds = %68, %22
  %36 = phi i32 [ %9, %22 ], [ %69, %68 ]
  %37 = phi i32 [ 0, %22 ], [ %70, %68 ]
  br i1 %24, label %61, label %38

38:                                               ; preds = %35, %38
  %39 = phi i64 [ %56, %38 ], [ 0, %35 ]
  %40 = phi <8 x i16> [ %54, %38 ], [ zeroinitializer, %35 ]
  %41 = phi <8 x i16> [ %55, %38 ], [ zeroinitializer, %35 ]
  %42 = getelementptr inbounds i16, ptr %0, i64 %39
  %43 = load <8 x i16>, ptr %42, align 2, !tbaa !30
  %44 = getelementptr inbounds i16, ptr %42, i64 8
  %45 = load <8 x i16>, ptr %44, align 2, !tbaa !30
  %46 = zext <8 x i16> %43 to <8 x i32>
  %47 = zext <8 x i16> %45 to <8 x i32>
  %48 = add nuw nsw <8 x i32> %27, %46
  %49 = add nuw nsw <8 x i32> %29, %47
  %50 = sub nsw <8 x i32> %48, %31
  %51 = sub nsw <8 x i32> %49, %33
  %52 = trunc <8 x i32> %50 to <8 x i16>
  %53 = trunc <8 x i32> %51 to <8 x i16>
  %54 = add <8 x i16> %40, %52
  %55 = add <8 x i16> %41, %53
  %56 = add nuw i64 %39, 16
  %57 = icmp eq i64 %56, %25
  br i1 %57, label %58, label %38, !llvm.loop !263

58:                                               ; preds = %38
  %59 = add <8 x i16> %55, %54
  %60 = tail call i16 @llvm.vector.reduce.add.v8i16(<8 x i16> %59)
  br i1 %34, label %84, label %61

61:                                               ; preds = %35, %58
  %62 = phi i64 [ 0, %35 ], [ %25, %58 ]
  %63 = phi i16 [ 0, %35 ], [ %60, %58 ]
  br label %72

64:                                               ; preds = %84
  %65 = load i32, ptr @current_test, align 4, !tbaa !9
  %66 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %65)
  %67 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %68

68:                                               ; preds = %64, %84
  %69 = phi i32 [ %67, %64 ], [ %36, %84 ]
  %70 = add nuw nsw i32 %37, 1
  %71 = icmp slt i32 %70, %69
  br i1 %71, label %35, label %111, !llvm.loop !264

72:                                               ; preds = %61, %72
  %73 = phi i64 [ %82, %72 ], [ %62, %61 ]
  %74 = phi i16 [ %81, %72 ], [ %63, %61 ]
  %75 = getelementptr inbounds i16, ptr %0, i64 %73
  %76 = load i16, ptr %75, align 2, !tbaa !30
  %77 = zext i16 %76 to i32
  %78 = add nuw nsw i32 %77, %13
  %79 = sub nsw i32 %78, %18
  %80 = trunc i32 %79 to i16
  %81 = add i16 %74, %80
  %82 = add nuw nsw i64 %73, 1
  %83 = icmp eq i64 %82, %23
  br i1 %83, label %84, label %72, !llvm.loop !265

84:                                               ; preds = %72, %58
  %85 = phi i16 [ %60, %58 ], [ %81, %72 ]
  %86 = load double, ptr @init_value, align 8, !tbaa !28
  %87 = fptoui double %86 to i16
  %88 = add i16 %87, %2
  %89 = sub i16 %88, %19
  %90 = mul i16 %89, 8000
  %91 = icmp eq i16 %90, %85
  br i1 %91, label %68, label %64

92:                                               ; preds = %20, %106
  %93 = phi i32 [ %107, %106 ], [ %9, %20 ]
  %94 = phi double [ %108, %106 ], [ %21, %20 ]
  %95 = phi i32 [ %109, %106 ], [ 0, %20 ]
  %96 = fptoui double %94 to i16
  %97 = add i16 %96, %2
  %98 = sub i16 %97, %19
  %99 = mul i16 %98, 8000
  %100 = icmp eq i16 %99, 0
  br i1 %100, label %106, label %101

101:                                              ; preds = %92
  %102 = load i32, ptr @current_test, align 4, !tbaa !9
  %103 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %102)
  %104 = load double, ptr @init_value, align 8, !tbaa !28
  %105 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %106

106:                                              ; preds = %92, %101
  %107 = phi i32 [ %93, %92 ], [ %105, %101 ]
  %108 = phi double [ %94, %92 ], [ %104, %101 ]
  %109 = add nuw nsw i32 %95, 1
  %110 = icmp slt i32 %109, %107
  br i1 %110, label %92, label %111, !llvm.loop !264

111:                                              ; preds = %106, %68, %7
  %112 = tail call i64 @clock() #17
  store i64 %112, ptr @end_time, align 8, !tbaa !26
  %113 = load i64, ptr @start_time, align 8, !tbaa !26
  %114 = load ptr, ptr @results, align 8, !tbaa !5
  %115 = icmp eq ptr %114, null
  br i1 %115, label %116, label %118

116:                                              ; preds = %111
  %117 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %122

118:                                              ; preds = %111
  %119 = load i32, ptr @current_test, align 4, !tbaa !9
  %120 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %121 = icmp slt i32 %119, %120
  br i1 %121, label %134, label %122

122:                                              ; preds = %118, %116
  %123 = phi i32 [ %117, %116 ], [ %120, %118 ]
  %124 = add nsw i32 %123, 10
  store i32 %124, ptr @allocated_results, align 4, !tbaa !9
  %125 = sext i32 %124 to i64
  %126 = shl nsw i64 %125, 4
  %127 = tail call ptr @realloc(ptr noundef %114, i64 noundef %126) #14
  store ptr %127, ptr @results, align 8, !tbaa !5
  %128 = icmp eq ptr %127, null
  br i1 %128, label %131, label %129

129:                                              ; preds = %122
  %130 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %134

131:                                              ; preds = %122
  %132 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %133 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %132)
  tail call void @exit(i32 noundef -1) #15
  unreachable

134:                                              ; preds = %118, %129
  %135 = phi i32 [ %130, %129 ], [ %119, %118 ]
  %136 = phi ptr [ %127, %129 ], [ %114, %118 ]
  %137 = sub nsw i64 %112, %113
  %138 = sitofp i64 %137 to double
  %139 = fdiv double %138, 1.000000e+06
  %140 = sext i32 %135 to i64
  %141 = getelementptr inbounds %struct.one_result, ptr %136, i64 %140
  store double %139, ptr %141, align 8, !tbaa !11
  %142 = getelementptr inbounds %struct.one_result, ptr %136, i64 %140, i32 1
  store ptr %6, ptr %142, align 8, !tbaa !14
  %143 = add nsw i32 %135, 1
  store i32 %143, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1It19custom_variable_andItEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i16 noundef zeroext %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !26
  %6 = load i32, ptr @iterations, align 4, !tbaa !9
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %86

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  br i1 %9, label %12, label %10

10:                                               ; preds = %8
  %11 = load double, ptr @init_value, align 8, !tbaa !28
  br label %68

12:                                               ; preds = %8
  %13 = zext i32 %1 to i64
  %14 = icmp ult i32 %1, 16
  %15 = and i64 %13, 4294967280
  %16 = insertelement <8 x i16> poison, i16 %2, i64 0
  %17 = shufflevector <8 x i16> %16, <8 x i16> poison, <8 x i32> zeroinitializer
  %18 = insertelement <8 x i16> poison, i16 %2, i64 0
  %19 = shufflevector <8 x i16> %18, <8 x i16> poison, <8 x i32> zeroinitializer
  %20 = icmp eq i64 %15, %13
  br label %21

21:                                               ; preds = %12, %48
  %22 = phi i32 [ %49, %48 ], [ %6, %12 ]
  %23 = phi i32 [ %50, %48 ], [ 0, %12 ]
  br i1 %14, label %41, label %24

24:                                               ; preds = %21, %24
  %25 = phi i64 [ %36, %24 ], [ 0, %21 ]
  %26 = phi <8 x i16> [ %34, %24 ], [ zeroinitializer, %21 ]
  %27 = phi <8 x i16> [ %35, %24 ], [ zeroinitializer, %21 ]
  %28 = getelementptr inbounds i16, ptr %0, i64 %25
  %29 = load <8 x i16>, ptr %28, align 2, !tbaa !30
  %30 = getelementptr inbounds i16, ptr %28, i64 8
  %31 = load <8 x i16>, ptr %30, align 2, !tbaa !30
  %32 = and <8 x i16> %29, %17
  %33 = and <8 x i16> %31, %19
  %34 = add <8 x i16> %32, %26
  %35 = add <8 x i16> %33, %27
  %36 = add nuw i64 %25, 16
  %37 = icmp eq i64 %36, %15
  br i1 %37, label %38, label %24, !llvm.loop !266

38:                                               ; preds = %24
  %39 = add <8 x i16> %35, %34
  %40 = tail call i16 @llvm.vector.reduce.add.v8i16(<8 x i16> %39)
  br i1 %20, label %61, label %41

41:                                               ; preds = %21, %38
  %42 = phi i64 [ 0, %21 ], [ %15, %38 ]
  %43 = phi i16 [ 0, %21 ], [ %40, %38 ]
  br label %52

44:                                               ; preds = %61
  %45 = load i32, ptr @current_test, align 4, !tbaa !9
  %46 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %45)
  %47 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %48

48:                                               ; preds = %44, %61
  %49 = phi i32 [ %47, %44 ], [ %22, %61 ]
  %50 = add nuw nsw i32 %23, 1
  %51 = icmp slt i32 %50, %49
  br i1 %51, label %21, label %86, !llvm.loop !267

52:                                               ; preds = %41, %52
  %53 = phi i64 [ %59, %52 ], [ %42, %41 ]
  %54 = phi i16 [ %58, %52 ], [ %43, %41 ]
  %55 = getelementptr inbounds i16, ptr %0, i64 %53
  %56 = load i16, ptr %55, align 2, !tbaa !30
  %57 = and i16 %56, %2
  %58 = add i16 %57, %54
  %59 = add nuw nsw i64 %53, 1
  %60 = icmp eq i64 %59, %13
  br i1 %60, label %61, label %52, !llvm.loop !268

61:                                               ; preds = %52, %38
  %62 = phi i16 [ %40, %38 ], [ %58, %52 ]
  %63 = load double, ptr @init_value, align 8, !tbaa !28
  %64 = fptoui double %63 to i16
  %65 = and i16 %64, %2
  %66 = mul i16 %65, 8000
  %67 = icmp eq i16 %66, %62
  br i1 %67, label %48, label %44

68:                                               ; preds = %10, %81
  %69 = phi i32 [ %82, %81 ], [ %6, %10 ]
  %70 = phi double [ %83, %81 ], [ %11, %10 ]
  %71 = phi i32 [ %84, %81 ], [ 0, %10 ]
  %72 = fptoui double %70 to i16
  %73 = and i16 %72, %2
  %74 = mul i16 %73, 8000
  %75 = icmp eq i16 %74, 0
  br i1 %75, label %81, label %76

76:                                               ; preds = %68
  %77 = load i32, ptr @current_test, align 4, !tbaa !9
  %78 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %77)
  %79 = load double, ptr @init_value, align 8, !tbaa !28
  %80 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %81

81:                                               ; preds = %68, %76
  %82 = phi i32 [ %69, %68 ], [ %80, %76 ]
  %83 = phi double [ %70, %68 ], [ %79, %76 ]
  %84 = add nuw nsw i32 %71, 1
  %85 = icmp slt i32 %84, %82
  br i1 %85, label %68, label %86, !llvm.loop !267

86:                                               ; preds = %81, %48, %4
  %87 = tail call i64 @clock() #17
  store i64 %87, ptr @end_time, align 8, !tbaa !26
  %88 = load i64, ptr @start_time, align 8, !tbaa !26
  %89 = load ptr, ptr @results, align 8, !tbaa !5
  %90 = icmp eq ptr %89, null
  br i1 %90, label %91, label %93

91:                                               ; preds = %86
  %92 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %97

93:                                               ; preds = %86
  %94 = load i32, ptr @current_test, align 4, !tbaa !9
  %95 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %96 = icmp slt i32 %94, %95
  br i1 %96, label %109, label %97

97:                                               ; preds = %93, %91
  %98 = phi i32 [ %92, %91 ], [ %95, %93 ]
  %99 = add nsw i32 %98, 10
  store i32 %99, ptr @allocated_results, align 4, !tbaa !9
  %100 = sext i32 %99 to i64
  %101 = shl nsw i64 %100, 4
  %102 = tail call ptr @realloc(ptr noundef %89, i64 noundef %101) #14
  store ptr %102, ptr @results, align 8, !tbaa !5
  %103 = icmp eq ptr %102, null
  br i1 %103, label %106, label %104

104:                                              ; preds = %97
  %105 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %109

106:                                              ; preds = %97
  %107 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %108 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %107)
  tail call void @exit(i32 noundef -1) #15
  unreachable

109:                                              ; preds = %93, %104
  %110 = phi i32 [ %105, %104 ], [ %94, %93 ]
  %111 = phi ptr [ %102, %104 ], [ %89, %93 ]
  %112 = sub nsw i64 %87, %88
  %113 = sitofp i64 %112 to double
  %114 = fdiv double %113, 1.000000e+06
  %115 = sext i32 %110 to i64
  %116 = getelementptr inbounds %struct.one_result, ptr %111, i64 %115
  store double %114, ptr %116, align 8, !tbaa !11
  %117 = getelementptr inbounds %struct.one_result, ptr %111, i64 %115, i32 1
  store ptr %3, ptr %117, align 8, !tbaa !14
  %118 = add nsw i32 %110, 1
  store i32 %118, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4It28custom_multiple_variable_andItEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i16 noundef zeroext %2, i16 noundef zeroext %3, i16 noundef zeroext %4, i16 noundef zeroext %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !26
  %9 = load i32, ptr @iterations, align 4, !tbaa !9
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %101

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  %13 = and i16 %3, %2
  %14 = and i16 %13, %4
  %15 = and i16 %14, %5
  br i1 %12, label %18, label %16

16:                                               ; preds = %11
  %17 = load double, ptr @init_value, align 8, !tbaa !28
  br label %83

18:                                               ; preds = %11
  %19 = zext i32 %1 to i64
  %20 = icmp ult i32 %1, 16
  %21 = and i64 %19, 4294967280
  %22 = and i16 %3, %2
  %23 = and i16 %3, %2
  %24 = and i16 %22, %4
  %25 = and i16 %23, %4
  %26 = and i16 %24, %5
  %27 = insertelement <8 x i16> poison, i16 %26, i64 0
  %28 = shufflevector <8 x i16> %27, <8 x i16> poison, <8 x i32> zeroinitializer
  %29 = and i16 %25, %5
  %30 = insertelement <8 x i16> poison, i16 %29, i64 0
  %31 = shufflevector <8 x i16> %30, <8 x i16> poison, <8 x i32> zeroinitializer
  %32 = icmp eq i64 %21, %19
  br label %33

33:                                               ; preds = %18, %60
  %34 = phi i32 [ %61, %60 ], [ %9, %18 ]
  %35 = phi i32 [ %62, %60 ], [ 0, %18 ]
  br i1 %20, label %53, label %36

36:                                               ; preds = %33, %36
  %37 = phi i64 [ %48, %36 ], [ 0, %33 ]
  %38 = phi <8 x i16> [ %46, %36 ], [ zeroinitializer, %33 ]
  %39 = phi <8 x i16> [ %47, %36 ], [ zeroinitializer, %33 ]
  %40 = getelementptr inbounds i16, ptr %0, i64 %37
  %41 = load <8 x i16>, ptr %40, align 2, !tbaa !30
  %42 = getelementptr inbounds i16, ptr %40, i64 8
  %43 = load <8 x i16>, ptr %42, align 2, !tbaa !30
  %44 = and <8 x i16> %28, %41
  %45 = and <8 x i16> %31, %43
  %46 = add <8 x i16> %44, %38
  %47 = add <8 x i16> %45, %39
  %48 = add nuw i64 %37, 16
  %49 = icmp eq i64 %48, %21
  br i1 %49, label %50, label %36, !llvm.loop !269

50:                                               ; preds = %36
  %51 = add <8 x i16> %47, %46
  %52 = tail call i16 @llvm.vector.reduce.add.v8i16(<8 x i16> %51)
  br i1 %32, label %76, label %53

53:                                               ; preds = %33, %50
  %54 = phi i64 [ 0, %33 ], [ %21, %50 ]
  %55 = phi i16 [ 0, %33 ], [ %52, %50 ]
  br label %64

56:                                               ; preds = %76
  %57 = load i32, ptr @current_test, align 4, !tbaa !9
  %58 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %57)
  %59 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %60

60:                                               ; preds = %56, %76
  %61 = phi i32 [ %59, %56 ], [ %34, %76 ]
  %62 = add nuw nsw i32 %35, 1
  %63 = icmp slt i32 %62, %61
  br i1 %63, label %33, label %101, !llvm.loop !270

64:                                               ; preds = %53, %64
  %65 = phi i64 [ %74, %64 ], [ %54, %53 ]
  %66 = phi i16 [ %73, %64 ], [ %55, %53 ]
  %67 = getelementptr inbounds i16, ptr %0, i64 %65
  %68 = load i16, ptr %67, align 2, !tbaa !30
  %69 = and i16 %68, %2
  %70 = and i16 %69, %3
  %71 = and i16 %70, %4
  %72 = and i16 %71, %5
  %73 = add i16 %72, %66
  %74 = add nuw nsw i64 %65, 1
  %75 = icmp eq i64 %74, %19
  br i1 %75, label %76, label %64, !llvm.loop !271

76:                                               ; preds = %64, %50
  %77 = phi i16 [ %52, %50 ], [ %73, %64 ]
  %78 = load double, ptr @init_value, align 8, !tbaa !28
  %79 = fptoui double %78 to i16
  %80 = and i16 %15, %79
  %81 = mul i16 %80, 8000
  %82 = icmp eq i16 %81, %77
  br i1 %82, label %60, label %56

83:                                               ; preds = %16, %96
  %84 = phi i32 [ %97, %96 ], [ %9, %16 ]
  %85 = phi double [ %98, %96 ], [ %17, %16 ]
  %86 = phi i32 [ %99, %96 ], [ 0, %16 ]
  %87 = fptoui double %85 to i16
  %88 = and i16 %15, %87
  %89 = mul i16 %88, 8000
  %90 = icmp eq i16 %89, 0
  br i1 %90, label %96, label %91

91:                                               ; preds = %83
  %92 = load i32, ptr @current_test, align 4, !tbaa !9
  %93 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %92)
  %94 = load double, ptr @init_value, align 8, !tbaa !28
  %95 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %96

96:                                               ; preds = %83, %91
  %97 = phi i32 [ %84, %83 ], [ %95, %91 ]
  %98 = phi double [ %85, %83 ], [ %94, %91 ]
  %99 = add nuw nsw i32 %86, 1
  %100 = icmp slt i32 %99, %97
  br i1 %100, label %83, label %101, !llvm.loop !270

101:                                              ; preds = %96, %60, %7
  %102 = tail call i64 @clock() #17
  store i64 %102, ptr @end_time, align 8, !tbaa !26
  %103 = load i64, ptr @start_time, align 8, !tbaa !26
  %104 = load ptr, ptr @results, align 8, !tbaa !5
  %105 = icmp eq ptr %104, null
  br i1 %105, label %106, label %108

106:                                              ; preds = %101
  %107 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %112

108:                                              ; preds = %101
  %109 = load i32, ptr @current_test, align 4, !tbaa !9
  %110 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %111 = icmp slt i32 %109, %110
  br i1 %111, label %124, label %112

112:                                              ; preds = %108, %106
  %113 = phi i32 [ %107, %106 ], [ %110, %108 ]
  %114 = add nsw i32 %113, 10
  store i32 %114, ptr @allocated_results, align 4, !tbaa !9
  %115 = sext i32 %114 to i64
  %116 = shl nsw i64 %115, 4
  %117 = tail call ptr @realloc(ptr noundef %104, i64 noundef %116) #14
  store ptr %117, ptr @results, align 8, !tbaa !5
  %118 = icmp eq ptr %117, null
  br i1 %118, label %121, label %119

119:                                              ; preds = %112
  %120 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %124

121:                                              ; preds = %112
  %122 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %123 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %122)
  tail call void @exit(i32 noundef -1) #15
  unreachable

124:                                              ; preds = %108, %119
  %125 = phi i32 [ %120, %119 ], [ %109, %108 ]
  %126 = phi ptr [ %117, %119 ], [ %104, %108 ]
  %127 = sub nsw i64 %102, %103
  %128 = sitofp i64 %127 to double
  %129 = fdiv double %128, 1.000000e+06
  %130 = sext i32 %125 to i64
  %131 = getelementptr inbounds %struct.one_result, ptr %126, i64 %130
  store double %129, ptr %131, align 8, !tbaa !11
  %132 = getelementptr inbounds %struct.one_result, ptr %126, i64 %130, i32 1
  store ptr %6, ptr %132, align 8, !tbaa !14
  %133 = add nsw i32 %125, 1
  store i32 %133, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1It18custom_variable_orItEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i16 noundef zeroext %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !26
  %6 = load i32, ptr @iterations, align 4, !tbaa !9
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %86

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  br i1 %9, label %12, label %10

10:                                               ; preds = %8
  %11 = load double, ptr @init_value, align 8, !tbaa !28
  br label %68

12:                                               ; preds = %8
  %13 = zext i32 %1 to i64
  %14 = icmp ult i32 %1, 16
  %15 = and i64 %13, 4294967280
  %16 = insertelement <8 x i16> poison, i16 %2, i64 0
  %17 = shufflevector <8 x i16> %16, <8 x i16> poison, <8 x i32> zeroinitializer
  %18 = insertelement <8 x i16> poison, i16 %2, i64 0
  %19 = shufflevector <8 x i16> %18, <8 x i16> poison, <8 x i32> zeroinitializer
  %20 = icmp eq i64 %15, %13
  br label %21

21:                                               ; preds = %12, %48
  %22 = phi i32 [ %49, %48 ], [ %6, %12 ]
  %23 = phi i32 [ %50, %48 ], [ 0, %12 ]
  br i1 %14, label %41, label %24

24:                                               ; preds = %21, %24
  %25 = phi i64 [ %36, %24 ], [ 0, %21 ]
  %26 = phi <8 x i16> [ %34, %24 ], [ zeroinitializer, %21 ]
  %27 = phi <8 x i16> [ %35, %24 ], [ zeroinitializer, %21 ]
  %28 = getelementptr inbounds i16, ptr %0, i64 %25
  %29 = load <8 x i16>, ptr %28, align 2, !tbaa !30
  %30 = getelementptr inbounds i16, ptr %28, i64 8
  %31 = load <8 x i16>, ptr %30, align 2, !tbaa !30
  %32 = or <8 x i16> %29, %17
  %33 = or <8 x i16> %31, %19
  %34 = add <8 x i16> %32, %26
  %35 = add <8 x i16> %33, %27
  %36 = add nuw i64 %25, 16
  %37 = icmp eq i64 %36, %15
  br i1 %37, label %38, label %24, !llvm.loop !272

38:                                               ; preds = %24
  %39 = add <8 x i16> %35, %34
  %40 = tail call i16 @llvm.vector.reduce.add.v8i16(<8 x i16> %39)
  br i1 %20, label %61, label %41

41:                                               ; preds = %21, %38
  %42 = phi i64 [ 0, %21 ], [ %15, %38 ]
  %43 = phi i16 [ 0, %21 ], [ %40, %38 ]
  br label %52

44:                                               ; preds = %61
  %45 = load i32, ptr @current_test, align 4, !tbaa !9
  %46 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %45)
  %47 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %48

48:                                               ; preds = %44, %61
  %49 = phi i32 [ %47, %44 ], [ %22, %61 ]
  %50 = add nuw nsw i32 %23, 1
  %51 = icmp slt i32 %50, %49
  br i1 %51, label %21, label %86, !llvm.loop !273

52:                                               ; preds = %41, %52
  %53 = phi i64 [ %59, %52 ], [ %42, %41 ]
  %54 = phi i16 [ %58, %52 ], [ %43, %41 ]
  %55 = getelementptr inbounds i16, ptr %0, i64 %53
  %56 = load i16, ptr %55, align 2, !tbaa !30
  %57 = or i16 %56, %2
  %58 = add i16 %57, %54
  %59 = add nuw nsw i64 %53, 1
  %60 = icmp eq i64 %59, %13
  br i1 %60, label %61, label %52, !llvm.loop !274

61:                                               ; preds = %52, %38
  %62 = phi i16 [ %40, %38 ], [ %58, %52 ]
  %63 = load double, ptr @init_value, align 8, !tbaa !28
  %64 = fptoui double %63 to i16
  %65 = or i16 %64, %2
  %66 = mul i16 %65, 8000
  %67 = icmp eq i16 %66, %62
  br i1 %67, label %48, label %44

68:                                               ; preds = %10, %81
  %69 = phi i32 [ %82, %81 ], [ %6, %10 ]
  %70 = phi double [ %83, %81 ], [ %11, %10 ]
  %71 = phi i32 [ %84, %81 ], [ 0, %10 ]
  %72 = fptoui double %70 to i16
  %73 = or i16 %72, %2
  %74 = mul i16 %73, 8000
  %75 = icmp eq i16 %74, 0
  br i1 %75, label %81, label %76

76:                                               ; preds = %68
  %77 = load i32, ptr @current_test, align 4, !tbaa !9
  %78 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %77)
  %79 = load double, ptr @init_value, align 8, !tbaa !28
  %80 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %81

81:                                               ; preds = %68, %76
  %82 = phi i32 [ %69, %68 ], [ %80, %76 ]
  %83 = phi double [ %70, %68 ], [ %79, %76 ]
  %84 = add nuw nsw i32 %71, 1
  %85 = icmp slt i32 %84, %82
  br i1 %85, label %68, label %86, !llvm.loop !273

86:                                               ; preds = %81, %48, %4
  %87 = tail call i64 @clock() #17
  store i64 %87, ptr @end_time, align 8, !tbaa !26
  %88 = load i64, ptr @start_time, align 8, !tbaa !26
  %89 = load ptr, ptr @results, align 8, !tbaa !5
  %90 = icmp eq ptr %89, null
  br i1 %90, label %91, label %93

91:                                               ; preds = %86
  %92 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %97

93:                                               ; preds = %86
  %94 = load i32, ptr @current_test, align 4, !tbaa !9
  %95 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %96 = icmp slt i32 %94, %95
  br i1 %96, label %109, label %97

97:                                               ; preds = %93, %91
  %98 = phi i32 [ %92, %91 ], [ %95, %93 ]
  %99 = add nsw i32 %98, 10
  store i32 %99, ptr @allocated_results, align 4, !tbaa !9
  %100 = sext i32 %99 to i64
  %101 = shl nsw i64 %100, 4
  %102 = tail call ptr @realloc(ptr noundef %89, i64 noundef %101) #14
  store ptr %102, ptr @results, align 8, !tbaa !5
  %103 = icmp eq ptr %102, null
  br i1 %103, label %106, label %104

104:                                              ; preds = %97
  %105 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %109

106:                                              ; preds = %97
  %107 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %108 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %107)
  tail call void @exit(i32 noundef -1) #15
  unreachable

109:                                              ; preds = %93, %104
  %110 = phi i32 [ %105, %104 ], [ %94, %93 ]
  %111 = phi ptr [ %102, %104 ], [ %89, %93 ]
  %112 = sub nsw i64 %87, %88
  %113 = sitofp i64 %112 to double
  %114 = fdiv double %113, 1.000000e+06
  %115 = sext i32 %110 to i64
  %116 = getelementptr inbounds %struct.one_result, ptr %111, i64 %115
  store double %114, ptr %116, align 8, !tbaa !11
  %117 = getelementptr inbounds %struct.one_result, ptr %111, i64 %115, i32 1
  store ptr %3, ptr %117, align 8, !tbaa !14
  %118 = add nsw i32 %110, 1
  store i32 %118, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4It27custom_multiple_variable_orItEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i16 noundef zeroext %2, i16 noundef zeroext %3, i16 noundef zeroext %4, i16 noundef zeroext %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !26
  %9 = load i32, ptr @iterations, align 4, !tbaa !9
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %101

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  %13 = or i16 %3, %2
  %14 = or i16 %13, %4
  %15 = or i16 %14, %5
  br i1 %12, label %18, label %16

16:                                               ; preds = %11
  %17 = load double, ptr @init_value, align 8, !tbaa !28
  br label %83

18:                                               ; preds = %11
  %19 = zext i32 %1 to i64
  %20 = icmp ult i32 %1, 16
  %21 = and i64 %19, 4294967280
  %22 = or i16 %3, %2
  %23 = or i16 %3, %2
  %24 = or i16 %22, %4
  %25 = or i16 %23, %4
  %26 = or i16 %24, %5
  %27 = insertelement <8 x i16> poison, i16 %26, i64 0
  %28 = shufflevector <8 x i16> %27, <8 x i16> poison, <8 x i32> zeroinitializer
  %29 = or i16 %25, %5
  %30 = insertelement <8 x i16> poison, i16 %29, i64 0
  %31 = shufflevector <8 x i16> %30, <8 x i16> poison, <8 x i32> zeroinitializer
  %32 = icmp eq i64 %21, %19
  br label %33

33:                                               ; preds = %18, %60
  %34 = phi i32 [ %61, %60 ], [ %9, %18 ]
  %35 = phi i32 [ %62, %60 ], [ 0, %18 ]
  br i1 %20, label %53, label %36

36:                                               ; preds = %33, %36
  %37 = phi i64 [ %48, %36 ], [ 0, %33 ]
  %38 = phi <8 x i16> [ %46, %36 ], [ zeroinitializer, %33 ]
  %39 = phi <8 x i16> [ %47, %36 ], [ zeroinitializer, %33 ]
  %40 = getelementptr inbounds i16, ptr %0, i64 %37
  %41 = load <8 x i16>, ptr %40, align 2, !tbaa !30
  %42 = getelementptr inbounds i16, ptr %40, i64 8
  %43 = load <8 x i16>, ptr %42, align 2, !tbaa !30
  %44 = or <8 x i16> %28, %41
  %45 = or <8 x i16> %31, %43
  %46 = add <8 x i16> %44, %38
  %47 = add <8 x i16> %45, %39
  %48 = add nuw i64 %37, 16
  %49 = icmp eq i64 %48, %21
  br i1 %49, label %50, label %36, !llvm.loop !275

50:                                               ; preds = %36
  %51 = add <8 x i16> %47, %46
  %52 = tail call i16 @llvm.vector.reduce.add.v8i16(<8 x i16> %51)
  br i1 %32, label %76, label %53

53:                                               ; preds = %33, %50
  %54 = phi i64 [ 0, %33 ], [ %21, %50 ]
  %55 = phi i16 [ 0, %33 ], [ %52, %50 ]
  br label %64

56:                                               ; preds = %76
  %57 = load i32, ptr @current_test, align 4, !tbaa !9
  %58 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %57)
  %59 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %60

60:                                               ; preds = %56, %76
  %61 = phi i32 [ %59, %56 ], [ %34, %76 ]
  %62 = add nuw nsw i32 %35, 1
  %63 = icmp slt i32 %62, %61
  br i1 %63, label %33, label %101, !llvm.loop !276

64:                                               ; preds = %53, %64
  %65 = phi i64 [ %74, %64 ], [ %54, %53 ]
  %66 = phi i16 [ %73, %64 ], [ %55, %53 ]
  %67 = getelementptr inbounds i16, ptr %0, i64 %65
  %68 = load i16, ptr %67, align 2, !tbaa !30
  %69 = or i16 %68, %2
  %70 = or i16 %69, %3
  %71 = or i16 %70, %4
  %72 = or i16 %71, %5
  %73 = add i16 %72, %66
  %74 = add nuw nsw i64 %65, 1
  %75 = icmp eq i64 %74, %19
  br i1 %75, label %76, label %64, !llvm.loop !277

76:                                               ; preds = %64, %50
  %77 = phi i16 [ %52, %50 ], [ %73, %64 ]
  %78 = load double, ptr @init_value, align 8, !tbaa !28
  %79 = fptoui double %78 to i16
  %80 = or i16 %15, %79
  %81 = mul i16 %80, 8000
  %82 = icmp eq i16 %81, %77
  br i1 %82, label %60, label %56

83:                                               ; preds = %16, %96
  %84 = phi i32 [ %97, %96 ], [ %9, %16 ]
  %85 = phi double [ %98, %96 ], [ %17, %16 ]
  %86 = phi i32 [ %99, %96 ], [ 0, %16 ]
  %87 = fptoui double %85 to i16
  %88 = or i16 %15, %87
  %89 = mul i16 %88, 8000
  %90 = icmp eq i16 %89, 0
  br i1 %90, label %96, label %91

91:                                               ; preds = %83
  %92 = load i32, ptr @current_test, align 4, !tbaa !9
  %93 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %92)
  %94 = load double, ptr @init_value, align 8, !tbaa !28
  %95 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %96

96:                                               ; preds = %83, %91
  %97 = phi i32 [ %84, %83 ], [ %95, %91 ]
  %98 = phi double [ %85, %83 ], [ %94, %91 ]
  %99 = add nuw nsw i32 %86, 1
  %100 = icmp slt i32 %99, %97
  br i1 %100, label %83, label %101, !llvm.loop !276

101:                                              ; preds = %96, %60, %7
  %102 = tail call i64 @clock() #17
  store i64 %102, ptr @end_time, align 8, !tbaa !26
  %103 = load i64, ptr @start_time, align 8, !tbaa !26
  %104 = load ptr, ptr @results, align 8, !tbaa !5
  %105 = icmp eq ptr %104, null
  br i1 %105, label %106, label %108

106:                                              ; preds = %101
  %107 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %112

108:                                              ; preds = %101
  %109 = load i32, ptr @current_test, align 4, !tbaa !9
  %110 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %111 = icmp slt i32 %109, %110
  br i1 %111, label %124, label %112

112:                                              ; preds = %108, %106
  %113 = phi i32 [ %107, %106 ], [ %110, %108 ]
  %114 = add nsw i32 %113, 10
  store i32 %114, ptr @allocated_results, align 4, !tbaa !9
  %115 = sext i32 %114 to i64
  %116 = shl nsw i64 %115, 4
  %117 = tail call ptr @realloc(ptr noundef %104, i64 noundef %116) #14
  store ptr %117, ptr @results, align 8, !tbaa !5
  %118 = icmp eq ptr %117, null
  br i1 %118, label %121, label %119

119:                                              ; preds = %112
  %120 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %124

121:                                              ; preds = %112
  %122 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %123 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %122)
  tail call void @exit(i32 noundef -1) #15
  unreachable

124:                                              ; preds = %108, %119
  %125 = phi i32 [ %120, %119 ], [ %109, %108 ]
  %126 = phi ptr [ %117, %119 ], [ %104, %108 ]
  %127 = sub nsw i64 %102, %103
  %128 = sitofp i64 %127 to double
  %129 = fdiv double %128, 1.000000e+06
  %130 = sext i32 %125 to i64
  %131 = getelementptr inbounds %struct.one_result, ptr %126, i64 %130
  store double %129, ptr %131, align 8, !tbaa !11
  %132 = getelementptr inbounds %struct.one_result, ptr %126, i64 %130, i32 1
  store ptr %6, ptr %132, align 8, !tbaa !14
  %133 = add nsw i32 %125, 1
  store i32 %133, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1It19custom_variable_xorItEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i16 noundef zeroext %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !26
  %6 = load i32, ptr @iterations, align 4, !tbaa !9
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %86

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  br i1 %9, label %12, label %10

10:                                               ; preds = %8
  %11 = load double, ptr @init_value, align 8, !tbaa !28
  br label %68

12:                                               ; preds = %8
  %13 = zext i32 %1 to i64
  %14 = icmp ult i32 %1, 16
  %15 = and i64 %13, 4294967280
  %16 = insertelement <8 x i16> poison, i16 %2, i64 0
  %17 = shufflevector <8 x i16> %16, <8 x i16> poison, <8 x i32> zeroinitializer
  %18 = insertelement <8 x i16> poison, i16 %2, i64 0
  %19 = shufflevector <8 x i16> %18, <8 x i16> poison, <8 x i32> zeroinitializer
  %20 = icmp eq i64 %15, %13
  br label %21

21:                                               ; preds = %12, %48
  %22 = phi i32 [ %49, %48 ], [ %6, %12 ]
  %23 = phi i32 [ %50, %48 ], [ 0, %12 ]
  br i1 %14, label %41, label %24

24:                                               ; preds = %21, %24
  %25 = phi i64 [ %36, %24 ], [ 0, %21 ]
  %26 = phi <8 x i16> [ %34, %24 ], [ zeroinitializer, %21 ]
  %27 = phi <8 x i16> [ %35, %24 ], [ zeroinitializer, %21 ]
  %28 = getelementptr inbounds i16, ptr %0, i64 %25
  %29 = load <8 x i16>, ptr %28, align 2, !tbaa !30
  %30 = getelementptr inbounds i16, ptr %28, i64 8
  %31 = load <8 x i16>, ptr %30, align 2, !tbaa !30
  %32 = xor <8 x i16> %29, %17
  %33 = xor <8 x i16> %31, %19
  %34 = add <8 x i16> %32, %26
  %35 = add <8 x i16> %33, %27
  %36 = add nuw i64 %25, 16
  %37 = icmp eq i64 %36, %15
  br i1 %37, label %38, label %24, !llvm.loop !278

38:                                               ; preds = %24
  %39 = add <8 x i16> %35, %34
  %40 = tail call i16 @llvm.vector.reduce.add.v8i16(<8 x i16> %39)
  br i1 %20, label %61, label %41

41:                                               ; preds = %21, %38
  %42 = phi i64 [ 0, %21 ], [ %15, %38 ]
  %43 = phi i16 [ 0, %21 ], [ %40, %38 ]
  br label %52

44:                                               ; preds = %61
  %45 = load i32, ptr @current_test, align 4, !tbaa !9
  %46 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %45)
  %47 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %48

48:                                               ; preds = %44, %61
  %49 = phi i32 [ %47, %44 ], [ %22, %61 ]
  %50 = add nuw nsw i32 %23, 1
  %51 = icmp slt i32 %50, %49
  br i1 %51, label %21, label %86, !llvm.loop !279

52:                                               ; preds = %41, %52
  %53 = phi i64 [ %59, %52 ], [ %42, %41 ]
  %54 = phi i16 [ %58, %52 ], [ %43, %41 ]
  %55 = getelementptr inbounds i16, ptr %0, i64 %53
  %56 = load i16, ptr %55, align 2, !tbaa !30
  %57 = xor i16 %56, %2
  %58 = add i16 %57, %54
  %59 = add nuw nsw i64 %53, 1
  %60 = icmp eq i64 %59, %13
  br i1 %60, label %61, label %52, !llvm.loop !280

61:                                               ; preds = %52, %38
  %62 = phi i16 [ %40, %38 ], [ %58, %52 ]
  %63 = load double, ptr @init_value, align 8, !tbaa !28
  %64 = fptoui double %63 to i16
  %65 = xor i16 %64, %2
  %66 = mul i16 %65, 8000
  %67 = icmp eq i16 %66, %62
  br i1 %67, label %48, label %44

68:                                               ; preds = %10, %81
  %69 = phi i32 [ %82, %81 ], [ %6, %10 ]
  %70 = phi double [ %83, %81 ], [ %11, %10 ]
  %71 = phi i32 [ %84, %81 ], [ 0, %10 ]
  %72 = fptoui double %70 to i16
  %73 = xor i16 %72, %2
  %74 = mul i16 %73, 8000
  %75 = icmp eq i16 %74, 0
  br i1 %75, label %81, label %76

76:                                               ; preds = %68
  %77 = load i32, ptr @current_test, align 4, !tbaa !9
  %78 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %77)
  %79 = load double, ptr @init_value, align 8, !tbaa !28
  %80 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %81

81:                                               ; preds = %68, %76
  %82 = phi i32 [ %69, %68 ], [ %80, %76 ]
  %83 = phi double [ %70, %68 ], [ %79, %76 ]
  %84 = add nuw nsw i32 %71, 1
  %85 = icmp slt i32 %84, %82
  br i1 %85, label %68, label %86, !llvm.loop !279

86:                                               ; preds = %81, %48, %4
  %87 = tail call i64 @clock() #17
  store i64 %87, ptr @end_time, align 8, !tbaa !26
  %88 = load i64, ptr @start_time, align 8, !tbaa !26
  %89 = load ptr, ptr @results, align 8, !tbaa !5
  %90 = icmp eq ptr %89, null
  br i1 %90, label %91, label %93

91:                                               ; preds = %86
  %92 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %97

93:                                               ; preds = %86
  %94 = load i32, ptr @current_test, align 4, !tbaa !9
  %95 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %96 = icmp slt i32 %94, %95
  br i1 %96, label %109, label %97

97:                                               ; preds = %93, %91
  %98 = phi i32 [ %92, %91 ], [ %95, %93 ]
  %99 = add nsw i32 %98, 10
  store i32 %99, ptr @allocated_results, align 4, !tbaa !9
  %100 = sext i32 %99 to i64
  %101 = shl nsw i64 %100, 4
  %102 = tail call ptr @realloc(ptr noundef %89, i64 noundef %101) #14
  store ptr %102, ptr @results, align 8, !tbaa !5
  %103 = icmp eq ptr %102, null
  br i1 %103, label %106, label %104

104:                                              ; preds = %97
  %105 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %109

106:                                              ; preds = %97
  %107 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %108 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %107)
  tail call void @exit(i32 noundef -1) #15
  unreachable

109:                                              ; preds = %93, %104
  %110 = phi i32 [ %105, %104 ], [ %94, %93 ]
  %111 = phi ptr [ %102, %104 ], [ %89, %93 ]
  %112 = sub nsw i64 %87, %88
  %113 = sitofp i64 %112 to double
  %114 = fdiv double %113, 1.000000e+06
  %115 = sext i32 %110 to i64
  %116 = getelementptr inbounds %struct.one_result, ptr %111, i64 %115
  store double %114, ptr %116, align 8, !tbaa !11
  %117 = getelementptr inbounds %struct.one_result, ptr %111, i64 %115, i32 1
  store ptr %3, ptr %117, align 8, !tbaa !14
  %118 = add nsw i32 %110, 1
  store i32 %118, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4It28custom_multiple_variable_xorItEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i16 noundef zeroext %2, i16 noundef zeroext %3, i16 noundef zeroext %4, i16 noundef zeroext %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !26
  %9 = load i32, ptr @iterations, align 4, !tbaa !9
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %101

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  %13 = xor i16 %3, %2
  %14 = xor i16 %13, %4
  %15 = xor i16 %14, %5
  br i1 %12, label %18, label %16

16:                                               ; preds = %11
  %17 = load double, ptr @init_value, align 8, !tbaa !28
  br label %83

18:                                               ; preds = %11
  %19 = zext i32 %1 to i64
  %20 = icmp ult i32 %1, 16
  %21 = and i64 %19, 4294967280
  %22 = xor i16 %3, %2
  %23 = xor i16 %3, %2
  %24 = xor i16 %22, %4
  %25 = xor i16 %23, %4
  %26 = xor i16 %24, %5
  %27 = insertelement <8 x i16> poison, i16 %26, i64 0
  %28 = shufflevector <8 x i16> %27, <8 x i16> poison, <8 x i32> zeroinitializer
  %29 = xor i16 %25, %5
  %30 = insertelement <8 x i16> poison, i16 %29, i64 0
  %31 = shufflevector <8 x i16> %30, <8 x i16> poison, <8 x i32> zeroinitializer
  %32 = icmp eq i64 %21, %19
  br label %33

33:                                               ; preds = %18, %60
  %34 = phi i32 [ %61, %60 ], [ %9, %18 ]
  %35 = phi i32 [ %62, %60 ], [ 0, %18 ]
  br i1 %20, label %53, label %36

36:                                               ; preds = %33, %36
  %37 = phi i64 [ %48, %36 ], [ 0, %33 ]
  %38 = phi <8 x i16> [ %46, %36 ], [ zeroinitializer, %33 ]
  %39 = phi <8 x i16> [ %47, %36 ], [ zeroinitializer, %33 ]
  %40 = getelementptr inbounds i16, ptr %0, i64 %37
  %41 = load <8 x i16>, ptr %40, align 2, !tbaa !30
  %42 = getelementptr inbounds i16, ptr %40, i64 8
  %43 = load <8 x i16>, ptr %42, align 2, !tbaa !30
  %44 = xor <8 x i16> %28, %41
  %45 = xor <8 x i16> %31, %43
  %46 = add <8 x i16> %44, %38
  %47 = add <8 x i16> %45, %39
  %48 = add nuw i64 %37, 16
  %49 = icmp eq i64 %48, %21
  br i1 %49, label %50, label %36, !llvm.loop !281

50:                                               ; preds = %36
  %51 = add <8 x i16> %47, %46
  %52 = tail call i16 @llvm.vector.reduce.add.v8i16(<8 x i16> %51)
  br i1 %32, label %76, label %53

53:                                               ; preds = %33, %50
  %54 = phi i64 [ 0, %33 ], [ %21, %50 ]
  %55 = phi i16 [ 0, %33 ], [ %52, %50 ]
  br label %64

56:                                               ; preds = %76
  %57 = load i32, ptr @current_test, align 4, !tbaa !9
  %58 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %57)
  %59 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %60

60:                                               ; preds = %56, %76
  %61 = phi i32 [ %59, %56 ], [ %34, %76 ]
  %62 = add nuw nsw i32 %35, 1
  %63 = icmp slt i32 %62, %61
  br i1 %63, label %33, label %101, !llvm.loop !282

64:                                               ; preds = %53, %64
  %65 = phi i64 [ %74, %64 ], [ %54, %53 ]
  %66 = phi i16 [ %73, %64 ], [ %55, %53 ]
  %67 = getelementptr inbounds i16, ptr %0, i64 %65
  %68 = load i16, ptr %67, align 2, !tbaa !30
  %69 = xor i16 %68, %2
  %70 = xor i16 %69, %3
  %71 = xor i16 %70, %4
  %72 = xor i16 %71, %5
  %73 = add i16 %72, %66
  %74 = add nuw nsw i64 %65, 1
  %75 = icmp eq i64 %74, %19
  br i1 %75, label %76, label %64, !llvm.loop !283

76:                                               ; preds = %64, %50
  %77 = phi i16 [ %52, %50 ], [ %73, %64 ]
  %78 = load double, ptr @init_value, align 8, !tbaa !28
  %79 = fptoui double %78 to i16
  %80 = xor i16 %15, %79
  %81 = mul i16 %80, 8000
  %82 = icmp eq i16 %81, %77
  br i1 %82, label %60, label %56

83:                                               ; preds = %16, %96
  %84 = phi i32 [ %97, %96 ], [ %9, %16 ]
  %85 = phi double [ %98, %96 ], [ %17, %16 ]
  %86 = phi i32 [ %99, %96 ], [ 0, %16 ]
  %87 = fptoui double %85 to i16
  %88 = xor i16 %15, %87
  %89 = mul i16 %88, 8000
  %90 = icmp eq i16 %89, 0
  br i1 %90, label %96, label %91

91:                                               ; preds = %83
  %92 = load i32, ptr @current_test, align 4, !tbaa !9
  %93 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %92)
  %94 = load double, ptr @init_value, align 8, !tbaa !28
  %95 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %96

96:                                               ; preds = %83, %91
  %97 = phi i32 [ %84, %83 ], [ %95, %91 ]
  %98 = phi double [ %85, %83 ], [ %94, %91 ]
  %99 = add nuw nsw i32 %86, 1
  %100 = icmp slt i32 %99, %97
  br i1 %100, label %83, label %101, !llvm.loop !282

101:                                              ; preds = %96, %60, %7
  %102 = tail call i64 @clock() #17
  store i64 %102, ptr @end_time, align 8, !tbaa !26
  %103 = load i64, ptr @start_time, align 8, !tbaa !26
  %104 = load ptr, ptr @results, align 8, !tbaa !5
  %105 = icmp eq ptr %104, null
  br i1 %105, label %106, label %108

106:                                              ; preds = %101
  %107 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %112

108:                                              ; preds = %101
  %109 = load i32, ptr @current_test, align 4, !tbaa !9
  %110 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %111 = icmp slt i32 %109, %110
  br i1 %111, label %124, label %112

112:                                              ; preds = %108, %106
  %113 = phi i32 [ %107, %106 ], [ %110, %108 ]
  %114 = add nsw i32 %113, 10
  store i32 %114, ptr @allocated_results, align 4, !tbaa !9
  %115 = sext i32 %114 to i64
  %116 = shl nsw i64 %115, 4
  %117 = tail call ptr @realloc(ptr noundef %104, i64 noundef %116) #14
  store ptr %117, ptr @results, align 8, !tbaa !5
  %118 = icmp eq ptr %117, null
  br i1 %118, label %121, label %119

119:                                              ; preds = %112
  %120 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %124

121:                                              ; preds = %112
  %122 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %123 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %122)
  tail call void @exit(i32 noundef -1) #15
  unreachable

124:                                              ; preds = %108, %119
  %125 = phi i32 [ %120, %119 ], [ %109, %108 ]
  %126 = phi ptr [ %117, %119 ], [ %104, %108 ]
  %127 = sub nsw i64 %102, %103
  %128 = sitofp i64 %127 to double
  %129 = fdiv double %128, 1.000000e+06
  %130 = sext i32 %125 to i64
  %131 = getelementptr inbounds %struct.one_result, ptr %126, i64 %130
  store double %129, ptr %131, align 8, !tbaa !11
  %132 = getelementptr inbounds %struct.one_result, ptr %126, i64 %130, i32 1
  store ptr %6, ptr %132, align 8, !tbaa !14
  %133 = add nsw i32 %125, 1
  store i32 %133, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1Ii19custom_add_variableIiEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i32 noundef %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !26
  %6 = load i32, ptr @iterations, align 4, !tbaa !9
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %85

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  br i1 %9, label %13, label %10

10:                                               ; preds = %8
  %11 = load double, ptr @init_value, align 8, !tbaa !28
  %12 = sub i32 0, %2
  br label %69

13:                                               ; preds = %8
  %14 = zext i32 %1 to i64
  %15 = icmp ult i32 %1, 8
  %16 = and i64 %14, 4294967288
  %17 = insertelement <4 x i32> poison, i32 %2, i64 0
  %18 = shufflevector <4 x i32> %17, <4 x i32> poison, <4 x i32> zeroinitializer
  %19 = insertelement <4 x i32> poison, i32 %2, i64 0
  %20 = shufflevector <4 x i32> %19, <4 x i32> poison, <4 x i32> zeroinitializer
  %21 = icmp eq i64 %16, %14
  br label %22

22:                                               ; preds = %13, %49
  %23 = phi i32 [ %50, %49 ], [ %6, %13 ]
  %24 = phi i32 [ %51, %49 ], [ 0, %13 ]
  br i1 %15, label %42, label %25

25:                                               ; preds = %22, %25
  %26 = phi i64 [ %37, %25 ], [ 0, %22 ]
  %27 = phi <4 x i32> [ %35, %25 ], [ zeroinitializer, %22 ]
  %28 = phi <4 x i32> [ %36, %25 ], [ zeroinitializer, %22 ]
  %29 = getelementptr inbounds i32, ptr %0, i64 %26
  %30 = load <4 x i32>, ptr %29, align 4, !tbaa !9
  %31 = getelementptr inbounds i32, ptr %29, i64 4
  %32 = load <4 x i32>, ptr %31, align 4, !tbaa !9
  %33 = add <4 x i32> %27, %18
  %34 = add <4 x i32> %28, %20
  %35 = add <4 x i32> %33, %30
  %36 = add <4 x i32> %34, %32
  %37 = add nuw i64 %26, 8
  %38 = icmp eq i64 %37, %16
  br i1 %38, label %39, label %25, !llvm.loop !284

39:                                               ; preds = %25
  %40 = add <4 x i32> %36, %35
  %41 = tail call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %40)
  br i1 %21, label %62, label %42

42:                                               ; preds = %22, %39
  %43 = phi i64 [ 0, %22 ], [ %16, %39 ]
  %44 = phi i32 [ 0, %22 ], [ %41, %39 ]
  br label %53

45:                                               ; preds = %62
  %46 = load i32, ptr @current_test, align 4, !tbaa !9
  %47 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %46)
  %48 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %49

49:                                               ; preds = %45, %62
  %50 = phi i32 [ %48, %45 ], [ %23, %62 ]
  %51 = add nuw nsw i32 %24, 1
  %52 = icmp slt i32 %51, %50
  br i1 %52, label %22, label %85, !llvm.loop !285

53:                                               ; preds = %42, %53
  %54 = phi i64 [ %60, %53 ], [ %43, %42 ]
  %55 = phi i32 [ %59, %53 ], [ %44, %42 ]
  %56 = getelementptr inbounds i32, ptr %0, i64 %54
  %57 = load i32, ptr %56, align 4, !tbaa !9
  %58 = add i32 %55, %2
  %59 = add i32 %58, %57
  %60 = add nuw nsw i64 %54, 1
  %61 = icmp eq i64 %60, %14
  br i1 %61, label %62, label %53, !llvm.loop !286

62:                                               ; preds = %53, %39
  %63 = phi i32 [ %41, %39 ], [ %59, %53 ]
  %64 = load double, ptr @init_value, align 8, !tbaa !28
  %65 = fptosi double %64 to i32
  %66 = add nsw i32 %65, %2
  %67 = mul nsw i32 %66, 8000
  %68 = icmp eq i32 %67, %63
  br i1 %68, label %49, label %45

69:                                               ; preds = %10, %80
  %70 = phi i32 [ %81, %80 ], [ %6, %10 ]
  %71 = phi double [ %82, %80 ], [ %11, %10 ]
  %72 = phi i32 [ %83, %80 ], [ 0, %10 ]
  %73 = fptosi double %71 to i32
  %74 = icmp eq i32 %73, %12
  br i1 %74, label %80, label %75

75:                                               ; preds = %69
  %76 = load i32, ptr @current_test, align 4, !tbaa !9
  %77 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %76)
  %78 = load double, ptr @init_value, align 8, !tbaa !28
  %79 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %80

80:                                               ; preds = %69, %75
  %81 = phi i32 [ %70, %69 ], [ %79, %75 ]
  %82 = phi double [ %71, %69 ], [ %78, %75 ]
  %83 = add nuw nsw i32 %72, 1
  %84 = icmp slt i32 %83, %81
  br i1 %84, label %69, label %85, !llvm.loop !285

85:                                               ; preds = %80, %49, %4
  %86 = tail call i64 @clock() #17
  store i64 %86, ptr @end_time, align 8, !tbaa !26
  %87 = load i64, ptr @start_time, align 8, !tbaa !26
  %88 = load ptr, ptr @results, align 8, !tbaa !5
  %89 = icmp eq ptr %88, null
  br i1 %89, label %90, label %92

90:                                               ; preds = %85
  %91 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %96

92:                                               ; preds = %85
  %93 = load i32, ptr @current_test, align 4, !tbaa !9
  %94 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %95 = icmp slt i32 %93, %94
  br i1 %95, label %108, label %96

96:                                               ; preds = %92, %90
  %97 = phi i32 [ %91, %90 ], [ %94, %92 ]
  %98 = add nsw i32 %97, 10
  store i32 %98, ptr @allocated_results, align 4, !tbaa !9
  %99 = sext i32 %98 to i64
  %100 = shl nsw i64 %99, 4
  %101 = tail call ptr @realloc(ptr noundef %88, i64 noundef %100) #14
  store ptr %101, ptr @results, align 8, !tbaa !5
  %102 = icmp eq ptr %101, null
  br i1 %102, label %105, label %103

103:                                              ; preds = %96
  %104 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %108

105:                                              ; preds = %96
  %106 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %107 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %106)
  tail call void @exit(i32 noundef -1) #15
  unreachable

108:                                              ; preds = %92, %103
  %109 = phi i32 [ %104, %103 ], [ %93, %92 ]
  %110 = phi ptr [ %101, %103 ], [ %88, %92 ]
  %111 = sub nsw i64 %86, %87
  %112 = sitofp i64 %111 to double
  %113 = fdiv double %112, 1.000000e+06
  %114 = sext i32 %109 to i64
  %115 = getelementptr inbounds %struct.one_result, ptr %110, i64 %114
  store double %113, ptr %115, align 8, !tbaa !11
  %116 = getelementptr inbounds %struct.one_result, ptr %110, i64 %114, i32 1
  store ptr %3, ptr %116, align 8, !tbaa !14
  %117 = add nsw i32 %109, 1
  store i32 %117, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z22test_hoisted_variable1Ii19custom_add_variableIiEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i32 noundef %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !26
  %6 = load i32, ptr @iterations, align 4, !tbaa !9
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %81

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  %10 = mul nsw i32 %2, %1
  br i1 %9, label %13, label %11

11:                                               ; preds = %8
  %12 = load double, ptr @init_value, align 8, !tbaa !28
  br label %63

13:                                               ; preds = %8
  %14 = zext i32 %1 to i64
  %15 = icmp ult i32 %1, 8
  %16 = and i64 %14, 4294967288
  %17 = icmp eq i64 %16, %14
  br label %18

18:                                               ; preds = %13, %43
  %19 = phi i32 [ %44, %43 ], [ %6, %13 ]
  %20 = phi i32 [ %45, %43 ], [ 0, %13 ]
  br i1 %15, label %36, label %21

21:                                               ; preds = %18, %21
  %22 = phi i64 [ %31, %21 ], [ 0, %18 ]
  %23 = phi <4 x i32> [ %29, %21 ], [ zeroinitializer, %18 ]
  %24 = phi <4 x i32> [ %30, %21 ], [ zeroinitializer, %18 ]
  %25 = getelementptr inbounds i32, ptr %0, i64 %22
  %26 = load <4 x i32>, ptr %25, align 4, !tbaa !9
  %27 = getelementptr inbounds i32, ptr %25, i64 4
  %28 = load <4 x i32>, ptr %27, align 4, !tbaa !9
  %29 = add <4 x i32> %26, %23
  %30 = add <4 x i32> %28, %24
  %31 = add nuw i64 %22, 8
  %32 = icmp eq i64 %31, %16
  br i1 %32, label %33, label %21, !llvm.loop !287

33:                                               ; preds = %21
  %34 = add <4 x i32> %30, %29
  %35 = tail call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %34)
  br i1 %17, label %55, label %36

36:                                               ; preds = %18, %33
  %37 = phi i64 [ 0, %18 ], [ %16, %33 ]
  %38 = phi i32 [ 0, %18 ], [ %35, %33 ]
  br label %47

39:                                               ; preds = %55
  %40 = load i32, ptr @current_test, align 4, !tbaa !9
  %41 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %40)
  %42 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %43

43:                                               ; preds = %39, %55
  %44 = phi i32 [ %42, %39 ], [ %19, %55 ]
  %45 = add nuw nsw i32 %20, 1
  %46 = icmp slt i32 %45, %44
  br i1 %46, label %18, label %81, !llvm.loop !288

47:                                               ; preds = %36, %47
  %48 = phi i64 [ %53, %47 ], [ %37, %36 ]
  %49 = phi i32 [ %52, %47 ], [ %38, %36 ]
  %50 = getelementptr inbounds i32, ptr %0, i64 %48
  %51 = load i32, ptr %50, align 4, !tbaa !9
  %52 = add nsw i32 %51, %49
  %53 = add nuw nsw i64 %48, 1
  %54 = icmp eq i64 %53, %14
  br i1 %54, label %55, label %47, !llvm.loop !289

55:                                               ; preds = %47, %33
  %56 = phi i32 [ %35, %33 ], [ %52, %47 ]
  %57 = add nsw i32 %56, %10
  %58 = load double, ptr @init_value, align 8, !tbaa !28
  %59 = fptosi double %58 to i32
  %60 = add nsw i32 %59, %2
  %61 = mul nsw i32 %60, 8000
  %62 = icmp eq i32 %61, %57
  br i1 %62, label %43, label %39

63:                                               ; preds = %11, %76
  %64 = phi i32 [ %77, %76 ], [ %6, %11 ]
  %65 = phi double [ %78, %76 ], [ %12, %11 ]
  %66 = phi i32 [ %79, %76 ], [ 0, %11 ]
  %67 = fptosi double %65 to i32
  %68 = add nsw i32 %67, %2
  %69 = mul nsw i32 %68, 8000
  %70 = icmp eq i32 %69, %10
  br i1 %70, label %76, label %71

71:                                               ; preds = %63
  %72 = load i32, ptr @current_test, align 4, !tbaa !9
  %73 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %72)
  %74 = load double, ptr @init_value, align 8, !tbaa !28
  %75 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %76

76:                                               ; preds = %63, %71
  %77 = phi i32 [ %64, %63 ], [ %75, %71 ]
  %78 = phi double [ %65, %63 ], [ %74, %71 ]
  %79 = add nuw nsw i32 %66, 1
  %80 = icmp slt i32 %79, %77
  br i1 %80, label %63, label %81, !llvm.loop !288

81:                                               ; preds = %76, %43, %4
  %82 = tail call i64 @clock() #17
  store i64 %82, ptr @end_time, align 8, !tbaa !26
  %83 = load i64, ptr @start_time, align 8, !tbaa !26
  %84 = load ptr, ptr @results, align 8, !tbaa !5
  %85 = icmp eq ptr %84, null
  br i1 %85, label %86, label %88

86:                                               ; preds = %81
  %87 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %92

88:                                               ; preds = %81
  %89 = load i32, ptr @current_test, align 4, !tbaa !9
  %90 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %91 = icmp slt i32 %89, %90
  br i1 %91, label %104, label %92

92:                                               ; preds = %88, %86
  %93 = phi i32 [ %87, %86 ], [ %90, %88 ]
  %94 = add nsw i32 %93, 10
  store i32 %94, ptr @allocated_results, align 4, !tbaa !9
  %95 = sext i32 %94 to i64
  %96 = shl nsw i64 %95, 4
  %97 = tail call ptr @realloc(ptr noundef %84, i64 noundef %96) #14
  store ptr %97, ptr @results, align 8, !tbaa !5
  %98 = icmp eq ptr %97, null
  br i1 %98, label %101, label %99

99:                                               ; preds = %92
  %100 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %104

101:                                              ; preds = %92
  %102 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %103 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %102)
  tail call void @exit(i32 noundef -1) #15
  unreachable

104:                                              ; preds = %88, %99
  %105 = phi i32 [ %100, %99 ], [ %89, %88 ]
  %106 = phi ptr [ %97, %99 ], [ %84, %88 ]
  %107 = sub nsw i64 %82, %83
  %108 = sitofp i64 %107 to double
  %109 = fdiv double %108, 1.000000e+06
  %110 = sext i32 %105 to i64
  %111 = getelementptr inbounds %struct.one_result, ptr %106, i64 %110
  store double %109, ptr %111, align 8, !tbaa !11
  %112 = getelementptr inbounds %struct.one_result, ptr %106, i64 %110, i32 1
  store ptr %3, ptr %112, align 8, !tbaa !14
  %113 = add nsw i32 %105, 1
  store i32 %113, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Ii28custom_add_multiple_variableIiEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3, i32 noundef %4, i32 noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !26
  %9 = load i32, ptr @iterations, align 4, !tbaa !9
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %91

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  %13 = add i32 %3, %2
  %14 = add i32 %13, %4
  %15 = add i32 %14, %5
  br i1 %12, label %18, label %16

16:                                               ; preds = %11
  %17 = load double, ptr @init_value, align 8, !tbaa !28
  br label %74

18:                                               ; preds = %11
  %19 = zext i32 %1 to i64
  %20 = icmp ult i32 %1, 8
  %21 = and i64 %19, 4294967288
  %22 = insertelement <4 x i32> poison, i32 %15, i64 0
  %23 = shufflevector <4 x i32> %22, <4 x i32> poison, <4 x i32> zeroinitializer
  %24 = insertelement <4 x i32> poison, i32 %15, i64 0
  %25 = shufflevector <4 x i32> %24, <4 x i32> poison, <4 x i32> zeroinitializer
  %26 = icmp eq i64 %21, %19
  br label %27

27:                                               ; preds = %18, %54
  %28 = phi i32 [ %55, %54 ], [ %9, %18 ]
  %29 = phi i32 [ %56, %54 ], [ 0, %18 ]
  br i1 %20, label %47, label %30

30:                                               ; preds = %27, %30
  %31 = phi i64 [ %42, %30 ], [ 0, %27 ]
  %32 = phi <4 x i32> [ %40, %30 ], [ zeroinitializer, %27 ]
  %33 = phi <4 x i32> [ %41, %30 ], [ zeroinitializer, %27 ]
  %34 = getelementptr inbounds i32, ptr %0, i64 %31
  %35 = load <4 x i32>, ptr %34, align 4, !tbaa !9
  %36 = getelementptr inbounds i32, ptr %34, i64 4
  %37 = load <4 x i32>, ptr %36, align 4, !tbaa !9
  %38 = add <4 x i32> %23, %32
  %39 = add <4 x i32> %25, %33
  %40 = add <4 x i32> %38, %35
  %41 = add <4 x i32> %39, %37
  %42 = add nuw i64 %31, 8
  %43 = icmp eq i64 %42, %21
  br i1 %43, label %44, label %30, !llvm.loop !290

44:                                               ; preds = %30
  %45 = add <4 x i32> %41, %40
  %46 = tail call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %45)
  br i1 %26, label %67, label %47

47:                                               ; preds = %27, %44
  %48 = phi i64 [ 0, %27 ], [ %21, %44 ]
  %49 = phi i32 [ 0, %27 ], [ %46, %44 ]
  br label %58

50:                                               ; preds = %67
  %51 = load i32, ptr @current_test, align 4, !tbaa !9
  %52 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %51)
  %53 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %54

54:                                               ; preds = %50, %67
  %55 = phi i32 [ %53, %50 ], [ %28, %67 ]
  %56 = add nuw nsw i32 %29, 1
  %57 = icmp slt i32 %56, %55
  br i1 %57, label %27, label %91, !llvm.loop !291

58:                                               ; preds = %47, %58
  %59 = phi i64 [ %65, %58 ], [ %48, %47 ]
  %60 = phi i32 [ %64, %58 ], [ %49, %47 ]
  %61 = getelementptr inbounds i32, ptr %0, i64 %59
  %62 = load i32, ptr %61, align 4, !tbaa !9
  %63 = add i32 %15, %60
  %64 = add i32 %63, %62
  %65 = add nuw nsw i64 %59, 1
  %66 = icmp eq i64 %65, %19
  br i1 %66, label %67, label %58, !llvm.loop !292

67:                                               ; preds = %58, %44
  %68 = phi i32 [ %46, %44 ], [ %64, %58 ]
  %69 = load double, ptr @init_value, align 8, !tbaa !28
  %70 = fptosi double %69 to i32
  %71 = add i32 %15, %70
  %72 = mul nsw i32 %71, 8000
  %73 = icmp eq i32 %72, %68
  br i1 %73, label %54, label %50

74:                                               ; preds = %16, %86
  %75 = phi i32 [ %87, %86 ], [ %9, %16 ]
  %76 = phi double [ %88, %86 ], [ %17, %16 ]
  %77 = phi i32 [ %89, %86 ], [ 0, %16 ]
  %78 = fptosi double %76 to i32
  %79 = sub i32 0, %78
  %80 = icmp eq i32 %15, %79
  br i1 %80, label %86, label %81

81:                                               ; preds = %74
  %82 = load i32, ptr @current_test, align 4, !tbaa !9
  %83 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %82)
  %84 = load double, ptr @init_value, align 8, !tbaa !28
  %85 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %86

86:                                               ; preds = %74, %81
  %87 = phi i32 [ %75, %74 ], [ %85, %81 ]
  %88 = phi double [ %76, %74 ], [ %84, %81 ]
  %89 = add nuw nsw i32 %77, 1
  %90 = icmp slt i32 %89, %87
  br i1 %90, label %74, label %91, !llvm.loop !291

91:                                               ; preds = %86, %54, %7
  %92 = tail call i64 @clock() #17
  store i64 %92, ptr @end_time, align 8, !tbaa !26
  %93 = load i64, ptr @start_time, align 8, !tbaa !26
  %94 = load ptr, ptr @results, align 8, !tbaa !5
  %95 = icmp eq ptr %94, null
  br i1 %95, label %96, label %98

96:                                               ; preds = %91
  %97 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %102

98:                                               ; preds = %91
  %99 = load i32, ptr @current_test, align 4, !tbaa !9
  %100 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %101 = icmp slt i32 %99, %100
  br i1 %101, label %114, label %102

102:                                              ; preds = %98, %96
  %103 = phi i32 [ %97, %96 ], [ %100, %98 ]
  %104 = add nsw i32 %103, 10
  store i32 %104, ptr @allocated_results, align 4, !tbaa !9
  %105 = sext i32 %104 to i64
  %106 = shl nsw i64 %105, 4
  %107 = tail call ptr @realloc(ptr noundef %94, i64 noundef %106) #14
  store ptr %107, ptr @results, align 8, !tbaa !5
  %108 = icmp eq ptr %107, null
  br i1 %108, label %111, label %109

109:                                              ; preds = %102
  %110 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %114

111:                                              ; preds = %102
  %112 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %113 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %112)
  tail call void @exit(i32 noundef -1) #15
  unreachable

114:                                              ; preds = %98, %109
  %115 = phi i32 [ %110, %109 ], [ %99, %98 ]
  %116 = phi ptr [ %107, %109 ], [ %94, %98 ]
  %117 = sub nsw i64 %92, %93
  %118 = sitofp i64 %117 to double
  %119 = fdiv double %118, 1.000000e+06
  %120 = sext i32 %115 to i64
  %121 = getelementptr inbounds %struct.one_result, ptr %116, i64 %120
  store double %119, ptr %121, align 8, !tbaa !11
  %122 = getelementptr inbounds %struct.one_result, ptr %116, i64 %120, i32 1
  store ptr %6, ptr %122, align 8, !tbaa !14
  %123 = add nsw i32 %115, 1
  store i32 %123, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1Ii19custom_sub_variableIiEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i32 noundef %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !26
  %6 = load i32, ptr @iterations, align 4, !tbaa !9
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %84

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  br i1 %9, label %12, label %10

10:                                               ; preds = %8
  %11 = load double, ptr @init_value, align 8, !tbaa !28
  br label %68

12:                                               ; preds = %8
  %13 = zext i32 %1 to i64
  %14 = icmp ult i32 %1, 8
  %15 = and i64 %13, 4294967288
  %16 = insertelement <4 x i32> poison, i32 %2, i64 0
  %17 = shufflevector <4 x i32> %16, <4 x i32> poison, <4 x i32> zeroinitializer
  %18 = insertelement <4 x i32> poison, i32 %2, i64 0
  %19 = shufflevector <4 x i32> %18, <4 x i32> poison, <4 x i32> zeroinitializer
  %20 = icmp eq i64 %15, %13
  br label %21

21:                                               ; preds = %12, %48
  %22 = phi i32 [ %49, %48 ], [ %6, %12 ]
  %23 = phi i32 [ %50, %48 ], [ 0, %12 ]
  br i1 %14, label %41, label %24

24:                                               ; preds = %21, %24
  %25 = phi i64 [ %36, %24 ], [ 0, %21 ]
  %26 = phi <4 x i32> [ %34, %24 ], [ zeroinitializer, %21 ]
  %27 = phi <4 x i32> [ %35, %24 ], [ zeroinitializer, %21 ]
  %28 = getelementptr inbounds i32, ptr %0, i64 %25
  %29 = load <4 x i32>, ptr %28, align 4, !tbaa !9
  %30 = getelementptr inbounds i32, ptr %28, i64 4
  %31 = load <4 x i32>, ptr %30, align 4, !tbaa !9
  %32 = sub <4 x i32> %26, %17
  %33 = sub <4 x i32> %27, %19
  %34 = add <4 x i32> %32, %29
  %35 = add <4 x i32> %33, %31
  %36 = add nuw i64 %25, 8
  %37 = icmp eq i64 %36, %15
  br i1 %37, label %38, label %24, !llvm.loop !293

38:                                               ; preds = %24
  %39 = add <4 x i32> %35, %34
  %40 = tail call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %39)
  br i1 %20, label %61, label %41

41:                                               ; preds = %21, %38
  %42 = phi i64 [ 0, %21 ], [ %15, %38 ]
  %43 = phi i32 [ 0, %21 ], [ %40, %38 ]
  br label %52

44:                                               ; preds = %61
  %45 = load i32, ptr @current_test, align 4, !tbaa !9
  %46 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %45)
  %47 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %48

48:                                               ; preds = %44, %61
  %49 = phi i32 [ %47, %44 ], [ %22, %61 ]
  %50 = add nuw nsw i32 %23, 1
  %51 = icmp slt i32 %50, %49
  br i1 %51, label %21, label %84, !llvm.loop !294

52:                                               ; preds = %41, %52
  %53 = phi i64 [ %59, %52 ], [ %42, %41 ]
  %54 = phi i32 [ %58, %52 ], [ %43, %41 ]
  %55 = getelementptr inbounds i32, ptr %0, i64 %53
  %56 = load i32, ptr %55, align 4, !tbaa !9
  %57 = sub i32 %54, %2
  %58 = add i32 %57, %56
  %59 = add nuw nsw i64 %53, 1
  %60 = icmp eq i64 %59, %13
  br i1 %60, label %61, label %52, !llvm.loop !295

61:                                               ; preds = %52, %38
  %62 = phi i32 [ %40, %38 ], [ %58, %52 ]
  %63 = load double, ptr @init_value, align 8, !tbaa !28
  %64 = fptosi double %63 to i32
  %65 = sub nsw i32 %64, %2
  %66 = mul nsw i32 %65, 8000
  %67 = icmp eq i32 %66, %62
  br i1 %67, label %48, label %44

68:                                               ; preds = %10, %79
  %69 = phi i32 [ %80, %79 ], [ %6, %10 ]
  %70 = phi double [ %81, %79 ], [ %11, %10 ]
  %71 = phi i32 [ %82, %79 ], [ 0, %10 ]
  %72 = fptosi double %70 to i32
  %73 = icmp eq i32 %72, %2
  br i1 %73, label %79, label %74

74:                                               ; preds = %68
  %75 = load i32, ptr @current_test, align 4, !tbaa !9
  %76 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %75)
  %77 = load double, ptr @init_value, align 8, !tbaa !28
  %78 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %79

79:                                               ; preds = %68, %74
  %80 = phi i32 [ %69, %68 ], [ %78, %74 ]
  %81 = phi double [ %70, %68 ], [ %77, %74 ]
  %82 = add nuw nsw i32 %71, 1
  %83 = icmp slt i32 %82, %80
  br i1 %83, label %68, label %84, !llvm.loop !294

84:                                               ; preds = %79, %48, %4
  %85 = tail call i64 @clock() #17
  store i64 %85, ptr @end_time, align 8, !tbaa !26
  %86 = load i64, ptr @start_time, align 8, !tbaa !26
  %87 = load ptr, ptr @results, align 8, !tbaa !5
  %88 = icmp eq ptr %87, null
  br i1 %88, label %89, label %91

89:                                               ; preds = %84
  %90 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %95

91:                                               ; preds = %84
  %92 = load i32, ptr @current_test, align 4, !tbaa !9
  %93 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %94 = icmp slt i32 %92, %93
  br i1 %94, label %107, label %95

95:                                               ; preds = %91, %89
  %96 = phi i32 [ %90, %89 ], [ %93, %91 ]
  %97 = add nsw i32 %96, 10
  store i32 %97, ptr @allocated_results, align 4, !tbaa !9
  %98 = sext i32 %97 to i64
  %99 = shl nsw i64 %98, 4
  %100 = tail call ptr @realloc(ptr noundef %87, i64 noundef %99) #14
  store ptr %100, ptr @results, align 8, !tbaa !5
  %101 = icmp eq ptr %100, null
  br i1 %101, label %104, label %102

102:                                              ; preds = %95
  %103 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %107

104:                                              ; preds = %95
  %105 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %106 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %105)
  tail call void @exit(i32 noundef -1) #15
  unreachable

107:                                              ; preds = %91, %102
  %108 = phi i32 [ %103, %102 ], [ %92, %91 ]
  %109 = phi ptr [ %100, %102 ], [ %87, %91 ]
  %110 = sub nsw i64 %85, %86
  %111 = sitofp i64 %110 to double
  %112 = fdiv double %111, 1.000000e+06
  %113 = sext i32 %108 to i64
  %114 = getelementptr inbounds %struct.one_result, ptr %109, i64 %113
  store double %112, ptr %114, align 8, !tbaa !11
  %115 = getelementptr inbounds %struct.one_result, ptr %109, i64 %113, i32 1
  store ptr %3, ptr %115, align 8, !tbaa !14
  %116 = add nsw i32 %108, 1
  store i32 %116, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Ii28custom_sub_multiple_variableIiEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3, i32 noundef %4, i32 noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !26
  %9 = load i32, ptr @iterations, align 4, !tbaa !9
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %90

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  %13 = add i32 %3, %2
  %14 = add i32 %13, %4
  %15 = add i32 %14, %5
  br i1 %12, label %18, label %16

16:                                               ; preds = %11
  %17 = load double, ptr @init_value, align 8, !tbaa !28
  br label %74

18:                                               ; preds = %11
  %19 = zext i32 %1 to i64
  %20 = icmp ult i32 %1, 8
  %21 = and i64 %19, 4294967288
  %22 = insertelement <4 x i32> poison, i32 %15, i64 0
  %23 = shufflevector <4 x i32> %22, <4 x i32> poison, <4 x i32> zeroinitializer
  %24 = insertelement <4 x i32> poison, i32 %15, i64 0
  %25 = shufflevector <4 x i32> %24, <4 x i32> poison, <4 x i32> zeroinitializer
  %26 = icmp eq i64 %21, %19
  br label %27

27:                                               ; preds = %18, %54
  %28 = phi i32 [ %55, %54 ], [ %9, %18 ]
  %29 = phi i32 [ %56, %54 ], [ 0, %18 ]
  br i1 %20, label %47, label %30

30:                                               ; preds = %27, %30
  %31 = phi i64 [ %42, %30 ], [ 0, %27 ]
  %32 = phi <4 x i32> [ %40, %30 ], [ zeroinitializer, %27 ]
  %33 = phi <4 x i32> [ %41, %30 ], [ zeroinitializer, %27 ]
  %34 = getelementptr inbounds i32, ptr %0, i64 %31
  %35 = load <4 x i32>, ptr %34, align 4, !tbaa !9
  %36 = getelementptr inbounds i32, ptr %34, i64 4
  %37 = load <4 x i32>, ptr %36, align 4, !tbaa !9
  %38 = sub <4 x i32> %32, %23
  %39 = sub <4 x i32> %33, %25
  %40 = add <4 x i32> %38, %35
  %41 = add <4 x i32> %39, %37
  %42 = add nuw i64 %31, 8
  %43 = icmp eq i64 %42, %21
  br i1 %43, label %44, label %30, !llvm.loop !296

44:                                               ; preds = %30
  %45 = add <4 x i32> %41, %40
  %46 = tail call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %45)
  br i1 %26, label %67, label %47

47:                                               ; preds = %27, %44
  %48 = phi i64 [ 0, %27 ], [ %21, %44 ]
  %49 = phi i32 [ 0, %27 ], [ %46, %44 ]
  br label %58

50:                                               ; preds = %67
  %51 = load i32, ptr @current_test, align 4, !tbaa !9
  %52 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %51)
  %53 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %54

54:                                               ; preds = %50, %67
  %55 = phi i32 [ %53, %50 ], [ %28, %67 ]
  %56 = add nuw nsw i32 %29, 1
  %57 = icmp slt i32 %56, %55
  br i1 %57, label %27, label %90, !llvm.loop !297

58:                                               ; preds = %47, %58
  %59 = phi i64 [ %65, %58 ], [ %48, %47 ]
  %60 = phi i32 [ %64, %58 ], [ %49, %47 ]
  %61 = getelementptr inbounds i32, ptr %0, i64 %59
  %62 = load i32, ptr %61, align 4, !tbaa !9
  %63 = sub i32 %60, %15
  %64 = add i32 %63, %62
  %65 = add nuw nsw i64 %59, 1
  %66 = icmp eq i64 %65, %19
  br i1 %66, label %67, label %58, !llvm.loop !298

67:                                               ; preds = %58, %44
  %68 = phi i32 [ %46, %44 ], [ %64, %58 ]
  %69 = load double, ptr @init_value, align 8, !tbaa !28
  %70 = fptosi double %69 to i32
  %71 = sub i32 %70, %15
  %72 = mul nsw i32 %71, 8000
  %73 = icmp eq i32 %72, %68
  br i1 %73, label %54, label %50

74:                                               ; preds = %16, %85
  %75 = phi i32 [ %86, %85 ], [ %9, %16 ]
  %76 = phi double [ %87, %85 ], [ %17, %16 ]
  %77 = phi i32 [ %88, %85 ], [ 0, %16 ]
  %78 = fptosi double %76 to i32
  %79 = icmp eq i32 %15, %78
  br i1 %79, label %85, label %80

80:                                               ; preds = %74
  %81 = load i32, ptr @current_test, align 4, !tbaa !9
  %82 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %81)
  %83 = load double, ptr @init_value, align 8, !tbaa !28
  %84 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %85

85:                                               ; preds = %74, %80
  %86 = phi i32 [ %75, %74 ], [ %84, %80 ]
  %87 = phi double [ %76, %74 ], [ %83, %80 ]
  %88 = add nuw nsw i32 %77, 1
  %89 = icmp slt i32 %88, %86
  br i1 %89, label %74, label %90, !llvm.loop !297

90:                                               ; preds = %85, %54, %7
  %91 = tail call i64 @clock() #17
  store i64 %91, ptr @end_time, align 8, !tbaa !26
  %92 = load i64, ptr @start_time, align 8, !tbaa !26
  %93 = load ptr, ptr @results, align 8, !tbaa !5
  %94 = icmp eq ptr %93, null
  br i1 %94, label %95, label %97

95:                                               ; preds = %90
  %96 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %101

97:                                               ; preds = %90
  %98 = load i32, ptr @current_test, align 4, !tbaa !9
  %99 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %100 = icmp slt i32 %98, %99
  br i1 %100, label %113, label %101

101:                                              ; preds = %97, %95
  %102 = phi i32 [ %96, %95 ], [ %99, %97 ]
  %103 = add nsw i32 %102, 10
  store i32 %103, ptr @allocated_results, align 4, !tbaa !9
  %104 = sext i32 %103 to i64
  %105 = shl nsw i64 %104, 4
  %106 = tail call ptr @realloc(ptr noundef %93, i64 noundef %105) #14
  store ptr %106, ptr @results, align 8, !tbaa !5
  %107 = icmp eq ptr %106, null
  br i1 %107, label %110, label %108

108:                                              ; preds = %101
  %109 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %113

110:                                              ; preds = %101
  %111 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %112 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %111)
  tail call void @exit(i32 noundef -1) #15
  unreachable

113:                                              ; preds = %97, %108
  %114 = phi i32 [ %109, %108 ], [ %98, %97 ]
  %115 = phi ptr [ %106, %108 ], [ %93, %97 ]
  %116 = sub nsw i64 %91, %92
  %117 = sitofp i64 %116 to double
  %118 = fdiv double %117, 1.000000e+06
  %119 = sext i32 %114 to i64
  %120 = getelementptr inbounds %struct.one_result, ptr %115, i64 %119
  store double %118, ptr %120, align 8, !tbaa !11
  %121 = getelementptr inbounds %struct.one_result, ptr %115, i64 %119, i32 1
  store ptr %6, ptr %121, align 8, !tbaa !14
  %122 = add nsw i32 %114, 1
  store i32 %122, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1Ii24custom_multiply_variableIiEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i32 noundef %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !26
  %6 = load i32, ptr @iterations, align 4, !tbaa !9
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %85

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  %10 = mul i32 %2, 8000
  br i1 %9, label %13, label %11

11:                                               ; preds = %8
  %12 = load double, ptr @init_value, align 8, !tbaa !28
  br label %68

13:                                               ; preds = %8
  %14 = zext i32 %1 to i64
  %15 = icmp ult i32 %1, 8
  %16 = and i64 %14, 4294967288
  %17 = insertelement <4 x i32> poison, i32 %2, i64 0
  %18 = shufflevector <4 x i32> %17, <4 x i32> poison, <4 x i32> zeroinitializer
  %19 = insertelement <4 x i32> poison, i32 %2, i64 0
  %20 = shufflevector <4 x i32> %19, <4 x i32> poison, <4 x i32> zeroinitializer
  %21 = icmp eq i64 %16, %14
  br label %22

22:                                               ; preds = %13, %49
  %23 = phi i32 [ %50, %49 ], [ %6, %13 ]
  %24 = phi i32 [ %51, %49 ], [ 0, %13 ]
  br i1 %15, label %42, label %25

25:                                               ; preds = %22, %25
  %26 = phi i64 [ %37, %25 ], [ 0, %22 ]
  %27 = phi <4 x i32> [ %35, %25 ], [ zeroinitializer, %22 ]
  %28 = phi <4 x i32> [ %36, %25 ], [ zeroinitializer, %22 ]
  %29 = getelementptr inbounds i32, ptr %0, i64 %26
  %30 = load <4 x i32>, ptr %29, align 4, !tbaa !9
  %31 = getelementptr inbounds i32, ptr %29, i64 4
  %32 = load <4 x i32>, ptr %31, align 4, !tbaa !9
  %33 = mul nsw <4 x i32> %30, %18
  %34 = mul nsw <4 x i32> %32, %20
  %35 = add <4 x i32> %33, %27
  %36 = add <4 x i32> %34, %28
  %37 = add nuw i64 %26, 8
  %38 = icmp eq i64 %37, %16
  br i1 %38, label %39, label %25, !llvm.loop !299

39:                                               ; preds = %25
  %40 = add <4 x i32> %36, %35
  %41 = tail call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %40)
  br i1 %21, label %62, label %42

42:                                               ; preds = %22, %39
  %43 = phi i64 [ 0, %22 ], [ %16, %39 ]
  %44 = phi i32 [ 0, %22 ], [ %41, %39 ]
  br label %53

45:                                               ; preds = %62
  %46 = load i32, ptr @current_test, align 4, !tbaa !9
  %47 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %46)
  %48 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %49

49:                                               ; preds = %45, %62
  %50 = phi i32 [ %48, %45 ], [ %23, %62 ]
  %51 = add nuw nsw i32 %24, 1
  %52 = icmp slt i32 %51, %50
  br i1 %52, label %22, label %85, !llvm.loop !300

53:                                               ; preds = %42, %53
  %54 = phi i64 [ %60, %53 ], [ %43, %42 ]
  %55 = phi i32 [ %59, %53 ], [ %44, %42 ]
  %56 = getelementptr inbounds i32, ptr %0, i64 %54
  %57 = load i32, ptr %56, align 4, !tbaa !9
  %58 = mul nsw i32 %57, %2
  %59 = add nsw i32 %58, %55
  %60 = add nuw nsw i64 %54, 1
  %61 = icmp eq i64 %60, %14
  br i1 %61, label %62, label %53, !llvm.loop !301

62:                                               ; preds = %53, %39
  %63 = phi i32 [ %41, %39 ], [ %59, %53 ]
  %64 = load double, ptr @init_value, align 8, !tbaa !28
  %65 = fptosi double %64 to i32
  %66 = mul i32 %10, %65
  %67 = icmp eq i32 %66, %63
  br i1 %67, label %49, label %45

68:                                               ; preds = %11, %80
  %69 = phi i32 [ %81, %80 ], [ %6, %11 ]
  %70 = phi double [ %82, %80 ], [ %12, %11 ]
  %71 = phi i32 [ %83, %80 ], [ 0, %11 ]
  %72 = fptosi double %70 to i32
  %73 = mul i32 %10, %72
  %74 = icmp eq i32 %73, 0
  br i1 %74, label %80, label %75

75:                                               ; preds = %68
  %76 = load i32, ptr @current_test, align 4, !tbaa !9
  %77 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %76)
  %78 = load double, ptr @init_value, align 8, !tbaa !28
  %79 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %80

80:                                               ; preds = %68, %75
  %81 = phi i32 [ %69, %68 ], [ %79, %75 ]
  %82 = phi double [ %70, %68 ], [ %78, %75 ]
  %83 = add nuw nsw i32 %71, 1
  %84 = icmp slt i32 %83, %81
  br i1 %84, label %68, label %85, !llvm.loop !300

85:                                               ; preds = %80, %49, %4
  %86 = tail call i64 @clock() #17
  store i64 %86, ptr @end_time, align 8, !tbaa !26
  %87 = load i64, ptr @start_time, align 8, !tbaa !26
  %88 = load ptr, ptr @results, align 8, !tbaa !5
  %89 = icmp eq ptr %88, null
  br i1 %89, label %90, label %92

90:                                               ; preds = %85
  %91 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %96

92:                                               ; preds = %85
  %93 = load i32, ptr @current_test, align 4, !tbaa !9
  %94 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %95 = icmp slt i32 %93, %94
  br i1 %95, label %108, label %96

96:                                               ; preds = %92, %90
  %97 = phi i32 [ %91, %90 ], [ %94, %92 ]
  %98 = add nsw i32 %97, 10
  store i32 %98, ptr @allocated_results, align 4, !tbaa !9
  %99 = sext i32 %98 to i64
  %100 = shl nsw i64 %99, 4
  %101 = tail call ptr @realloc(ptr noundef %88, i64 noundef %100) #14
  store ptr %101, ptr @results, align 8, !tbaa !5
  %102 = icmp eq ptr %101, null
  br i1 %102, label %105, label %103

103:                                              ; preds = %96
  %104 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %108

105:                                              ; preds = %96
  %106 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %107 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %106)
  tail call void @exit(i32 noundef -1) #15
  unreachable

108:                                              ; preds = %92, %103
  %109 = phi i32 [ %104, %103 ], [ %93, %92 ]
  %110 = phi ptr [ %101, %103 ], [ %88, %92 ]
  %111 = sub nsw i64 %86, %87
  %112 = sitofp i64 %111 to double
  %113 = fdiv double %112, 1.000000e+06
  %114 = sext i32 %109 to i64
  %115 = getelementptr inbounds %struct.one_result, ptr %110, i64 %114
  store double %113, ptr %115, align 8, !tbaa !11
  %116 = getelementptr inbounds %struct.one_result, ptr %110, i64 %114, i32 1
  store ptr %3, ptr %116, align 8, !tbaa !14
  %117 = add nsw i32 %109, 1
  store i32 %117, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Ii33custom_multiply_multiple_variableIiEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3, i32 noundef %4, i32 noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !26
  %9 = load i32, ptr @iterations, align 4, !tbaa !9
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %93

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  %13 = mul i32 %3, %2
  %14 = mul i32 %13, %4
  %15 = mul i32 %14, %5
  %16 = mul i32 %13, 8000
  %17 = mul i32 %16, %4
  %18 = mul i32 %17, %5
  br i1 %12, label %21, label %19

19:                                               ; preds = %11
  %20 = load double, ptr @init_value, align 8, !tbaa !28
  br label %76

21:                                               ; preds = %11
  %22 = zext i32 %1 to i64
  %23 = icmp ult i32 %1, 8
  %24 = and i64 %22, 4294967288
  %25 = insertelement <4 x i32> poison, i32 %15, i64 0
  %26 = shufflevector <4 x i32> %25, <4 x i32> poison, <4 x i32> zeroinitializer
  %27 = insertelement <4 x i32> poison, i32 %15, i64 0
  %28 = shufflevector <4 x i32> %27, <4 x i32> poison, <4 x i32> zeroinitializer
  %29 = icmp eq i64 %24, %22
  br label %30

30:                                               ; preds = %21, %57
  %31 = phi i32 [ %58, %57 ], [ %9, %21 ]
  %32 = phi i32 [ %59, %57 ], [ 0, %21 ]
  br i1 %23, label %50, label %33

33:                                               ; preds = %30, %33
  %34 = phi i64 [ %45, %33 ], [ 0, %30 ]
  %35 = phi <4 x i32> [ %43, %33 ], [ zeroinitializer, %30 ]
  %36 = phi <4 x i32> [ %44, %33 ], [ zeroinitializer, %30 ]
  %37 = getelementptr inbounds i32, ptr %0, i64 %34
  %38 = load <4 x i32>, ptr %37, align 4, !tbaa !9
  %39 = getelementptr inbounds i32, ptr %37, i64 4
  %40 = load <4 x i32>, ptr %39, align 4, !tbaa !9
  %41 = mul <4 x i32> %26, %38
  %42 = mul <4 x i32> %28, %40
  %43 = add <4 x i32> %41, %35
  %44 = add <4 x i32> %42, %36
  %45 = add nuw i64 %34, 8
  %46 = icmp eq i64 %45, %24
  br i1 %46, label %47, label %33, !llvm.loop !302

47:                                               ; preds = %33
  %48 = add <4 x i32> %44, %43
  %49 = tail call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %48)
  br i1 %29, label %70, label %50

50:                                               ; preds = %30, %47
  %51 = phi i64 [ 0, %30 ], [ %24, %47 ]
  %52 = phi i32 [ 0, %30 ], [ %49, %47 ]
  br label %61

53:                                               ; preds = %70
  %54 = load i32, ptr @current_test, align 4, !tbaa !9
  %55 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %54)
  %56 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %57

57:                                               ; preds = %53, %70
  %58 = phi i32 [ %56, %53 ], [ %31, %70 ]
  %59 = add nuw nsw i32 %32, 1
  %60 = icmp slt i32 %59, %58
  br i1 %60, label %30, label %93, !llvm.loop !303

61:                                               ; preds = %50, %61
  %62 = phi i64 [ %68, %61 ], [ %51, %50 ]
  %63 = phi i32 [ %67, %61 ], [ %52, %50 ]
  %64 = getelementptr inbounds i32, ptr %0, i64 %62
  %65 = load i32, ptr %64, align 4, !tbaa !9
  %66 = mul i32 %15, %65
  %67 = add nsw i32 %66, %63
  %68 = add nuw nsw i64 %62, 1
  %69 = icmp eq i64 %68, %22
  br i1 %69, label %70, label %61, !llvm.loop !304

70:                                               ; preds = %61, %47
  %71 = phi i32 [ %49, %47 ], [ %67, %61 ]
  %72 = load double, ptr @init_value, align 8, !tbaa !28
  %73 = fptosi double %72 to i32
  %74 = mul i32 %18, %73
  %75 = icmp eq i32 %74, %71
  br i1 %75, label %57, label %53

76:                                               ; preds = %19, %88
  %77 = phi i32 [ %89, %88 ], [ %9, %19 ]
  %78 = phi double [ %90, %88 ], [ %20, %19 ]
  %79 = phi i32 [ %91, %88 ], [ 0, %19 ]
  %80 = fptosi double %78 to i32
  %81 = mul i32 %18, %80
  %82 = icmp eq i32 %81, 0
  br i1 %82, label %88, label %83

83:                                               ; preds = %76
  %84 = load i32, ptr @current_test, align 4, !tbaa !9
  %85 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %84)
  %86 = load double, ptr @init_value, align 8, !tbaa !28
  %87 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %88

88:                                               ; preds = %76, %83
  %89 = phi i32 [ %77, %76 ], [ %87, %83 ]
  %90 = phi double [ %78, %76 ], [ %86, %83 ]
  %91 = add nuw nsw i32 %79, 1
  %92 = icmp slt i32 %91, %89
  br i1 %92, label %76, label %93, !llvm.loop !303

93:                                               ; preds = %88, %57, %7
  %94 = tail call i64 @clock() #17
  store i64 %94, ptr @end_time, align 8, !tbaa !26
  %95 = load i64, ptr @start_time, align 8, !tbaa !26
  %96 = load ptr, ptr @results, align 8, !tbaa !5
  %97 = icmp eq ptr %96, null
  br i1 %97, label %98, label %100

98:                                               ; preds = %93
  %99 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %104

100:                                              ; preds = %93
  %101 = load i32, ptr @current_test, align 4, !tbaa !9
  %102 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %103 = icmp slt i32 %101, %102
  br i1 %103, label %116, label %104

104:                                              ; preds = %100, %98
  %105 = phi i32 [ %99, %98 ], [ %102, %100 ]
  %106 = add nsw i32 %105, 10
  store i32 %106, ptr @allocated_results, align 4, !tbaa !9
  %107 = sext i32 %106 to i64
  %108 = shl nsw i64 %107, 4
  %109 = tail call ptr @realloc(ptr noundef %96, i64 noundef %108) #14
  store ptr %109, ptr @results, align 8, !tbaa !5
  %110 = icmp eq ptr %109, null
  br i1 %110, label %113, label %111

111:                                              ; preds = %104
  %112 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %116

113:                                              ; preds = %104
  %114 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %115 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %114)
  tail call void @exit(i32 noundef -1) #15
  unreachable

116:                                              ; preds = %100, %111
  %117 = phi i32 [ %112, %111 ], [ %101, %100 ]
  %118 = phi ptr [ %109, %111 ], [ %96, %100 ]
  %119 = sub nsw i64 %94, %95
  %120 = sitofp i64 %119 to double
  %121 = fdiv double %120, 1.000000e+06
  %122 = sext i32 %117 to i64
  %123 = getelementptr inbounds %struct.one_result, ptr %118, i64 %122
  store double %121, ptr %123, align 8, !tbaa !11
  %124 = getelementptr inbounds %struct.one_result, ptr %118, i64 %122, i32 1
  store ptr %6, ptr %124, align 8, !tbaa !14
  %125 = add nsw i32 %117, 1
  store i32 %125, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Ii34custom_multiply_multiple_variable2IiEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3, i32 noundef %4, i32 noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !26
  %9 = load i32, ptr @iterations, align 4, !tbaa !9
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %91

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  %13 = mul nsw i32 %3, %2
  %14 = mul nsw i32 %13, %4
  %15 = mul nsw i32 %14, %5
  br i1 %12, label %18, label %16

16:                                               ; preds = %11
  %17 = load double, ptr @init_value, align 8, !tbaa !28
  br label %74

18:                                               ; preds = %11
  %19 = zext i32 %1 to i64
  %20 = icmp ult i32 %1, 8
  %21 = and i64 %19, 4294967288
  %22 = insertelement <4 x i32> poison, i32 %15, i64 0
  %23 = shufflevector <4 x i32> %22, <4 x i32> poison, <4 x i32> zeroinitializer
  %24 = insertelement <4 x i32> poison, i32 %15, i64 0
  %25 = shufflevector <4 x i32> %24, <4 x i32> poison, <4 x i32> zeroinitializer
  %26 = icmp eq i64 %21, %19
  br label %27

27:                                               ; preds = %18, %54
  %28 = phi i32 [ %55, %54 ], [ %9, %18 ]
  %29 = phi i32 [ %56, %54 ], [ 0, %18 ]
  br i1 %20, label %47, label %30

30:                                               ; preds = %27, %30
  %31 = phi i64 [ %42, %30 ], [ 0, %27 ]
  %32 = phi <4 x i32> [ %40, %30 ], [ zeroinitializer, %27 ]
  %33 = phi <4 x i32> [ %41, %30 ], [ zeroinitializer, %27 ]
  %34 = getelementptr inbounds i32, ptr %0, i64 %31
  %35 = load <4 x i32>, ptr %34, align 4, !tbaa !9
  %36 = getelementptr inbounds i32, ptr %34, i64 4
  %37 = load <4 x i32>, ptr %36, align 4, !tbaa !9
  %38 = add <4 x i32> %32, %23
  %39 = add <4 x i32> %33, %25
  %40 = add <4 x i32> %38, %35
  %41 = add <4 x i32> %39, %37
  %42 = add nuw i64 %31, 8
  %43 = icmp eq i64 %42, %21
  br i1 %43, label %44, label %30, !llvm.loop !305

44:                                               ; preds = %30
  %45 = add <4 x i32> %41, %40
  %46 = tail call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %45)
  br i1 %26, label %67, label %47

47:                                               ; preds = %27, %44
  %48 = phi i64 [ 0, %27 ], [ %21, %44 ]
  %49 = phi i32 [ 0, %27 ], [ %46, %44 ]
  br label %58

50:                                               ; preds = %67
  %51 = load i32, ptr @current_test, align 4, !tbaa !9
  %52 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %51)
  %53 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %54

54:                                               ; preds = %50, %67
  %55 = phi i32 [ %53, %50 ], [ %28, %67 ]
  %56 = add nuw nsw i32 %29, 1
  %57 = icmp slt i32 %56, %55
  br i1 %57, label %27, label %91, !llvm.loop !306

58:                                               ; preds = %47, %58
  %59 = phi i64 [ %65, %58 ], [ %48, %47 ]
  %60 = phi i32 [ %64, %58 ], [ %49, %47 ]
  %61 = getelementptr inbounds i32, ptr %0, i64 %59
  %62 = load i32, ptr %61, align 4, !tbaa !9
  %63 = add i32 %60, %15
  %64 = add i32 %63, %62
  %65 = add nuw nsw i64 %59, 1
  %66 = icmp eq i64 %65, %19
  br i1 %66, label %67, label %58, !llvm.loop !307

67:                                               ; preds = %58, %44
  %68 = phi i32 [ %46, %44 ], [ %64, %58 ]
  %69 = load double, ptr @init_value, align 8, !tbaa !28
  %70 = fptosi double %69 to i32
  %71 = add nsw i32 %15, %70
  %72 = mul nsw i32 %71, 8000
  %73 = icmp eq i32 %72, %68
  br i1 %73, label %54, label %50

74:                                               ; preds = %16, %86
  %75 = phi i32 [ %87, %86 ], [ %9, %16 ]
  %76 = phi double [ %88, %86 ], [ %17, %16 ]
  %77 = phi i32 [ %89, %86 ], [ 0, %16 ]
  %78 = fptosi double %76 to i32
  %79 = sub i32 0, %78
  %80 = icmp eq i32 %15, %79
  br i1 %80, label %86, label %81

81:                                               ; preds = %74
  %82 = load i32, ptr @current_test, align 4, !tbaa !9
  %83 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %82)
  %84 = load double, ptr @init_value, align 8, !tbaa !28
  %85 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %86

86:                                               ; preds = %74, %81
  %87 = phi i32 [ %75, %74 ], [ %85, %81 ]
  %88 = phi double [ %76, %74 ], [ %84, %81 ]
  %89 = add nuw nsw i32 %77, 1
  %90 = icmp slt i32 %89, %87
  br i1 %90, label %74, label %91, !llvm.loop !306

91:                                               ; preds = %86, %54, %7
  %92 = tail call i64 @clock() #17
  store i64 %92, ptr @end_time, align 8, !tbaa !26
  %93 = load i64, ptr @start_time, align 8, !tbaa !26
  %94 = load ptr, ptr @results, align 8, !tbaa !5
  %95 = icmp eq ptr %94, null
  br i1 %95, label %96, label %98

96:                                               ; preds = %91
  %97 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %102

98:                                               ; preds = %91
  %99 = load i32, ptr @current_test, align 4, !tbaa !9
  %100 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %101 = icmp slt i32 %99, %100
  br i1 %101, label %114, label %102

102:                                              ; preds = %98, %96
  %103 = phi i32 [ %97, %96 ], [ %100, %98 ]
  %104 = add nsw i32 %103, 10
  store i32 %104, ptr @allocated_results, align 4, !tbaa !9
  %105 = sext i32 %104 to i64
  %106 = shl nsw i64 %105, 4
  %107 = tail call ptr @realloc(ptr noundef %94, i64 noundef %106) #14
  store ptr %107, ptr @results, align 8, !tbaa !5
  %108 = icmp eq ptr %107, null
  br i1 %108, label %111, label %109

109:                                              ; preds = %102
  %110 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %114

111:                                              ; preds = %102
  %112 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %113 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %112)
  tail call void @exit(i32 noundef -1) #15
  unreachable

114:                                              ; preds = %98, %109
  %115 = phi i32 [ %110, %109 ], [ %99, %98 ]
  %116 = phi ptr [ %107, %109 ], [ %94, %98 ]
  %117 = sub nsw i64 %92, %93
  %118 = sitofp i64 %117 to double
  %119 = fdiv double %118, 1.000000e+06
  %120 = sext i32 %115 to i64
  %121 = getelementptr inbounds %struct.one_result, ptr %116, i64 %120
  store double %119, ptr %121, align 8, !tbaa !11
  %122 = getelementptr inbounds %struct.one_result, ptr %116, i64 %120, i32 1
  store ptr %6, ptr %122, align 8, !tbaa !14
  %123 = add nsw i32 %115, 1
  store i32 %123, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1Ii22custom_divide_variableIiEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i32 noundef %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !26
  %6 = load i32, ptr @iterations, align 4, !tbaa !9
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %78

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  br i1 %9, label %12, label %10

10:                                               ; preds = %8
  %11 = load double, ptr @init_value, align 8, !tbaa !28
  br label %61

12:                                               ; preds = %8
  %13 = zext i32 %1 to i64
  %14 = and i64 %13, 1
  %15 = icmp eq i32 %1, 1
  %16 = and i64 %13, 4294967294
  %17 = icmp eq i64 %14, 0
  br label %18

18:                                               ; preds = %12, %25
  %19 = phi i32 [ %26, %25 ], [ %6, %12 ]
  %20 = phi i32 [ %27, %25 ], [ 0, %12 ]
  br i1 %15, label %45, label %29

21:                                               ; preds = %54
  %22 = load i32, ptr @current_test, align 4, !tbaa !9
  %23 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %22)
  %24 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %25

25:                                               ; preds = %21, %54
  %26 = phi i32 [ %24, %21 ], [ %19, %54 ]
  %27 = add nuw nsw i32 %20, 1
  %28 = icmp slt i32 %27, %26
  br i1 %28, label %18, label %78, !llvm.loop !308

29:                                               ; preds = %18, %29
  %30 = phi i64 [ %42, %29 ], [ 0, %18 ]
  %31 = phi i32 [ %41, %29 ], [ 0, %18 ]
  %32 = phi i64 [ %43, %29 ], [ 0, %18 ]
  %33 = getelementptr inbounds i32, ptr %0, i64 %30
  %34 = load i32, ptr %33, align 4, !tbaa !9
  %35 = sdiv i32 %34, %2
  %36 = add nsw i32 %35, %31
  %37 = or i64 %30, 1
  %38 = getelementptr inbounds i32, ptr %0, i64 %37
  %39 = load i32, ptr %38, align 4, !tbaa !9
  %40 = sdiv i32 %39, %2
  %41 = add nsw i32 %40, %36
  %42 = add nuw nsw i64 %30, 2
  %43 = add i64 %32, 2
  %44 = icmp eq i64 %43, %16
  br i1 %44, label %45, label %29, !llvm.loop !309

45:                                               ; preds = %29, %18
  %46 = phi i32 [ undef, %18 ], [ %41, %29 ]
  %47 = phi i64 [ 0, %18 ], [ %42, %29 ]
  %48 = phi i32 [ 0, %18 ], [ %41, %29 ]
  br i1 %17, label %54, label %49

49:                                               ; preds = %45
  %50 = getelementptr inbounds i32, ptr %0, i64 %47
  %51 = load i32, ptr %50, align 4, !tbaa !9
  %52 = sdiv i32 %51, %2
  %53 = add nsw i32 %52, %48
  br label %54

54:                                               ; preds = %45, %49
  %55 = phi i32 [ %46, %45 ], [ %53, %49 ]
  %56 = load double, ptr @init_value, align 8, !tbaa !28
  %57 = fptosi double %56 to i32
  %58 = sdiv i32 %57, %2
  %59 = mul nsw i32 %58, 8000
  %60 = icmp eq i32 %59, %55
  br i1 %60, label %25, label %21

61:                                               ; preds = %10, %73
  %62 = phi i32 [ %74, %73 ], [ %6, %10 ]
  %63 = phi double [ %75, %73 ], [ %11, %10 ]
  %64 = phi i32 [ %76, %73 ], [ 0, %10 ]
  %65 = fptosi double %63 to i32
  %66 = sdiv i32 %65, %2
  %67 = icmp eq i32 %66, 0
  br i1 %67, label %73, label %68

68:                                               ; preds = %61
  %69 = load i32, ptr @current_test, align 4, !tbaa !9
  %70 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %69)
  %71 = load double, ptr @init_value, align 8, !tbaa !28
  %72 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %73

73:                                               ; preds = %61, %68
  %74 = phi i32 [ %62, %61 ], [ %72, %68 ]
  %75 = phi double [ %63, %61 ], [ %71, %68 ]
  %76 = add nuw nsw i32 %64, 1
  %77 = icmp slt i32 %76, %74
  br i1 %77, label %61, label %78, !llvm.loop !308

78:                                               ; preds = %73, %25, %4
  %79 = tail call i64 @clock() #17
  store i64 %79, ptr @end_time, align 8, !tbaa !26
  %80 = load i64, ptr @start_time, align 8, !tbaa !26
  %81 = load ptr, ptr @results, align 8, !tbaa !5
  %82 = icmp eq ptr %81, null
  br i1 %82, label %83, label %85

83:                                               ; preds = %78
  %84 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %89

85:                                               ; preds = %78
  %86 = load i32, ptr @current_test, align 4, !tbaa !9
  %87 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %88 = icmp slt i32 %86, %87
  br i1 %88, label %101, label %89

89:                                               ; preds = %85, %83
  %90 = phi i32 [ %84, %83 ], [ %87, %85 ]
  %91 = add nsw i32 %90, 10
  store i32 %91, ptr @allocated_results, align 4, !tbaa !9
  %92 = sext i32 %91 to i64
  %93 = shl nsw i64 %92, 4
  %94 = tail call ptr @realloc(ptr noundef %81, i64 noundef %93) #14
  store ptr %94, ptr @results, align 8, !tbaa !5
  %95 = icmp eq ptr %94, null
  br i1 %95, label %98, label %96

96:                                               ; preds = %89
  %97 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %101

98:                                               ; preds = %89
  %99 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %100 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %99)
  tail call void @exit(i32 noundef -1) #15
  unreachable

101:                                              ; preds = %85, %96
  %102 = phi i32 [ %97, %96 ], [ %86, %85 ]
  %103 = phi ptr [ %94, %96 ], [ %81, %85 ]
  %104 = sub nsw i64 %79, %80
  %105 = sitofp i64 %104 to double
  %106 = fdiv double %105, 1.000000e+06
  %107 = sext i32 %102 to i64
  %108 = getelementptr inbounds %struct.one_result, ptr %103, i64 %107
  store double %106, ptr %108, align 8, !tbaa !11
  %109 = getelementptr inbounds %struct.one_result, ptr %103, i64 %107, i32 1
  store ptr %3, ptr %109, align 8, !tbaa !14
  %110 = add nsw i32 %102, 1
  store i32 %110, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Ii31custom_divide_multiple_variableIiEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3, i32 noundef %4, i32 noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !26
  %9 = load i32, ptr @iterations, align 4, !tbaa !9
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %69

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  br i1 %12, label %15, label %13

13:                                               ; preds = %11
  %14 = load double, ptr @init_value, align 8, !tbaa !28
  br label %49

15:                                               ; preds = %11
  %16 = zext i32 %1 to i64
  br label %17

17:                                               ; preds = %15, %24
  %18 = phi i32 [ %25, %24 ], [ %9, %15 ]
  %19 = phi i32 [ %26, %24 ], [ 0, %15 ]
  br label %28

20:                                               ; preds = %40
  %21 = load i32, ptr @current_test, align 4, !tbaa !9
  %22 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %21)
  %23 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %24

24:                                               ; preds = %20, %40
  %25 = phi i32 [ %23, %20 ], [ %18, %40 ]
  %26 = add nuw nsw i32 %19, 1
  %27 = icmp slt i32 %26, %25
  br i1 %27, label %17, label %69, !llvm.loop !310

28:                                               ; preds = %17, %28
  %29 = phi i64 [ 0, %17 ], [ %38, %28 ]
  %30 = phi i32 [ 0, %17 ], [ %37, %28 ]
  %31 = getelementptr inbounds i32, ptr %0, i64 %29
  %32 = load i32, ptr %31, align 4, !tbaa !9
  %33 = sdiv i32 %32, %2
  %34 = sdiv i32 %33, %3
  %35 = sdiv i32 %34, %4
  %36 = sdiv i32 %35, %5
  %37 = add nsw i32 %36, %30
  %38 = add nuw nsw i64 %29, 1
  %39 = icmp eq i64 %38, %16
  br i1 %39, label %40, label %28, !llvm.loop !311

40:                                               ; preds = %28
  %41 = load double, ptr @init_value, align 8, !tbaa !28
  %42 = fptosi double %41 to i32
  %43 = sdiv i32 %42, %2
  %44 = sdiv i32 %43, %3
  %45 = sdiv i32 %44, %4
  %46 = sdiv i32 %45, %5
  %47 = mul nsw i32 %46, 8000
  %48 = icmp eq i32 %47, %37
  br i1 %48, label %24, label %20

49:                                               ; preds = %13, %64
  %50 = phi i32 [ %65, %64 ], [ %9, %13 ]
  %51 = phi double [ %66, %64 ], [ %14, %13 ]
  %52 = phi i32 [ %67, %64 ], [ 0, %13 ]
  %53 = fptosi double %51 to i32
  %54 = sdiv i32 %53, %2
  %55 = sdiv i32 %54, %3
  %56 = sdiv i32 %55, %4
  %57 = sdiv i32 %56, %5
  %58 = icmp eq i32 %57, 0
  br i1 %58, label %64, label %59

59:                                               ; preds = %49
  %60 = load i32, ptr @current_test, align 4, !tbaa !9
  %61 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %60)
  %62 = load double, ptr @init_value, align 8, !tbaa !28
  %63 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %64

64:                                               ; preds = %49, %59
  %65 = phi i32 [ %50, %49 ], [ %63, %59 ]
  %66 = phi double [ %51, %49 ], [ %62, %59 ]
  %67 = add nuw nsw i32 %52, 1
  %68 = icmp slt i32 %67, %65
  br i1 %68, label %49, label %69, !llvm.loop !310

69:                                               ; preds = %64, %24, %7
  %70 = tail call i64 @clock() #17
  store i64 %70, ptr @end_time, align 8, !tbaa !26
  %71 = load i64, ptr @start_time, align 8, !tbaa !26
  %72 = load ptr, ptr @results, align 8, !tbaa !5
  %73 = icmp eq ptr %72, null
  br i1 %73, label %74, label %76

74:                                               ; preds = %69
  %75 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %80

76:                                               ; preds = %69
  %77 = load i32, ptr @current_test, align 4, !tbaa !9
  %78 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %79 = icmp slt i32 %77, %78
  br i1 %79, label %92, label %80

80:                                               ; preds = %76, %74
  %81 = phi i32 [ %75, %74 ], [ %78, %76 ]
  %82 = add nsw i32 %81, 10
  store i32 %82, ptr @allocated_results, align 4, !tbaa !9
  %83 = sext i32 %82 to i64
  %84 = shl nsw i64 %83, 4
  %85 = tail call ptr @realloc(ptr noundef %72, i64 noundef %84) #14
  store ptr %85, ptr @results, align 8, !tbaa !5
  %86 = icmp eq ptr %85, null
  br i1 %86, label %89, label %87

87:                                               ; preds = %80
  %88 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %92

89:                                               ; preds = %80
  %90 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %91 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %90)
  tail call void @exit(i32 noundef -1) #15
  unreachable

92:                                               ; preds = %76, %87
  %93 = phi i32 [ %88, %87 ], [ %77, %76 ]
  %94 = phi ptr [ %85, %87 ], [ %72, %76 ]
  %95 = sub nsw i64 %70, %71
  %96 = sitofp i64 %95 to double
  %97 = fdiv double %96, 1.000000e+06
  %98 = sext i32 %93 to i64
  %99 = getelementptr inbounds %struct.one_result, ptr %94, i64 %98
  store double %97, ptr %99, align 8, !tbaa !11
  %100 = getelementptr inbounds %struct.one_result, ptr %94, i64 %98, i32 1
  store ptr %6, ptr %100, align 8, !tbaa !14
  %101 = add nsw i32 %93, 1
  store i32 %101, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Ii32custom_divide_multiple_variable2IiEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3, i32 noundef %4, i32 noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !26
  %9 = load i32, ptr @iterations, align 4, !tbaa !9
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %91

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  %13 = sdiv i32 %2, %3
  %14 = sdiv i32 %13, %4
  %15 = sdiv i32 %14, %5
  br i1 %12, label %18, label %16

16:                                               ; preds = %11
  %17 = load double, ptr @init_value, align 8, !tbaa !28
  br label %74

18:                                               ; preds = %11
  %19 = zext i32 %1 to i64
  %20 = icmp ult i32 %1, 8
  %21 = and i64 %19, 4294967288
  %22 = insertelement <4 x i32> poison, i32 %15, i64 0
  %23 = shufflevector <4 x i32> %22, <4 x i32> poison, <4 x i32> zeroinitializer
  %24 = insertelement <4 x i32> poison, i32 %15, i64 0
  %25 = shufflevector <4 x i32> %24, <4 x i32> poison, <4 x i32> zeroinitializer
  %26 = icmp eq i64 %21, %19
  br label %27

27:                                               ; preds = %54, %18
  %28 = phi i32 [ %9, %18 ], [ %55, %54 ]
  %29 = phi i32 [ 0, %18 ], [ %56, %54 ]
  br i1 %20, label %47, label %30

30:                                               ; preds = %27, %30
  %31 = phi i64 [ %42, %30 ], [ 0, %27 ]
  %32 = phi <4 x i32> [ %40, %30 ], [ zeroinitializer, %27 ]
  %33 = phi <4 x i32> [ %41, %30 ], [ zeroinitializer, %27 ]
  %34 = getelementptr inbounds i32, ptr %0, i64 %31
  %35 = load <4 x i32>, ptr %34, align 4, !tbaa !9
  %36 = getelementptr inbounds i32, ptr %34, i64 4
  %37 = load <4 x i32>, ptr %36, align 4, !tbaa !9
  %38 = add <4 x i32> %35, %32
  %39 = add <4 x i32> %37, %33
  %40 = add <4 x i32> %38, %23
  %41 = add <4 x i32> %39, %25
  %42 = add nuw i64 %31, 8
  %43 = icmp eq i64 %42, %21
  br i1 %43, label %44, label %30, !llvm.loop !312

44:                                               ; preds = %30
  %45 = add <4 x i32> %41, %40
  %46 = tail call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %45)
  br i1 %26, label %67, label %47

47:                                               ; preds = %27, %44
  %48 = phi i64 [ 0, %27 ], [ %21, %44 ]
  %49 = phi i32 [ 0, %27 ], [ %46, %44 ]
  br label %58

50:                                               ; preds = %67
  %51 = load i32, ptr @current_test, align 4, !tbaa !9
  %52 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %51)
  %53 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %54

54:                                               ; preds = %50, %67
  %55 = phi i32 [ %53, %50 ], [ %28, %67 ]
  %56 = add nuw nsw i32 %29, 1
  %57 = icmp slt i32 %56, %55
  br i1 %57, label %27, label %91, !llvm.loop !313

58:                                               ; preds = %47, %58
  %59 = phi i64 [ %65, %58 ], [ %48, %47 ]
  %60 = phi i32 [ %64, %58 ], [ %49, %47 ]
  %61 = getelementptr inbounds i32, ptr %0, i64 %59
  %62 = load i32, ptr %61, align 4, !tbaa !9
  %63 = add i32 %62, %60
  %64 = add i32 %63, %15
  %65 = add nuw nsw i64 %59, 1
  %66 = icmp eq i64 %65, %19
  br i1 %66, label %67, label %58, !llvm.loop !314

67:                                               ; preds = %58, %44
  %68 = phi i32 [ %46, %44 ], [ %64, %58 ]
  %69 = load double, ptr @init_value, align 8, !tbaa !28
  %70 = fptosi double %69 to i32
  %71 = add nsw i32 %15, %70
  %72 = mul nsw i32 %71, 8000
  %73 = icmp eq i32 %72, %68
  br i1 %73, label %54, label %50

74:                                               ; preds = %16, %86
  %75 = phi i32 [ %87, %86 ], [ %9, %16 ]
  %76 = phi double [ %88, %86 ], [ %17, %16 ]
  %77 = phi i32 [ %89, %86 ], [ 0, %16 ]
  %78 = fptosi double %76 to i32
  %79 = sub i32 0, %78
  %80 = icmp eq i32 %15, %79
  br i1 %80, label %86, label %81

81:                                               ; preds = %74
  %82 = load i32, ptr @current_test, align 4, !tbaa !9
  %83 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %82)
  %84 = load double, ptr @init_value, align 8, !tbaa !28
  %85 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %86

86:                                               ; preds = %74, %81
  %87 = phi i32 [ %75, %74 ], [ %85, %81 ]
  %88 = phi double [ %76, %74 ], [ %84, %81 ]
  %89 = add nuw nsw i32 %77, 1
  %90 = icmp slt i32 %89, %87
  br i1 %90, label %74, label %91, !llvm.loop !313

91:                                               ; preds = %86, %54, %7
  %92 = tail call i64 @clock() #17
  store i64 %92, ptr @end_time, align 8, !tbaa !26
  %93 = load i64, ptr @start_time, align 8, !tbaa !26
  %94 = load ptr, ptr @results, align 8, !tbaa !5
  %95 = icmp eq ptr %94, null
  br i1 %95, label %96, label %98

96:                                               ; preds = %91
  %97 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %102

98:                                               ; preds = %91
  %99 = load i32, ptr @current_test, align 4, !tbaa !9
  %100 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %101 = icmp slt i32 %99, %100
  br i1 %101, label %114, label %102

102:                                              ; preds = %98, %96
  %103 = phi i32 [ %97, %96 ], [ %100, %98 ]
  %104 = add nsw i32 %103, 10
  store i32 %104, ptr @allocated_results, align 4, !tbaa !9
  %105 = sext i32 %104 to i64
  %106 = shl nsw i64 %105, 4
  %107 = tail call ptr @realloc(ptr noundef %94, i64 noundef %106) #14
  store ptr %107, ptr @results, align 8, !tbaa !5
  %108 = icmp eq ptr %107, null
  br i1 %108, label %111, label %109

109:                                              ; preds = %102
  %110 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %114

111:                                              ; preds = %102
  %112 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %113 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %112)
  tail call void @exit(i32 noundef -1) #15
  unreachable

114:                                              ; preds = %98, %109
  %115 = phi i32 [ %110, %109 ], [ %99, %98 ]
  %116 = phi ptr [ %107, %109 ], [ %94, %98 ]
  %117 = sub nsw i64 %92, %93
  %118 = sitofp i64 %117 to double
  %119 = fdiv double %118, 1.000000e+06
  %120 = sext i32 %115 to i64
  %121 = getelementptr inbounds %struct.one_result, ptr %116, i64 %120
  store double %119, ptr %121, align 8, !tbaa !11
  %122 = getelementptr inbounds %struct.one_result, ptr %116, i64 %120, i32 1
  store ptr %6, ptr %122, align 8, !tbaa !14
  %123 = add nsw i32 %115, 1
  store i32 %123, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Ii30custom_mixed_multiple_variableIiEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3, i32 noundef %4, i32 noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !26
  %9 = load i32, ptr @iterations, align 4, !tbaa !9
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %98

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  %13 = mul nsw i32 %4, %3
  %14 = sdiv i32 %13, %5
  br i1 %12, label %17, label %15

15:                                               ; preds = %11
  %16 = load double, ptr @init_value, align 8, !tbaa !28
  br label %81

17:                                               ; preds = %11
  %18 = zext i32 %1 to i64
  %19 = icmp ult i32 %1, 8
  %20 = and i64 %18, 4294967288
  %21 = insertelement <4 x i32> poison, i32 %2, i64 0
  %22 = shufflevector <4 x i32> %21, <4 x i32> poison, <4 x i32> zeroinitializer
  %23 = insertelement <4 x i32> poison, i32 %2, i64 0
  %24 = shufflevector <4 x i32> %23, <4 x i32> poison, <4 x i32> zeroinitializer
  %25 = insertelement <4 x i32> poison, i32 %14, i64 0
  %26 = shufflevector <4 x i32> %25, <4 x i32> poison, <4 x i32> zeroinitializer
  %27 = insertelement <4 x i32> poison, i32 %14, i64 0
  %28 = shufflevector <4 x i32> %27, <4 x i32> poison, <4 x i32> zeroinitializer
  %29 = icmp eq i64 %20, %18
  br label %30

30:                                               ; preds = %59, %17
  %31 = phi i32 [ %9, %17 ], [ %60, %59 ]
  %32 = phi i32 [ 0, %17 ], [ %61, %59 ]
  br i1 %19, label %52, label %33

33:                                               ; preds = %30, %33
  %34 = phi i64 [ %47, %33 ], [ 0, %30 ]
  %35 = phi <4 x i32> [ %45, %33 ], [ zeroinitializer, %30 ]
  %36 = phi <4 x i32> [ %46, %33 ], [ zeroinitializer, %30 ]
  %37 = getelementptr inbounds i32, ptr %0, i64 %34
  %38 = load <4 x i32>, ptr %37, align 4, !tbaa !9
  %39 = getelementptr inbounds i32, ptr %37, i64 4
  %40 = load <4 x i32>, ptr %39, align 4, !tbaa !9
  %41 = add <4 x i32> %35, %22
  %42 = add <4 x i32> %36, %24
  %43 = add <4 x i32> %41, %38
  %44 = add <4 x i32> %42, %40
  %45 = sub <4 x i32> %43, %26
  %46 = sub <4 x i32> %44, %28
  %47 = add nuw i64 %34, 8
  %48 = icmp eq i64 %47, %20
  br i1 %48, label %49, label %33, !llvm.loop !315

49:                                               ; preds = %33
  %50 = add <4 x i32> %46, %45
  %51 = tail call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %50)
  br i1 %29, label %73, label %52

52:                                               ; preds = %30, %49
  %53 = phi i64 [ 0, %30 ], [ %20, %49 ]
  %54 = phi i32 [ 0, %30 ], [ %51, %49 ]
  br label %63

55:                                               ; preds = %73
  %56 = load i32, ptr @current_test, align 4, !tbaa !9
  %57 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %56)
  %58 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %59

59:                                               ; preds = %55, %73
  %60 = phi i32 [ %58, %55 ], [ %31, %73 ]
  %61 = add nuw nsw i32 %32, 1
  %62 = icmp slt i32 %61, %60
  br i1 %62, label %30, label %98, !llvm.loop !316

63:                                               ; preds = %52, %63
  %64 = phi i64 [ %71, %63 ], [ %53, %52 ]
  %65 = phi i32 [ %70, %63 ], [ %54, %52 ]
  %66 = getelementptr inbounds i32, ptr %0, i64 %64
  %67 = load i32, ptr %66, align 4, !tbaa !9
  %68 = add i32 %65, %2
  %69 = add i32 %68, %67
  %70 = sub i32 %69, %14
  %71 = add nuw nsw i64 %64, 1
  %72 = icmp eq i64 %71, %18
  br i1 %72, label %73, label %63, !llvm.loop !317

73:                                               ; preds = %63, %49
  %74 = phi i32 [ %51, %49 ], [ %70, %63 ]
  %75 = load double, ptr @init_value, align 8, !tbaa !28
  %76 = fptosi double %75 to i32
  %77 = add nsw i32 %76, %2
  %78 = sub i32 %77, %14
  %79 = mul nsw i32 %78, 8000
  %80 = icmp eq i32 %79, %74
  br i1 %80, label %59, label %55

81:                                               ; preds = %15, %93
  %82 = phi i32 [ %94, %93 ], [ %9, %15 ]
  %83 = phi double [ %95, %93 ], [ %16, %15 ]
  %84 = phi i32 [ %96, %93 ], [ 0, %15 ]
  %85 = fptosi double %83 to i32
  %86 = add nsw i32 %85, %2
  %87 = icmp eq i32 %86, %14
  br i1 %87, label %93, label %88

88:                                               ; preds = %81
  %89 = load i32, ptr @current_test, align 4, !tbaa !9
  %90 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %89)
  %91 = load double, ptr @init_value, align 8, !tbaa !28
  %92 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %93

93:                                               ; preds = %81, %88
  %94 = phi i32 [ %82, %81 ], [ %92, %88 ]
  %95 = phi double [ %83, %81 ], [ %91, %88 ]
  %96 = add nuw nsw i32 %84, 1
  %97 = icmp slt i32 %96, %94
  br i1 %97, label %81, label %98, !llvm.loop !316

98:                                               ; preds = %93, %59, %7
  %99 = tail call i64 @clock() #17
  store i64 %99, ptr @end_time, align 8, !tbaa !26
  %100 = load i64, ptr @start_time, align 8, !tbaa !26
  %101 = load ptr, ptr @results, align 8, !tbaa !5
  %102 = icmp eq ptr %101, null
  br i1 %102, label %103, label %105

103:                                              ; preds = %98
  %104 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %109

105:                                              ; preds = %98
  %106 = load i32, ptr @current_test, align 4, !tbaa !9
  %107 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %108 = icmp slt i32 %106, %107
  br i1 %108, label %121, label %109

109:                                              ; preds = %105, %103
  %110 = phi i32 [ %104, %103 ], [ %107, %105 ]
  %111 = add nsw i32 %110, 10
  store i32 %111, ptr @allocated_results, align 4, !tbaa !9
  %112 = sext i32 %111 to i64
  %113 = shl nsw i64 %112, 4
  %114 = tail call ptr @realloc(ptr noundef %101, i64 noundef %113) #14
  store ptr %114, ptr @results, align 8, !tbaa !5
  %115 = icmp eq ptr %114, null
  br i1 %115, label %118, label %116

116:                                              ; preds = %109
  %117 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %121

118:                                              ; preds = %109
  %119 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %120 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %119)
  tail call void @exit(i32 noundef -1) #15
  unreachable

121:                                              ; preds = %105, %116
  %122 = phi i32 [ %117, %116 ], [ %106, %105 ]
  %123 = phi ptr [ %114, %116 ], [ %101, %105 ]
  %124 = sub nsw i64 %99, %100
  %125 = sitofp i64 %124 to double
  %126 = fdiv double %125, 1.000000e+06
  %127 = sext i32 %122 to i64
  %128 = getelementptr inbounds %struct.one_result, ptr %123, i64 %127
  store double %126, ptr %128, align 8, !tbaa !11
  %129 = getelementptr inbounds %struct.one_result, ptr %123, i64 %127, i32 1
  store ptr %6, ptr %129, align 8, !tbaa !14
  %130 = add nsw i32 %122, 1
  store i32 %130, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1Ii19custom_variable_andIiEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i32 noundef %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !26
  %6 = load i32, ptr @iterations, align 4, !tbaa !9
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %85

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  br i1 %9, label %12, label %10

10:                                               ; preds = %8
  %11 = load double, ptr @init_value, align 8, !tbaa !28
  br label %68

12:                                               ; preds = %8
  %13 = zext i32 %1 to i64
  %14 = icmp ult i32 %1, 8
  %15 = and i64 %13, 4294967288
  %16 = insertelement <4 x i32> poison, i32 %2, i64 0
  %17 = shufflevector <4 x i32> %16, <4 x i32> poison, <4 x i32> zeroinitializer
  %18 = insertelement <4 x i32> poison, i32 %2, i64 0
  %19 = shufflevector <4 x i32> %18, <4 x i32> poison, <4 x i32> zeroinitializer
  %20 = icmp eq i64 %15, %13
  br label %21

21:                                               ; preds = %12, %48
  %22 = phi i32 [ %49, %48 ], [ %6, %12 ]
  %23 = phi i32 [ %50, %48 ], [ 0, %12 ]
  br i1 %14, label %41, label %24

24:                                               ; preds = %21, %24
  %25 = phi i64 [ %36, %24 ], [ 0, %21 ]
  %26 = phi <4 x i32> [ %34, %24 ], [ zeroinitializer, %21 ]
  %27 = phi <4 x i32> [ %35, %24 ], [ zeroinitializer, %21 ]
  %28 = getelementptr inbounds i32, ptr %0, i64 %25
  %29 = load <4 x i32>, ptr %28, align 4, !tbaa !9
  %30 = getelementptr inbounds i32, ptr %28, i64 4
  %31 = load <4 x i32>, ptr %30, align 4, !tbaa !9
  %32 = and <4 x i32> %29, %17
  %33 = and <4 x i32> %31, %19
  %34 = add <4 x i32> %32, %26
  %35 = add <4 x i32> %33, %27
  %36 = add nuw i64 %25, 8
  %37 = icmp eq i64 %36, %15
  br i1 %37, label %38, label %24, !llvm.loop !318

38:                                               ; preds = %24
  %39 = add <4 x i32> %35, %34
  %40 = tail call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %39)
  br i1 %20, label %61, label %41

41:                                               ; preds = %21, %38
  %42 = phi i64 [ 0, %21 ], [ %15, %38 ]
  %43 = phi i32 [ 0, %21 ], [ %40, %38 ]
  br label %52

44:                                               ; preds = %61
  %45 = load i32, ptr @current_test, align 4, !tbaa !9
  %46 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %45)
  %47 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %48

48:                                               ; preds = %44, %61
  %49 = phi i32 [ %47, %44 ], [ %22, %61 ]
  %50 = add nuw nsw i32 %23, 1
  %51 = icmp slt i32 %50, %49
  br i1 %51, label %21, label %85, !llvm.loop !319

52:                                               ; preds = %41, %52
  %53 = phi i64 [ %59, %52 ], [ %42, %41 ]
  %54 = phi i32 [ %58, %52 ], [ %43, %41 ]
  %55 = getelementptr inbounds i32, ptr %0, i64 %53
  %56 = load i32, ptr %55, align 4, !tbaa !9
  %57 = and i32 %56, %2
  %58 = add nsw i32 %57, %54
  %59 = add nuw nsw i64 %53, 1
  %60 = icmp eq i64 %59, %13
  br i1 %60, label %61, label %52, !llvm.loop !320

61:                                               ; preds = %52, %38
  %62 = phi i32 [ %40, %38 ], [ %58, %52 ]
  %63 = load double, ptr @init_value, align 8, !tbaa !28
  %64 = fptosi double %63 to i32
  %65 = and i32 %64, %2
  %66 = mul nsw i32 %65, 8000
  %67 = icmp eq i32 %66, %62
  br i1 %67, label %48, label %44

68:                                               ; preds = %10, %80
  %69 = phi i32 [ %81, %80 ], [ %6, %10 ]
  %70 = phi double [ %82, %80 ], [ %11, %10 ]
  %71 = phi i32 [ %83, %80 ], [ 0, %10 ]
  %72 = fptosi double %70 to i32
  %73 = and i32 %72, %2
  %74 = icmp eq i32 %73, 0
  br i1 %74, label %80, label %75

75:                                               ; preds = %68
  %76 = load i32, ptr @current_test, align 4, !tbaa !9
  %77 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %76)
  %78 = load double, ptr @init_value, align 8, !tbaa !28
  %79 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %80

80:                                               ; preds = %68, %75
  %81 = phi i32 [ %69, %68 ], [ %79, %75 ]
  %82 = phi double [ %70, %68 ], [ %78, %75 ]
  %83 = add nuw nsw i32 %71, 1
  %84 = icmp slt i32 %83, %81
  br i1 %84, label %68, label %85, !llvm.loop !319

85:                                               ; preds = %80, %48, %4
  %86 = tail call i64 @clock() #17
  store i64 %86, ptr @end_time, align 8, !tbaa !26
  %87 = load i64, ptr @start_time, align 8, !tbaa !26
  %88 = load ptr, ptr @results, align 8, !tbaa !5
  %89 = icmp eq ptr %88, null
  br i1 %89, label %90, label %92

90:                                               ; preds = %85
  %91 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %96

92:                                               ; preds = %85
  %93 = load i32, ptr @current_test, align 4, !tbaa !9
  %94 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %95 = icmp slt i32 %93, %94
  br i1 %95, label %108, label %96

96:                                               ; preds = %92, %90
  %97 = phi i32 [ %91, %90 ], [ %94, %92 ]
  %98 = add nsw i32 %97, 10
  store i32 %98, ptr @allocated_results, align 4, !tbaa !9
  %99 = sext i32 %98 to i64
  %100 = shl nsw i64 %99, 4
  %101 = tail call ptr @realloc(ptr noundef %88, i64 noundef %100) #14
  store ptr %101, ptr @results, align 8, !tbaa !5
  %102 = icmp eq ptr %101, null
  br i1 %102, label %105, label %103

103:                                              ; preds = %96
  %104 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %108

105:                                              ; preds = %96
  %106 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %107 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %106)
  tail call void @exit(i32 noundef -1) #15
  unreachable

108:                                              ; preds = %92, %103
  %109 = phi i32 [ %104, %103 ], [ %93, %92 ]
  %110 = phi ptr [ %101, %103 ], [ %88, %92 ]
  %111 = sub nsw i64 %86, %87
  %112 = sitofp i64 %111 to double
  %113 = fdiv double %112, 1.000000e+06
  %114 = sext i32 %109 to i64
  %115 = getelementptr inbounds %struct.one_result, ptr %110, i64 %114
  store double %113, ptr %115, align 8, !tbaa !11
  %116 = getelementptr inbounds %struct.one_result, ptr %110, i64 %114, i32 1
  store ptr %3, ptr %116, align 8, !tbaa !14
  %117 = add nsw i32 %109, 1
  store i32 %117, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Ii28custom_multiple_variable_andIiEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3, i32 noundef %4, i32 noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !26
  %9 = load i32, ptr @iterations, align 4, !tbaa !9
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %100

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  %13 = and i32 %3, %2
  %14 = and i32 %13, %4
  %15 = and i32 %14, %5
  br i1 %12, label %18, label %16

16:                                               ; preds = %11
  %17 = load double, ptr @init_value, align 8, !tbaa !28
  br label %83

18:                                               ; preds = %11
  %19 = zext i32 %1 to i64
  %20 = icmp ult i32 %1, 8
  %21 = and i64 %19, 4294967288
  %22 = and i32 %3, %2
  %23 = and i32 %3, %2
  %24 = and i32 %22, %4
  %25 = and i32 %23, %4
  %26 = and i32 %24, %5
  %27 = insertelement <4 x i32> poison, i32 %26, i64 0
  %28 = shufflevector <4 x i32> %27, <4 x i32> poison, <4 x i32> zeroinitializer
  %29 = and i32 %25, %5
  %30 = insertelement <4 x i32> poison, i32 %29, i64 0
  %31 = shufflevector <4 x i32> %30, <4 x i32> poison, <4 x i32> zeroinitializer
  %32 = icmp eq i64 %21, %19
  br label %33

33:                                               ; preds = %18, %60
  %34 = phi i32 [ %61, %60 ], [ %9, %18 ]
  %35 = phi i32 [ %62, %60 ], [ 0, %18 ]
  br i1 %20, label %53, label %36

36:                                               ; preds = %33, %36
  %37 = phi i64 [ %48, %36 ], [ 0, %33 ]
  %38 = phi <4 x i32> [ %46, %36 ], [ zeroinitializer, %33 ]
  %39 = phi <4 x i32> [ %47, %36 ], [ zeroinitializer, %33 ]
  %40 = getelementptr inbounds i32, ptr %0, i64 %37
  %41 = load <4 x i32>, ptr %40, align 4, !tbaa !9
  %42 = getelementptr inbounds i32, ptr %40, i64 4
  %43 = load <4 x i32>, ptr %42, align 4, !tbaa !9
  %44 = and <4 x i32> %28, %41
  %45 = and <4 x i32> %31, %43
  %46 = add <4 x i32> %44, %38
  %47 = add <4 x i32> %45, %39
  %48 = add nuw i64 %37, 8
  %49 = icmp eq i64 %48, %21
  br i1 %49, label %50, label %36, !llvm.loop !321

50:                                               ; preds = %36
  %51 = add <4 x i32> %47, %46
  %52 = tail call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %51)
  br i1 %32, label %76, label %53

53:                                               ; preds = %33, %50
  %54 = phi i64 [ 0, %33 ], [ %21, %50 ]
  %55 = phi i32 [ 0, %33 ], [ %52, %50 ]
  br label %64

56:                                               ; preds = %76
  %57 = load i32, ptr @current_test, align 4, !tbaa !9
  %58 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %57)
  %59 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %60

60:                                               ; preds = %56, %76
  %61 = phi i32 [ %59, %56 ], [ %34, %76 ]
  %62 = add nuw nsw i32 %35, 1
  %63 = icmp slt i32 %62, %61
  br i1 %63, label %33, label %100, !llvm.loop !322

64:                                               ; preds = %53, %64
  %65 = phi i64 [ %74, %64 ], [ %54, %53 ]
  %66 = phi i32 [ %73, %64 ], [ %55, %53 ]
  %67 = getelementptr inbounds i32, ptr %0, i64 %65
  %68 = load i32, ptr %67, align 4, !tbaa !9
  %69 = and i32 %68, %2
  %70 = and i32 %69, %3
  %71 = and i32 %70, %4
  %72 = and i32 %71, %5
  %73 = add nsw i32 %72, %66
  %74 = add nuw nsw i64 %65, 1
  %75 = icmp eq i64 %74, %19
  br i1 %75, label %76, label %64, !llvm.loop !323

76:                                               ; preds = %64, %50
  %77 = phi i32 [ %52, %50 ], [ %73, %64 ]
  %78 = load double, ptr @init_value, align 8, !tbaa !28
  %79 = fptosi double %78 to i32
  %80 = and i32 %15, %79
  %81 = mul nsw i32 %80, 8000
  %82 = icmp eq i32 %81, %77
  br i1 %82, label %60, label %56

83:                                               ; preds = %16, %95
  %84 = phi i32 [ %96, %95 ], [ %9, %16 ]
  %85 = phi double [ %97, %95 ], [ %17, %16 ]
  %86 = phi i32 [ %98, %95 ], [ 0, %16 ]
  %87 = fptosi double %85 to i32
  %88 = and i32 %15, %87
  %89 = icmp eq i32 %88, 0
  br i1 %89, label %95, label %90

90:                                               ; preds = %83
  %91 = load i32, ptr @current_test, align 4, !tbaa !9
  %92 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %91)
  %93 = load double, ptr @init_value, align 8, !tbaa !28
  %94 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %95

95:                                               ; preds = %83, %90
  %96 = phi i32 [ %84, %83 ], [ %94, %90 ]
  %97 = phi double [ %85, %83 ], [ %93, %90 ]
  %98 = add nuw nsw i32 %86, 1
  %99 = icmp slt i32 %98, %96
  br i1 %99, label %83, label %100, !llvm.loop !322

100:                                              ; preds = %95, %60, %7
  %101 = tail call i64 @clock() #17
  store i64 %101, ptr @end_time, align 8, !tbaa !26
  %102 = load i64, ptr @start_time, align 8, !tbaa !26
  %103 = load ptr, ptr @results, align 8, !tbaa !5
  %104 = icmp eq ptr %103, null
  br i1 %104, label %105, label %107

105:                                              ; preds = %100
  %106 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %111

107:                                              ; preds = %100
  %108 = load i32, ptr @current_test, align 4, !tbaa !9
  %109 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %110 = icmp slt i32 %108, %109
  br i1 %110, label %123, label %111

111:                                              ; preds = %107, %105
  %112 = phi i32 [ %106, %105 ], [ %109, %107 ]
  %113 = add nsw i32 %112, 10
  store i32 %113, ptr @allocated_results, align 4, !tbaa !9
  %114 = sext i32 %113 to i64
  %115 = shl nsw i64 %114, 4
  %116 = tail call ptr @realloc(ptr noundef %103, i64 noundef %115) #14
  store ptr %116, ptr @results, align 8, !tbaa !5
  %117 = icmp eq ptr %116, null
  br i1 %117, label %120, label %118

118:                                              ; preds = %111
  %119 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %123

120:                                              ; preds = %111
  %121 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %122 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %121)
  tail call void @exit(i32 noundef -1) #15
  unreachable

123:                                              ; preds = %107, %118
  %124 = phi i32 [ %119, %118 ], [ %108, %107 ]
  %125 = phi ptr [ %116, %118 ], [ %103, %107 ]
  %126 = sub nsw i64 %101, %102
  %127 = sitofp i64 %126 to double
  %128 = fdiv double %127, 1.000000e+06
  %129 = sext i32 %124 to i64
  %130 = getelementptr inbounds %struct.one_result, ptr %125, i64 %129
  store double %128, ptr %130, align 8, !tbaa !11
  %131 = getelementptr inbounds %struct.one_result, ptr %125, i64 %129, i32 1
  store ptr %6, ptr %131, align 8, !tbaa !14
  %132 = add nsw i32 %124, 1
  store i32 %132, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1Ii18custom_variable_orIiEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i32 noundef %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !26
  %6 = load i32, ptr @iterations, align 4, !tbaa !9
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %85

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  br i1 %9, label %12, label %10

10:                                               ; preds = %8
  %11 = load double, ptr @init_value, align 8, !tbaa !28
  br label %68

12:                                               ; preds = %8
  %13 = zext i32 %1 to i64
  %14 = icmp ult i32 %1, 8
  %15 = and i64 %13, 4294967288
  %16 = insertelement <4 x i32> poison, i32 %2, i64 0
  %17 = shufflevector <4 x i32> %16, <4 x i32> poison, <4 x i32> zeroinitializer
  %18 = insertelement <4 x i32> poison, i32 %2, i64 0
  %19 = shufflevector <4 x i32> %18, <4 x i32> poison, <4 x i32> zeroinitializer
  %20 = icmp eq i64 %15, %13
  br label %21

21:                                               ; preds = %12, %48
  %22 = phi i32 [ %49, %48 ], [ %6, %12 ]
  %23 = phi i32 [ %50, %48 ], [ 0, %12 ]
  br i1 %14, label %41, label %24

24:                                               ; preds = %21, %24
  %25 = phi i64 [ %36, %24 ], [ 0, %21 ]
  %26 = phi <4 x i32> [ %34, %24 ], [ zeroinitializer, %21 ]
  %27 = phi <4 x i32> [ %35, %24 ], [ zeroinitializer, %21 ]
  %28 = getelementptr inbounds i32, ptr %0, i64 %25
  %29 = load <4 x i32>, ptr %28, align 4, !tbaa !9
  %30 = getelementptr inbounds i32, ptr %28, i64 4
  %31 = load <4 x i32>, ptr %30, align 4, !tbaa !9
  %32 = or <4 x i32> %29, %17
  %33 = or <4 x i32> %31, %19
  %34 = add <4 x i32> %32, %26
  %35 = add <4 x i32> %33, %27
  %36 = add nuw i64 %25, 8
  %37 = icmp eq i64 %36, %15
  br i1 %37, label %38, label %24, !llvm.loop !324

38:                                               ; preds = %24
  %39 = add <4 x i32> %35, %34
  %40 = tail call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %39)
  br i1 %20, label %61, label %41

41:                                               ; preds = %21, %38
  %42 = phi i64 [ 0, %21 ], [ %15, %38 ]
  %43 = phi i32 [ 0, %21 ], [ %40, %38 ]
  br label %52

44:                                               ; preds = %61
  %45 = load i32, ptr @current_test, align 4, !tbaa !9
  %46 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %45)
  %47 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %48

48:                                               ; preds = %44, %61
  %49 = phi i32 [ %47, %44 ], [ %22, %61 ]
  %50 = add nuw nsw i32 %23, 1
  %51 = icmp slt i32 %50, %49
  br i1 %51, label %21, label %85, !llvm.loop !325

52:                                               ; preds = %41, %52
  %53 = phi i64 [ %59, %52 ], [ %42, %41 ]
  %54 = phi i32 [ %58, %52 ], [ %43, %41 ]
  %55 = getelementptr inbounds i32, ptr %0, i64 %53
  %56 = load i32, ptr %55, align 4, !tbaa !9
  %57 = or i32 %56, %2
  %58 = add nsw i32 %57, %54
  %59 = add nuw nsw i64 %53, 1
  %60 = icmp eq i64 %59, %13
  br i1 %60, label %61, label %52, !llvm.loop !326

61:                                               ; preds = %52, %38
  %62 = phi i32 [ %40, %38 ], [ %58, %52 ]
  %63 = load double, ptr @init_value, align 8, !tbaa !28
  %64 = fptosi double %63 to i32
  %65 = or i32 %64, %2
  %66 = mul nsw i32 %65, 8000
  %67 = icmp eq i32 %66, %62
  br i1 %67, label %48, label %44

68:                                               ; preds = %10, %80
  %69 = phi i32 [ %81, %80 ], [ %6, %10 ]
  %70 = phi double [ %82, %80 ], [ %11, %10 ]
  %71 = phi i32 [ %83, %80 ], [ 0, %10 ]
  %72 = fptosi double %70 to i32
  %73 = or i32 %72, %2
  %74 = icmp eq i32 %73, 0
  br i1 %74, label %80, label %75

75:                                               ; preds = %68
  %76 = load i32, ptr @current_test, align 4, !tbaa !9
  %77 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %76)
  %78 = load double, ptr @init_value, align 8, !tbaa !28
  %79 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %80

80:                                               ; preds = %68, %75
  %81 = phi i32 [ %69, %68 ], [ %79, %75 ]
  %82 = phi double [ %70, %68 ], [ %78, %75 ]
  %83 = add nuw nsw i32 %71, 1
  %84 = icmp slt i32 %83, %81
  br i1 %84, label %68, label %85, !llvm.loop !325

85:                                               ; preds = %80, %48, %4
  %86 = tail call i64 @clock() #17
  store i64 %86, ptr @end_time, align 8, !tbaa !26
  %87 = load i64, ptr @start_time, align 8, !tbaa !26
  %88 = load ptr, ptr @results, align 8, !tbaa !5
  %89 = icmp eq ptr %88, null
  br i1 %89, label %90, label %92

90:                                               ; preds = %85
  %91 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %96

92:                                               ; preds = %85
  %93 = load i32, ptr @current_test, align 4, !tbaa !9
  %94 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %95 = icmp slt i32 %93, %94
  br i1 %95, label %108, label %96

96:                                               ; preds = %92, %90
  %97 = phi i32 [ %91, %90 ], [ %94, %92 ]
  %98 = add nsw i32 %97, 10
  store i32 %98, ptr @allocated_results, align 4, !tbaa !9
  %99 = sext i32 %98 to i64
  %100 = shl nsw i64 %99, 4
  %101 = tail call ptr @realloc(ptr noundef %88, i64 noundef %100) #14
  store ptr %101, ptr @results, align 8, !tbaa !5
  %102 = icmp eq ptr %101, null
  br i1 %102, label %105, label %103

103:                                              ; preds = %96
  %104 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %108

105:                                              ; preds = %96
  %106 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %107 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %106)
  tail call void @exit(i32 noundef -1) #15
  unreachable

108:                                              ; preds = %92, %103
  %109 = phi i32 [ %104, %103 ], [ %93, %92 ]
  %110 = phi ptr [ %101, %103 ], [ %88, %92 ]
  %111 = sub nsw i64 %86, %87
  %112 = sitofp i64 %111 to double
  %113 = fdiv double %112, 1.000000e+06
  %114 = sext i32 %109 to i64
  %115 = getelementptr inbounds %struct.one_result, ptr %110, i64 %114
  store double %113, ptr %115, align 8, !tbaa !11
  %116 = getelementptr inbounds %struct.one_result, ptr %110, i64 %114, i32 1
  store ptr %3, ptr %116, align 8, !tbaa !14
  %117 = add nsw i32 %109, 1
  store i32 %117, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Ii27custom_multiple_variable_orIiEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3, i32 noundef %4, i32 noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !26
  %9 = load i32, ptr @iterations, align 4, !tbaa !9
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %100

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  %13 = or i32 %3, %2
  %14 = or i32 %13, %4
  %15 = or i32 %14, %5
  br i1 %12, label %18, label %16

16:                                               ; preds = %11
  %17 = load double, ptr @init_value, align 8, !tbaa !28
  br label %83

18:                                               ; preds = %11
  %19 = zext i32 %1 to i64
  %20 = icmp ult i32 %1, 8
  %21 = and i64 %19, 4294967288
  %22 = or i32 %3, %2
  %23 = or i32 %3, %2
  %24 = or i32 %22, %4
  %25 = or i32 %23, %4
  %26 = or i32 %24, %5
  %27 = insertelement <4 x i32> poison, i32 %26, i64 0
  %28 = shufflevector <4 x i32> %27, <4 x i32> poison, <4 x i32> zeroinitializer
  %29 = or i32 %25, %5
  %30 = insertelement <4 x i32> poison, i32 %29, i64 0
  %31 = shufflevector <4 x i32> %30, <4 x i32> poison, <4 x i32> zeroinitializer
  %32 = icmp eq i64 %21, %19
  br label %33

33:                                               ; preds = %18, %60
  %34 = phi i32 [ %61, %60 ], [ %9, %18 ]
  %35 = phi i32 [ %62, %60 ], [ 0, %18 ]
  br i1 %20, label %53, label %36

36:                                               ; preds = %33, %36
  %37 = phi i64 [ %48, %36 ], [ 0, %33 ]
  %38 = phi <4 x i32> [ %46, %36 ], [ zeroinitializer, %33 ]
  %39 = phi <4 x i32> [ %47, %36 ], [ zeroinitializer, %33 ]
  %40 = getelementptr inbounds i32, ptr %0, i64 %37
  %41 = load <4 x i32>, ptr %40, align 4, !tbaa !9
  %42 = getelementptr inbounds i32, ptr %40, i64 4
  %43 = load <4 x i32>, ptr %42, align 4, !tbaa !9
  %44 = or <4 x i32> %28, %41
  %45 = or <4 x i32> %31, %43
  %46 = add <4 x i32> %44, %38
  %47 = add <4 x i32> %45, %39
  %48 = add nuw i64 %37, 8
  %49 = icmp eq i64 %48, %21
  br i1 %49, label %50, label %36, !llvm.loop !327

50:                                               ; preds = %36
  %51 = add <4 x i32> %47, %46
  %52 = tail call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %51)
  br i1 %32, label %76, label %53

53:                                               ; preds = %33, %50
  %54 = phi i64 [ 0, %33 ], [ %21, %50 ]
  %55 = phi i32 [ 0, %33 ], [ %52, %50 ]
  br label %64

56:                                               ; preds = %76
  %57 = load i32, ptr @current_test, align 4, !tbaa !9
  %58 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %57)
  %59 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %60

60:                                               ; preds = %56, %76
  %61 = phi i32 [ %59, %56 ], [ %34, %76 ]
  %62 = add nuw nsw i32 %35, 1
  %63 = icmp slt i32 %62, %61
  br i1 %63, label %33, label %100, !llvm.loop !328

64:                                               ; preds = %53, %64
  %65 = phi i64 [ %74, %64 ], [ %54, %53 ]
  %66 = phi i32 [ %73, %64 ], [ %55, %53 ]
  %67 = getelementptr inbounds i32, ptr %0, i64 %65
  %68 = load i32, ptr %67, align 4, !tbaa !9
  %69 = or i32 %68, %2
  %70 = or i32 %69, %3
  %71 = or i32 %70, %4
  %72 = or i32 %71, %5
  %73 = add nsw i32 %72, %66
  %74 = add nuw nsw i64 %65, 1
  %75 = icmp eq i64 %74, %19
  br i1 %75, label %76, label %64, !llvm.loop !329

76:                                               ; preds = %64, %50
  %77 = phi i32 [ %52, %50 ], [ %73, %64 ]
  %78 = load double, ptr @init_value, align 8, !tbaa !28
  %79 = fptosi double %78 to i32
  %80 = or i32 %15, %79
  %81 = mul nsw i32 %80, 8000
  %82 = icmp eq i32 %81, %77
  br i1 %82, label %60, label %56

83:                                               ; preds = %16, %95
  %84 = phi i32 [ %96, %95 ], [ %9, %16 ]
  %85 = phi double [ %97, %95 ], [ %17, %16 ]
  %86 = phi i32 [ %98, %95 ], [ 0, %16 ]
  %87 = fptosi double %85 to i32
  %88 = or i32 %15, %87
  %89 = icmp eq i32 %88, 0
  br i1 %89, label %95, label %90

90:                                               ; preds = %83
  %91 = load i32, ptr @current_test, align 4, !tbaa !9
  %92 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %91)
  %93 = load double, ptr @init_value, align 8, !tbaa !28
  %94 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %95

95:                                               ; preds = %83, %90
  %96 = phi i32 [ %84, %83 ], [ %94, %90 ]
  %97 = phi double [ %85, %83 ], [ %93, %90 ]
  %98 = add nuw nsw i32 %86, 1
  %99 = icmp slt i32 %98, %96
  br i1 %99, label %83, label %100, !llvm.loop !328

100:                                              ; preds = %95, %60, %7
  %101 = tail call i64 @clock() #17
  store i64 %101, ptr @end_time, align 8, !tbaa !26
  %102 = load i64, ptr @start_time, align 8, !tbaa !26
  %103 = load ptr, ptr @results, align 8, !tbaa !5
  %104 = icmp eq ptr %103, null
  br i1 %104, label %105, label %107

105:                                              ; preds = %100
  %106 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %111

107:                                              ; preds = %100
  %108 = load i32, ptr @current_test, align 4, !tbaa !9
  %109 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %110 = icmp slt i32 %108, %109
  br i1 %110, label %123, label %111

111:                                              ; preds = %107, %105
  %112 = phi i32 [ %106, %105 ], [ %109, %107 ]
  %113 = add nsw i32 %112, 10
  store i32 %113, ptr @allocated_results, align 4, !tbaa !9
  %114 = sext i32 %113 to i64
  %115 = shl nsw i64 %114, 4
  %116 = tail call ptr @realloc(ptr noundef %103, i64 noundef %115) #14
  store ptr %116, ptr @results, align 8, !tbaa !5
  %117 = icmp eq ptr %116, null
  br i1 %117, label %120, label %118

118:                                              ; preds = %111
  %119 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %123

120:                                              ; preds = %111
  %121 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %122 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %121)
  tail call void @exit(i32 noundef -1) #15
  unreachable

123:                                              ; preds = %107, %118
  %124 = phi i32 [ %119, %118 ], [ %108, %107 ]
  %125 = phi ptr [ %116, %118 ], [ %103, %107 ]
  %126 = sub nsw i64 %101, %102
  %127 = sitofp i64 %126 to double
  %128 = fdiv double %127, 1.000000e+06
  %129 = sext i32 %124 to i64
  %130 = getelementptr inbounds %struct.one_result, ptr %125, i64 %129
  store double %128, ptr %130, align 8, !tbaa !11
  %131 = getelementptr inbounds %struct.one_result, ptr %125, i64 %129, i32 1
  store ptr %6, ptr %131, align 8, !tbaa !14
  %132 = add nsw i32 %124, 1
  store i32 %132, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1Ii19custom_variable_xorIiEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i32 noundef %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !26
  %6 = load i32, ptr @iterations, align 4, !tbaa !9
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %84

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  br i1 %9, label %12, label %10

10:                                               ; preds = %8
  %11 = load double, ptr @init_value, align 8, !tbaa !28
  br label %68

12:                                               ; preds = %8
  %13 = zext i32 %1 to i64
  %14 = icmp ult i32 %1, 8
  %15 = and i64 %13, 4294967288
  %16 = insertelement <4 x i32> poison, i32 %2, i64 0
  %17 = shufflevector <4 x i32> %16, <4 x i32> poison, <4 x i32> zeroinitializer
  %18 = insertelement <4 x i32> poison, i32 %2, i64 0
  %19 = shufflevector <4 x i32> %18, <4 x i32> poison, <4 x i32> zeroinitializer
  %20 = icmp eq i64 %15, %13
  br label %21

21:                                               ; preds = %12, %48
  %22 = phi i32 [ %49, %48 ], [ %6, %12 ]
  %23 = phi i32 [ %50, %48 ], [ 0, %12 ]
  br i1 %14, label %41, label %24

24:                                               ; preds = %21, %24
  %25 = phi i64 [ %36, %24 ], [ 0, %21 ]
  %26 = phi <4 x i32> [ %34, %24 ], [ zeroinitializer, %21 ]
  %27 = phi <4 x i32> [ %35, %24 ], [ zeroinitializer, %21 ]
  %28 = getelementptr inbounds i32, ptr %0, i64 %25
  %29 = load <4 x i32>, ptr %28, align 4, !tbaa !9
  %30 = getelementptr inbounds i32, ptr %28, i64 4
  %31 = load <4 x i32>, ptr %30, align 4, !tbaa !9
  %32 = xor <4 x i32> %29, %17
  %33 = xor <4 x i32> %31, %19
  %34 = add <4 x i32> %32, %26
  %35 = add <4 x i32> %33, %27
  %36 = add nuw i64 %25, 8
  %37 = icmp eq i64 %36, %15
  br i1 %37, label %38, label %24, !llvm.loop !330

38:                                               ; preds = %24
  %39 = add <4 x i32> %35, %34
  %40 = tail call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %39)
  br i1 %20, label %61, label %41

41:                                               ; preds = %21, %38
  %42 = phi i64 [ 0, %21 ], [ %15, %38 ]
  %43 = phi i32 [ 0, %21 ], [ %40, %38 ]
  br label %52

44:                                               ; preds = %61
  %45 = load i32, ptr @current_test, align 4, !tbaa !9
  %46 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %45)
  %47 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %48

48:                                               ; preds = %44, %61
  %49 = phi i32 [ %47, %44 ], [ %22, %61 ]
  %50 = add nuw nsw i32 %23, 1
  %51 = icmp slt i32 %50, %49
  br i1 %51, label %21, label %84, !llvm.loop !331

52:                                               ; preds = %41, %52
  %53 = phi i64 [ %59, %52 ], [ %42, %41 ]
  %54 = phi i32 [ %58, %52 ], [ %43, %41 ]
  %55 = getelementptr inbounds i32, ptr %0, i64 %53
  %56 = load i32, ptr %55, align 4, !tbaa !9
  %57 = xor i32 %56, %2
  %58 = add nsw i32 %57, %54
  %59 = add nuw nsw i64 %53, 1
  %60 = icmp eq i64 %59, %13
  br i1 %60, label %61, label %52, !llvm.loop !332

61:                                               ; preds = %52, %38
  %62 = phi i32 [ %40, %38 ], [ %58, %52 ]
  %63 = load double, ptr @init_value, align 8, !tbaa !28
  %64 = fptosi double %63 to i32
  %65 = xor i32 %64, %2
  %66 = mul nsw i32 %65, 8000
  %67 = icmp eq i32 %66, %62
  br i1 %67, label %48, label %44

68:                                               ; preds = %10, %79
  %69 = phi i32 [ %80, %79 ], [ %6, %10 ]
  %70 = phi double [ %81, %79 ], [ %11, %10 ]
  %71 = phi i32 [ %82, %79 ], [ 0, %10 ]
  %72 = fptosi double %70 to i32
  %73 = icmp eq i32 %72, %2
  br i1 %73, label %79, label %74

74:                                               ; preds = %68
  %75 = load i32, ptr @current_test, align 4, !tbaa !9
  %76 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %75)
  %77 = load double, ptr @init_value, align 8, !tbaa !28
  %78 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %79

79:                                               ; preds = %68, %74
  %80 = phi i32 [ %69, %68 ], [ %78, %74 ]
  %81 = phi double [ %70, %68 ], [ %77, %74 ]
  %82 = add nuw nsw i32 %71, 1
  %83 = icmp slt i32 %82, %80
  br i1 %83, label %68, label %84, !llvm.loop !331

84:                                               ; preds = %79, %48, %4
  %85 = tail call i64 @clock() #17
  store i64 %85, ptr @end_time, align 8, !tbaa !26
  %86 = load i64, ptr @start_time, align 8, !tbaa !26
  %87 = load ptr, ptr @results, align 8, !tbaa !5
  %88 = icmp eq ptr %87, null
  br i1 %88, label %89, label %91

89:                                               ; preds = %84
  %90 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %95

91:                                               ; preds = %84
  %92 = load i32, ptr @current_test, align 4, !tbaa !9
  %93 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %94 = icmp slt i32 %92, %93
  br i1 %94, label %107, label %95

95:                                               ; preds = %91, %89
  %96 = phi i32 [ %90, %89 ], [ %93, %91 ]
  %97 = add nsw i32 %96, 10
  store i32 %97, ptr @allocated_results, align 4, !tbaa !9
  %98 = sext i32 %97 to i64
  %99 = shl nsw i64 %98, 4
  %100 = tail call ptr @realloc(ptr noundef %87, i64 noundef %99) #14
  store ptr %100, ptr @results, align 8, !tbaa !5
  %101 = icmp eq ptr %100, null
  br i1 %101, label %104, label %102

102:                                              ; preds = %95
  %103 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %107

104:                                              ; preds = %95
  %105 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %106 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %105)
  tail call void @exit(i32 noundef -1) #15
  unreachable

107:                                              ; preds = %91, %102
  %108 = phi i32 [ %103, %102 ], [ %92, %91 ]
  %109 = phi ptr [ %100, %102 ], [ %87, %91 ]
  %110 = sub nsw i64 %85, %86
  %111 = sitofp i64 %110 to double
  %112 = fdiv double %111, 1.000000e+06
  %113 = sext i32 %108 to i64
  %114 = getelementptr inbounds %struct.one_result, ptr %109, i64 %113
  store double %112, ptr %114, align 8, !tbaa !11
  %115 = getelementptr inbounds %struct.one_result, ptr %109, i64 %113, i32 1
  store ptr %3, ptr %115, align 8, !tbaa !14
  %116 = add nsw i32 %108, 1
  store i32 %116, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Ii28custom_multiple_variable_xorIiEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3, i32 noundef %4, i32 noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !26
  %9 = load i32, ptr @iterations, align 4, !tbaa !9
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %99

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  %13 = xor i32 %3, %2
  %14 = xor i32 %13, %4
  %15 = xor i32 %14, %5
  br i1 %12, label %18, label %16

16:                                               ; preds = %11
  %17 = load double, ptr @init_value, align 8, !tbaa !28
  br label %83

18:                                               ; preds = %11
  %19 = zext i32 %1 to i64
  %20 = icmp ult i32 %1, 8
  %21 = and i64 %19, 4294967288
  %22 = xor i32 %3, %2
  %23 = xor i32 %3, %2
  %24 = xor i32 %22, %4
  %25 = xor i32 %23, %4
  %26 = xor i32 %24, %5
  %27 = insertelement <4 x i32> poison, i32 %26, i64 0
  %28 = shufflevector <4 x i32> %27, <4 x i32> poison, <4 x i32> zeroinitializer
  %29 = xor i32 %25, %5
  %30 = insertelement <4 x i32> poison, i32 %29, i64 0
  %31 = shufflevector <4 x i32> %30, <4 x i32> poison, <4 x i32> zeroinitializer
  %32 = icmp eq i64 %21, %19
  br label %33

33:                                               ; preds = %18, %60
  %34 = phi i32 [ %61, %60 ], [ %9, %18 ]
  %35 = phi i32 [ %62, %60 ], [ 0, %18 ]
  br i1 %20, label %53, label %36

36:                                               ; preds = %33, %36
  %37 = phi i64 [ %48, %36 ], [ 0, %33 ]
  %38 = phi <4 x i32> [ %46, %36 ], [ zeroinitializer, %33 ]
  %39 = phi <4 x i32> [ %47, %36 ], [ zeroinitializer, %33 ]
  %40 = getelementptr inbounds i32, ptr %0, i64 %37
  %41 = load <4 x i32>, ptr %40, align 4, !tbaa !9
  %42 = getelementptr inbounds i32, ptr %40, i64 4
  %43 = load <4 x i32>, ptr %42, align 4, !tbaa !9
  %44 = xor <4 x i32> %28, %41
  %45 = xor <4 x i32> %31, %43
  %46 = add <4 x i32> %44, %38
  %47 = add <4 x i32> %45, %39
  %48 = add nuw i64 %37, 8
  %49 = icmp eq i64 %48, %21
  br i1 %49, label %50, label %36, !llvm.loop !333

50:                                               ; preds = %36
  %51 = add <4 x i32> %47, %46
  %52 = tail call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %51)
  br i1 %32, label %76, label %53

53:                                               ; preds = %33, %50
  %54 = phi i64 [ 0, %33 ], [ %21, %50 ]
  %55 = phi i32 [ 0, %33 ], [ %52, %50 ]
  br label %64

56:                                               ; preds = %76
  %57 = load i32, ptr @current_test, align 4, !tbaa !9
  %58 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %57)
  %59 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %60

60:                                               ; preds = %56, %76
  %61 = phi i32 [ %59, %56 ], [ %34, %76 ]
  %62 = add nuw nsw i32 %35, 1
  %63 = icmp slt i32 %62, %61
  br i1 %63, label %33, label %99, !llvm.loop !334

64:                                               ; preds = %53, %64
  %65 = phi i64 [ %74, %64 ], [ %54, %53 ]
  %66 = phi i32 [ %73, %64 ], [ %55, %53 ]
  %67 = getelementptr inbounds i32, ptr %0, i64 %65
  %68 = load i32, ptr %67, align 4, !tbaa !9
  %69 = xor i32 %68, %2
  %70 = xor i32 %69, %3
  %71 = xor i32 %70, %4
  %72 = xor i32 %71, %5
  %73 = add nsw i32 %72, %66
  %74 = add nuw nsw i64 %65, 1
  %75 = icmp eq i64 %74, %19
  br i1 %75, label %76, label %64, !llvm.loop !335

76:                                               ; preds = %64, %50
  %77 = phi i32 [ %52, %50 ], [ %73, %64 ]
  %78 = load double, ptr @init_value, align 8, !tbaa !28
  %79 = fptosi double %78 to i32
  %80 = xor i32 %15, %79
  %81 = mul nsw i32 %80, 8000
  %82 = icmp eq i32 %81, %77
  br i1 %82, label %60, label %56

83:                                               ; preds = %16, %94
  %84 = phi i32 [ %95, %94 ], [ %9, %16 ]
  %85 = phi double [ %96, %94 ], [ %17, %16 ]
  %86 = phi i32 [ %97, %94 ], [ 0, %16 ]
  %87 = fptosi double %85 to i32
  %88 = icmp eq i32 %15, %87
  br i1 %88, label %94, label %89

89:                                               ; preds = %83
  %90 = load i32, ptr @current_test, align 4, !tbaa !9
  %91 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %90)
  %92 = load double, ptr @init_value, align 8, !tbaa !28
  %93 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %94

94:                                               ; preds = %83, %89
  %95 = phi i32 [ %84, %83 ], [ %93, %89 ]
  %96 = phi double [ %85, %83 ], [ %92, %89 ]
  %97 = add nuw nsw i32 %86, 1
  %98 = icmp slt i32 %97, %95
  br i1 %98, label %83, label %99, !llvm.loop !334

99:                                               ; preds = %94, %60, %7
  %100 = tail call i64 @clock() #17
  store i64 %100, ptr @end_time, align 8, !tbaa !26
  %101 = load i64, ptr @start_time, align 8, !tbaa !26
  %102 = load ptr, ptr @results, align 8, !tbaa !5
  %103 = icmp eq ptr %102, null
  br i1 %103, label %104, label %106

104:                                              ; preds = %99
  %105 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %110

106:                                              ; preds = %99
  %107 = load i32, ptr @current_test, align 4, !tbaa !9
  %108 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %109 = icmp slt i32 %107, %108
  br i1 %109, label %122, label %110

110:                                              ; preds = %106, %104
  %111 = phi i32 [ %105, %104 ], [ %108, %106 ]
  %112 = add nsw i32 %111, 10
  store i32 %112, ptr @allocated_results, align 4, !tbaa !9
  %113 = sext i32 %112 to i64
  %114 = shl nsw i64 %113, 4
  %115 = tail call ptr @realloc(ptr noundef %102, i64 noundef %114) #14
  store ptr %115, ptr @results, align 8, !tbaa !5
  %116 = icmp eq ptr %115, null
  br i1 %116, label %119, label %117

117:                                              ; preds = %110
  %118 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %122

119:                                              ; preds = %110
  %120 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %121 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %120)
  tail call void @exit(i32 noundef -1) #15
  unreachable

122:                                              ; preds = %106, %117
  %123 = phi i32 [ %118, %117 ], [ %107, %106 ]
  %124 = phi ptr [ %115, %117 ], [ %102, %106 ]
  %125 = sub nsw i64 %100, %101
  %126 = sitofp i64 %125 to double
  %127 = fdiv double %126, 1.000000e+06
  %128 = sext i32 %123 to i64
  %129 = getelementptr inbounds %struct.one_result, ptr %124, i64 %128
  store double %127, ptr %129, align 8, !tbaa !11
  %130 = getelementptr inbounds %struct.one_result, ptr %124, i64 %128, i32 1
  store ptr %6, ptr %130, align 8, !tbaa !14
  %131 = add nsw i32 %123, 1
  store i32 %131, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1Ij19custom_add_variableIjEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i32 noundef %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !26
  %6 = load i32, ptr @iterations, align 4, !tbaa !9
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %86

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  br i1 %9, label %12, label %10

10:                                               ; preds = %8
  %11 = load double, ptr @init_value, align 8, !tbaa !28
  br label %68

12:                                               ; preds = %8
  %13 = zext i32 %1 to i64
  %14 = icmp ult i32 %1, 8
  %15 = and i64 %13, 4294967288
  %16 = insertelement <4 x i32> poison, i32 %2, i64 0
  %17 = shufflevector <4 x i32> %16, <4 x i32> poison, <4 x i32> zeroinitializer
  %18 = insertelement <4 x i32> poison, i32 %2, i64 0
  %19 = shufflevector <4 x i32> %18, <4 x i32> poison, <4 x i32> zeroinitializer
  %20 = icmp eq i64 %15, %13
  br label %21

21:                                               ; preds = %12, %48
  %22 = phi i32 [ %49, %48 ], [ %6, %12 ]
  %23 = phi i32 [ %50, %48 ], [ 0, %12 ]
  br i1 %14, label %41, label %24

24:                                               ; preds = %21, %24
  %25 = phi i64 [ %36, %24 ], [ 0, %21 ]
  %26 = phi <4 x i32> [ %34, %24 ], [ zeroinitializer, %21 ]
  %27 = phi <4 x i32> [ %35, %24 ], [ zeroinitializer, %21 ]
  %28 = getelementptr inbounds i32, ptr %0, i64 %25
  %29 = load <4 x i32>, ptr %28, align 4, !tbaa !9
  %30 = getelementptr inbounds i32, ptr %28, i64 4
  %31 = load <4 x i32>, ptr %30, align 4, !tbaa !9
  %32 = add <4 x i32> %26, %17
  %33 = add <4 x i32> %27, %19
  %34 = add <4 x i32> %32, %29
  %35 = add <4 x i32> %33, %31
  %36 = add nuw i64 %25, 8
  %37 = icmp eq i64 %36, %15
  br i1 %37, label %38, label %24, !llvm.loop !336

38:                                               ; preds = %24
  %39 = add <4 x i32> %35, %34
  %40 = tail call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %39)
  br i1 %20, label %61, label %41

41:                                               ; preds = %21, %38
  %42 = phi i64 [ 0, %21 ], [ %15, %38 ]
  %43 = phi i32 [ 0, %21 ], [ %40, %38 ]
  br label %52

44:                                               ; preds = %61
  %45 = load i32, ptr @current_test, align 4, !tbaa !9
  %46 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %45)
  %47 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %48

48:                                               ; preds = %44, %61
  %49 = phi i32 [ %47, %44 ], [ %22, %61 ]
  %50 = add nuw nsw i32 %23, 1
  %51 = icmp slt i32 %50, %49
  br i1 %51, label %21, label %86, !llvm.loop !337

52:                                               ; preds = %41, %52
  %53 = phi i64 [ %59, %52 ], [ %42, %41 ]
  %54 = phi i32 [ %58, %52 ], [ %43, %41 ]
  %55 = getelementptr inbounds i32, ptr %0, i64 %53
  %56 = load i32, ptr %55, align 4, !tbaa !9
  %57 = add i32 %54, %2
  %58 = add i32 %57, %56
  %59 = add nuw nsw i64 %53, 1
  %60 = icmp eq i64 %59, %13
  br i1 %60, label %61, label %52, !llvm.loop !338

61:                                               ; preds = %52, %38
  %62 = phi i32 [ %40, %38 ], [ %58, %52 ]
  %63 = load double, ptr @init_value, align 8, !tbaa !28
  %64 = fptoui double %63 to i32
  %65 = add i32 %64, %2
  %66 = mul i32 %65, 8000
  %67 = icmp eq i32 %66, %62
  br i1 %67, label %48, label %44

68:                                               ; preds = %10, %81
  %69 = phi i32 [ %82, %81 ], [ %6, %10 ]
  %70 = phi double [ %83, %81 ], [ %11, %10 ]
  %71 = phi i32 [ %84, %81 ], [ 0, %10 ]
  %72 = fptoui double %70 to i32
  %73 = add i32 %72, %2
  %74 = mul i32 %73, 8000
  %75 = icmp eq i32 %74, 0
  br i1 %75, label %81, label %76

76:                                               ; preds = %68
  %77 = load i32, ptr @current_test, align 4, !tbaa !9
  %78 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %77)
  %79 = load double, ptr @init_value, align 8, !tbaa !28
  %80 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %81

81:                                               ; preds = %68, %76
  %82 = phi i32 [ %69, %68 ], [ %80, %76 ]
  %83 = phi double [ %70, %68 ], [ %79, %76 ]
  %84 = add nuw nsw i32 %71, 1
  %85 = icmp slt i32 %84, %82
  br i1 %85, label %68, label %86, !llvm.loop !337

86:                                               ; preds = %81, %48, %4
  %87 = tail call i64 @clock() #17
  store i64 %87, ptr @end_time, align 8, !tbaa !26
  %88 = load i64, ptr @start_time, align 8, !tbaa !26
  %89 = load ptr, ptr @results, align 8, !tbaa !5
  %90 = icmp eq ptr %89, null
  br i1 %90, label %91, label %93

91:                                               ; preds = %86
  %92 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %97

93:                                               ; preds = %86
  %94 = load i32, ptr @current_test, align 4, !tbaa !9
  %95 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %96 = icmp slt i32 %94, %95
  br i1 %96, label %109, label %97

97:                                               ; preds = %93, %91
  %98 = phi i32 [ %92, %91 ], [ %95, %93 ]
  %99 = add nsw i32 %98, 10
  store i32 %99, ptr @allocated_results, align 4, !tbaa !9
  %100 = sext i32 %99 to i64
  %101 = shl nsw i64 %100, 4
  %102 = tail call ptr @realloc(ptr noundef %89, i64 noundef %101) #14
  store ptr %102, ptr @results, align 8, !tbaa !5
  %103 = icmp eq ptr %102, null
  br i1 %103, label %106, label %104

104:                                              ; preds = %97
  %105 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %109

106:                                              ; preds = %97
  %107 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %108 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %107)
  tail call void @exit(i32 noundef -1) #15
  unreachable

109:                                              ; preds = %93, %104
  %110 = phi i32 [ %105, %104 ], [ %94, %93 ]
  %111 = phi ptr [ %102, %104 ], [ %89, %93 ]
  %112 = sub nsw i64 %87, %88
  %113 = sitofp i64 %112 to double
  %114 = fdiv double %113, 1.000000e+06
  %115 = sext i32 %110 to i64
  %116 = getelementptr inbounds %struct.one_result, ptr %111, i64 %115
  store double %114, ptr %116, align 8, !tbaa !11
  %117 = getelementptr inbounds %struct.one_result, ptr %111, i64 %115, i32 1
  store ptr %3, ptr %117, align 8, !tbaa !14
  %118 = add nsw i32 %110, 1
  store i32 %118, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z22test_hoisted_variable1Ij19custom_add_variableIjEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i32 noundef %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !26
  %6 = load i32, ptr @iterations, align 4, !tbaa !9
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %81

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  %10 = mul i32 %2, %1
  br i1 %9, label %13, label %11

11:                                               ; preds = %8
  %12 = load double, ptr @init_value, align 8, !tbaa !28
  br label %63

13:                                               ; preds = %8
  %14 = zext i32 %1 to i64
  %15 = icmp ult i32 %1, 8
  %16 = and i64 %14, 4294967288
  %17 = icmp eq i64 %16, %14
  br label %18

18:                                               ; preds = %13, %43
  %19 = phi i32 [ %44, %43 ], [ %6, %13 ]
  %20 = phi i32 [ %45, %43 ], [ 0, %13 ]
  br i1 %15, label %36, label %21

21:                                               ; preds = %18, %21
  %22 = phi i64 [ %31, %21 ], [ 0, %18 ]
  %23 = phi <4 x i32> [ %29, %21 ], [ zeroinitializer, %18 ]
  %24 = phi <4 x i32> [ %30, %21 ], [ zeroinitializer, %18 ]
  %25 = getelementptr inbounds i32, ptr %0, i64 %22
  %26 = load <4 x i32>, ptr %25, align 4, !tbaa !9
  %27 = getelementptr inbounds i32, ptr %25, i64 4
  %28 = load <4 x i32>, ptr %27, align 4, !tbaa !9
  %29 = add <4 x i32> %26, %23
  %30 = add <4 x i32> %28, %24
  %31 = add nuw i64 %22, 8
  %32 = icmp eq i64 %31, %16
  br i1 %32, label %33, label %21, !llvm.loop !339

33:                                               ; preds = %21
  %34 = add <4 x i32> %30, %29
  %35 = tail call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %34)
  br i1 %17, label %55, label %36

36:                                               ; preds = %18, %33
  %37 = phi i64 [ 0, %18 ], [ %16, %33 ]
  %38 = phi i32 [ 0, %18 ], [ %35, %33 ]
  br label %47

39:                                               ; preds = %55
  %40 = load i32, ptr @current_test, align 4, !tbaa !9
  %41 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %40)
  %42 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %43

43:                                               ; preds = %39, %55
  %44 = phi i32 [ %42, %39 ], [ %19, %55 ]
  %45 = add nuw nsw i32 %20, 1
  %46 = icmp slt i32 %45, %44
  br i1 %46, label %18, label %81, !llvm.loop !340

47:                                               ; preds = %36, %47
  %48 = phi i64 [ %53, %47 ], [ %37, %36 ]
  %49 = phi i32 [ %52, %47 ], [ %38, %36 ]
  %50 = getelementptr inbounds i32, ptr %0, i64 %48
  %51 = load i32, ptr %50, align 4, !tbaa !9
  %52 = add i32 %51, %49
  %53 = add nuw nsw i64 %48, 1
  %54 = icmp eq i64 %53, %14
  br i1 %54, label %55, label %47, !llvm.loop !341

55:                                               ; preds = %47, %33
  %56 = phi i32 [ %35, %33 ], [ %52, %47 ]
  %57 = add i32 %56, %10
  %58 = load double, ptr @init_value, align 8, !tbaa !28
  %59 = fptoui double %58 to i32
  %60 = add i32 %59, %2
  %61 = mul i32 %60, 8000
  %62 = icmp eq i32 %61, %57
  br i1 %62, label %43, label %39

63:                                               ; preds = %11, %76
  %64 = phi i32 [ %77, %76 ], [ %6, %11 ]
  %65 = phi double [ %78, %76 ], [ %12, %11 ]
  %66 = phi i32 [ %79, %76 ], [ 0, %11 ]
  %67 = fptoui double %65 to i32
  %68 = add i32 %67, %2
  %69 = mul i32 %68, 8000
  %70 = icmp eq i32 %69, %10
  br i1 %70, label %76, label %71

71:                                               ; preds = %63
  %72 = load i32, ptr @current_test, align 4, !tbaa !9
  %73 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %72)
  %74 = load double, ptr @init_value, align 8, !tbaa !28
  %75 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %76

76:                                               ; preds = %63, %71
  %77 = phi i32 [ %64, %63 ], [ %75, %71 ]
  %78 = phi double [ %65, %63 ], [ %74, %71 ]
  %79 = add nuw nsw i32 %66, 1
  %80 = icmp slt i32 %79, %77
  br i1 %80, label %63, label %81, !llvm.loop !340

81:                                               ; preds = %76, %43, %4
  %82 = tail call i64 @clock() #17
  store i64 %82, ptr @end_time, align 8, !tbaa !26
  %83 = load i64, ptr @start_time, align 8, !tbaa !26
  %84 = load ptr, ptr @results, align 8, !tbaa !5
  %85 = icmp eq ptr %84, null
  br i1 %85, label %86, label %88

86:                                               ; preds = %81
  %87 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %92

88:                                               ; preds = %81
  %89 = load i32, ptr @current_test, align 4, !tbaa !9
  %90 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %91 = icmp slt i32 %89, %90
  br i1 %91, label %104, label %92

92:                                               ; preds = %88, %86
  %93 = phi i32 [ %87, %86 ], [ %90, %88 ]
  %94 = add nsw i32 %93, 10
  store i32 %94, ptr @allocated_results, align 4, !tbaa !9
  %95 = sext i32 %94 to i64
  %96 = shl nsw i64 %95, 4
  %97 = tail call ptr @realloc(ptr noundef %84, i64 noundef %96) #14
  store ptr %97, ptr @results, align 8, !tbaa !5
  %98 = icmp eq ptr %97, null
  br i1 %98, label %101, label %99

99:                                               ; preds = %92
  %100 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %104

101:                                              ; preds = %92
  %102 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %103 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %102)
  tail call void @exit(i32 noundef -1) #15
  unreachable

104:                                              ; preds = %88, %99
  %105 = phi i32 [ %100, %99 ], [ %89, %88 ]
  %106 = phi ptr [ %97, %99 ], [ %84, %88 ]
  %107 = sub nsw i64 %82, %83
  %108 = sitofp i64 %107 to double
  %109 = fdiv double %108, 1.000000e+06
  %110 = sext i32 %105 to i64
  %111 = getelementptr inbounds %struct.one_result, ptr %106, i64 %110
  store double %109, ptr %111, align 8, !tbaa !11
  %112 = getelementptr inbounds %struct.one_result, ptr %106, i64 %110, i32 1
  store ptr %3, ptr %112, align 8, !tbaa !14
  %113 = add nsw i32 %105, 1
  store i32 %113, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Ij28custom_add_multiple_variableIjEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3, i32 noundef %4, i32 noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !26
  %9 = load i32, ptr @iterations, align 4, !tbaa !9
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %92

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  %13 = add i32 %3, %2
  %14 = add i32 %13, %4
  %15 = add i32 %14, %5
  br i1 %12, label %18, label %16

16:                                               ; preds = %11
  %17 = load double, ptr @init_value, align 8, !tbaa !28
  br label %74

18:                                               ; preds = %11
  %19 = zext i32 %1 to i64
  %20 = icmp ult i32 %1, 8
  %21 = and i64 %19, 4294967288
  %22 = insertelement <4 x i32> poison, i32 %15, i64 0
  %23 = shufflevector <4 x i32> %22, <4 x i32> poison, <4 x i32> zeroinitializer
  %24 = insertelement <4 x i32> poison, i32 %15, i64 0
  %25 = shufflevector <4 x i32> %24, <4 x i32> poison, <4 x i32> zeroinitializer
  %26 = icmp eq i64 %21, %19
  br label %27

27:                                               ; preds = %18, %54
  %28 = phi i32 [ %55, %54 ], [ %9, %18 ]
  %29 = phi i32 [ %56, %54 ], [ 0, %18 ]
  br i1 %20, label %47, label %30

30:                                               ; preds = %27, %30
  %31 = phi i64 [ %42, %30 ], [ 0, %27 ]
  %32 = phi <4 x i32> [ %40, %30 ], [ zeroinitializer, %27 ]
  %33 = phi <4 x i32> [ %41, %30 ], [ zeroinitializer, %27 ]
  %34 = getelementptr inbounds i32, ptr %0, i64 %31
  %35 = load <4 x i32>, ptr %34, align 4, !tbaa !9
  %36 = getelementptr inbounds i32, ptr %34, i64 4
  %37 = load <4 x i32>, ptr %36, align 4, !tbaa !9
  %38 = add <4 x i32> %23, %32
  %39 = add <4 x i32> %25, %33
  %40 = add <4 x i32> %38, %35
  %41 = add <4 x i32> %39, %37
  %42 = add nuw i64 %31, 8
  %43 = icmp eq i64 %42, %21
  br i1 %43, label %44, label %30, !llvm.loop !342

44:                                               ; preds = %30
  %45 = add <4 x i32> %41, %40
  %46 = tail call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %45)
  br i1 %26, label %67, label %47

47:                                               ; preds = %27, %44
  %48 = phi i64 [ 0, %27 ], [ %21, %44 ]
  %49 = phi i32 [ 0, %27 ], [ %46, %44 ]
  br label %58

50:                                               ; preds = %67
  %51 = load i32, ptr @current_test, align 4, !tbaa !9
  %52 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %51)
  %53 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %54

54:                                               ; preds = %50, %67
  %55 = phi i32 [ %53, %50 ], [ %28, %67 ]
  %56 = add nuw nsw i32 %29, 1
  %57 = icmp slt i32 %56, %55
  br i1 %57, label %27, label %92, !llvm.loop !343

58:                                               ; preds = %47, %58
  %59 = phi i64 [ %65, %58 ], [ %48, %47 ]
  %60 = phi i32 [ %64, %58 ], [ %49, %47 ]
  %61 = getelementptr inbounds i32, ptr %0, i64 %59
  %62 = load i32, ptr %61, align 4, !tbaa !9
  %63 = add i32 %15, %60
  %64 = add i32 %63, %62
  %65 = add nuw nsw i64 %59, 1
  %66 = icmp eq i64 %65, %19
  br i1 %66, label %67, label %58, !llvm.loop !344

67:                                               ; preds = %58, %44
  %68 = phi i32 [ %46, %44 ], [ %64, %58 ]
  %69 = load double, ptr @init_value, align 8, !tbaa !28
  %70 = fptoui double %69 to i32
  %71 = add i32 %15, %70
  %72 = mul i32 %71, 8000
  %73 = icmp eq i32 %72, %68
  br i1 %73, label %54, label %50

74:                                               ; preds = %16, %87
  %75 = phi i32 [ %88, %87 ], [ %9, %16 ]
  %76 = phi double [ %89, %87 ], [ %17, %16 ]
  %77 = phi i32 [ %90, %87 ], [ 0, %16 ]
  %78 = fptoui double %76 to i32
  %79 = add i32 %15, %78
  %80 = mul i32 %79, 8000
  %81 = icmp eq i32 %80, 0
  br i1 %81, label %87, label %82

82:                                               ; preds = %74
  %83 = load i32, ptr @current_test, align 4, !tbaa !9
  %84 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %83)
  %85 = load double, ptr @init_value, align 8, !tbaa !28
  %86 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %87

87:                                               ; preds = %74, %82
  %88 = phi i32 [ %75, %74 ], [ %86, %82 ]
  %89 = phi double [ %76, %74 ], [ %85, %82 ]
  %90 = add nuw nsw i32 %77, 1
  %91 = icmp slt i32 %90, %88
  br i1 %91, label %74, label %92, !llvm.loop !343

92:                                               ; preds = %87, %54, %7
  %93 = tail call i64 @clock() #17
  store i64 %93, ptr @end_time, align 8, !tbaa !26
  %94 = load i64, ptr @start_time, align 8, !tbaa !26
  %95 = load ptr, ptr @results, align 8, !tbaa !5
  %96 = icmp eq ptr %95, null
  br i1 %96, label %97, label %99

97:                                               ; preds = %92
  %98 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %103

99:                                               ; preds = %92
  %100 = load i32, ptr @current_test, align 4, !tbaa !9
  %101 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %102 = icmp slt i32 %100, %101
  br i1 %102, label %115, label %103

103:                                              ; preds = %99, %97
  %104 = phi i32 [ %98, %97 ], [ %101, %99 ]
  %105 = add nsw i32 %104, 10
  store i32 %105, ptr @allocated_results, align 4, !tbaa !9
  %106 = sext i32 %105 to i64
  %107 = shl nsw i64 %106, 4
  %108 = tail call ptr @realloc(ptr noundef %95, i64 noundef %107) #14
  store ptr %108, ptr @results, align 8, !tbaa !5
  %109 = icmp eq ptr %108, null
  br i1 %109, label %112, label %110

110:                                              ; preds = %103
  %111 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %115

112:                                              ; preds = %103
  %113 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %114 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %113)
  tail call void @exit(i32 noundef -1) #15
  unreachable

115:                                              ; preds = %99, %110
  %116 = phi i32 [ %111, %110 ], [ %100, %99 ]
  %117 = phi ptr [ %108, %110 ], [ %95, %99 ]
  %118 = sub nsw i64 %93, %94
  %119 = sitofp i64 %118 to double
  %120 = fdiv double %119, 1.000000e+06
  %121 = sext i32 %116 to i64
  %122 = getelementptr inbounds %struct.one_result, ptr %117, i64 %121
  store double %120, ptr %122, align 8, !tbaa !11
  %123 = getelementptr inbounds %struct.one_result, ptr %117, i64 %121, i32 1
  store ptr %6, ptr %123, align 8, !tbaa !14
  %124 = add nsw i32 %116, 1
  store i32 %124, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1Ij19custom_sub_variableIjEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i32 noundef %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !26
  %6 = load i32, ptr @iterations, align 4, !tbaa !9
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %86

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  br i1 %9, label %12, label %10

10:                                               ; preds = %8
  %11 = load double, ptr @init_value, align 8, !tbaa !28
  br label %68

12:                                               ; preds = %8
  %13 = zext i32 %1 to i64
  %14 = icmp ult i32 %1, 8
  %15 = and i64 %13, 4294967288
  %16 = insertelement <4 x i32> poison, i32 %2, i64 0
  %17 = shufflevector <4 x i32> %16, <4 x i32> poison, <4 x i32> zeroinitializer
  %18 = insertelement <4 x i32> poison, i32 %2, i64 0
  %19 = shufflevector <4 x i32> %18, <4 x i32> poison, <4 x i32> zeroinitializer
  %20 = icmp eq i64 %15, %13
  br label %21

21:                                               ; preds = %12, %48
  %22 = phi i32 [ %49, %48 ], [ %6, %12 ]
  %23 = phi i32 [ %50, %48 ], [ 0, %12 ]
  br i1 %14, label %41, label %24

24:                                               ; preds = %21, %24
  %25 = phi i64 [ %36, %24 ], [ 0, %21 ]
  %26 = phi <4 x i32> [ %34, %24 ], [ zeroinitializer, %21 ]
  %27 = phi <4 x i32> [ %35, %24 ], [ zeroinitializer, %21 ]
  %28 = getelementptr inbounds i32, ptr %0, i64 %25
  %29 = load <4 x i32>, ptr %28, align 4, !tbaa !9
  %30 = getelementptr inbounds i32, ptr %28, i64 4
  %31 = load <4 x i32>, ptr %30, align 4, !tbaa !9
  %32 = sub <4 x i32> %26, %17
  %33 = sub <4 x i32> %27, %19
  %34 = add <4 x i32> %32, %29
  %35 = add <4 x i32> %33, %31
  %36 = add nuw i64 %25, 8
  %37 = icmp eq i64 %36, %15
  br i1 %37, label %38, label %24, !llvm.loop !345

38:                                               ; preds = %24
  %39 = add <4 x i32> %35, %34
  %40 = tail call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %39)
  br i1 %20, label %61, label %41

41:                                               ; preds = %21, %38
  %42 = phi i64 [ 0, %21 ], [ %15, %38 ]
  %43 = phi i32 [ 0, %21 ], [ %40, %38 ]
  br label %52

44:                                               ; preds = %61
  %45 = load i32, ptr @current_test, align 4, !tbaa !9
  %46 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %45)
  %47 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %48

48:                                               ; preds = %44, %61
  %49 = phi i32 [ %47, %44 ], [ %22, %61 ]
  %50 = add nuw nsw i32 %23, 1
  %51 = icmp slt i32 %50, %49
  br i1 %51, label %21, label %86, !llvm.loop !346

52:                                               ; preds = %41, %52
  %53 = phi i64 [ %59, %52 ], [ %42, %41 ]
  %54 = phi i32 [ %58, %52 ], [ %43, %41 ]
  %55 = getelementptr inbounds i32, ptr %0, i64 %53
  %56 = load i32, ptr %55, align 4, !tbaa !9
  %57 = sub i32 %54, %2
  %58 = add i32 %57, %56
  %59 = add nuw nsw i64 %53, 1
  %60 = icmp eq i64 %59, %13
  br i1 %60, label %61, label %52, !llvm.loop !347

61:                                               ; preds = %52, %38
  %62 = phi i32 [ %40, %38 ], [ %58, %52 ]
  %63 = load double, ptr @init_value, align 8, !tbaa !28
  %64 = fptoui double %63 to i32
  %65 = sub i32 %64, %2
  %66 = mul i32 %65, 8000
  %67 = icmp eq i32 %66, %62
  br i1 %67, label %48, label %44

68:                                               ; preds = %10, %81
  %69 = phi i32 [ %82, %81 ], [ %6, %10 ]
  %70 = phi double [ %83, %81 ], [ %11, %10 ]
  %71 = phi i32 [ %84, %81 ], [ 0, %10 ]
  %72 = fptoui double %70 to i32
  %73 = sub i32 %72, %2
  %74 = mul i32 %73, 8000
  %75 = icmp eq i32 %74, 0
  br i1 %75, label %81, label %76

76:                                               ; preds = %68
  %77 = load i32, ptr @current_test, align 4, !tbaa !9
  %78 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %77)
  %79 = load double, ptr @init_value, align 8, !tbaa !28
  %80 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %81

81:                                               ; preds = %68, %76
  %82 = phi i32 [ %69, %68 ], [ %80, %76 ]
  %83 = phi double [ %70, %68 ], [ %79, %76 ]
  %84 = add nuw nsw i32 %71, 1
  %85 = icmp slt i32 %84, %82
  br i1 %85, label %68, label %86, !llvm.loop !346

86:                                               ; preds = %81, %48, %4
  %87 = tail call i64 @clock() #17
  store i64 %87, ptr @end_time, align 8, !tbaa !26
  %88 = load i64, ptr @start_time, align 8, !tbaa !26
  %89 = load ptr, ptr @results, align 8, !tbaa !5
  %90 = icmp eq ptr %89, null
  br i1 %90, label %91, label %93

91:                                               ; preds = %86
  %92 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %97

93:                                               ; preds = %86
  %94 = load i32, ptr @current_test, align 4, !tbaa !9
  %95 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %96 = icmp slt i32 %94, %95
  br i1 %96, label %109, label %97

97:                                               ; preds = %93, %91
  %98 = phi i32 [ %92, %91 ], [ %95, %93 ]
  %99 = add nsw i32 %98, 10
  store i32 %99, ptr @allocated_results, align 4, !tbaa !9
  %100 = sext i32 %99 to i64
  %101 = shl nsw i64 %100, 4
  %102 = tail call ptr @realloc(ptr noundef %89, i64 noundef %101) #14
  store ptr %102, ptr @results, align 8, !tbaa !5
  %103 = icmp eq ptr %102, null
  br i1 %103, label %106, label %104

104:                                              ; preds = %97
  %105 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %109

106:                                              ; preds = %97
  %107 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %108 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %107)
  tail call void @exit(i32 noundef -1) #15
  unreachable

109:                                              ; preds = %93, %104
  %110 = phi i32 [ %105, %104 ], [ %94, %93 ]
  %111 = phi ptr [ %102, %104 ], [ %89, %93 ]
  %112 = sub nsw i64 %87, %88
  %113 = sitofp i64 %112 to double
  %114 = fdiv double %113, 1.000000e+06
  %115 = sext i32 %110 to i64
  %116 = getelementptr inbounds %struct.one_result, ptr %111, i64 %115
  store double %114, ptr %116, align 8, !tbaa !11
  %117 = getelementptr inbounds %struct.one_result, ptr %111, i64 %115, i32 1
  store ptr %3, ptr %117, align 8, !tbaa !14
  %118 = add nsw i32 %110, 1
  store i32 %118, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Ij28custom_sub_multiple_variableIjEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3, i32 noundef %4, i32 noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !26
  %9 = load i32, ptr @iterations, align 4, !tbaa !9
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %92

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  %13 = add i32 %3, %2
  %14 = add i32 %13, %4
  %15 = add i32 %14, %5
  br i1 %12, label %18, label %16

16:                                               ; preds = %11
  %17 = load double, ptr @init_value, align 8, !tbaa !28
  br label %74

18:                                               ; preds = %11
  %19 = zext i32 %1 to i64
  %20 = icmp ult i32 %1, 8
  %21 = and i64 %19, 4294967288
  %22 = insertelement <4 x i32> poison, i32 %15, i64 0
  %23 = shufflevector <4 x i32> %22, <4 x i32> poison, <4 x i32> zeroinitializer
  %24 = insertelement <4 x i32> poison, i32 %15, i64 0
  %25 = shufflevector <4 x i32> %24, <4 x i32> poison, <4 x i32> zeroinitializer
  %26 = icmp eq i64 %21, %19
  br label %27

27:                                               ; preds = %18, %54
  %28 = phi i32 [ %55, %54 ], [ %9, %18 ]
  %29 = phi i32 [ %56, %54 ], [ 0, %18 ]
  br i1 %20, label %47, label %30

30:                                               ; preds = %27, %30
  %31 = phi i64 [ %42, %30 ], [ 0, %27 ]
  %32 = phi <4 x i32> [ %40, %30 ], [ zeroinitializer, %27 ]
  %33 = phi <4 x i32> [ %41, %30 ], [ zeroinitializer, %27 ]
  %34 = getelementptr inbounds i32, ptr %0, i64 %31
  %35 = load <4 x i32>, ptr %34, align 4, !tbaa !9
  %36 = getelementptr inbounds i32, ptr %34, i64 4
  %37 = load <4 x i32>, ptr %36, align 4, !tbaa !9
  %38 = sub <4 x i32> %32, %23
  %39 = sub <4 x i32> %33, %25
  %40 = add <4 x i32> %38, %35
  %41 = add <4 x i32> %39, %37
  %42 = add nuw i64 %31, 8
  %43 = icmp eq i64 %42, %21
  br i1 %43, label %44, label %30, !llvm.loop !348

44:                                               ; preds = %30
  %45 = add <4 x i32> %41, %40
  %46 = tail call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %45)
  br i1 %26, label %67, label %47

47:                                               ; preds = %27, %44
  %48 = phi i64 [ 0, %27 ], [ %21, %44 ]
  %49 = phi i32 [ 0, %27 ], [ %46, %44 ]
  br label %58

50:                                               ; preds = %67
  %51 = load i32, ptr @current_test, align 4, !tbaa !9
  %52 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %51)
  %53 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %54

54:                                               ; preds = %50, %67
  %55 = phi i32 [ %53, %50 ], [ %28, %67 ]
  %56 = add nuw nsw i32 %29, 1
  %57 = icmp slt i32 %56, %55
  br i1 %57, label %27, label %92, !llvm.loop !349

58:                                               ; preds = %47, %58
  %59 = phi i64 [ %65, %58 ], [ %48, %47 ]
  %60 = phi i32 [ %64, %58 ], [ %49, %47 ]
  %61 = getelementptr inbounds i32, ptr %0, i64 %59
  %62 = load i32, ptr %61, align 4, !tbaa !9
  %63 = sub i32 %60, %15
  %64 = add i32 %63, %62
  %65 = add nuw nsw i64 %59, 1
  %66 = icmp eq i64 %65, %19
  br i1 %66, label %67, label %58, !llvm.loop !350

67:                                               ; preds = %58, %44
  %68 = phi i32 [ %46, %44 ], [ %64, %58 ]
  %69 = load double, ptr @init_value, align 8, !tbaa !28
  %70 = fptoui double %69 to i32
  %71 = sub i32 %70, %15
  %72 = mul i32 %71, 8000
  %73 = icmp eq i32 %72, %68
  br i1 %73, label %54, label %50

74:                                               ; preds = %16, %87
  %75 = phi i32 [ %88, %87 ], [ %9, %16 ]
  %76 = phi double [ %89, %87 ], [ %17, %16 ]
  %77 = phi i32 [ %90, %87 ], [ 0, %16 ]
  %78 = fptoui double %76 to i32
  %79 = sub i32 %78, %15
  %80 = mul i32 %79, 8000
  %81 = icmp eq i32 %80, 0
  br i1 %81, label %87, label %82

82:                                               ; preds = %74
  %83 = load i32, ptr @current_test, align 4, !tbaa !9
  %84 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %83)
  %85 = load double, ptr @init_value, align 8, !tbaa !28
  %86 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %87

87:                                               ; preds = %74, %82
  %88 = phi i32 [ %75, %74 ], [ %86, %82 ]
  %89 = phi double [ %76, %74 ], [ %85, %82 ]
  %90 = add nuw nsw i32 %77, 1
  %91 = icmp slt i32 %90, %88
  br i1 %91, label %74, label %92, !llvm.loop !349

92:                                               ; preds = %87, %54, %7
  %93 = tail call i64 @clock() #17
  store i64 %93, ptr @end_time, align 8, !tbaa !26
  %94 = load i64, ptr @start_time, align 8, !tbaa !26
  %95 = load ptr, ptr @results, align 8, !tbaa !5
  %96 = icmp eq ptr %95, null
  br i1 %96, label %97, label %99

97:                                               ; preds = %92
  %98 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %103

99:                                               ; preds = %92
  %100 = load i32, ptr @current_test, align 4, !tbaa !9
  %101 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %102 = icmp slt i32 %100, %101
  br i1 %102, label %115, label %103

103:                                              ; preds = %99, %97
  %104 = phi i32 [ %98, %97 ], [ %101, %99 ]
  %105 = add nsw i32 %104, 10
  store i32 %105, ptr @allocated_results, align 4, !tbaa !9
  %106 = sext i32 %105 to i64
  %107 = shl nsw i64 %106, 4
  %108 = tail call ptr @realloc(ptr noundef %95, i64 noundef %107) #14
  store ptr %108, ptr @results, align 8, !tbaa !5
  %109 = icmp eq ptr %108, null
  br i1 %109, label %112, label %110

110:                                              ; preds = %103
  %111 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %115

112:                                              ; preds = %103
  %113 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %114 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %113)
  tail call void @exit(i32 noundef -1) #15
  unreachable

115:                                              ; preds = %99, %110
  %116 = phi i32 [ %111, %110 ], [ %100, %99 ]
  %117 = phi ptr [ %108, %110 ], [ %95, %99 ]
  %118 = sub nsw i64 %93, %94
  %119 = sitofp i64 %118 to double
  %120 = fdiv double %119, 1.000000e+06
  %121 = sext i32 %116 to i64
  %122 = getelementptr inbounds %struct.one_result, ptr %117, i64 %121
  store double %120, ptr %122, align 8, !tbaa !11
  %123 = getelementptr inbounds %struct.one_result, ptr %117, i64 %121, i32 1
  store ptr %6, ptr %123, align 8, !tbaa !14
  %124 = add nsw i32 %116, 1
  store i32 %124, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1Ij24custom_multiply_variableIjEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i32 noundef %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !26
  %6 = load i32, ptr @iterations, align 4, !tbaa !9
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %85

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  %10 = mul i32 %2, 8000
  br i1 %9, label %13, label %11

11:                                               ; preds = %8
  %12 = load double, ptr @init_value, align 8, !tbaa !28
  br label %68

13:                                               ; preds = %8
  %14 = zext i32 %1 to i64
  %15 = icmp ult i32 %1, 8
  %16 = and i64 %14, 4294967288
  %17 = insertelement <4 x i32> poison, i32 %2, i64 0
  %18 = shufflevector <4 x i32> %17, <4 x i32> poison, <4 x i32> zeroinitializer
  %19 = insertelement <4 x i32> poison, i32 %2, i64 0
  %20 = shufflevector <4 x i32> %19, <4 x i32> poison, <4 x i32> zeroinitializer
  %21 = icmp eq i64 %16, %14
  br label %22

22:                                               ; preds = %13, %49
  %23 = phi i32 [ %50, %49 ], [ %6, %13 ]
  %24 = phi i32 [ %51, %49 ], [ 0, %13 ]
  br i1 %15, label %42, label %25

25:                                               ; preds = %22, %25
  %26 = phi i64 [ %37, %25 ], [ 0, %22 ]
  %27 = phi <4 x i32> [ %35, %25 ], [ zeroinitializer, %22 ]
  %28 = phi <4 x i32> [ %36, %25 ], [ zeroinitializer, %22 ]
  %29 = getelementptr inbounds i32, ptr %0, i64 %26
  %30 = load <4 x i32>, ptr %29, align 4, !tbaa !9
  %31 = getelementptr inbounds i32, ptr %29, i64 4
  %32 = load <4 x i32>, ptr %31, align 4, !tbaa !9
  %33 = mul <4 x i32> %30, %18
  %34 = mul <4 x i32> %32, %20
  %35 = add <4 x i32> %33, %27
  %36 = add <4 x i32> %34, %28
  %37 = add nuw i64 %26, 8
  %38 = icmp eq i64 %37, %16
  br i1 %38, label %39, label %25, !llvm.loop !351

39:                                               ; preds = %25
  %40 = add <4 x i32> %36, %35
  %41 = tail call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %40)
  br i1 %21, label %62, label %42

42:                                               ; preds = %22, %39
  %43 = phi i64 [ 0, %22 ], [ %16, %39 ]
  %44 = phi i32 [ 0, %22 ], [ %41, %39 ]
  br label %53

45:                                               ; preds = %62
  %46 = load i32, ptr @current_test, align 4, !tbaa !9
  %47 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %46)
  %48 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %49

49:                                               ; preds = %45, %62
  %50 = phi i32 [ %48, %45 ], [ %23, %62 ]
  %51 = add nuw nsw i32 %24, 1
  %52 = icmp slt i32 %51, %50
  br i1 %52, label %22, label %85, !llvm.loop !352

53:                                               ; preds = %42, %53
  %54 = phi i64 [ %60, %53 ], [ %43, %42 ]
  %55 = phi i32 [ %59, %53 ], [ %44, %42 ]
  %56 = getelementptr inbounds i32, ptr %0, i64 %54
  %57 = load i32, ptr %56, align 4, !tbaa !9
  %58 = mul i32 %57, %2
  %59 = add i32 %58, %55
  %60 = add nuw nsw i64 %54, 1
  %61 = icmp eq i64 %60, %14
  br i1 %61, label %62, label %53, !llvm.loop !353

62:                                               ; preds = %53, %39
  %63 = phi i32 [ %41, %39 ], [ %59, %53 ]
  %64 = load double, ptr @init_value, align 8, !tbaa !28
  %65 = fptoui double %64 to i32
  %66 = mul i32 %10, %65
  %67 = icmp eq i32 %66, %63
  br i1 %67, label %49, label %45

68:                                               ; preds = %11, %80
  %69 = phi i32 [ %81, %80 ], [ %6, %11 ]
  %70 = phi double [ %82, %80 ], [ %12, %11 ]
  %71 = phi i32 [ %83, %80 ], [ 0, %11 ]
  %72 = fptoui double %70 to i32
  %73 = mul i32 %10, %72
  %74 = icmp eq i32 %73, 0
  br i1 %74, label %80, label %75

75:                                               ; preds = %68
  %76 = load i32, ptr @current_test, align 4, !tbaa !9
  %77 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %76)
  %78 = load double, ptr @init_value, align 8, !tbaa !28
  %79 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %80

80:                                               ; preds = %68, %75
  %81 = phi i32 [ %69, %68 ], [ %79, %75 ]
  %82 = phi double [ %70, %68 ], [ %78, %75 ]
  %83 = add nuw nsw i32 %71, 1
  %84 = icmp slt i32 %83, %81
  br i1 %84, label %68, label %85, !llvm.loop !352

85:                                               ; preds = %80, %49, %4
  %86 = tail call i64 @clock() #17
  store i64 %86, ptr @end_time, align 8, !tbaa !26
  %87 = load i64, ptr @start_time, align 8, !tbaa !26
  %88 = load ptr, ptr @results, align 8, !tbaa !5
  %89 = icmp eq ptr %88, null
  br i1 %89, label %90, label %92

90:                                               ; preds = %85
  %91 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %96

92:                                               ; preds = %85
  %93 = load i32, ptr @current_test, align 4, !tbaa !9
  %94 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %95 = icmp slt i32 %93, %94
  br i1 %95, label %108, label %96

96:                                               ; preds = %92, %90
  %97 = phi i32 [ %91, %90 ], [ %94, %92 ]
  %98 = add nsw i32 %97, 10
  store i32 %98, ptr @allocated_results, align 4, !tbaa !9
  %99 = sext i32 %98 to i64
  %100 = shl nsw i64 %99, 4
  %101 = tail call ptr @realloc(ptr noundef %88, i64 noundef %100) #14
  store ptr %101, ptr @results, align 8, !tbaa !5
  %102 = icmp eq ptr %101, null
  br i1 %102, label %105, label %103

103:                                              ; preds = %96
  %104 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %108

105:                                              ; preds = %96
  %106 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %107 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %106)
  tail call void @exit(i32 noundef -1) #15
  unreachable

108:                                              ; preds = %92, %103
  %109 = phi i32 [ %104, %103 ], [ %93, %92 ]
  %110 = phi ptr [ %101, %103 ], [ %88, %92 ]
  %111 = sub nsw i64 %86, %87
  %112 = sitofp i64 %111 to double
  %113 = fdiv double %112, 1.000000e+06
  %114 = sext i32 %109 to i64
  %115 = getelementptr inbounds %struct.one_result, ptr %110, i64 %114
  store double %113, ptr %115, align 8, !tbaa !11
  %116 = getelementptr inbounds %struct.one_result, ptr %110, i64 %114, i32 1
  store ptr %3, ptr %116, align 8, !tbaa !14
  %117 = add nsw i32 %109, 1
  store i32 %117, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Ij33custom_multiply_multiple_variableIjEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3, i32 noundef %4, i32 noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !26
  %9 = load i32, ptr @iterations, align 4, !tbaa !9
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %93

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  %13 = mul i32 %3, %2
  %14 = mul i32 %13, %4
  %15 = mul i32 %14, %5
  %16 = mul i32 %13, 8000
  %17 = mul i32 %16, %4
  %18 = mul i32 %17, %5
  br i1 %12, label %21, label %19

19:                                               ; preds = %11
  %20 = load double, ptr @init_value, align 8, !tbaa !28
  br label %76

21:                                               ; preds = %11
  %22 = zext i32 %1 to i64
  %23 = icmp ult i32 %1, 8
  %24 = and i64 %22, 4294967288
  %25 = insertelement <4 x i32> poison, i32 %15, i64 0
  %26 = shufflevector <4 x i32> %25, <4 x i32> poison, <4 x i32> zeroinitializer
  %27 = insertelement <4 x i32> poison, i32 %15, i64 0
  %28 = shufflevector <4 x i32> %27, <4 x i32> poison, <4 x i32> zeroinitializer
  %29 = icmp eq i64 %24, %22
  br label %30

30:                                               ; preds = %21, %57
  %31 = phi i32 [ %58, %57 ], [ %9, %21 ]
  %32 = phi i32 [ %59, %57 ], [ 0, %21 ]
  br i1 %23, label %50, label %33

33:                                               ; preds = %30, %33
  %34 = phi i64 [ %45, %33 ], [ 0, %30 ]
  %35 = phi <4 x i32> [ %43, %33 ], [ zeroinitializer, %30 ]
  %36 = phi <4 x i32> [ %44, %33 ], [ zeroinitializer, %30 ]
  %37 = getelementptr inbounds i32, ptr %0, i64 %34
  %38 = load <4 x i32>, ptr %37, align 4, !tbaa !9
  %39 = getelementptr inbounds i32, ptr %37, i64 4
  %40 = load <4 x i32>, ptr %39, align 4, !tbaa !9
  %41 = mul <4 x i32> %26, %38
  %42 = mul <4 x i32> %28, %40
  %43 = add <4 x i32> %41, %35
  %44 = add <4 x i32> %42, %36
  %45 = add nuw i64 %34, 8
  %46 = icmp eq i64 %45, %24
  br i1 %46, label %47, label %33, !llvm.loop !354

47:                                               ; preds = %33
  %48 = add <4 x i32> %44, %43
  %49 = tail call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %48)
  br i1 %29, label %70, label %50

50:                                               ; preds = %30, %47
  %51 = phi i64 [ 0, %30 ], [ %24, %47 ]
  %52 = phi i32 [ 0, %30 ], [ %49, %47 ]
  br label %61

53:                                               ; preds = %70
  %54 = load i32, ptr @current_test, align 4, !tbaa !9
  %55 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %54)
  %56 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %57

57:                                               ; preds = %53, %70
  %58 = phi i32 [ %56, %53 ], [ %31, %70 ]
  %59 = add nuw nsw i32 %32, 1
  %60 = icmp slt i32 %59, %58
  br i1 %60, label %30, label %93, !llvm.loop !355

61:                                               ; preds = %50, %61
  %62 = phi i64 [ %68, %61 ], [ %51, %50 ]
  %63 = phi i32 [ %67, %61 ], [ %52, %50 ]
  %64 = getelementptr inbounds i32, ptr %0, i64 %62
  %65 = load i32, ptr %64, align 4, !tbaa !9
  %66 = mul i32 %15, %65
  %67 = add i32 %66, %63
  %68 = add nuw nsw i64 %62, 1
  %69 = icmp eq i64 %68, %22
  br i1 %69, label %70, label %61, !llvm.loop !356

70:                                               ; preds = %61, %47
  %71 = phi i32 [ %49, %47 ], [ %67, %61 ]
  %72 = load double, ptr @init_value, align 8, !tbaa !28
  %73 = fptoui double %72 to i32
  %74 = mul i32 %18, %73
  %75 = icmp eq i32 %74, %71
  br i1 %75, label %57, label %53

76:                                               ; preds = %19, %88
  %77 = phi i32 [ %89, %88 ], [ %9, %19 ]
  %78 = phi double [ %90, %88 ], [ %20, %19 ]
  %79 = phi i32 [ %91, %88 ], [ 0, %19 ]
  %80 = fptoui double %78 to i32
  %81 = mul i32 %18, %80
  %82 = icmp eq i32 %81, 0
  br i1 %82, label %88, label %83

83:                                               ; preds = %76
  %84 = load i32, ptr @current_test, align 4, !tbaa !9
  %85 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %84)
  %86 = load double, ptr @init_value, align 8, !tbaa !28
  %87 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %88

88:                                               ; preds = %76, %83
  %89 = phi i32 [ %77, %76 ], [ %87, %83 ]
  %90 = phi double [ %78, %76 ], [ %86, %83 ]
  %91 = add nuw nsw i32 %79, 1
  %92 = icmp slt i32 %91, %89
  br i1 %92, label %76, label %93, !llvm.loop !355

93:                                               ; preds = %88, %57, %7
  %94 = tail call i64 @clock() #17
  store i64 %94, ptr @end_time, align 8, !tbaa !26
  %95 = load i64, ptr @start_time, align 8, !tbaa !26
  %96 = load ptr, ptr @results, align 8, !tbaa !5
  %97 = icmp eq ptr %96, null
  br i1 %97, label %98, label %100

98:                                               ; preds = %93
  %99 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %104

100:                                              ; preds = %93
  %101 = load i32, ptr @current_test, align 4, !tbaa !9
  %102 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %103 = icmp slt i32 %101, %102
  br i1 %103, label %116, label %104

104:                                              ; preds = %100, %98
  %105 = phi i32 [ %99, %98 ], [ %102, %100 ]
  %106 = add nsw i32 %105, 10
  store i32 %106, ptr @allocated_results, align 4, !tbaa !9
  %107 = sext i32 %106 to i64
  %108 = shl nsw i64 %107, 4
  %109 = tail call ptr @realloc(ptr noundef %96, i64 noundef %108) #14
  store ptr %109, ptr @results, align 8, !tbaa !5
  %110 = icmp eq ptr %109, null
  br i1 %110, label %113, label %111

111:                                              ; preds = %104
  %112 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %116

113:                                              ; preds = %104
  %114 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %115 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %114)
  tail call void @exit(i32 noundef -1) #15
  unreachable

116:                                              ; preds = %100, %111
  %117 = phi i32 [ %112, %111 ], [ %101, %100 ]
  %118 = phi ptr [ %109, %111 ], [ %96, %100 ]
  %119 = sub nsw i64 %94, %95
  %120 = sitofp i64 %119 to double
  %121 = fdiv double %120, 1.000000e+06
  %122 = sext i32 %117 to i64
  %123 = getelementptr inbounds %struct.one_result, ptr %118, i64 %122
  store double %121, ptr %123, align 8, !tbaa !11
  %124 = getelementptr inbounds %struct.one_result, ptr %118, i64 %122, i32 1
  store ptr %6, ptr %124, align 8, !tbaa !14
  %125 = add nsw i32 %117, 1
  store i32 %125, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Ij34custom_multiply_multiple_variable2IjEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3, i32 noundef %4, i32 noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !26
  %9 = load i32, ptr @iterations, align 4, !tbaa !9
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %92

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  %13 = mul i32 %3, %2
  %14 = mul i32 %13, %4
  %15 = mul i32 %14, %5
  br i1 %12, label %18, label %16

16:                                               ; preds = %11
  %17 = load double, ptr @init_value, align 8, !tbaa !28
  br label %74

18:                                               ; preds = %11
  %19 = zext i32 %1 to i64
  %20 = icmp ult i32 %1, 8
  %21 = and i64 %19, 4294967288
  %22 = insertelement <4 x i32> poison, i32 %15, i64 0
  %23 = shufflevector <4 x i32> %22, <4 x i32> poison, <4 x i32> zeroinitializer
  %24 = insertelement <4 x i32> poison, i32 %15, i64 0
  %25 = shufflevector <4 x i32> %24, <4 x i32> poison, <4 x i32> zeroinitializer
  %26 = icmp eq i64 %21, %19
  br label %27

27:                                               ; preds = %18, %54
  %28 = phi i32 [ %55, %54 ], [ %9, %18 ]
  %29 = phi i32 [ %56, %54 ], [ 0, %18 ]
  br i1 %20, label %47, label %30

30:                                               ; preds = %27, %30
  %31 = phi i64 [ %42, %30 ], [ 0, %27 ]
  %32 = phi <4 x i32> [ %40, %30 ], [ zeroinitializer, %27 ]
  %33 = phi <4 x i32> [ %41, %30 ], [ zeroinitializer, %27 ]
  %34 = getelementptr inbounds i32, ptr %0, i64 %31
  %35 = load <4 x i32>, ptr %34, align 4, !tbaa !9
  %36 = getelementptr inbounds i32, ptr %34, i64 4
  %37 = load <4 x i32>, ptr %36, align 4, !tbaa !9
  %38 = add <4 x i32> %32, %23
  %39 = add <4 x i32> %33, %25
  %40 = add <4 x i32> %38, %35
  %41 = add <4 x i32> %39, %37
  %42 = add nuw i64 %31, 8
  %43 = icmp eq i64 %42, %21
  br i1 %43, label %44, label %30, !llvm.loop !357

44:                                               ; preds = %30
  %45 = add <4 x i32> %41, %40
  %46 = tail call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %45)
  br i1 %26, label %67, label %47

47:                                               ; preds = %27, %44
  %48 = phi i64 [ 0, %27 ], [ %21, %44 ]
  %49 = phi i32 [ 0, %27 ], [ %46, %44 ]
  br label %58

50:                                               ; preds = %67
  %51 = load i32, ptr @current_test, align 4, !tbaa !9
  %52 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %51)
  %53 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %54

54:                                               ; preds = %50, %67
  %55 = phi i32 [ %53, %50 ], [ %28, %67 ]
  %56 = add nuw nsw i32 %29, 1
  %57 = icmp slt i32 %56, %55
  br i1 %57, label %27, label %92, !llvm.loop !358

58:                                               ; preds = %47, %58
  %59 = phi i64 [ %65, %58 ], [ %48, %47 ]
  %60 = phi i32 [ %64, %58 ], [ %49, %47 ]
  %61 = getelementptr inbounds i32, ptr %0, i64 %59
  %62 = load i32, ptr %61, align 4, !tbaa !9
  %63 = add i32 %60, %15
  %64 = add i32 %63, %62
  %65 = add nuw nsw i64 %59, 1
  %66 = icmp eq i64 %65, %19
  br i1 %66, label %67, label %58, !llvm.loop !359

67:                                               ; preds = %58, %44
  %68 = phi i32 [ %46, %44 ], [ %64, %58 ]
  %69 = load double, ptr @init_value, align 8, !tbaa !28
  %70 = fptoui double %69 to i32
  %71 = add i32 %15, %70
  %72 = mul i32 %71, 8000
  %73 = icmp eq i32 %72, %68
  br i1 %73, label %54, label %50

74:                                               ; preds = %16, %87
  %75 = phi i32 [ %88, %87 ], [ %9, %16 ]
  %76 = phi double [ %89, %87 ], [ %17, %16 ]
  %77 = phi i32 [ %90, %87 ], [ 0, %16 ]
  %78 = fptoui double %76 to i32
  %79 = add i32 %15, %78
  %80 = mul i32 %79, 8000
  %81 = icmp eq i32 %80, 0
  br i1 %81, label %87, label %82

82:                                               ; preds = %74
  %83 = load i32, ptr @current_test, align 4, !tbaa !9
  %84 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %83)
  %85 = load double, ptr @init_value, align 8, !tbaa !28
  %86 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %87

87:                                               ; preds = %74, %82
  %88 = phi i32 [ %75, %74 ], [ %86, %82 ]
  %89 = phi double [ %76, %74 ], [ %85, %82 ]
  %90 = add nuw nsw i32 %77, 1
  %91 = icmp slt i32 %90, %88
  br i1 %91, label %74, label %92, !llvm.loop !358

92:                                               ; preds = %87, %54, %7
  %93 = tail call i64 @clock() #17
  store i64 %93, ptr @end_time, align 8, !tbaa !26
  %94 = load i64, ptr @start_time, align 8, !tbaa !26
  %95 = load ptr, ptr @results, align 8, !tbaa !5
  %96 = icmp eq ptr %95, null
  br i1 %96, label %97, label %99

97:                                               ; preds = %92
  %98 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %103

99:                                               ; preds = %92
  %100 = load i32, ptr @current_test, align 4, !tbaa !9
  %101 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %102 = icmp slt i32 %100, %101
  br i1 %102, label %115, label %103

103:                                              ; preds = %99, %97
  %104 = phi i32 [ %98, %97 ], [ %101, %99 ]
  %105 = add nsw i32 %104, 10
  store i32 %105, ptr @allocated_results, align 4, !tbaa !9
  %106 = sext i32 %105 to i64
  %107 = shl nsw i64 %106, 4
  %108 = tail call ptr @realloc(ptr noundef %95, i64 noundef %107) #14
  store ptr %108, ptr @results, align 8, !tbaa !5
  %109 = icmp eq ptr %108, null
  br i1 %109, label %112, label %110

110:                                              ; preds = %103
  %111 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %115

112:                                              ; preds = %103
  %113 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %114 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %113)
  tail call void @exit(i32 noundef -1) #15
  unreachable

115:                                              ; preds = %99, %110
  %116 = phi i32 [ %111, %110 ], [ %100, %99 ]
  %117 = phi ptr [ %108, %110 ], [ %95, %99 ]
  %118 = sub nsw i64 %93, %94
  %119 = sitofp i64 %118 to double
  %120 = fdiv double %119, 1.000000e+06
  %121 = sext i32 %116 to i64
  %122 = getelementptr inbounds %struct.one_result, ptr %117, i64 %121
  store double %120, ptr %122, align 8, !tbaa !11
  %123 = getelementptr inbounds %struct.one_result, ptr %117, i64 %121, i32 1
  store ptr %6, ptr %123, align 8, !tbaa !14
  %124 = add nsw i32 %116, 1
  store i32 %124, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1Ij22custom_divide_variableIjEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i32 noundef %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !26
  %6 = load i32, ptr @iterations, align 4, !tbaa !9
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %79

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  br i1 %9, label %12, label %10

10:                                               ; preds = %8
  %11 = load double, ptr @init_value, align 8, !tbaa !28
  br label %61

12:                                               ; preds = %8
  %13 = zext i32 %1 to i64
  %14 = and i64 %13, 1
  %15 = icmp eq i32 %1, 1
  %16 = and i64 %13, 4294967294
  %17 = icmp eq i64 %14, 0
  br label %18

18:                                               ; preds = %12, %25
  %19 = phi i32 [ %26, %25 ], [ %6, %12 ]
  %20 = phi i32 [ %27, %25 ], [ 0, %12 ]
  br i1 %15, label %45, label %29

21:                                               ; preds = %54
  %22 = load i32, ptr @current_test, align 4, !tbaa !9
  %23 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %22)
  %24 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %25

25:                                               ; preds = %21, %54
  %26 = phi i32 [ %24, %21 ], [ %19, %54 ]
  %27 = add nuw nsw i32 %20, 1
  %28 = icmp slt i32 %27, %26
  br i1 %28, label %18, label %79, !llvm.loop !360

29:                                               ; preds = %18, %29
  %30 = phi i64 [ %42, %29 ], [ 0, %18 ]
  %31 = phi i32 [ %41, %29 ], [ 0, %18 ]
  %32 = phi i64 [ %43, %29 ], [ 0, %18 ]
  %33 = getelementptr inbounds i32, ptr %0, i64 %30
  %34 = load i32, ptr %33, align 4, !tbaa !9
  %35 = udiv i32 %34, %2
  %36 = add i32 %35, %31
  %37 = or i64 %30, 1
  %38 = getelementptr inbounds i32, ptr %0, i64 %37
  %39 = load i32, ptr %38, align 4, !tbaa !9
  %40 = udiv i32 %39, %2
  %41 = add i32 %40, %36
  %42 = add nuw nsw i64 %30, 2
  %43 = add i64 %32, 2
  %44 = icmp eq i64 %43, %16
  br i1 %44, label %45, label %29, !llvm.loop !361

45:                                               ; preds = %29, %18
  %46 = phi i32 [ undef, %18 ], [ %41, %29 ]
  %47 = phi i64 [ 0, %18 ], [ %42, %29 ]
  %48 = phi i32 [ 0, %18 ], [ %41, %29 ]
  br i1 %17, label %54, label %49

49:                                               ; preds = %45
  %50 = getelementptr inbounds i32, ptr %0, i64 %47
  %51 = load i32, ptr %50, align 4, !tbaa !9
  %52 = udiv i32 %51, %2
  %53 = add i32 %52, %48
  br label %54

54:                                               ; preds = %45, %49
  %55 = phi i32 [ %46, %45 ], [ %53, %49 ]
  %56 = load double, ptr @init_value, align 8, !tbaa !28
  %57 = fptoui double %56 to i32
  %58 = udiv i32 %57, %2
  %59 = mul i32 %58, 8000
  %60 = icmp eq i32 %59, %55
  br i1 %60, label %25, label %21

61:                                               ; preds = %10, %74
  %62 = phi i32 [ %75, %74 ], [ %6, %10 ]
  %63 = phi double [ %76, %74 ], [ %11, %10 ]
  %64 = phi i32 [ %77, %74 ], [ 0, %10 ]
  %65 = fptoui double %63 to i32
  %66 = udiv i32 %65, %2
  %67 = mul i32 %66, 8000
  %68 = icmp eq i32 %67, 0
  br i1 %68, label %74, label %69

69:                                               ; preds = %61
  %70 = load i32, ptr @current_test, align 4, !tbaa !9
  %71 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %70)
  %72 = load double, ptr @init_value, align 8, !tbaa !28
  %73 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %74

74:                                               ; preds = %61, %69
  %75 = phi i32 [ %62, %61 ], [ %73, %69 ]
  %76 = phi double [ %63, %61 ], [ %72, %69 ]
  %77 = add nuw nsw i32 %64, 1
  %78 = icmp slt i32 %77, %75
  br i1 %78, label %61, label %79, !llvm.loop !360

79:                                               ; preds = %74, %25, %4
  %80 = tail call i64 @clock() #17
  store i64 %80, ptr @end_time, align 8, !tbaa !26
  %81 = load i64, ptr @start_time, align 8, !tbaa !26
  %82 = load ptr, ptr @results, align 8, !tbaa !5
  %83 = icmp eq ptr %82, null
  br i1 %83, label %84, label %86

84:                                               ; preds = %79
  %85 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %90

86:                                               ; preds = %79
  %87 = load i32, ptr @current_test, align 4, !tbaa !9
  %88 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %89 = icmp slt i32 %87, %88
  br i1 %89, label %102, label %90

90:                                               ; preds = %86, %84
  %91 = phi i32 [ %85, %84 ], [ %88, %86 ]
  %92 = add nsw i32 %91, 10
  store i32 %92, ptr @allocated_results, align 4, !tbaa !9
  %93 = sext i32 %92 to i64
  %94 = shl nsw i64 %93, 4
  %95 = tail call ptr @realloc(ptr noundef %82, i64 noundef %94) #14
  store ptr %95, ptr @results, align 8, !tbaa !5
  %96 = icmp eq ptr %95, null
  br i1 %96, label %99, label %97

97:                                               ; preds = %90
  %98 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %102

99:                                               ; preds = %90
  %100 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %101 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %100)
  tail call void @exit(i32 noundef -1) #15
  unreachable

102:                                              ; preds = %86, %97
  %103 = phi i32 [ %98, %97 ], [ %87, %86 ]
  %104 = phi ptr [ %95, %97 ], [ %82, %86 ]
  %105 = sub nsw i64 %80, %81
  %106 = sitofp i64 %105 to double
  %107 = fdiv double %106, 1.000000e+06
  %108 = sext i32 %103 to i64
  %109 = getelementptr inbounds %struct.one_result, ptr %104, i64 %108
  store double %107, ptr %109, align 8, !tbaa !11
  %110 = getelementptr inbounds %struct.one_result, ptr %104, i64 %108, i32 1
  store ptr %3, ptr %110, align 8, !tbaa !14
  %111 = add nsw i32 %103, 1
  store i32 %111, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Ij31custom_divide_multiple_variableIjEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3, i32 noundef %4, i32 noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !26
  %9 = load i32, ptr @iterations, align 4, !tbaa !9
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %70

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  br i1 %12, label %15, label %13

13:                                               ; preds = %11
  %14 = load double, ptr @init_value, align 8, !tbaa !28
  br label %49

15:                                               ; preds = %11
  %16 = zext i32 %1 to i64
  br label %17

17:                                               ; preds = %15, %24
  %18 = phi i32 [ %25, %24 ], [ %9, %15 ]
  %19 = phi i32 [ %26, %24 ], [ 0, %15 ]
  br label %28

20:                                               ; preds = %40
  %21 = load i32, ptr @current_test, align 4, !tbaa !9
  %22 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %21)
  %23 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %24

24:                                               ; preds = %20, %40
  %25 = phi i32 [ %23, %20 ], [ %18, %40 ]
  %26 = add nuw nsw i32 %19, 1
  %27 = icmp slt i32 %26, %25
  br i1 %27, label %17, label %70, !llvm.loop !362

28:                                               ; preds = %17, %28
  %29 = phi i64 [ 0, %17 ], [ %38, %28 ]
  %30 = phi i32 [ 0, %17 ], [ %37, %28 ]
  %31 = getelementptr inbounds i32, ptr %0, i64 %29
  %32 = load i32, ptr %31, align 4, !tbaa !9
  %33 = udiv i32 %32, %2
  %34 = udiv i32 %33, %3
  %35 = udiv i32 %34, %4
  %36 = udiv i32 %35, %5
  %37 = add i32 %36, %30
  %38 = add nuw nsw i64 %29, 1
  %39 = icmp eq i64 %38, %16
  br i1 %39, label %40, label %28, !llvm.loop !363

40:                                               ; preds = %28
  %41 = load double, ptr @init_value, align 8, !tbaa !28
  %42 = fptoui double %41 to i32
  %43 = udiv i32 %42, %2
  %44 = udiv i32 %43, %3
  %45 = udiv i32 %44, %4
  %46 = udiv i32 %45, %5
  %47 = mul i32 %46, 8000
  %48 = icmp eq i32 %47, %37
  br i1 %48, label %24, label %20

49:                                               ; preds = %13, %65
  %50 = phi i32 [ %66, %65 ], [ %9, %13 ]
  %51 = phi double [ %67, %65 ], [ %14, %13 ]
  %52 = phi i32 [ %68, %65 ], [ 0, %13 ]
  %53 = fptoui double %51 to i32
  %54 = udiv i32 %53, %2
  %55 = udiv i32 %54, %3
  %56 = udiv i32 %55, %4
  %57 = udiv i32 %56, %5
  %58 = mul i32 %57, 8000
  %59 = icmp eq i32 %58, 0
  br i1 %59, label %65, label %60

60:                                               ; preds = %49
  %61 = load i32, ptr @current_test, align 4, !tbaa !9
  %62 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %61)
  %63 = load double, ptr @init_value, align 8, !tbaa !28
  %64 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %65

65:                                               ; preds = %49, %60
  %66 = phi i32 [ %50, %49 ], [ %64, %60 ]
  %67 = phi double [ %51, %49 ], [ %63, %60 ]
  %68 = add nuw nsw i32 %52, 1
  %69 = icmp slt i32 %68, %66
  br i1 %69, label %49, label %70, !llvm.loop !362

70:                                               ; preds = %65, %24, %7
  %71 = tail call i64 @clock() #17
  store i64 %71, ptr @end_time, align 8, !tbaa !26
  %72 = load i64, ptr @start_time, align 8, !tbaa !26
  %73 = load ptr, ptr @results, align 8, !tbaa !5
  %74 = icmp eq ptr %73, null
  br i1 %74, label %75, label %77

75:                                               ; preds = %70
  %76 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %81

77:                                               ; preds = %70
  %78 = load i32, ptr @current_test, align 4, !tbaa !9
  %79 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %80 = icmp slt i32 %78, %79
  br i1 %80, label %93, label %81

81:                                               ; preds = %77, %75
  %82 = phi i32 [ %76, %75 ], [ %79, %77 ]
  %83 = add nsw i32 %82, 10
  store i32 %83, ptr @allocated_results, align 4, !tbaa !9
  %84 = sext i32 %83 to i64
  %85 = shl nsw i64 %84, 4
  %86 = tail call ptr @realloc(ptr noundef %73, i64 noundef %85) #14
  store ptr %86, ptr @results, align 8, !tbaa !5
  %87 = icmp eq ptr %86, null
  br i1 %87, label %90, label %88

88:                                               ; preds = %81
  %89 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %93

90:                                               ; preds = %81
  %91 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %92 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %91)
  tail call void @exit(i32 noundef -1) #15
  unreachable

93:                                               ; preds = %77, %88
  %94 = phi i32 [ %89, %88 ], [ %78, %77 ]
  %95 = phi ptr [ %86, %88 ], [ %73, %77 ]
  %96 = sub nsw i64 %71, %72
  %97 = sitofp i64 %96 to double
  %98 = fdiv double %97, 1.000000e+06
  %99 = sext i32 %94 to i64
  %100 = getelementptr inbounds %struct.one_result, ptr %95, i64 %99
  store double %98, ptr %100, align 8, !tbaa !11
  %101 = getelementptr inbounds %struct.one_result, ptr %95, i64 %99, i32 1
  store ptr %6, ptr %101, align 8, !tbaa !14
  %102 = add nsw i32 %94, 1
  store i32 %102, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Ij32custom_divide_multiple_variable2IjEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3, i32 noundef %4, i32 noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !26
  %9 = load i32, ptr @iterations, align 4, !tbaa !9
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %92

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  %13 = udiv i32 %2, %3
  %14 = udiv i32 %13, %4
  %15 = udiv i32 %14, %5
  br i1 %12, label %18, label %16

16:                                               ; preds = %11
  %17 = load double, ptr @init_value, align 8, !tbaa !28
  br label %74

18:                                               ; preds = %11
  %19 = zext i32 %1 to i64
  %20 = icmp ult i32 %1, 8
  %21 = and i64 %19, 4294967288
  %22 = insertelement <4 x i32> poison, i32 %15, i64 0
  %23 = shufflevector <4 x i32> %22, <4 x i32> poison, <4 x i32> zeroinitializer
  %24 = insertelement <4 x i32> poison, i32 %15, i64 0
  %25 = shufflevector <4 x i32> %24, <4 x i32> poison, <4 x i32> zeroinitializer
  %26 = icmp eq i64 %21, %19
  br label %27

27:                                               ; preds = %54, %18
  %28 = phi i32 [ %9, %18 ], [ %55, %54 ]
  %29 = phi i32 [ 0, %18 ], [ %56, %54 ]
  br i1 %20, label %47, label %30

30:                                               ; preds = %27, %30
  %31 = phi i64 [ %42, %30 ], [ 0, %27 ]
  %32 = phi <4 x i32> [ %40, %30 ], [ zeroinitializer, %27 ]
  %33 = phi <4 x i32> [ %41, %30 ], [ zeroinitializer, %27 ]
  %34 = getelementptr inbounds i32, ptr %0, i64 %31
  %35 = load <4 x i32>, ptr %34, align 4, !tbaa !9
  %36 = getelementptr inbounds i32, ptr %34, i64 4
  %37 = load <4 x i32>, ptr %36, align 4, !tbaa !9
  %38 = add <4 x i32> %35, %32
  %39 = add <4 x i32> %37, %33
  %40 = add <4 x i32> %38, %23
  %41 = add <4 x i32> %39, %25
  %42 = add nuw i64 %31, 8
  %43 = icmp eq i64 %42, %21
  br i1 %43, label %44, label %30, !llvm.loop !364

44:                                               ; preds = %30
  %45 = add <4 x i32> %41, %40
  %46 = tail call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %45)
  br i1 %26, label %67, label %47

47:                                               ; preds = %27, %44
  %48 = phi i64 [ 0, %27 ], [ %21, %44 ]
  %49 = phi i32 [ 0, %27 ], [ %46, %44 ]
  br label %58

50:                                               ; preds = %67
  %51 = load i32, ptr @current_test, align 4, !tbaa !9
  %52 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %51)
  %53 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %54

54:                                               ; preds = %50, %67
  %55 = phi i32 [ %53, %50 ], [ %28, %67 ]
  %56 = add nuw nsw i32 %29, 1
  %57 = icmp slt i32 %56, %55
  br i1 %57, label %27, label %92, !llvm.loop !365

58:                                               ; preds = %47, %58
  %59 = phi i64 [ %65, %58 ], [ %48, %47 ]
  %60 = phi i32 [ %64, %58 ], [ %49, %47 ]
  %61 = getelementptr inbounds i32, ptr %0, i64 %59
  %62 = load i32, ptr %61, align 4, !tbaa !9
  %63 = add i32 %62, %60
  %64 = add i32 %63, %15
  %65 = add nuw nsw i64 %59, 1
  %66 = icmp eq i64 %65, %19
  br i1 %66, label %67, label %58, !llvm.loop !366

67:                                               ; preds = %58, %44
  %68 = phi i32 [ %46, %44 ], [ %64, %58 ]
  %69 = load double, ptr @init_value, align 8, !tbaa !28
  %70 = fptoui double %69 to i32
  %71 = add i32 %15, %70
  %72 = mul i32 %71, 8000
  %73 = icmp eq i32 %72, %68
  br i1 %73, label %54, label %50

74:                                               ; preds = %16, %87
  %75 = phi i32 [ %88, %87 ], [ %9, %16 ]
  %76 = phi double [ %89, %87 ], [ %17, %16 ]
  %77 = phi i32 [ %90, %87 ], [ 0, %16 ]
  %78 = fptoui double %76 to i32
  %79 = add i32 %15, %78
  %80 = mul i32 %79, 8000
  %81 = icmp eq i32 %80, 0
  br i1 %81, label %87, label %82

82:                                               ; preds = %74
  %83 = load i32, ptr @current_test, align 4, !tbaa !9
  %84 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %83)
  %85 = load double, ptr @init_value, align 8, !tbaa !28
  %86 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %87

87:                                               ; preds = %74, %82
  %88 = phi i32 [ %75, %74 ], [ %86, %82 ]
  %89 = phi double [ %76, %74 ], [ %85, %82 ]
  %90 = add nuw nsw i32 %77, 1
  %91 = icmp slt i32 %90, %88
  br i1 %91, label %74, label %92, !llvm.loop !365

92:                                               ; preds = %87, %54, %7
  %93 = tail call i64 @clock() #17
  store i64 %93, ptr @end_time, align 8, !tbaa !26
  %94 = load i64, ptr @start_time, align 8, !tbaa !26
  %95 = load ptr, ptr @results, align 8, !tbaa !5
  %96 = icmp eq ptr %95, null
  br i1 %96, label %97, label %99

97:                                               ; preds = %92
  %98 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %103

99:                                               ; preds = %92
  %100 = load i32, ptr @current_test, align 4, !tbaa !9
  %101 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %102 = icmp slt i32 %100, %101
  br i1 %102, label %115, label %103

103:                                              ; preds = %99, %97
  %104 = phi i32 [ %98, %97 ], [ %101, %99 ]
  %105 = add nsw i32 %104, 10
  store i32 %105, ptr @allocated_results, align 4, !tbaa !9
  %106 = sext i32 %105 to i64
  %107 = shl nsw i64 %106, 4
  %108 = tail call ptr @realloc(ptr noundef %95, i64 noundef %107) #14
  store ptr %108, ptr @results, align 8, !tbaa !5
  %109 = icmp eq ptr %108, null
  br i1 %109, label %112, label %110

110:                                              ; preds = %103
  %111 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %115

112:                                              ; preds = %103
  %113 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %114 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %113)
  tail call void @exit(i32 noundef -1) #15
  unreachable

115:                                              ; preds = %99, %110
  %116 = phi i32 [ %111, %110 ], [ %100, %99 ]
  %117 = phi ptr [ %108, %110 ], [ %95, %99 ]
  %118 = sub nsw i64 %93, %94
  %119 = sitofp i64 %118 to double
  %120 = fdiv double %119, 1.000000e+06
  %121 = sext i32 %116 to i64
  %122 = getelementptr inbounds %struct.one_result, ptr %117, i64 %121
  store double %120, ptr %122, align 8, !tbaa !11
  %123 = getelementptr inbounds %struct.one_result, ptr %117, i64 %121, i32 1
  store ptr %6, ptr %123, align 8, !tbaa !14
  %124 = add nsw i32 %116, 1
  store i32 %124, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Ij30custom_mixed_multiple_variableIjEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3, i32 noundef %4, i32 noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !26
  %9 = load i32, ptr @iterations, align 4, !tbaa !9
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %100

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  %13 = mul i32 %4, %3
  %14 = udiv i32 %13, %5
  br i1 %12, label %17, label %15

15:                                               ; preds = %11
  %16 = load double, ptr @init_value, align 8, !tbaa !28
  br label %81

17:                                               ; preds = %11
  %18 = zext i32 %1 to i64
  %19 = icmp ult i32 %1, 8
  %20 = and i64 %18, 4294967288
  %21 = insertelement <4 x i32> poison, i32 %2, i64 0
  %22 = shufflevector <4 x i32> %21, <4 x i32> poison, <4 x i32> zeroinitializer
  %23 = insertelement <4 x i32> poison, i32 %2, i64 0
  %24 = shufflevector <4 x i32> %23, <4 x i32> poison, <4 x i32> zeroinitializer
  %25 = insertelement <4 x i32> poison, i32 %14, i64 0
  %26 = shufflevector <4 x i32> %25, <4 x i32> poison, <4 x i32> zeroinitializer
  %27 = insertelement <4 x i32> poison, i32 %14, i64 0
  %28 = shufflevector <4 x i32> %27, <4 x i32> poison, <4 x i32> zeroinitializer
  %29 = icmp eq i64 %20, %18
  br label %30

30:                                               ; preds = %59, %17
  %31 = phi i32 [ %9, %17 ], [ %60, %59 ]
  %32 = phi i32 [ 0, %17 ], [ %61, %59 ]
  br i1 %19, label %52, label %33

33:                                               ; preds = %30, %33
  %34 = phi i64 [ %47, %33 ], [ 0, %30 ]
  %35 = phi <4 x i32> [ %45, %33 ], [ zeroinitializer, %30 ]
  %36 = phi <4 x i32> [ %46, %33 ], [ zeroinitializer, %30 ]
  %37 = getelementptr inbounds i32, ptr %0, i64 %34
  %38 = load <4 x i32>, ptr %37, align 4, !tbaa !9
  %39 = getelementptr inbounds i32, ptr %37, i64 4
  %40 = load <4 x i32>, ptr %39, align 4, !tbaa !9
  %41 = add <4 x i32> %35, %22
  %42 = add <4 x i32> %36, %24
  %43 = add <4 x i32> %41, %38
  %44 = add <4 x i32> %42, %40
  %45 = sub <4 x i32> %43, %26
  %46 = sub <4 x i32> %44, %28
  %47 = add nuw i64 %34, 8
  %48 = icmp eq i64 %47, %20
  br i1 %48, label %49, label %33, !llvm.loop !367

49:                                               ; preds = %33
  %50 = add <4 x i32> %46, %45
  %51 = tail call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %50)
  br i1 %29, label %73, label %52

52:                                               ; preds = %30, %49
  %53 = phi i64 [ 0, %30 ], [ %20, %49 ]
  %54 = phi i32 [ 0, %30 ], [ %51, %49 ]
  br label %63

55:                                               ; preds = %73
  %56 = load i32, ptr @current_test, align 4, !tbaa !9
  %57 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %56)
  %58 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %59

59:                                               ; preds = %55, %73
  %60 = phi i32 [ %58, %55 ], [ %31, %73 ]
  %61 = add nuw nsw i32 %32, 1
  %62 = icmp slt i32 %61, %60
  br i1 %62, label %30, label %100, !llvm.loop !368

63:                                               ; preds = %52, %63
  %64 = phi i64 [ %71, %63 ], [ %53, %52 ]
  %65 = phi i32 [ %70, %63 ], [ %54, %52 ]
  %66 = getelementptr inbounds i32, ptr %0, i64 %64
  %67 = load i32, ptr %66, align 4, !tbaa !9
  %68 = add i32 %65, %2
  %69 = add i32 %68, %67
  %70 = sub i32 %69, %14
  %71 = add nuw nsw i64 %64, 1
  %72 = icmp eq i64 %71, %18
  br i1 %72, label %73, label %63, !llvm.loop !369

73:                                               ; preds = %63, %49
  %74 = phi i32 [ %51, %49 ], [ %70, %63 ]
  %75 = load double, ptr @init_value, align 8, !tbaa !28
  %76 = fptoui double %75 to i32
  %77 = add i32 %76, %2
  %78 = sub i32 %77, %14
  %79 = mul i32 %78, 8000
  %80 = icmp eq i32 %79, %74
  br i1 %80, label %59, label %55

81:                                               ; preds = %15, %95
  %82 = phi i32 [ %96, %95 ], [ %9, %15 ]
  %83 = phi double [ %97, %95 ], [ %16, %15 ]
  %84 = phi i32 [ %98, %95 ], [ 0, %15 ]
  %85 = fptoui double %83 to i32
  %86 = add i32 %85, %2
  %87 = sub i32 %86, %14
  %88 = mul i32 %87, 8000
  %89 = icmp eq i32 %88, 0
  br i1 %89, label %95, label %90

90:                                               ; preds = %81
  %91 = load i32, ptr @current_test, align 4, !tbaa !9
  %92 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %91)
  %93 = load double, ptr @init_value, align 8, !tbaa !28
  %94 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %95

95:                                               ; preds = %81, %90
  %96 = phi i32 [ %82, %81 ], [ %94, %90 ]
  %97 = phi double [ %83, %81 ], [ %93, %90 ]
  %98 = add nuw nsw i32 %84, 1
  %99 = icmp slt i32 %98, %96
  br i1 %99, label %81, label %100, !llvm.loop !368

100:                                              ; preds = %95, %59, %7
  %101 = tail call i64 @clock() #17
  store i64 %101, ptr @end_time, align 8, !tbaa !26
  %102 = load i64, ptr @start_time, align 8, !tbaa !26
  %103 = load ptr, ptr @results, align 8, !tbaa !5
  %104 = icmp eq ptr %103, null
  br i1 %104, label %105, label %107

105:                                              ; preds = %100
  %106 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %111

107:                                              ; preds = %100
  %108 = load i32, ptr @current_test, align 4, !tbaa !9
  %109 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %110 = icmp slt i32 %108, %109
  br i1 %110, label %123, label %111

111:                                              ; preds = %107, %105
  %112 = phi i32 [ %106, %105 ], [ %109, %107 ]
  %113 = add nsw i32 %112, 10
  store i32 %113, ptr @allocated_results, align 4, !tbaa !9
  %114 = sext i32 %113 to i64
  %115 = shl nsw i64 %114, 4
  %116 = tail call ptr @realloc(ptr noundef %103, i64 noundef %115) #14
  store ptr %116, ptr @results, align 8, !tbaa !5
  %117 = icmp eq ptr %116, null
  br i1 %117, label %120, label %118

118:                                              ; preds = %111
  %119 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %123

120:                                              ; preds = %111
  %121 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %122 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %121)
  tail call void @exit(i32 noundef -1) #15
  unreachable

123:                                              ; preds = %107, %118
  %124 = phi i32 [ %119, %118 ], [ %108, %107 ]
  %125 = phi ptr [ %116, %118 ], [ %103, %107 ]
  %126 = sub nsw i64 %101, %102
  %127 = sitofp i64 %126 to double
  %128 = fdiv double %127, 1.000000e+06
  %129 = sext i32 %124 to i64
  %130 = getelementptr inbounds %struct.one_result, ptr %125, i64 %129
  store double %128, ptr %130, align 8, !tbaa !11
  %131 = getelementptr inbounds %struct.one_result, ptr %125, i64 %129, i32 1
  store ptr %6, ptr %131, align 8, !tbaa !14
  %132 = add nsw i32 %124, 1
  store i32 %132, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1Ij19custom_variable_andIjEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i32 noundef %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !26
  %6 = load i32, ptr @iterations, align 4, !tbaa !9
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %86

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  br i1 %9, label %12, label %10

10:                                               ; preds = %8
  %11 = load double, ptr @init_value, align 8, !tbaa !28
  br label %68

12:                                               ; preds = %8
  %13 = zext i32 %1 to i64
  %14 = icmp ult i32 %1, 8
  %15 = and i64 %13, 4294967288
  %16 = insertelement <4 x i32> poison, i32 %2, i64 0
  %17 = shufflevector <4 x i32> %16, <4 x i32> poison, <4 x i32> zeroinitializer
  %18 = insertelement <4 x i32> poison, i32 %2, i64 0
  %19 = shufflevector <4 x i32> %18, <4 x i32> poison, <4 x i32> zeroinitializer
  %20 = icmp eq i64 %15, %13
  br label %21

21:                                               ; preds = %12, %48
  %22 = phi i32 [ %49, %48 ], [ %6, %12 ]
  %23 = phi i32 [ %50, %48 ], [ 0, %12 ]
  br i1 %14, label %41, label %24

24:                                               ; preds = %21, %24
  %25 = phi i64 [ %36, %24 ], [ 0, %21 ]
  %26 = phi <4 x i32> [ %34, %24 ], [ zeroinitializer, %21 ]
  %27 = phi <4 x i32> [ %35, %24 ], [ zeroinitializer, %21 ]
  %28 = getelementptr inbounds i32, ptr %0, i64 %25
  %29 = load <4 x i32>, ptr %28, align 4, !tbaa !9
  %30 = getelementptr inbounds i32, ptr %28, i64 4
  %31 = load <4 x i32>, ptr %30, align 4, !tbaa !9
  %32 = and <4 x i32> %29, %17
  %33 = and <4 x i32> %31, %19
  %34 = add <4 x i32> %32, %26
  %35 = add <4 x i32> %33, %27
  %36 = add nuw i64 %25, 8
  %37 = icmp eq i64 %36, %15
  br i1 %37, label %38, label %24, !llvm.loop !370

38:                                               ; preds = %24
  %39 = add <4 x i32> %35, %34
  %40 = tail call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %39)
  br i1 %20, label %61, label %41

41:                                               ; preds = %21, %38
  %42 = phi i64 [ 0, %21 ], [ %15, %38 ]
  %43 = phi i32 [ 0, %21 ], [ %40, %38 ]
  br label %52

44:                                               ; preds = %61
  %45 = load i32, ptr @current_test, align 4, !tbaa !9
  %46 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %45)
  %47 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %48

48:                                               ; preds = %44, %61
  %49 = phi i32 [ %47, %44 ], [ %22, %61 ]
  %50 = add nuw nsw i32 %23, 1
  %51 = icmp slt i32 %50, %49
  br i1 %51, label %21, label %86, !llvm.loop !371

52:                                               ; preds = %41, %52
  %53 = phi i64 [ %59, %52 ], [ %42, %41 ]
  %54 = phi i32 [ %58, %52 ], [ %43, %41 ]
  %55 = getelementptr inbounds i32, ptr %0, i64 %53
  %56 = load i32, ptr %55, align 4, !tbaa !9
  %57 = and i32 %56, %2
  %58 = add i32 %57, %54
  %59 = add nuw nsw i64 %53, 1
  %60 = icmp eq i64 %59, %13
  br i1 %60, label %61, label %52, !llvm.loop !372

61:                                               ; preds = %52, %38
  %62 = phi i32 [ %40, %38 ], [ %58, %52 ]
  %63 = load double, ptr @init_value, align 8, !tbaa !28
  %64 = fptoui double %63 to i32
  %65 = and i32 %64, %2
  %66 = mul i32 %65, 8000
  %67 = icmp eq i32 %66, %62
  br i1 %67, label %48, label %44

68:                                               ; preds = %10, %81
  %69 = phi i32 [ %82, %81 ], [ %6, %10 ]
  %70 = phi double [ %83, %81 ], [ %11, %10 ]
  %71 = phi i32 [ %84, %81 ], [ 0, %10 ]
  %72 = fptoui double %70 to i32
  %73 = and i32 %72, %2
  %74 = mul i32 %73, 8000
  %75 = icmp eq i32 %74, 0
  br i1 %75, label %81, label %76

76:                                               ; preds = %68
  %77 = load i32, ptr @current_test, align 4, !tbaa !9
  %78 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %77)
  %79 = load double, ptr @init_value, align 8, !tbaa !28
  %80 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %81

81:                                               ; preds = %68, %76
  %82 = phi i32 [ %69, %68 ], [ %80, %76 ]
  %83 = phi double [ %70, %68 ], [ %79, %76 ]
  %84 = add nuw nsw i32 %71, 1
  %85 = icmp slt i32 %84, %82
  br i1 %85, label %68, label %86, !llvm.loop !371

86:                                               ; preds = %81, %48, %4
  %87 = tail call i64 @clock() #17
  store i64 %87, ptr @end_time, align 8, !tbaa !26
  %88 = load i64, ptr @start_time, align 8, !tbaa !26
  %89 = load ptr, ptr @results, align 8, !tbaa !5
  %90 = icmp eq ptr %89, null
  br i1 %90, label %91, label %93

91:                                               ; preds = %86
  %92 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %97

93:                                               ; preds = %86
  %94 = load i32, ptr @current_test, align 4, !tbaa !9
  %95 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %96 = icmp slt i32 %94, %95
  br i1 %96, label %109, label %97

97:                                               ; preds = %93, %91
  %98 = phi i32 [ %92, %91 ], [ %95, %93 ]
  %99 = add nsw i32 %98, 10
  store i32 %99, ptr @allocated_results, align 4, !tbaa !9
  %100 = sext i32 %99 to i64
  %101 = shl nsw i64 %100, 4
  %102 = tail call ptr @realloc(ptr noundef %89, i64 noundef %101) #14
  store ptr %102, ptr @results, align 8, !tbaa !5
  %103 = icmp eq ptr %102, null
  br i1 %103, label %106, label %104

104:                                              ; preds = %97
  %105 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %109

106:                                              ; preds = %97
  %107 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %108 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %107)
  tail call void @exit(i32 noundef -1) #15
  unreachable

109:                                              ; preds = %93, %104
  %110 = phi i32 [ %105, %104 ], [ %94, %93 ]
  %111 = phi ptr [ %102, %104 ], [ %89, %93 ]
  %112 = sub nsw i64 %87, %88
  %113 = sitofp i64 %112 to double
  %114 = fdiv double %113, 1.000000e+06
  %115 = sext i32 %110 to i64
  %116 = getelementptr inbounds %struct.one_result, ptr %111, i64 %115
  store double %114, ptr %116, align 8, !tbaa !11
  %117 = getelementptr inbounds %struct.one_result, ptr %111, i64 %115, i32 1
  store ptr %3, ptr %117, align 8, !tbaa !14
  %118 = add nsw i32 %110, 1
  store i32 %118, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Ij28custom_multiple_variable_andIjEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3, i32 noundef %4, i32 noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !26
  %9 = load i32, ptr @iterations, align 4, !tbaa !9
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %101

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  %13 = and i32 %3, %2
  %14 = and i32 %13, %4
  %15 = and i32 %14, %5
  br i1 %12, label %18, label %16

16:                                               ; preds = %11
  %17 = load double, ptr @init_value, align 8, !tbaa !28
  br label %83

18:                                               ; preds = %11
  %19 = zext i32 %1 to i64
  %20 = icmp ult i32 %1, 8
  %21 = and i64 %19, 4294967288
  %22 = and i32 %3, %2
  %23 = and i32 %3, %2
  %24 = and i32 %22, %4
  %25 = and i32 %23, %4
  %26 = and i32 %24, %5
  %27 = insertelement <4 x i32> poison, i32 %26, i64 0
  %28 = shufflevector <4 x i32> %27, <4 x i32> poison, <4 x i32> zeroinitializer
  %29 = and i32 %25, %5
  %30 = insertelement <4 x i32> poison, i32 %29, i64 0
  %31 = shufflevector <4 x i32> %30, <4 x i32> poison, <4 x i32> zeroinitializer
  %32 = icmp eq i64 %21, %19
  br label %33

33:                                               ; preds = %18, %60
  %34 = phi i32 [ %61, %60 ], [ %9, %18 ]
  %35 = phi i32 [ %62, %60 ], [ 0, %18 ]
  br i1 %20, label %53, label %36

36:                                               ; preds = %33, %36
  %37 = phi i64 [ %48, %36 ], [ 0, %33 ]
  %38 = phi <4 x i32> [ %46, %36 ], [ zeroinitializer, %33 ]
  %39 = phi <4 x i32> [ %47, %36 ], [ zeroinitializer, %33 ]
  %40 = getelementptr inbounds i32, ptr %0, i64 %37
  %41 = load <4 x i32>, ptr %40, align 4, !tbaa !9
  %42 = getelementptr inbounds i32, ptr %40, i64 4
  %43 = load <4 x i32>, ptr %42, align 4, !tbaa !9
  %44 = and <4 x i32> %28, %41
  %45 = and <4 x i32> %31, %43
  %46 = add <4 x i32> %44, %38
  %47 = add <4 x i32> %45, %39
  %48 = add nuw i64 %37, 8
  %49 = icmp eq i64 %48, %21
  br i1 %49, label %50, label %36, !llvm.loop !373

50:                                               ; preds = %36
  %51 = add <4 x i32> %47, %46
  %52 = tail call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %51)
  br i1 %32, label %76, label %53

53:                                               ; preds = %33, %50
  %54 = phi i64 [ 0, %33 ], [ %21, %50 ]
  %55 = phi i32 [ 0, %33 ], [ %52, %50 ]
  br label %64

56:                                               ; preds = %76
  %57 = load i32, ptr @current_test, align 4, !tbaa !9
  %58 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %57)
  %59 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %60

60:                                               ; preds = %56, %76
  %61 = phi i32 [ %59, %56 ], [ %34, %76 ]
  %62 = add nuw nsw i32 %35, 1
  %63 = icmp slt i32 %62, %61
  br i1 %63, label %33, label %101, !llvm.loop !374

64:                                               ; preds = %53, %64
  %65 = phi i64 [ %74, %64 ], [ %54, %53 ]
  %66 = phi i32 [ %73, %64 ], [ %55, %53 ]
  %67 = getelementptr inbounds i32, ptr %0, i64 %65
  %68 = load i32, ptr %67, align 4, !tbaa !9
  %69 = and i32 %68, %2
  %70 = and i32 %69, %3
  %71 = and i32 %70, %4
  %72 = and i32 %71, %5
  %73 = add i32 %72, %66
  %74 = add nuw nsw i64 %65, 1
  %75 = icmp eq i64 %74, %19
  br i1 %75, label %76, label %64, !llvm.loop !375

76:                                               ; preds = %64, %50
  %77 = phi i32 [ %52, %50 ], [ %73, %64 ]
  %78 = load double, ptr @init_value, align 8, !tbaa !28
  %79 = fptoui double %78 to i32
  %80 = and i32 %15, %79
  %81 = mul i32 %80, 8000
  %82 = icmp eq i32 %81, %77
  br i1 %82, label %60, label %56

83:                                               ; preds = %16, %96
  %84 = phi i32 [ %97, %96 ], [ %9, %16 ]
  %85 = phi double [ %98, %96 ], [ %17, %16 ]
  %86 = phi i32 [ %99, %96 ], [ 0, %16 ]
  %87 = fptoui double %85 to i32
  %88 = and i32 %15, %87
  %89 = mul i32 %88, 8000
  %90 = icmp eq i32 %89, 0
  br i1 %90, label %96, label %91

91:                                               ; preds = %83
  %92 = load i32, ptr @current_test, align 4, !tbaa !9
  %93 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %92)
  %94 = load double, ptr @init_value, align 8, !tbaa !28
  %95 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %96

96:                                               ; preds = %83, %91
  %97 = phi i32 [ %84, %83 ], [ %95, %91 ]
  %98 = phi double [ %85, %83 ], [ %94, %91 ]
  %99 = add nuw nsw i32 %86, 1
  %100 = icmp slt i32 %99, %97
  br i1 %100, label %83, label %101, !llvm.loop !374

101:                                              ; preds = %96, %60, %7
  %102 = tail call i64 @clock() #17
  store i64 %102, ptr @end_time, align 8, !tbaa !26
  %103 = load i64, ptr @start_time, align 8, !tbaa !26
  %104 = load ptr, ptr @results, align 8, !tbaa !5
  %105 = icmp eq ptr %104, null
  br i1 %105, label %106, label %108

106:                                              ; preds = %101
  %107 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %112

108:                                              ; preds = %101
  %109 = load i32, ptr @current_test, align 4, !tbaa !9
  %110 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %111 = icmp slt i32 %109, %110
  br i1 %111, label %124, label %112

112:                                              ; preds = %108, %106
  %113 = phi i32 [ %107, %106 ], [ %110, %108 ]
  %114 = add nsw i32 %113, 10
  store i32 %114, ptr @allocated_results, align 4, !tbaa !9
  %115 = sext i32 %114 to i64
  %116 = shl nsw i64 %115, 4
  %117 = tail call ptr @realloc(ptr noundef %104, i64 noundef %116) #14
  store ptr %117, ptr @results, align 8, !tbaa !5
  %118 = icmp eq ptr %117, null
  br i1 %118, label %121, label %119

119:                                              ; preds = %112
  %120 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %124

121:                                              ; preds = %112
  %122 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %123 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %122)
  tail call void @exit(i32 noundef -1) #15
  unreachable

124:                                              ; preds = %108, %119
  %125 = phi i32 [ %120, %119 ], [ %109, %108 ]
  %126 = phi ptr [ %117, %119 ], [ %104, %108 ]
  %127 = sub nsw i64 %102, %103
  %128 = sitofp i64 %127 to double
  %129 = fdiv double %128, 1.000000e+06
  %130 = sext i32 %125 to i64
  %131 = getelementptr inbounds %struct.one_result, ptr %126, i64 %130
  store double %129, ptr %131, align 8, !tbaa !11
  %132 = getelementptr inbounds %struct.one_result, ptr %126, i64 %130, i32 1
  store ptr %6, ptr %132, align 8, !tbaa !14
  %133 = add nsw i32 %125, 1
  store i32 %133, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1Ij18custom_variable_orIjEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i32 noundef %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !26
  %6 = load i32, ptr @iterations, align 4, !tbaa !9
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %86

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  br i1 %9, label %12, label %10

10:                                               ; preds = %8
  %11 = load double, ptr @init_value, align 8, !tbaa !28
  br label %68

12:                                               ; preds = %8
  %13 = zext i32 %1 to i64
  %14 = icmp ult i32 %1, 8
  %15 = and i64 %13, 4294967288
  %16 = insertelement <4 x i32> poison, i32 %2, i64 0
  %17 = shufflevector <4 x i32> %16, <4 x i32> poison, <4 x i32> zeroinitializer
  %18 = insertelement <4 x i32> poison, i32 %2, i64 0
  %19 = shufflevector <4 x i32> %18, <4 x i32> poison, <4 x i32> zeroinitializer
  %20 = icmp eq i64 %15, %13
  br label %21

21:                                               ; preds = %12, %48
  %22 = phi i32 [ %49, %48 ], [ %6, %12 ]
  %23 = phi i32 [ %50, %48 ], [ 0, %12 ]
  br i1 %14, label %41, label %24

24:                                               ; preds = %21, %24
  %25 = phi i64 [ %36, %24 ], [ 0, %21 ]
  %26 = phi <4 x i32> [ %34, %24 ], [ zeroinitializer, %21 ]
  %27 = phi <4 x i32> [ %35, %24 ], [ zeroinitializer, %21 ]
  %28 = getelementptr inbounds i32, ptr %0, i64 %25
  %29 = load <4 x i32>, ptr %28, align 4, !tbaa !9
  %30 = getelementptr inbounds i32, ptr %28, i64 4
  %31 = load <4 x i32>, ptr %30, align 4, !tbaa !9
  %32 = or <4 x i32> %29, %17
  %33 = or <4 x i32> %31, %19
  %34 = add <4 x i32> %32, %26
  %35 = add <4 x i32> %33, %27
  %36 = add nuw i64 %25, 8
  %37 = icmp eq i64 %36, %15
  br i1 %37, label %38, label %24, !llvm.loop !376

38:                                               ; preds = %24
  %39 = add <4 x i32> %35, %34
  %40 = tail call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %39)
  br i1 %20, label %61, label %41

41:                                               ; preds = %21, %38
  %42 = phi i64 [ 0, %21 ], [ %15, %38 ]
  %43 = phi i32 [ 0, %21 ], [ %40, %38 ]
  br label %52

44:                                               ; preds = %61
  %45 = load i32, ptr @current_test, align 4, !tbaa !9
  %46 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %45)
  %47 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %48

48:                                               ; preds = %44, %61
  %49 = phi i32 [ %47, %44 ], [ %22, %61 ]
  %50 = add nuw nsw i32 %23, 1
  %51 = icmp slt i32 %50, %49
  br i1 %51, label %21, label %86, !llvm.loop !377

52:                                               ; preds = %41, %52
  %53 = phi i64 [ %59, %52 ], [ %42, %41 ]
  %54 = phi i32 [ %58, %52 ], [ %43, %41 ]
  %55 = getelementptr inbounds i32, ptr %0, i64 %53
  %56 = load i32, ptr %55, align 4, !tbaa !9
  %57 = or i32 %56, %2
  %58 = add i32 %57, %54
  %59 = add nuw nsw i64 %53, 1
  %60 = icmp eq i64 %59, %13
  br i1 %60, label %61, label %52, !llvm.loop !378

61:                                               ; preds = %52, %38
  %62 = phi i32 [ %40, %38 ], [ %58, %52 ]
  %63 = load double, ptr @init_value, align 8, !tbaa !28
  %64 = fptoui double %63 to i32
  %65 = or i32 %64, %2
  %66 = mul i32 %65, 8000
  %67 = icmp eq i32 %66, %62
  br i1 %67, label %48, label %44

68:                                               ; preds = %10, %81
  %69 = phi i32 [ %82, %81 ], [ %6, %10 ]
  %70 = phi double [ %83, %81 ], [ %11, %10 ]
  %71 = phi i32 [ %84, %81 ], [ 0, %10 ]
  %72 = fptoui double %70 to i32
  %73 = or i32 %72, %2
  %74 = mul i32 %73, 8000
  %75 = icmp eq i32 %74, 0
  br i1 %75, label %81, label %76

76:                                               ; preds = %68
  %77 = load i32, ptr @current_test, align 4, !tbaa !9
  %78 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %77)
  %79 = load double, ptr @init_value, align 8, !tbaa !28
  %80 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %81

81:                                               ; preds = %68, %76
  %82 = phi i32 [ %69, %68 ], [ %80, %76 ]
  %83 = phi double [ %70, %68 ], [ %79, %76 ]
  %84 = add nuw nsw i32 %71, 1
  %85 = icmp slt i32 %84, %82
  br i1 %85, label %68, label %86, !llvm.loop !377

86:                                               ; preds = %81, %48, %4
  %87 = tail call i64 @clock() #17
  store i64 %87, ptr @end_time, align 8, !tbaa !26
  %88 = load i64, ptr @start_time, align 8, !tbaa !26
  %89 = load ptr, ptr @results, align 8, !tbaa !5
  %90 = icmp eq ptr %89, null
  br i1 %90, label %91, label %93

91:                                               ; preds = %86
  %92 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %97

93:                                               ; preds = %86
  %94 = load i32, ptr @current_test, align 4, !tbaa !9
  %95 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %96 = icmp slt i32 %94, %95
  br i1 %96, label %109, label %97

97:                                               ; preds = %93, %91
  %98 = phi i32 [ %92, %91 ], [ %95, %93 ]
  %99 = add nsw i32 %98, 10
  store i32 %99, ptr @allocated_results, align 4, !tbaa !9
  %100 = sext i32 %99 to i64
  %101 = shl nsw i64 %100, 4
  %102 = tail call ptr @realloc(ptr noundef %89, i64 noundef %101) #14
  store ptr %102, ptr @results, align 8, !tbaa !5
  %103 = icmp eq ptr %102, null
  br i1 %103, label %106, label %104

104:                                              ; preds = %97
  %105 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %109

106:                                              ; preds = %97
  %107 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %108 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %107)
  tail call void @exit(i32 noundef -1) #15
  unreachable

109:                                              ; preds = %93, %104
  %110 = phi i32 [ %105, %104 ], [ %94, %93 ]
  %111 = phi ptr [ %102, %104 ], [ %89, %93 ]
  %112 = sub nsw i64 %87, %88
  %113 = sitofp i64 %112 to double
  %114 = fdiv double %113, 1.000000e+06
  %115 = sext i32 %110 to i64
  %116 = getelementptr inbounds %struct.one_result, ptr %111, i64 %115
  store double %114, ptr %116, align 8, !tbaa !11
  %117 = getelementptr inbounds %struct.one_result, ptr %111, i64 %115, i32 1
  store ptr %3, ptr %117, align 8, !tbaa !14
  %118 = add nsw i32 %110, 1
  store i32 %118, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Ij27custom_multiple_variable_orIjEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3, i32 noundef %4, i32 noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !26
  %9 = load i32, ptr @iterations, align 4, !tbaa !9
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %101

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  %13 = or i32 %3, %2
  %14 = or i32 %13, %4
  %15 = or i32 %14, %5
  br i1 %12, label %18, label %16

16:                                               ; preds = %11
  %17 = load double, ptr @init_value, align 8, !tbaa !28
  br label %83

18:                                               ; preds = %11
  %19 = zext i32 %1 to i64
  %20 = icmp ult i32 %1, 8
  %21 = and i64 %19, 4294967288
  %22 = or i32 %3, %2
  %23 = or i32 %3, %2
  %24 = or i32 %22, %4
  %25 = or i32 %23, %4
  %26 = or i32 %24, %5
  %27 = insertelement <4 x i32> poison, i32 %26, i64 0
  %28 = shufflevector <4 x i32> %27, <4 x i32> poison, <4 x i32> zeroinitializer
  %29 = or i32 %25, %5
  %30 = insertelement <4 x i32> poison, i32 %29, i64 0
  %31 = shufflevector <4 x i32> %30, <4 x i32> poison, <4 x i32> zeroinitializer
  %32 = icmp eq i64 %21, %19
  br label %33

33:                                               ; preds = %18, %60
  %34 = phi i32 [ %61, %60 ], [ %9, %18 ]
  %35 = phi i32 [ %62, %60 ], [ 0, %18 ]
  br i1 %20, label %53, label %36

36:                                               ; preds = %33, %36
  %37 = phi i64 [ %48, %36 ], [ 0, %33 ]
  %38 = phi <4 x i32> [ %46, %36 ], [ zeroinitializer, %33 ]
  %39 = phi <4 x i32> [ %47, %36 ], [ zeroinitializer, %33 ]
  %40 = getelementptr inbounds i32, ptr %0, i64 %37
  %41 = load <4 x i32>, ptr %40, align 4, !tbaa !9
  %42 = getelementptr inbounds i32, ptr %40, i64 4
  %43 = load <4 x i32>, ptr %42, align 4, !tbaa !9
  %44 = or <4 x i32> %28, %41
  %45 = or <4 x i32> %31, %43
  %46 = add <4 x i32> %44, %38
  %47 = add <4 x i32> %45, %39
  %48 = add nuw i64 %37, 8
  %49 = icmp eq i64 %48, %21
  br i1 %49, label %50, label %36, !llvm.loop !379

50:                                               ; preds = %36
  %51 = add <4 x i32> %47, %46
  %52 = tail call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %51)
  br i1 %32, label %76, label %53

53:                                               ; preds = %33, %50
  %54 = phi i64 [ 0, %33 ], [ %21, %50 ]
  %55 = phi i32 [ 0, %33 ], [ %52, %50 ]
  br label %64

56:                                               ; preds = %76
  %57 = load i32, ptr @current_test, align 4, !tbaa !9
  %58 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %57)
  %59 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %60

60:                                               ; preds = %56, %76
  %61 = phi i32 [ %59, %56 ], [ %34, %76 ]
  %62 = add nuw nsw i32 %35, 1
  %63 = icmp slt i32 %62, %61
  br i1 %63, label %33, label %101, !llvm.loop !380

64:                                               ; preds = %53, %64
  %65 = phi i64 [ %74, %64 ], [ %54, %53 ]
  %66 = phi i32 [ %73, %64 ], [ %55, %53 ]
  %67 = getelementptr inbounds i32, ptr %0, i64 %65
  %68 = load i32, ptr %67, align 4, !tbaa !9
  %69 = or i32 %68, %2
  %70 = or i32 %69, %3
  %71 = or i32 %70, %4
  %72 = or i32 %71, %5
  %73 = add i32 %72, %66
  %74 = add nuw nsw i64 %65, 1
  %75 = icmp eq i64 %74, %19
  br i1 %75, label %76, label %64, !llvm.loop !381

76:                                               ; preds = %64, %50
  %77 = phi i32 [ %52, %50 ], [ %73, %64 ]
  %78 = load double, ptr @init_value, align 8, !tbaa !28
  %79 = fptoui double %78 to i32
  %80 = or i32 %15, %79
  %81 = mul i32 %80, 8000
  %82 = icmp eq i32 %81, %77
  br i1 %82, label %60, label %56

83:                                               ; preds = %16, %96
  %84 = phi i32 [ %97, %96 ], [ %9, %16 ]
  %85 = phi double [ %98, %96 ], [ %17, %16 ]
  %86 = phi i32 [ %99, %96 ], [ 0, %16 ]
  %87 = fptoui double %85 to i32
  %88 = or i32 %15, %87
  %89 = mul i32 %88, 8000
  %90 = icmp eq i32 %89, 0
  br i1 %90, label %96, label %91

91:                                               ; preds = %83
  %92 = load i32, ptr @current_test, align 4, !tbaa !9
  %93 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %92)
  %94 = load double, ptr @init_value, align 8, !tbaa !28
  %95 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %96

96:                                               ; preds = %83, %91
  %97 = phi i32 [ %84, %83 ], [ %95, %91 ]
  %98 = phi double [ %85, %83 ], [ %94, %91 ]
  %99 = add nuw nsw i32 %86, 1
  %100 = icmp slt i32 %99, %97
  br i1 %100, label %83, label %101, !llvm.loop !380

101:                                              ; preds = %96, %60, %7
  %102 = tail call i64 @clock() #17
  store i64 %102, ptr @end_time, align 8, !tbaa !26
  %103 = load i64, ptr @start_time, align 8, !tbaa !26
  %104 = load ptr, ptr @results, align 8, !tbaa !5
  %105 = icmp eq ptr %104, null
  br i1 %105, label %106, label %108

106:                                              ; preds = %101
  %107 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %112

108:                                              ; preds = %101
  %109 = load i32, ptr @current_test, align 4, !tbaa !9
  %110 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %111 = icmp slt i32 %109, %110
  br i1 %111, label %124, label %112

112:                                              ; preds = %108, %106
  %113 = phi i32 [ %107, %106 ], [ %110, %108 ]
  %114 = add nsw i32 %113, 10
  store i32 %114, ptr @allocated_results, align 4, !tbaa !9
  %115 = sext i32 %114 to i64
  %116 = shl nsw i64 %115, 4
  %117 = tail call ptr @realloc(ptr noundef %104, i64 noundef %116) #14
  store ptr %117, ptr @results, align 8, !tbaa !5
  %118 = icmp eq ptr %117, null
  br i1 %118, label %121, label %119

119:                                              ; preds = %112
  %120 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %124

121:                                              ; preds = %112
  %122 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %123 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %122)
  tail call void @exit(i32 noundef -1) #15
  unreachable

124:                                              ; preds = %108, %119
  %125 = phi i32 [ %120, %119 ], [ %109, %108 ]
  %126 = phi ptr [ %117, %119 ], [ %104, %108 ]
  %127 = sub nsw i64 %102, %103
  %128 = sitofp i64 %127 to double
  %129 = fdiv double %128, 1.000000e+06
  %130 = sext i32 %125 to i64
  %131 = getelementptr inbounds %struct.one_result, ptr %126, i64 %130
  store double %129, ptr %131, align 8, !tbaa !11
  %132 = getelementptr inbounds %struct.one_result, ptr %126, i64 %130, i32 1
  store ptr %6, ptr %132, align 8, !tbaa !14
  %133 = add nsw i32 %125, 1
  store i32 %133, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1Ij19custom_variable_xorIjEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i32 noundef %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !26
  %6 = load i32, ptr @iterations, align 4, !tbaa !9
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %86

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  br i1 %9, label %12, label %10

10:                                               ; preds = %8
  %11 = load double, ptr @init_value, align 8, !tbaa !28
  br label %68

12:                                               ; preds = %8
  %13 = zext i32 %1 to i64
  %14 = icmp ult i32 %1, 8
  %15 = and i64 %13, 4294967288
  %16 = insertelement <4 x i32> poison, i32 %2, i64 0
  %17 = shufflevector <4 x i32> %16, <4 x i32> poison, <4 x i32> zeroinitializer
  %18 = insertelement <4 x i32> poison, i32 %2, i64 0
  %19 = shufflevector <4 x i32> %18, <4 x i32> poison, <4 x i32> zeroinitializer
  %20 = icmp eq i64 %15, %13
  br label %21

21:                                               ; preds = %12, %48
  %22 = phi i32 [ %49, %48 ], [ %6, %12 ]
  %23 = phi i32 [ %50, %48 ], [ 0, %12 ]
  br i1 %14, label %41, label %24

24:                                               ; preds = %21, %24
  %25 = phi i64 [ %36, %24 ], [ 0, %21 ]
  %26 = phi <4 x i32> [ %34, %24 ], [ zeroinitializer, %21 ]
  %27 = phi <4 x i32> [ %35, %24 ], [ zeroinitializer, %21 ]
  %28 = getelementptr inbounds i32, ptr %0, i64 %25
  %29 = load <4 x i32>, ptr %28, align 4, !tbaa !9
  %30 = getelementptr inbounds i32, ptr %28, i64 4
  %31 = load <4 x i32>, ptr %30, align 4, !tbaa !9
  %32 = xor <4 x i32> %29, %17
  %33 = xor <4 x i32> %31, %19
  %34 = add <4 x i32> %32, %26
  %35 = add <4 x i32> %33, %27
  %36 = add nuw i64 %25, 8
  %37 = icmp eq i64 %36, %15
  br i1 %37, label %38, label %24, !llvm.loop !382

38:                                               ; preds = %24
  %39 = add <4 x i32> %35, %34
  %40 = tail call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %39)
  br i1 %20, label %61, label %41

41:                                               ; preds = %21, %38
  %42 = phi i64 [ 0, %21 ], [ %15, %38 ]
  %43 = phi i32 [ 0, %21 ], [ %40, %38 ]
  br label %52

44:                                               ; preds = %61
  %45 = load i32, ptr @current_test, align 4, !tbaa !9
  %46 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %45)
  %47 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %48

48:                                               ; preds = %44, %61
  %49 = phi i32 [ %47, %44 ], [ %22, %61 ]
  %50 = add nuw nsw i32 %23, 1
  %51 = icmp slt i32 %50, %49
  br i1 %51, label %21, label %86, !llvm.loop !383

52:                                               ; preds = %41, %52
  %53 = phi i64 [ %59, %52 ], [ %42, %41 ]
  %54 = phi i32 [ %58, %52 ], [ %43, %41 ]
  %55 = getelementptr inbounds i32, ptr %0, i64 %53
  %56 = load i32, ptr %55, align 4, !tbaa !9
  %57 = xor i32 %56, %2
  %58 = add i32 %57, %54
  %59 = add nuw nsw i64 %53, 1
  %60 = icmp eq i64 %59, %13
  br i1 %60, label %61, label %52, !llvm.loop !384

61:                                               ; preds = %52, %38
  %62 = phi i32 [ %40, %38 ], [ %58, %52 ]
  %63 = load double, ptr @init_value, align 8, !tbaa !28
  %64 = fptoui double %63 to i32
  %65 = xor i32 %64, %2
  %66 = mul i32 %65, 8000
  %67 = icmp eq i32 %66, %62
  br i1 %67, label %48, label %44

68:                                               ; preds = %10, %81
  %69 = phi i32 [ %82, %81 ], [ %6, %10 ]
  %70 = phi double [ %83, %81 ], [ %11, %10 ]
  %71 = phi i32 [ %84, %81 ], [ 0, %10 ]
  %72 = fptoui double %70 to i32
  %73 = xor i32 %72, %2
  %74 = mul i32 %73, 8000
  %75 = icmp eq i32 %74, 0
  br i1 %75, label %81, label %76

76:                                               ; preds = %68
  %77 = load i32, ptr @current_test, align 4, !tbaa !9
  %78 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %77)
  %79 = load double, ptr @init_value, align 8, !tbaa !28
  %80 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %81

81:                                               ; preds = %68, %76
  %82 = phi i32 [ %69, %68 ], [ %80, %76 ]
  %83 = phi double [ %70, %68 ], [ %79, %76 ]
  %84 = add nuw nsw i32 %71, 1
  %85 = icmp slt i32 %84, %82
  br i1 %85, label %68, label %86, !llvm.loop !383

86:                                               ; preds = %81, %48, %4
  %87 = tail call i64 @clock() #17
  store i64 %87, ptr @end_time, align 8, !tbaa !26
  %88 = load i64, ptr @start_time, align 8, !tbaa !26
  %89 = load ptr, ptr @results, align 8, !tbaa !5
  %90 = icmp eq ptr %89, null
  br i1 %90, label %91, label %93

91:                                               ; preds = %86
  %92 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %97

93:                                               ; preds = %86
  %94 = load i32, ptr @current_test, align 4, !tbaa !9
  %95 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %96 = icmp slt i32 %94, %95
  br i1 %96, label %109, label %97

97:                                               ; preds = %93, %91
  %98 = phi i32 [ %92, %91 ], [ %95, %93 ]
  %99 = add nsw i32 %98, 10
  store i32 %99, ptr @allocated_results, align 4, !tbaa !9
  %100 = sext i32 %99 to i64
  %101 = shl nsw i64 %100, 4
  %102 = tail call ptr @realloc(ptr noundef %89, i64 noundef %101) #14
  store ptr %102, ptr @results, align 8, !tbaa !5
  %103 = icmp eq ptr %102, null
  br i1 %103, label %106, label %104

104:                                              ; preds = %97
  %105 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %109

106:                                              ; preds = %97
  %107 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %108 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %107)
  tail call void @exit(i32 noundef -1) #15
  unreachable

109:                                              ; preds = %93, %104
  %110 = phi i32 [ %105, %104 ], [ %94, %93 ]
  %111 = phi ptr [ %102, %104 ], [ %89, %93 ]
  %112 = sub nsw i64 %87, %88
  %113 = sitofp i64 %112 to double
  %114 = fdiv double %113, 1.000000e+06
  %115 = sext i32 %110 to i64
  %116 = getelementptr inbounds %struct.one_result, ptr %111, i64 %115
  store double %114, ptr %116, align 8, !tbaa !11
  %117 = getelementptr inbounds %struct.one_result, ptr %111, i64 %115, i32 1
  store ptr %3, ptr %117, align 8, !tbaa !14
  %118 = add nsw i32 %110, 1
  store i32 %118, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Ij28custom_multiple_variable_xorIjEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3, i32 noundef %4, i32 noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !26
  %9 = load i32, ptr @iterations, align 4, !tbaa !9
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %101

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  %13 = xor i32 %3, %2
  %14 = xor i32 %13, %4
  %15 = xor i32 %14, %5
  br i1 %12, label %18, label %16

16:                                               ; preds = %11
  %17 = load double, ptr @init_value, align 8, !tbaa !28
  br label %83

18:                                               ; preds = %11
  %19 = zext i32 %1 to i64
  %20 = icmp ult i32 %1, 8
  %21 = and i64 %19, 4294967288
  %22 = xor i32 %3, %2
  %23 = xor i32 %3, %2
  %24 = xor i32 %22, %4
  %25 = xor i32 %23, %4
  %26 = xor i32 %24, %5
  %27 = insertelement <4 x i32> poison, i32 %26, i64 0
  %28 = shufflevector <4 x i32> %27, <4 x i32> poison, <4 x i32> zeroinitializer
  %29 = xor i32 %25, %5
  %30 = insertelement <4 x i32> poison, i32 %29, i64 0
  %31 = shufflevector <4 x i32> %30, <4 x i32> poison, <4 x i32> zeroinitializer
  %32 = icmp eq i64 %21, %19
  br label %33

33:                                               ; preds = %18, %60
  %34 = phi i32 [ %61, %60 ], [ %9, %18 ]
  %35 = phi i32 [ %62, %60 ], [ 0, %18 ]
  br i1 %20, label %53, label %36

36:                                               ; preds = %33, %36
  %37 = phi i64 [ %48, %36 ], [ 0, %33 ]
  %38 = phi <4 x i32> [ %46, %36 ], [ zeroinitializer, %33 ]
  %39 = phi <4 x i32> [ %47, %36 ], [ zeroinitializer, %33 ]
  %40 = getelementptr inbounds i32, ptr %0, i64 %37
  %41 = load <4 x i32>, ptr %40, align 4, !tbaa !9
  %42 = getelementptr inbounds i32, ptr %40, i64 4
  %43 = load <4 x i32>, ptr %42, align 4, !tbaa !9
  %44 = xor <4 x i32> %28, %41
  %45 = xor <4 x i32> %31, %43
  %46 = add <4 x i32> %44, %38
  %47 = add <4 x i32> %45, %39
  %48 = add nuw i64 %37, 8
  %49 = icmp eq i64 %48, %21
  br i1 %49, label %50, label %36, !llvm.loop !385

50:                                               ; preds = %36
  %51 = add <4 x i32> %47, %46
  %52 = tail call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %51)
  br i1 %32, label %76, label %53

53:                                               ; preds = %33, %50
  %54 = phi i64 [ 0, %33 ], [ %21, %50 ]
  %55 = phi i32 [ 0, %33 ], [ %52, %50 ]
  br label %64

56:                                               ; preds = %76
  %57 = load i32, ptr @current_test, align 4, !tbaa !9
  %58 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %57)
  %59 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %60

60:                                               ; preds = %56, %76
  %61 = phi i32 [ %59, %56 ], [ %34, %76 ]
  %62 = add nuw nsw i32 %35, 1
  %63 = icmp slt i32 %62, %61
  br i1 %63, label %33, label %101, !llvm.loop !386

64:                                               ; preds = %53, %64
  %65 = phi i64 [ %74, %64 ], [ %54, %53 ]
  %66 = phi i32 [ %73, %64 ], [ %55, %53 ]
  %67 = getelementptr inbounds i32, ptr %0, i64 %65
  %68 = load i32, ptr %67, align 4, !tbaa !9
  %69 = xor i32 %68, %2
  %70 = xor i32 %69, %3
  %71 = xor i32 %70, %4
  %72 = xor i32 %71, %5
  %73 = add i32 %72, %66
  %74 = add nuw nsw i64 %65, 1
  %75 = icmp eq i64 %74, %19
  br i1 %75, label %76, label %64, !llvm.loop !387

76:                                               ; preds = %64, %50
  %77 = phi i32 [ %52, %50 ], [ %73, %64 ]
  %78 = load double, ptr @init_value, align 8, !tbaa !28
  %79 = fptoui double %78 to i32
  %80 = xor i32 %15, %79
  %81 = mul i32 %80, 8000
  %82 = icmp eq i32 %81, %77
  br i1 %82, label %60, label %56

83:                                               ; preds = %16, %96
  %84 = phi i32 [ %97, %96 ], [ %9, %16 ]
  %85 = phi double [ %98, %96 ], [ %17, %16 ]
  %86 = phi i32 [ %99, %96 ], [ 0, %16 ]
  %87 = fptoui double %85 to i32
  %88 = xor i32 %15, %87
  %89 = mul i32 %88, 8000
  %90 = icmp eq i32 %89, 0
  br i1 %90, label %96, label %91

91:                                               ; preds = %83
  %92 = load i32, ptr @current_test, align 4, !tbaa !9
  %93 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %92)
  %94 = load double, ptr @init_value, align 8, !tbaa !28
  %95 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %96

96:                                               ; preds = %83, %91
  %97 = phi i32 [ %84, %83 ], [ %95, %91 ]
  %98 = phi double [ %85, %83 ], [ %94, %91 ]
  %99 = add nuw nsw i32 %86, 1
  %100 = icmp slt i32 %99, %97
  br i1 %100, label %83, label %101, !llvm.loop !386

101:                                              ; preds = %96, %60, %7
  %102 = tail call i64 @clock() #17
  store i64 %102, ptr @end_time, align 8, !tbaa !26
  %103 = load i64, ptr @start_time, align 8, !tbaa !26
  %104 = load ptr, ptr @results, align 8, !tbaa !5
  %105 = icmp eq ptr %104, null
  br i1 %105, label %106, label %108

106:                                              ; preds = %101
  %107 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %112

108:                                              ; preds = %101
  %109 = load i32, ptr @current_test, align 4, !tbaa !9
  %110 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %111 = icmp slt i32 %109, %110
  br i1 %111, label %124, label %112

112:                                              ; preds = %108, %106
  %113 = phi i32 [ %107, %106 ], [ %110, %108 ]
  %114 = add nsw i32 %113, 10
  store i32 %114, ptr @allocated_results, align 4, !tbaa !9
  %115 = sext i32 %114 to i64
  %116 = shl nsw i64 %115, 4
  %117 = tail call ptr @realloc(ptr noundef %104, i64 noundef %116) #14
  store ptr %117, ptr @results, align 8, !tbaa !5
  %118 = icmp eq ptr %117, null
  br i1 %118, label %121, label %119

119:                                              ; preds = %112
  %120 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %124

121:                                              ; preds = %112
  %122 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %123 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %122)
  tail call void @exit(i32 noundef -1) #15
  unreachable

124:                                              ; preds = %108, %119
  %125 = phi i32 [ %120, %119 ], [ %109, %108 ]
  %126 = phi ptr [ %117, %119 ], [ %104, %108 ]
  %127 = sub nsw i64 %102, %103
  %128 = sitofp i64 %127 to double
  %129 = fdiv double %128, 1.000000e+06
  %130 = sext i32 %125 to i64
  %131 = getelementptr inbounds %struct.one_result, ptr %126, i64 %130
  store double %129, ptr %131, align 8, !tbaa !11
  %132 = getelementptr inbounds %struct.one_result, ptr %126, i64 %130, i32 1
  store ptr %6, ptr %132, align 8, !tbaa !14
  %133 = add nsw i32 %125, 1
  store i32 %133, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1Il19custom_add_variableIlEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i64 noundef %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !26
  %6 = load i32, ptr @iterations, align 4, !tbaa !9
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %85

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  br i1 %9, label %13, label %10

10:                                               ; preds = %8
  %11 = load double, ptr @init_value, align 8, !tbaa !28
  %12 = sub i64 0, %2
  br label %69

13:                                               ; preds = %8
  %14 = zext i32 %1 to i64
  %15 = icmp ult i32 %1, 4
  %16 = and i64 %14, 4294967292
  %17 = insertelement <2 x i64> poison, i64 %2, i64 0
  %18 = shufflevector <2 x i64> %17, <2 x i64> poison, <2 x i32> zeroinitializer
  %19 = insertelement <2 x i64> poison, i64 %2, i64 0
  %20 = shufflevector <2 x i64> %19, <2 x i64> poison, <2 x i32> zeroinitializer
  %21 = icmp eq i64 %16, %14
  br label %22

22:                                               ; preds = %13, %49
  %23 = phi i32 [ %50, %49 ], [ %6, %13 ]
  %24 = phi i32 [ %51, %49 ], [ 0, %13 ]
  br i1 %15, label %42, label %25

25:                                               ; preds = %22, %25
  %26 = phi i64 [ %37, %25 ], [ 0, %22 ]
  %27 = phi <2 x i64> [ %35, %25 ], [ zeroinitializer, %22 ]
  %28 = phi <2 x i64> [ %36, %25 ], [ zeroinitializer, %22 ]
  %29 = getelementptr inbounds i64, ptr %0, i64 %26
  %30 = load <2 x i64>, ptr %29, align 8, !tbaa !26
  %31 = getelementptr inbounds i64, ptr %29, i64 2
  %32 = load <2 x i64>, ptr %31, align 8, !tbaa !26
  %33 = add <2 x i64> %27, %18
  %34 = add <2 x i64> %28, %20
  %35 = add <2 x i64> %33, %30
  %36 = add <2 x i64> %34, %32
  %37 = add nuw i64 %26, 4
  %38 = icmp eq i64 %37, %16
  br i1 %38, label %39, label %25, !llvm.loop !388

39:                                               ; preds = %25
  %40 = add <2 x i64> %36, %35
  %41 = tail call i64 @llvm.vector.reduce.add.v2i64(<2 x i64> %40)
  br i1 %21, label %62, label %42

42:                                               ; preds = %22, %39
  %43 = phi i64 [ 0, %22 ], [ %16, %39 ]
  %44 = phi i64 [ 0, %22 ], [ %41, %39 ]
  br label %53

45:                                               ; preds = %62
  %46 = load i32, ptr @current_test, align 4, !tbaa !9
  %47 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %46)
  %48 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %49

49:                                               ; preds = %45, %62
  %50 = phi i32 [ %48, %45 ], [ %23, %62 ]
  %51 = add nuw nsw i32 %24, 1
  %52 = icmp slt i32 %51, %50
  br i1 %52, label %22, label %85, !llvm.loop !389

53:                                               ; preds = %42, %53
  %54 = phi i64 [ %60, %53 ], [ %43, %42 ]
  %55 = phi i64 [ %59, %53 ], [ %44, %42 ]
  %56 = getelementptr inbounds i64, ptr %0, i64 %54
  %57 = load i64, ptr %56, align 8, !tbaa !26
  %58 = add i64 %55, %2
  %59 = add i64 %58, %57
  %60 = add nuw nsw i64 %54, 1
  %61 = icmp eq i64 %60, %14
  br i1 %61, label %62, label %53, !llvm.loop !390

62:                                               ; preds = %53, %39
  %63 = phi i64 [ %41, %39 ], [ %59, %53 ]
  %64 = load double, ptr @init_value, align 8, !tbaa !28
  %65 = fptosi double %64 to i64
  %66 = add nsw i64 %65, %2
  %67 = mul nsw i64 %66, 8000
  %68 = icmp eq i64 %67, %63
  br i1 %68, label %49, label %45

69:                                               ; preds = %10, %80
  %70 = phi i32 [ %81, %80 ], [ %6, %10 ]
  %71 = phi double [ %82, %80 ], [ %11, %10 ]
  %72 = phi i32 [ %83, %80 ], [ 0, %10 ]
  %73 = fptosi double %71 to i64
  %74 = icmp eq i64 %73, %12
  br i1 %74, label %80, label %75

75:                                               ; preds = %69
  %76 = load i32, ptr @current_test, align 4, !tbaa !9
  %77 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %76)
  %78 = load double, ptr @init_value, align 8, !tbaa !28
  %79 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %80

80:                                               ; preds = %69, %75
  %81 = phi i32 [ %70, %69 ], [ %79, %75 ]
  %82 = phi double [ %71, %69 ], [ %78, %75 ]
  %83 = add nuw nsw i32 %72, 1
  %84 = icmp slt i32 %83, %81
  br i1 %84, label %69, label %85, !llvm.loop !389

85:                                               ; preds = %80, %49, %4
  %86 = tail call i64 @clock() #17
  store i64 %86, ptr @end_time, align 8, !tbaa !26
  %87 = load i64, ptr @start_time, align 8, !tbaa !26
  %88 = load ptr, ptr @results, align 8, !tbaa !5
  %89 = icmp eq ptr %88, null
  br i1 %89, label %90, label %92

90:                                               ; preds = %85
  %91 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %96

92:                                               ; preds = %85
  %93 = load i32, ptr @current_test, align 4, !tbaa !9
  %94 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %95 = icmp slt i32 %93, %94
  br i1 %95, label %108, label %96

96:                                               ; preds = %92, %90
  %97 = phi i32 [ %91, %90 ], [ %94, %92 ]
  %98 = add nsw i32 %97, 10
  store i32 %98, ptr @allocated_results, align 4, !tbaa !9
  %99 = sext i32 %98 to i64
  %100 = shl nsw i64 %99, 4
  %101 = tail call ptr @realloc(ptr noundef %88, i64 noundef %100) #14
  store ptr %101, ptr @results, align 8, !tbaa !5
  %102 = icmp eq ptr %101, null
  br i1 %102, label %105, label %103

103:                                              ; preds = %96
  %104 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %108

105:                                              ; preds = %96
  %106 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %107 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %106)
  tail call void @exit(i32 noundef -1) #15
  unreachable

108:                                              ; preds = %92, %103
  %109 = phi i32 [ %104, %103 ], [ %93, %92 ]
  %110 = phi ptr [ %101, %103 ], [ %88, %92 ]
  %111 = sub nsw i64 %86, %87
  %112 = sitofp i64 %111 to double
  %113 = fdiv double %112, 1.000000e+06
  %114 = sext i32 %109 to i64
  %115 = getelementptr inbounds %struct.one_result, ptr %110, i64 %114
  store double %113, ptr %115, align 8, !tbaa !11
  %116 = getelementptr inbounds %struct.one_result, ptr %110, i64 %114, i32 1
  store ptr %3, ptr %116, align 8, !tbaa !14
  %117 = add nsw i32 %109, 1
  store i32 %117, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z22test_hoisted_variable1Il19custom_add_variableIlEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i64 noundef %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !26
  %6 = load i32, ptr @iterations, align 4, !tbaa !9
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %82

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  %10 = sext i32 %1 to i64
  %11 = mul nsw i64 %10, %2
  br i1 %9, label %14, label %12

12:                                               ; preds = %8
  %13 = load double, ptr @init_value, align 8, !tbaa !28
  br label %64

14:                                               ; preds = %8
  %15 = zext i32 %1 to i64
  %16 = icmp ult i32 %1, 4
  %17 = and i64 %15, 4294967292
  %18 = icmp eq i64 %17, %15
  br label %19

19:                                               ; preds = %14, %44
  %20 = phi i32 [ %45, %44 ], [ %6, %14 ]
  %21 = phi i32 [ %46, %44 ], [ 0, %14 ]
  br i1 %16, label %37, label %22

22:                                               ; preds = %19, %22
  %23 = phi i64 [ %32, %22 ], [ 0, %19 ]
  %24 = phi <2 x i64> [ %30, %22 ], [ zeroinitializer, %19 ]
  %25 = phi <2 x i64> [ %31, %22 ], [ zeroinitializer, %19 ]
  %26 = getelementptr inbounds i64, ptr %0, i64 %23
  %27 = load <2 x i64>, ptr %26, align 8, !tbaa !26
  %28 = getelementptr inbounds i64, ptr %26, i64 2
  %29 = load <2 x i64>, ptr %28, align 8, !tbaa !26
  %30 = add <2 x i64> %27, %24
  %31 = add <2 x i64> %29, %25
  %32 = add nuw i64 %23, 4
  %33 = icmp eq i64 %32, %17
  br i1 %33, label %34, label %22, !llvm.loop !391

34:                                               ; preds = %22
  %35 = add <2 x i64> %31, %30
  %36 = tail call i64 @llvm.vector.reduce.add.v2i64(<2 x i64> %35)
  br i1 %18, label %56, label %37

37:                                               ; preds = %19, %34
  %38 = phi i64 [ 0, %19 ], [ %17, %34 ]
  %39 = phi i64 [ 0, %19 ], [ %36, %34 ]
  br label %48

40:                                               ; preds = %56
  %41 = load i32, ptr @current_test, align 4, !tbaa !9
  %42 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %41)
  %43 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %44

44:                                               ; preds = %40, %56
  %45 = phi i32 [ %43, %40 ], [ %20, %56 ]
  %46 = add nuw nsw i32 %21, 1
  %47 = icmp slt i32 %46, %45
  br i1 %47, label %19, label %82, !llvm.loop !392

48:                                               ; preds = %37, %48
  %49 = phi i64 [ %54, %48 ], [ %38, %37 ]
  %50 = phi i64 [ %53, %48 ], [ %39, %37 ]
  %51 = getelementptr inbounds i64, ptr %0, i64 %49
  %52 = load i64, ptr %51, align 8, !tbaa !26
  %53 = add nsw i64 %52, %50
  %54 = add nuw nsw i64 %49, 1
  %55 = icmp eq i64 %54, %15
  br i1 %55, label %56, label %48, !llvm.loop !393

56:                                               ; preds = %48, %34
  %57 = phi i64 [ %36, %34 ], [ %53, %48 ]
  %58 = add nsw i64 %57, %11
  %59 = load double, ptr @init_value, align 8, !tbaa !28
  %60 = fptosi double %59 to i64
  %61 = add nsw i64 %60, %2
  %62 = mul nsw i64 %61, 8000
  %63 = icmp eq i64 %62, %58
  br i1 %63, label %44, label %40

64:                                               ; preds = %12, %77
  %65 = phi i32 [ %78, %77 ], [ %6, %12 ]
  %66 = phi double [ %79, %77 ], [ %13, %12 ]
  %67 = phi i32 [ %80, %77 ], [ 0, %12 ]
  %68 = fptosi double %66 to i64
  %69 = add nsw i64 %68, %2
  %70 = mul nsw i64 %69, 8000
  %71 = icmp eq i64 %70, %11
  br i1 %71, label %77, label %72

72:                                               ; preds = %64
  %73 = load i32, ptr @current_test, align 4, !tbaa !9
  %74 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %73)
  %75 = load double, ptr @init_value, align 8, !tbaa !28
  %76 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %77

77:                                               ; preds = %64, %72
  %78 = phi i32 [ %65, %64 ], [ %76, %72 ]
  %79 = phi double [ %66, %64 ], [ %75, %72 ]
  %80 = add nuw nsw i32 %67, 1
  %81 = icmp slt i32 %80, %78
  br i1 %81, label %64, label %82, !llvm.loop !392

82:                                               ; preds = %77, %44, %4
  %83 = tail call i64 @clock() #17
  store i64 %83, ptr @end_time, align 8, !tbaa !26
  %84 = load i64, ptr @start_time, align 8, !tbaa !26
  %85 = load ptr, ptr @results, align 8, !tbaa !5
  %86 = icmp eq ptr %85, null
  br i1 %86, label %87, label %89

87:                                               ; preds = %82
  %88 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %93

89:                                               ; preds = %82
  %90 = load i32, ptr @current_test, align 4, !tbaa !9
  %91 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %92 = icmp slt i32 %90, %91
  br i1 %92, label %105, label %93

93:                                               ; preds = %89, %87
  %94 = phi i32 [ %88, %87 ], [ %91, %89 ]
  %95 = add nsw i32 %94, 10
  store i32 %95, ptr @allocated_results, align 4, !tbaa !9
  %96 = sext i32 %95 to i64
  %97 = shl nsw i64 %96, 4
  %98 = tail call ptr @realloc(ptr noundef %85, i64 noundef %97) #14
  store ptr %98, ptr @results, align 8, !tbaa !5
  %99 = icmp eq ptr %98, null
  br i1 %99, label %102, label %100

100:                                              ; preds = %93
  %101 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %105

102:                                              ; preds = %93
  %103 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %104 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %103)
  tail call void @exit(i32 noundef -1) #15
  unreachable

105:                                              ; preds = %89, %100
  %106 = phi i32 [ %101, %100 ], [ %90, %89 ]
  %107 = phi ptr [ %98, %100 ], [ %85, %89 ]
  %108 = sub nsw i64 %83, %84
  %109 = sitofp i64 %108 to double
  %110 = fdiv double %109, 1.000000e+06
  %111 = sext i32 %106 to i64
  %112 = getelementptr inbounds %struct.one_result, ptr %107, i64 %111
  store double %110, ptr %112, align 8, !tbaa !11
  %113 = getelementptr inbounds %struct.one_result, ptr %107, i64 %111, i32 1
  store ptr %3, ptr %113, align 8, !tbaa !14
  %114 = add nsw i32 %106, 1
  store i32 %114, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Il28custom_add_multiple_variableIlEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i64 noundef %2, i64 noundef %3, i64 noundef %4, i64 noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !26
  %9 = load i32, ptr @iterations, align 4, !tbaa !9
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %91

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  %13 = add i64 %3, %2
  %14 = add i64 %13, %4
  %15 = add i64 %14, %5
  br i1 %12, label %18, label %16

16:                                               ; preds = %11
  %17 = load double, ptr @init_value, align 8, !tbaa !28
  br label %74

18:                                               ; preds = %11
  %19 = zext i32 %1 to i64
  %20 = icmp ult i32 %1, 4
  %21 = and i64 %19, 4294967292
  %22 = insertelement <2 x i64> poison, i64 %15, i64 0
  %23 = shufflevector <2 x i64> %22, <2 x i64> poison, <2 x i32> zeroinitializer
  %24 = insertelement <2 x i64> poison, i64 %15, i64 0
  %25 = shufflevector <2 x i64> %24, <2 x i64> poison, <2 x i32> zeroinitializer
  %26 = icmp eq i64 %21, %19
  br label %27

27:                                               ; preds = %18, %54
  %28 = phi i32 [ %55, %54 ], [ %9, %18 ]
  %29 = phi i32 [ %56, %54 ], [ 0, %18 ]
  br i1 %20, label %47, label %30

30:                                               ; preds = %27, %30
  %31 = phi i64 [ %42, %30 ], [ 0, %27 ]
  %32 = phi <2 x i64> [ %40, %30 ], [ zeroinitializer, %27 ]
  %33 = phi <2 x i64> [ %41, %30 ], [ zeroinitializer, %27 ]
  %34 = getelementptr inbounds i64, ptr %0, i64 %31
  %35 = load <2 x i64>, ptr %34, align 8, !tbaa !26
  %36 = getelementptr inbounds i64, ptr %34, i64 2
  %37 = load <2 x i64>, ptr %36, align 8, !tbaa !26
  %38 = add <2 x i64> %23, %32
  %39 = add <2 x i64> %25, %33
  %40 = add <2 x i64> %38, %35
  %41 = add <2 x i64> %39, %37
  %42 = add nuw i64 %31, 4
  %43 = icmp eq i64 %42, %21
  br i1 %43, label %44, label %30, !llvm.loop !394

44:                                               ; preds = %30
  %45 = add <2 x i64> %41, %40
  %46 = tail call i64 @llvm.vector.reduce.add.v2i64(<2 x i64> %45)
  br i1 %26, label %67, label %47

47:                                               ; preds = %27, %44
  %48 = phi i64 [ 0, %27 ], [ %21, %44 ]
  %49 = phi i64 [ 0, %27 ], [ %46, %44 ]
  br label %58

50:                                               ; preds = %67
  %51 = load i32, ptr @current_test, align 4, !tbaa !9
  %52 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %51)
  %53 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %54

54:                                               ; preds = %50, %67
  %55 = phi i32 [ %53, %50 ], [ %28, %67 ]
  %56 = add nuw nsw i32 %29, 1
  %57 = icmp slt i32 %56, %55
  br i1 %57, label %27, label %91, !llvm.loop !395

58:                                               ; preds = %47, %58
  %59 = phi i64 [ %65, %58 ], [ %48, %47 ]
  %60 = phi i64 [ %64, %58 ], [ %49, %47 ]
  %61 = getelementptr inbounds i64, ptr %0, i64 %59
  %62 = load i64, ptr %61, align 8, !tbaa !26
  %63 = add i64 %15, %60
  %64 = add i64 %63, %62
  %65 = add nuw nsw i64 %59, 1
  %66 = icmp eq i64 %65, %19
  br i1 %66, label %67, label %58, !llvm.loop !396

67:                                               ; preds = %58, %44
  %68 = phi i64 [ %46, %44 ], [ %64, %58 ]
  %69 = load double, ptr @init_value, align 8, !tbaa !28
  %70 = fptosi double %69 to i64
  %71 = add i64 %15, %70
  %72 = mul nsw i64 %71, 8000
  %73 = icmp eq i64 %72, %68
  br i1 %73, label %54, label %50

74:                                               ; preds = %16, %86
  %75 = phi i32 [ %87, %86 ], [ %9, %16 ]
  %76 = phi double [ %88, %86 ], [ %17, %16 ]
  %77 = phi i32 [ %89, %86 ], [ 0, %16 ]
  %78 = fptosi double %76 to i64
  %79 = sub i64 0, %78
  %80 = icmp eq i64 %15, %79
  br i1 %80, label %86, label %81

81:                                               ; preds = %74
  %82 = load i32, ptr @current_test, align 4, !tbaa !9
  %83 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %82)
  %84 = load double, ptr @init_value, align 8, !tbaa !28
  %85 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %86

86:                                               ; preds = %74, %81
  %87 = phi i32 [ %75, %74 ], [ %85, %81 ]
  %88 = phi double [ %76, %74 ], [ %84, %81 ]
  %89 = add nuw nsw i32 %77, 1
  %90 = icmp slt i32 %89, %87
  br i1 %90, label %74, label %91, !llvm.loop !395

91:                                               ; preds = %86, %54, %7
  %92 = tail call i64 @clock() #17
  store i64 %92, ptr @end_time, align 8, !tbaa !26
  %93 = load i64, ptr @start_time, align 8, !tbaa !26
  %94 = load ptr, ptr @results, align 8, !tbaa !5
  %95 = icmp eq ptr %94, null
  br i1 %95, label %96, label %98

96:                                               ; preds = %91
  %97 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %102

98:                                               ; preds = %91
  %99 = load i32, ptr @current_test, align 4, !tbaa !9
  %100 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %101 = icmp slt i32 %99, %100
  br i1 %101, label %114, label %102

102:                                              ; preds = %98, %96
  %103 = phi i32 [ %97, %96 ], [ %100, %98 ]
  %104 = add nsw i32 %103, 10
  store i32 %104, ptr @allocated_results, align 4, !tbaa !9
  %105 = sext i32 %104 to i64
  %106 = shl nsw i64 %105, 4
  %107 = tail call ptr @realloc(ptr noundef %94, i64 noundef %106) #14
  store ptr %107, ptr @results, align 8, !tbaa !5
  %108 = icmp eq ptr %107, null
  br i1 %108, label %111, label %109

109:                                              ; preds = %102
  %110 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %114

111:                                              ; preds = %102
  %112 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %113 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %112)
  tail call void @exit(i32 noundef -1) #15
  unreachable

114:                                              ; preds = %98, %109
  %115 = phi i32 [ %110, %109 ], [ %99, %98 ]
  %116 = phi ptr [ %107, %109 ], [ %94, %98 ]
  %117 = sub nsw i64 %92, %93
  %118 = sitofp i64 %117 to double
  %119 = fdiv double %118, 1.000000e+06
  %120 = sext i32 %115 to i64
  %121 = getelementptr inbounds %struct.one_result, ptr %116, i64 %120
  store double %119, ptr %121, align 8, !tbaa !11
  %122 = getelementptr inbounds %struct.one_result, ptr %116, i64 %120, i32 1
  store ptr %6, ptr %122, align 8, !tbaa !14
  %123 = add nsw i32 %115, 1
  store i32 %123, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1Il19custom_sub_variableIlEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i64 noundef %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !26
  %6 = load i32, ptr @iterations, align 4, !tbaa !9
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %84

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  br i1 %9, label %12, label %10

10:                                               ; preds = %8
  %11 = load double, ptr @init_value, align 8, !tbaa !28
  br label %68

12:                                               ; preds = %8
  %13 = zext i32 %1 to i64
  %14 = icmp ult i32 %1, 4
  %15 = and i64 %13, 4294967292
  %16 = insertelement <2 x i64> poison, i64 %2, i64 0
  %17 = shufflevector <2 x i64> %16, <2 x i64> poison, <2 x i32> zeroinitializer
  %18 = insertelement <2 x i64> poison, i64 %2, i64 0
  %19 = shufflevector <2 x i64> %18, <2 x i64> poison, <2 x i32> zeroinitializer
  %20 = icmp eq i64 %15, %13
  br label %21

21:                                               ; preds = %12, %48
  %22 = phi i32 [ %49, %48 ], [ %6, %12 ]
  %23 = phi i32 [ %50, %48 ], [ 0, %12 ]
  br i1 %14, label %41, label %24

24:                                               ; preds = %21, %24
  %25 = phi i64 [ %36, %24 ], [ 0, %21 ]
  %26 = phi <2 x i64> [ %34, %24 ], [ zeroinitializer, %21 ]
  %27 = phi <2 x i64> [ %35, %24 ], [ zeroinitializer, %21 ]
  %28 = getelementptr inbounds i64, ptr %0, i64 %25
  %29 = load <2 x i64>, ptr %28, align 8, !tbaa !26
  %30 = getelementptr inbounds i64, ptr %28, i64 2
  %31 = load <2 x i64>, ptr %30, align 8, !tbaa !26
  %32 = sub <2 x i64> %26, %17
  %33 = sub <2 x i64> %27, %19
  %34 = add <2 x i64> %32, %29
  %35 = add <2 x i64> %33, %31
  %36 = add nuw i64 %25, 4
  %37 = icmp eq i64 %36, %15
  br i1 %37, label %38, label %24, !llvm.loop !397

38:                                               ; preds = %24
  %39 = add <2 x i64> %35, %34
  %40 = tail call i64 @llvm.vector.reduce.add.v2i64(<2 x i64> %39)
  br i1 %20, label %61, label %41

41:                                               ; preds = %21, %38
  %42 = phi i64 [ 0, %21 ], [ %15, %38 ]
  %43 = phi i64 [ 0, %21 ], [ %40, %38 ]
  br label %52

44:                                               ; preds = %61
  %45 = load i32, ptr @current_test, align 4, !tbaa !9
  %46 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %45)
  %47 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %48

48:                                               ; preds = %44, %61
  %49 = phi i32 [ %47, %44 ], [ %22, %61 ]
  %50 = add nuw nsw i32 %23, 1
  %51 = icmp slt i32 %50, %49
  br i1 %51, label %21, label %84, !llvm.loop !398

52:                                               ; preds = %41, %52
  %53 = phi i64 [ %59, %52 ], [ %42, %41 ]
  %54 = phi i64 [ %58, %52 ], [ %43, %41 ]
  %55 = getelementptr inbounds i64, ptr %0, i64 %53
  %56 = load i64, ptr %55, align 8, !tbaa !26
  %57 = sub i64 %54, %2
  %58 = add i64 %57, %56
  %59 = add nuw nsw i64 %53, 1
  %60 = icmp eq i64 %59, %13
  br i1 %60, label %61, label %52, !llvm.loop !399

61:                                               ; preds = %52, %38
  %62 = phi i64 [ %40, %38 ], [ %58, %52 ]
  %63 = load double, ptr @init_value, align 8, !tbaa !28
  %64 = fptosi double %63 to i64
  %65 = sub nsw i64 %64, %2
  %66 = mul nsw i64 %65, 8000
  %67 = icmp eq i64 %66, %62
  br i1 %67, label %48, label %44

68:                                               ; preds = %10, %79
  %69 = phi i32 [ %80, %79 ], [ %6, %10 ]
  %70 = phi double [ %81, %79 ], [ %11, %10 ]
  %71 = phi i32 [ %82, %79 ], [ 0, %10 ]
  %72 = fptosi double %70 to i64
  %73 = icmp eq i64 %72, %2
  br i1 %73, label %79, label %74

74:                                               ; preds = %68
  %75 = load i32, ptr @current_test, align 4, !tbaa !9
  %76 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %75)
  %77 = load double, ptr @init_value, align 8, !tbaa !28
  %78 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %79

79:                                               ; preds = %68, %74
  %80 = phi i32 [ %69, %68 ], [ %78, %74 ]
  %81 = phi double [ %70, %68 ], [ %77, %74 ]
  %82 = add nuw nsw i32 %71, 1
  %83 = icmp slt i32 %82, %80
  br i1 %83, label %68, label %84, !llvm.loop !398

84:                                               ; preds = %79, %48, %4
  %85 = tail call i64 @clock() #17
  store i64 %85, ptr @end_time, align 8, !tbaa !26
  %86 = load i64, ptr @start_time, align 8, !tbaa !26
  %87 = load ptr, ptr @results, align 8, !tbaa !5
  %88 = icmp eq ptr %87, null
  br i1 %88, label %89, label %91

89:                                               ; preds = %84
  %90 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %95

91:                                               ; preds = %84
  %92 = load i32, ptr @current_test, align 4, !tbaa !9
  %93 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %94 = icmp slt i32 %92, %93
  br i1 %94, label %107, label %95

95:                                               ; preds = %91, %89
  %96 = phi i32 [ %90, %89 ], [ %93, %91 ]
  %97 = add nsw i32 %96, 10
  store i32 %97, ptr @allocated_results, align 4, !tbaa !9
  %98 = sext i32 %97 to i64
  %99 = shl nsw i64 %98, 4
  %100 = tail call ptr @realloc(ptr noundef %87, i64 noundef %99) #14
  store ptr %100, ptr @results, align 8, !tbaa !5
  %101 = icmp eq ptr %100, null
  br i1 %101, label %104, label %102

102:                                              ; preds = %95
  %103 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %107

104:                                              ; preds = %95
  %105 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %106 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %105)
  tail call void @exit(i32 noundef -1) #15
  unreachable

107:                                              ; preds = %91, %102
  %108 = phi i32 [ %103, %102 ], [ %92, %91 ]
  %109 = phi ptr [ %100, %102 ], [ %87, %91 ]
  %110 = sub nsw i64 %85, %86
  %111 = sitofp i64 %110 to double
  %112 = fdiv double %111, 1.000000e+06
  %113 = sext i32 %108 to i64
  %114 = getelementptr inbounds %struct.one_result, ptr %109, i64 %113
  store double %112, ptr %114, align 8, !tbaa !11
  %115 = getelementptr inbounds %struct.one_result, ptr %109, i64 %113, i32 1
  store ptr %3, ptr %115, align 8, !tbaa !14
  %116 = add nsw i32 %108, 1
  store i32 %116, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Il28custom_sub_multiple_variableIlEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i64 noundef %2, i64 noundef %3, i64 noundef %4, i64 noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !26
  %9 = load i32, ptr @iterations, align 4, !tbaa !9
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %90

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  %13 = add i64 %3, %2
  %14 = add i64 %13, %4
  %15 = add i64 %14, %5
  br i1 %12, label %18, label %16

16:                                               ; preds = %11
  %17 = load double, ptr @init_value, align 8, !tbaa !28
  br label %74

18:                                               ; preds = %11
  %19 = zext i32 %1 to i64
  %20 = icmp ult i32 %1, 4
  %21 = and i64 %19, 4294967292
  %22 = insertelement <2 x i64> poison, i64 %15, i64 0
  %23 = shufflevector <2 x i64> %22, <2 x i64> poison, <2 x i32> zeroinitializer
  %24 = insertelement <2 x i64> poison, i64 %15, i64 0
  %25 = shufflevector <2 x i64> %24, <2 x i64> poison, <2 x i32> zeroinitializer
  %26 = icmp eq i64 %21, %19
  br label %27

27:                                               ; preds = %18, %54
  %28 = phi i32 [ %55, %54 ], [ %9, %18 ]
  %29 = phi i32 [ %56, %54 ], [ 0, %18 ]
  br i1 %20, label %47, label %30

30:                                               ; preds = %27, %30
  %31 = phi i64 [ %42, %30 ], [ 0, %27 ]
  %32 = phi <2 x i64> [ %40, %30 ], [ zeroinitializer, %27 ]
  %33 = phi <2 x i64> [ %41, %30 ], [ zeroinitializer, %27 ]
  %34 = getelementptr inbounds i64, ptr %0, i64 %31
  %35 = load <2 x i64>, ptr %34, align 8, !tbaa !26
  %36 = getelementptr inbounds i64, ptr %34, i64 2
  %37 = load <2 x i64>, ptr %36, align 8, !tbaa !26
  %38 = sub <2 x i64> %32, %23
  %39 = sub <2 x i64> %33, %25
  %40 = add <2 x i64> %38, %35
  %41 = add <2 x i64> %39, %37
  %42 = add nuw i64 %31, 4
  %43 = icmp eq i64 %42, %21
  br i1 %43, label %44, label %30, !llvm.loop !400

44:                                               ; preds = %30
  %45 = add <2 x i64> %41, %40
  %46 = tail call i64 @llvm.vector.reduce.add.v2i64(<2 x i64> %45)
  br i1 %26, label %67, label %47

47:                                               ; preds = %27, %44
  %48 = phi i64 [ 0, %27 ], [ %21, %44 ]
  %49 = phi i64 [ 0, %27 ], [ %46, %44 ]
  br label %58

50:                                               ; preds = %67
  %51 = load i32, ptr @current_test, align 4, !tbaa !9
  %52 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %51)
  %53 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %54

54:                                               ; preds = %50, %67
  %55 = phi i32 [ %53, %50 ], [ %28, %67 ]
  %56 = add nuw nsw i32 %29, 1
  %57 = icmp slt i32 %56, %55
  br i1 %57, label %27, label %90, !llvm.loop !401

58:                                               ; preds = %47, %58
  %59 = phi i64 [ %65, %58 ], [ %48, %47 ]
  %60 = phi i64 [ %64, %58 ], [ %49, %47 ]
  %61 = getelementptr inbounds i64, ptr %0, i64 %59
  %62 = load i64, ptr %61, align 8, !tbaa !26
  %63 = sub i64 %60, %15
  %64 = add i64 %63, %62
  %65 = add nuw nsw i64 %59, 1
  %66 = icmp eq i64 %65, %19
  br i1 %66, label %67, label %58, !llvm.loop !402

67:                                               ; preds = %58, %44
  %68 = phi i64 [ %46, %44 ], [ %64, %58 ]
  %69 = load double, ptr @init_value, align 8, !tbaa !28
  %70 = fptosi double %69 to i64
  %71 = sub i64 %70, %15
  %72 = mul nsw i64 %71, 8000
  %73 = icmp eq i64 %72, %68
  br i1 %73, label %54, label %50

74:                                               ; preds = %16, %85
  %75 = phi i32 [ %86, %85 ], [ %9, %16 ]
  %76 = phi double [ %87, %85 ], [ %17, %16 ]
  %77 = phi i32 [ %88, %85 ], [ 0, %16 ]
  %78 = fptosi double %76 to i64
  %79 = icmp eq i64 %15, %78
  br i1 %79, label %85, label %80

80:                                               ; preds = %74
  %81 = load i32, ptr @current_test, align 4, !tbaa !9
  %82 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %81)
  %83 = load double, ptr @init_value, align 8, !tbaa !28
  %84 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %85

85:                                               ; preds = %74, %80
  %86 = phi i32 [ %75, %74 ], [ %84, %80 ]
  %87 = phi double [ %76, %74 ], [ %83, %80 ]
  %88 = add nuw nsw i32 %77, 1
  %89 = icmp slt i32 %88, %86
  br i1 %89, label %74, label %90, !llvm.loop !401

90:                                               ; preds = %85, %54, %7
  %91 = tail call i64 @clock() #17
  store i64 %91, ptr @end_time, align 8, !tbaa !26
  %92 = load i64, ptr @start_time, align 8, !tbaa !26
  %93 = load ptr, ptr @results, align 8, !tbaa !5
  %94 = icmp eq ptr %93, null
  br i1 %94, label %95, label %97

95:                                               ; preds = %90
  %96 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %101

97:                                               ; preds = %90
  %98 = load i32, ptr @current_test, align 4, !tbaa !9
  %99 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %100 = icmp slt i32 %98, %99
  br i1 %100, label %113, label %101

101:                                              ; preds = %97, %95
  %102 = phi i32 [ %96, %95 ], [ %99, %97 ]
  %103 = add nsw i32 %102, 10
  store i32 %103, ptr @allocated_results, align 4, !tbaa !9
  %104 = sext i32 %103 to i64
  %105 = shl nsw i64 %104, 4
  %106 = tail call ptr @realloc(ptr noundef %93, i64 noundef %105) #14
  store ptr %106, ptr @results, align 8, !tbaa !5
  %107 = icmp eq ptr %106, null
  br i1 %107, label %110, label %108

108:                                              ; preds = %101
  %109 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %113

110:                                              ; preds = %101
  %111 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %112 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %111)
  tail call void @exit(i32 noundef -1) #15
  unreachable

113:                                              ; preds = %97, %108
  %114 = phi i32 [ %109, %108 ], [ %98, %97 ]
  %115 = phi ptr [ %106, %108 ], [ %93, %97 ]
  %116 = sub nsw i64 %91, %92
  %117 = sitofp i64 %116 to double
  %118 = fdiv double %117, 1.000000e+06
  %119 = sext i32 %114 to i64
  %120 = getelementptr inbounds %struct.one_result, ptr %115, i64 %119
  store double %118, ptr %120, align 8, !tbaa !11
  %121 = getelementptr inbounds %struct.one_result, ptr %115, i64 %119, i32 1
  store ptr %6, ptr %121, align 8, !tbaa !14
  %122 = add nsw i32 %114, 1
  store i32 %122, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1Il24custom_multiply_variableIlEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i64 noundef %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !26
  %6 = load i32, ptr @iterations, align 4, !tbaa !9
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %94

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  %10 = mul i64 %2, 8000
  br i1 %9, label %13, label %11

11:                                               ; preds = %8
  %12 = load double, ptr @init_value, align 8, !tbaa !28
  br label %77

13:                                               ; preds = %8
  %14 = zext i32 %1 to i64
  %15 = and i64 %14, 3
  %16 = icmp ult i32 %1, 4
  %17 = and i64 %14, 4294967292
  %18 = icmp eq i64 %15, 0
  br label %19

19:                                               ; preds = %13, %26
  %20 = phi i32 [ %27, %26 ], [ %6, %13 ]
  %21 = phi i32 [ %28, %26 ], [ 0, %13 ]
  br i1 %16, label %56, label %30

22:                                               ; preds = %71
  %23 = load i32, ptr @current_test, align 4, !tbaa !9
  %24 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %23)
  %25 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %26

26:                                               ; preds = %22, %71
  %27 = phi i32 [ %25, %22 ], [ %20, %71 ]
  %28 = add nuw nsw i32 %21, 1
  %29 = icmp slt i32 %28, %27
  br i1 %29, label %19, label %94, !llvm.loop !403

30:                                               ; preds = %19, %30
  %31 = phi i64 [ %53, %30 ], [ 0, %19 ]
  %32 = phi i64 [ %52, %30 ], [ 0, %19 ]
  %33 = phi i64 [ %54, %30 ], [ 0, %19 ]
  %34 = getelementptr inbounds i64, ptr %0, i64 %31
  %35 = load i64, ptr %34, align 8, !tbaa !26
  %36 = mul nsw i64 %35, %2
  %37 = add nsw i64 %36, %32
  %38 = or i64 %31, 1
  %39 = getelementptr inbounds i64, ptr %0, i64 %38
  %40 = load i64, ptr %39, align 8, !tbaa !26
  %41 = mul nsw i64 %40, %2
  %42 = add nsw i64 %41, %37
  %43 = or i64 %31, 2
  %44 = getelementptr inbounds i64, ptr %0, i64 %43
  %45 = load i64, ptr %44, align 8, !tbaa !26
  %46 = mul nsw i64 %45, %2
  %47 = add nsw i64 %46, %42
  %48 = or i64 %31, 3
  %49 = getelementptr inbounds i64, ptr %0, i64 %48
  %50 = load i64, ptr %49, align 8, !tbaa !26
  %51 = mul nsw i64 %50, %2
  %52 = add nsw i64 %51, %47
  %53 = add nuw nsw i64 %31, 4
  %54 = add i64 %33, 4
  %55 = icmp eq i64 %54, %17
  br i1 %55, label %56, label %30, !llvm.loop !404

56:                                               ; preds = %30, %19
  %57 = phi i64 [ undef, %19 ], [ %52, %30 ]
  %58 = phi i64 [ 0, %19 ], [ %53, %30 ]
  %59 = phi i64 [ 0, %19 ], [ %52, %30 ]
  br i1 %18, label %71, label %60

60:                                               ; preds = %56, %60
  %61 = phi i64 [ %68, %60 ], [ %58, %56 ]
  %62 = phi i64 [ %67, %60 ], [ %59, %56 ]
  %63 = phi i64 [ %69, %60 ], [ 0, %56 ]
  %64 = getelementptr inbounds i64, ptr %0, i64 %61
  %65 = load i64, ptr %64, align 8, !tbaa !26
  %66 = mul nsw i64 %65, %2
  %67 = add nsw i64 %66, %62
  %68 = add nuw nsw i64 %61, 1
  %69 = add i64 %63, 1
  %70 = icmp eq i64 %69, %15
  br i1 %70, label %71, label %60, !llvm.loop !405

71:                                               ; preds = %60, %56
  %72 = phi i64 [ %57, %56 ], [ %67, %60 ]
  %73 = load double, ptr @init_value, align 8, !tbaa !28
  %74 = fptosi double %73 to i64
  %75 = mul i64 %10, %74
  %76 = icmp eq i64 %75, %72
  br i1 %76, label %26, label %22

77:                                               ; preds = %11, %89
  %78 = phi i32 [ %90, %89 ], [ %6, %11 ]
  %79 = phi double [ %91, %89 ], [ %12, %11 ]
  %80 = phi i32 [ %92, %89 ], [ 0, %11 ]
  %81 = fptosi double %79 to i64
  %82 = mul i64 %10, %81
  %83 = icmp eq i64 %82, 0
  br i1 %83, label %89, label %84

84:                                               ; preds = %77
  %85 = load i32, ptr @current_test, align 4, !tbaa !9
  %86 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %85)
  %87 = load double, ptr @init_value, align 8, !tbaa !28
  %88 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %89

89:                                               ; preds = %77, %84
  %90 = phi i32 [ %78, %77 ], [ %88, %84 ]
  %91 = phi double [ %79, %77 ], [ %87, %84 ]
  %92 = add nuw nsw i32 %80, 1
  %93 = icmp slt i32 %92, %90
  br i1 %93, label %77, label %94, !llvm.loop !403

94:                                               ; preds = %89, %26, %4
  %95 = tail call i64 @clock() #17
  store i64 %95, ptr @end_time, align 8, !tbaa !26
  %96 = load i64, ptr @start_time, align 8, !tbaa !26
  %97 = load ptr, ptr @results, align 8, !tbaa !5
  %98 = icmp eq ptr %97, null
  br i1 %98, label %99, label %101

99:                                               ; preds = %94
  %100 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %105

101:                                              ; preds = %94
  %102 = load i32, ptr @current_test, align 4, !tbaa !9
  %103 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %104 = icmp slt i32 %102, %103
  br i1 %104, label %117, label %105

105:                                              ; preds = %101, %99
  %106 = phi i32 [ %100, %99 ], [ %103, %101 ]
  %107 = add nsw i32 %106, 10
  store i32 %107, ptr @allocated_results, align 4, !tbaa !9
  %108 = sext i32 %107 to i64
  %109 = shl nsw i64 %108, 4
  %110 = tail call ptr @realloc(ptr noundef %97, i64 noundef %109) #14
  store ptr %110, ptr @results, align 8, !tbaa !5
  %111 = icmp eq ptr %110, null
  br i1 %111, label %114, label %112

112:                                              ; preds = %105
  %113 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %117

114:                                              ; preds = %105
  %115 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %116 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %115)
  tail call void @exit(i32 noundef -1) #15
  unreachable

117:                                              ; preds = %101, %112
  %118 = phi i32 [ %113, %112 ], [ %102, %101 ]
  %119 = phi ptr [ %110, %112 ], [ %97, %101 ]
  %120 = sub nsw i64 %95, %96
  %121 = sitofp i64 %120 to double
  %122 = fdiv double %121, 1.000000e+06
  %123 = sext i32 %118 to i64
  %124 = getelementptr inbounds %struct.one_result, ptr %119, i64 %123
  store double %122, ptr %124, align 8, !tbaa !11
  %125 = getelementptr inbounds %struct.one_result, ptr %119, i64 %123, i32 1
  store ptr %3, ptr %125, align 8, !tbaa !14
  %126 = add nsw i32 %118, 1
  store i32 %126, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Il33custom_multiply_multiple_variableIlEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i64 noundef %2, i64 noundef %3, i64 noundef %4, i64 noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !26
  %9 = load i32, ptr @iterations, align 4, !tbaa !9
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %102

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  %13 = mul i64 %3, %2
  %14 = mul i64 %13, %4
  %15 = mul i64 %14, %5
  %16 = mul i64 %13, 8000
  %17 = mul i64 %16, %4
  %18 = mul i64 %17, %5
  br i1 %12, label %21, label %19

19:                                               ; preds = %11
  %20 = load double, ptr @init_value, align 8, !tbaa !28
  br label %85

21:                                               ; preds = %11
  %22 = zext i32 %1 to i64
  %23 = and i64 %22, 3
  %24 = icmp ult i32 %1, 4
  %25 = and i64 %22, 4294967292
  %26 = icmp eq i64 %23, 0
  br label %27

27:                                               ; preds = %21, %34
  %28 = phi i32 [ %35, %34 ], [ %9, %21 ]
  %29 = phi i32 [ %36, %34 ], [ 0, %21 ]
  br i1 %24, label %64, label %38

30:                                               ; preds = %79
  %31 = load i32, ptr @current_test, align 4, !tbaa !9
  %32 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %31)
  %33 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %34

34:                                               ; preds = %30, %79
  %35 = phi i32 [ %33, %30 ], [ %28, %79 ]
  %36 = add nuw nsw i32 %29, 1
  %37 = icmp slt i32 %36, %35
  br i1 %37, label %27, label %102, !llvm.loop !406

38:                                               ; preds = %27, %38
  %39 = phi i64 [ %61, %38 ], [ 0, %27 ]
  %40 = phi i64 [ %60, %38 ], [ 0, %27 ]
  %41 = phi i64 [ %62, %38 ], [ 0, %27 ]
  %42 = getelementptr inbounds i64, ptr %0, i64 %39
  %43 = load i64, ptr %42, align 8, !tbaa !26
  %44 = mul i64 %15, %43
  %45 = add nsw i64 %44, %40
  %46 = or i64 %39, 1
  %47 = getelementptr inbounds i64, ptr %0, i64 %46
  %48 = load i64, ptr %47, align 8, !tbaa !26
  %49 = mul i64 %15, %48
  %50 = add nsw i64 %49, %45
  %51 = or i64 %39, 2
  %52 = getelementptr inbounds i64, ptr %0, i64 %51
  %53 = load i64, ptr %52, align 8, !tbaa !26
  %54 = mul i64 %15, %53
  %55 = add nsw i64 %54, %50
  %56 = or i64 %39, 3
  %57 = getelementptr inbounds i64, ptr %0, i64 %56
  %58 = load i64, ptr %57, align 8, !tbaa !26
  %59 = mul i64 %15, %58
  %60 = add nsw i64 %59, %55
  %61 = add nuw nsw i64 %39, 4
  %62 = add i64 %41, 4
  %63 = icmp eq i64 %62, %25
  br i1 %63, label %64, label %38, !llvm.loop !407

64:                                               ; preds = %38, %27
  %65 = phi i64 [ undef, %27 ], [ %60, %38 ]
  %66 = phi i64 [ 0, %27 ], [ %61, %38 ]
  %67 = phi i64 [ 0, %27 ], [ %60, %38 ]
  br i1 %26, label %79, label %68

68:                                               ; preds = %64, %68
  %69 = phi i64 [ %76, %68 ], [ %66, %64 ]
  %70 = phi i64 [ %75, %68 ], [ %67, %64 ]
  %71 = phi i64 [ %77, %68 ], [ 0, %64 ]
  %72 = getelementptr inbounds i64, ptr %0, i64 %69
  %73 = load i64, ptr %72, align 8, !tbaa !26
  %74 = mul i64 %15, %73
  %75 = add nsw i64 %74, %70
  %76 = add nuw nsw i64 %69, 1
  %77 = add i64 %71, 1
  %78 = icmp eq i64 %77, %23
  br i1 %78, label %79, label %68, !llvm.loop !408

79:                                               ; preds = %68, %64
  %80 = phi i64 [ %65, %64 ], [ %75, %68 ]
  %81 = load double, ptr @init_value, align 8, !tbaa !28
  %82 = fptosi double %81 to i64
  %83 = mul i64 %18, %82
  %84 = icmp eq i64 %83, %80
  br i1 %84, label %34, label %30

85:                                               ; preds = %19, %97
  %86 = phi i32 [ %98, %97 ], [ %9, %19 ]
  %87 = phi double [ %99, %97 ], [ %20, %19 ]
  %88 = phi i32 [ %100, %97 ], [ 0, %19 ]
  %89 = fptosi double %87 to i64
  %90 = mul i64 %18, %89
  %91 = icmp eq i64 %90, 0
  br i1 %91, label %97, label %92

92:                                               ; preds = %85
  %93 = load i32, ptr @current_test, align 4, !tbaa !9
  %94 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %93)
  %95 = load double, ptr @init_value, align 8, !tbaa !28
  %96 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %97

97:                                               ; preds = %85, %92
  %98 = phi i32 [ %86, %85 ], [ %96, %92 ]
  %99 = phi double [ %87, %85 ], [ %95, %92 ]
  %100 = add nuw nsw i32 %88, 1
  %101 = icmp slt i32 %100, %98
  br i1 %101, label %85, label %102, !llvm.loop !406

102:                                              ; preds = %97, %34, %7
  %103 = tail call i64 @clock() #17
  store i64 %103, ptr @end_time, align 8, !tbaa !26
  %104 = load i64, ptr @start_time, align 8, !tbaa !26
  %105 = load ptr, ptr @results, align 8, !tbaa !5
  %106 = icmp eq ptr %105, null
  br i1 %106, label %107, label %109

107:                                              ; preds = %102
  %108 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %113

109:                                              ; preds = %102
  %110 = load i32, ptr @current_test, align 4, !tbaa !9
  %111 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %112 = icmp slt i32 %110, %111
  br i1 %112, label %125, label %113

113:                                              ; preds = %109, %107
  %114 = phi i32 [ %108, %107 ], [ %111, %109 ]
  %115 = add nsw i32 %114, 10
  store i32 %115, ptr @allocated_results, align 4, !tbaa !9
  %116 = sext i32 %115 to i64
  %117 = shl nsw i64 %116, 4
  %118 = tail call ptr @realloc(ptr noundef %105, i64 noundef %117) #14
  store ptr %118, ptr @results, align 8, !tbaa !5
  %119 = icmp eq ptr %118, null
  br i1 %119, label %122, label %120

120:                                              ; preds = %113
  %121 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %125

122:                                              ; preds = %113
  %123 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %124 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %123)
  tail call void @exit(i32 noundef -1) #15
  unreachable

125:                                              ; preds = %109, %120
  %126 = phi i32 [ %121, %120 ], [ %110, %109 ]
  %127 = phi ptr [ %118, %120 ], [ %105, %109 ]
  %128 = sub nsw i64 %103, %104
  %129 = sitofp i64 %128 to double
  %130 = fdiv double %129, 1.000000e+06
  %131 = sext i32 %126 to i64
  %132 = getelementptr inbounds %struct.one_result, ptr %127, i64 %131
  store double %130, ptr %132, align 8, !tbaa !11
  %133 = getelementptr inbounds %struct.one_result, ptr %127, i64 %131, i32 1
  store ptr %6, ptr %133, align 8, !tbaa !14
  %134 = add nsw i32 %126, 1
  store i32 %134, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Il34custom_multiply_multiple_variable2IlEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i64 noundef %2, i64 noundef %3, i64 noundef %4, i64 noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !26
  %9 = load i32, ptr @iterations, align 4, !tbaa !9
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %91

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  %13 = mul nsw i64 %3, %2
  %14 = mul nsw i64 %13, %4
  %15 = mul nsw i64 %14, %5
  br i1 %12, label %18, label %16

16:                                               ; preds = %11
  %17 = load double, ptr @init_value, align 8, !tbaa !28
  br label %74

18:                                               ; preds = %11
  %19 = zext i32 %1 to i64
  %20 = icmp ult i32 %1, 4
  %21 = and i64 %19, 4294967292
  %22 = insertelement <2 x i64> poison, i64 %15, i64 0
  %23 = shufflevector <2 x i64> %22, <2 x i64> poison, <2 x i32> zeroinitializer
  %24 = insertelement <2 x i64> poison, i64 %15, i64 0
  %25 = shufflevector <2 x i64> %24, <2 x i64> poison, <2 x i32> zeroinitializer
  %26 = icmp eq i64 %21, %19
  br label %27

27:                                               ; preds = %18, %54
  %28 = phi i32 [ %55, %54 ], [ %9, %18 ]
  %29 = phi i32 [ %56, %54 ], [ 0, %18 ]
  br i1 %20, label %47, label %30

30:                                               ; preds = %27, %30
  %31 = phi i64 [ %42, %30 ], [ 0, %27 ]
  %32 = phi <2 x i64> [ %40, %30 ], [ zeroinitializer, %27 ]
  %33 = phi <2 x i64> [ %41, %30 ], [ zeroinitializer, %27 ]
  %34 = getelementptr inbounds i64, ptr %0, i64 %31
  %35 = load <2 x i64>, ptr %34, align 8, !tbaa !26
  %36 = getelementptr inbounds i64, ptr %34, i64 2
  %37 = load <2 x i64>, ptr %36, align 8, !tbaa !26
  %38 = add <2 x i64> %32, %23
  %39 = add <2 x i64> %33, %25
  %40 = add <2 x i64> %38, %35
  %41 = add <2 x i64> %39, %37
  %42 = add nuw i64 %31, 4
  %43 = icmp eq i64 %42, %21
  br i1 %43, label %44, label %30, !llvm.loop !409

44:                                               ; preds = %30
  %45 = add <2 x i64> %41, %40
  %46 = tail call i64 @llvm.vector.reduce.add.v2i64(<2 x i64> %45)
  br i1 %26, label %67, label %47

47:                                               ; preds = %27, %44
  %48 = phi i64 [ 0, %27 ], [ %21, %44 ]
  %49 = phi i64 [ 0, %27 ], [ %46, %44 ]
  br label %58

50:                                               ; preds = %67
  %51 = load i32, ptr @current_test, align 4, !tbaa !9
  %52 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %51)
  %53 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %54

54:                                               ; preds = %50, %67
  %55 = phi i32 [ %53, %50 ], [ %28, %67 ]
  %56 = add nuw nsw i32 %29, 1
  %57 = icmp slt i32 %56, %55
  br i1 %57, label %27, label %91, !llvm.loop !410

58:                                               ; preds = %47, %58
  %59 = phi i64 [ %65, %58 ], [ %48, %47 ]
  %60 = phi i64 [ %64, %58 ], [ %49, %47 ]
  %61 = getelementptr inbounds i64, ptr %0, i64 %59
  %62 = load i64, ptr %61, align 8, !tbaa !26
  %63 = add i64 %60, %15
  %64 = add i64 %63, %62
  %65 = add nuw nsw i64 %59, 1
  %66 = icmp eq i64 %65, %19
  br i1 %66, label %67, label %58, !llvm.loop !411

67:                                               ; preds = %58, %44
  %68 = phi i64 [ %46, %44 ], [ %64, %58 ]
  %69 = load double, ptr @init_value, align 8, !tbaa !28
  %70 = fptosi double %69 to i64
  %71 = add nsw i64 %15, %70
  %72 = mul nsw i64 %71, 8000
  %73 = icmp eq i64 %72, %68
  br i1 %73, label %54, label %50

74:                                               ; preds = %16, %86
  %75 = phi i32 [ %87, %86 ], [ %9, %16 ]
  %76 = phi double [ %88, %86 ], [ %17, %16 ]
  %77 = phi i32 [ %89, %86 ], [ 0, %16 ]
  %78 = fptosi double %76 to i64
  %79 = sub i64 0, %78
  %80 = icmp eq i64 %15, %79
  br i1 %80, label %86, label %81

81:                                               ; preds = %74
  %82 = load i32, ptr @current_test, align 4, !tbaa !9
  %83 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %82)
  %84 = load double, ptr @init_value, align 8, !tbaa !28
  %85 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %86

86:                                               ; preds = %74, %81
  %87 = phi i32 [ %75, %74 ], [ %85, %81 ]
  %88 = phi double [ %76, %74 ], [ %84, %81 ]
  %89 = add nuw nsw i32 %77, 1
  %90 = icmp slt i32 %89, %87
  br i1 %90, label %74, label %91, !llvm.loop !410

91:                                               ; preds = %86, %54, %7
  %92 = tail call i64 @clock() #17
  store i64 %92, ptr @end_time, align 8, !tbaa !26
  %93 = load i64, ptr @start_time, align 8, !tbaa !26
  %94 = load ptr, ptr @results, align 8, !tbaa !5
  %95 = icmp eq ptr %94, null
  br i1 %95, label %96, label %98

96:                                               ; preds = %91
  %97 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %102

98:                                               ; preds = %91
  %99 = load i32, ptr @current_test, align 4, !tbaa !9
  %100 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %101 = icmp slt i32 %99, %100
  br i1 %101, label %114, label %102

102:                                              ; preds = %98, %96
  %103 = phi i32 [ %97, %96 ], [ %100, %98 ]
  %104 = add nsw i32 %103, 10
  store i32 %104, ptr @allocated_results, align 4, !tbaa !9
  %105 = sext i32 %104 to i64
  %106 = shl nsw i64 %105, 4
  %107 = tail call ptr @realloc(ptr noundef %94, i64 noundef %106) #14
  store ptr %107, ptr @results, align 8, !tbaa !5
  %108 = icmp eq ptr %107, null
  br i1 %108, label %111, label %109

109:                                              ; preds = %102
  %110 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %114

111:                                              ; preds = %102
  %112 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %113 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %112)
  tail call void @exit(i32 noundef -1) #15
  unreachable

114:                                              ; preds = %98, %109
  %115 = phi i32 [ %110, %109 ], [ %99, %98 ]
  %116 = phi ptr [ %107, %109 ], [ %94, %98 ]
  %117 = sub nsw i64 %92, %93
  %118 = sitofp i64 %117 to double
  %119 = fdiv double %118, 1.000000e+06
  %120 = sext i32 %115 to i64
  %121 = getelementptr inbounds %struct.one_result, ptr %116, i64 %120
  store double %119, ptr %121, align 8, !tbaa !11
  %122 = getelementptr inbounds %struct.one_result, ptr %116, i64 %120, i32 1
  store ptr %6, ptr %122, align 8, !tbaa !14
  %123 = add nsw i32 %115, 1
  store i32 %123, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1Il22custom_divide_variableIlEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i64 noundef %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !26
  %6 = load i32, ptr @iterations, align 4, !tbaa !9
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %78

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  br i1 %9, label %12, label %10

10:                                               ; preds = %8
  %11 = load double, ptr @init_value, align 8, !tbaa !28
  br label %61

12:                                               ; preds = %8
  %13 = zext i32 %1 to i64
  %14 = and i64 %13, 1
  %15 = icmp eq i32 %1, 1
  %16 = and i64 %13, 4294967294
  %17 = icmp eq i64 %14, 0
  br label %18

18:                                               ; preds = %12, %25
  %19 = phi i32 [ %26, %25 ], [ %6, %12 ]
  %20 = phi i32 [ %27, %25 ], [ 0, %12 ]
  br i1 %15, label %45, label %29

21:                                               ; preds = %54
  %22 = load i32, ptr @current_test, align 4, !tbaa !9
  %23 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %22)
  %24 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %25

25:                                               ; preds = %21, %54
  %26 = phi i32 [ %24, %21 ], [ %19, %54 ]
  %27 = add nuw nsw i32 %20, 1
  %28 = icmp slt i32 %27, %26
  br i1 %28, label %18, label %78, !llvm.loop !412

29:                                               ; preds = %18, %29
  %30 = phi i64 [ %42, %29 ], [ 0, %18 ]
  %31 = phi i64 [ %41, %29 ], [ 0, %18 ]
  %32 = phi i64 [ %43, %29 ], [ 0, %18 ]
  %33 = getelementptr inbounds i64, ptr %0, i64 %30
  %34 = load i64, ptr %33, align 8, !tbaa !26
  %35 = sdiv i64 %34, %2
  %36 = add nsw i64 %35, %31
  %37 = or i64 %30, 1
  %38 = getelementptr inbounds i64, ptr %0, i64 %37
  %39 = load i64, ptr %38, align 8, !tbaa !26
  %40 = sdiv i64 %39, %2
  %41 = add nsw i64 %40, %36
  %42 = add nuw nsw i64 %30, 2
  %43 = add i64 %32, 2
  %44 = icmp eq i64 %43, %16
  br i1 %44, label %45, label %29, !llvm.loop !413

45:                                               ; preds = %29, %18
  %46 = phi i64 [ undef, %18 ], [ %41, %29 ]
  %47 = phi i64 [ 0, %18 ], [ %42, %29 ]
  %48 = phi i64 [ 0, %18 ], [ %41, %29 ]
  br i1 %17, label %54, label %49

49:                                               ; preds = %45
  %50 = getelementptr inbounds i64, ptr %0, i64 %47
  %51 = load i64, ptr %50, align 8, !tbaa !26
  %52 = sdiv i64 %51, %2
  %53 = add nsw i64 %52, %48
  br label %54

54:                                               ; preds = %45, %49
  %55 = phi i64 [ %46, %45 ], [ %53, %49 ]
  %56 = load double, ptr @init_value, align 8, !tbaa !28
  %57 = fptosi double %56 to i64
  %58 = sdiv i64 %57, %2
  %59 = mul nsw i64 %58, 8000
  %60 = icmp eq i64 %59, %55
  br i1 %60, label %25, label %21

61:                                               ; preds = %10, %73
  %62 = phi i32 [ %74, %73 ], [ %6, %10 ]
  %63 = phi double [ %75, %73 ], [ %11, %10 ]
  %64 = phi i32 [ %76, %73 ], [ 0, %10 ]
  %65 = fptosi double %63 to i64
  %66 = sdiv i64 %65, %2
  %67 = icmp eq i64 %66, 0
  br i1 %67, label %73, label %68

68:                                               ; preds = %61
  %69 = load i32, ptr @current_test, align 4, !tbaa !9
  %70 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %69)
  %71 = load double, ptr @init_value, align 8, !tbaa !28
  %72 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %73

73:                                               ; preds = %61, %68
  %74 = phi i32 [ %62, %61 ], [ %72, %68 ]
  %75 = phi double [ %63, %61 ], [ %71, %68 ]
  %76 = add nuw nsw i32 %64, 1
  %77 = icmp slt i32 %76, %74
  br i1 %77, label %61, label %78, !llvm.loop !412

78:                                               ; preds = %73, %25, %4
  %79 = tail call i64 @clock() #17
  store i64 %79, ptr @end_time, align 8, !tbaa !26
  %80 = load i64, ptr @start_time, align 8, !tbaa !26
  %81 = load ptr, ptr @results, align 8, !tbaa !5
  %82 = icmp eq ptr %81, null
  br i1 %82, label %83, label %85

83:                                               ; preds = %78
  %84 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %89

85:                                               ; preds = %78
  %86 = load i32, ptr @current_test, align 4, !tbaa !9
  %87 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %88 = icmp slt i32 %86, %87
  br i1 %88, label %101, label %89

89:                                               ; preds = %85, %83
  %90 = phi i32 [ %84, %83 ], [ %87, %85 ]
  %91 = add nsw i32 %90, 10
  store i32 %91, ptr @allocated_results, align 4, !tbaa !9
  %92 = sext i32 %91 to i64
  %93 = shl nsw i64 %92, 4
  %94 = tail call ptr @realloc(ptr noundef %81, i64 noundef %93) #14
  store ptr %94, ptr @results, align 8, !tbaa !5
  %95 = icmp eq ptr %94, null
  br i1 %95, label %98, label %96

96:                                               ; preds = %89
  %97 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %101

98:                                               ; preds = %89
  %99 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %100 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %99)
  tail call void @exit(i32 noundef -1) #15
  unreachable

101:                                              ; preds = %85, %96
  %102 = phi i32 [ %97, %96 ], [ %86, %85 ]
  %103 = phi ptr [ %94, %96 ], [ %81, %85 ]
  %104 = sub nsw i64 %79, %80
  %105 = sitofp i64 %104 to double
  %106 = fdiv double %105, 1.000000e+06
  %107 = sext i32 %102 to i64
  %108 = getelementptr inbounds %struct.one_result, ptr %103, i64 %107
  store double %106, ptr %108, align 8, !tbaa !11
  %109 = getelementptr inbounds %struct.one_result, ptr %103, i64 %107, i32 1
  store ptr %3, ptr %109, align 8, !tbaa !14
  %110 = add nsw i32 %102, 1
  store i32 %110, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Il31custom_divide_multiple_variableIlEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i64 noundef %2, i64 noundef %3, i64 noundef %4, i64 noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !26
  %9 = load i32, ptr @iterations, align 4, !tbaa !9
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %69

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  br i1 %12, label %15, label %13

13:                                               ; preds = %11
  %14 = load double, ptr @init_value, align 8, !tbaa !28
  br label %49

15:                                               ; preds = %11
  %16 = zext i32 %1 to i64
  br label %17

17:                                               ; preds = %15, %24
  %18 = phi i32 [ %25, %24 ], [ %9, %15 ]
  %19 = phi i32 [ %26, %24 ], [ 0, %15 ]
  br label %28

20:                                               ; preds = %40
  %21 = load i32, ptr @current_test, align 4, !tbaa !9
  %22 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %21)
  %23 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %24

24:                                               ; preds = %20, %40
  %25 = phi i32 [ %23, %20 ], [ %18, %40 ]
  %26 = add nuw nsw i32 %19, 1
  %27 = icmp slt i32 %26, %25
  br i1 %27, label %17, label %69, !llvm.loop !414

28:                                               ; preds = %17, %28
  %29 = phi i64 [ 0, %17 ], [ %38, %28 ]
  %30 = phi i64 [ 0, %17 ], [ %37, %28 ]
  %31 = getelementptr inbounds i64, ptr %0, i64 %29
  %32 = load i64, ptr %31, align 8, !tbaa !26
  %33 = sdiv i64 %32, %2
  %34 = sdiv i64 %33, %3
  %35 = sdiv i64 %34, %4
  %36 = sdiv i64 %35, %5
  %37 = add nsw i64 %36, %30
  %38 = add nuw nsw i64 %29, 1
  %39 = icmp eq i64 %38, %16
  br i1 %39, label %40, label %28, !llvm.loop !415

40:                                               ; preds = %28
  %41 = load double, ptr @init_value, align 8, !tbaa !28
  %42 = fptosi double %41 to i64
  %43 = sdiv i64 %42, %2
  %44 = sdiv i64 %43, %3
  %45 = sdiv i64 %44, %4
  %46 = sdiv i64 %45, %5
  %47 = mul nsw i64 %46, 8000
  %48 = icmp eq i64 %47, %37
  br i1 %48, label %24, label %20

49:                                               ; preds = %13, %64
  %50 = phi i32 [ %65, %64 ], [ %9, %13 ]
  %51 = phi double [ %66, %64 ], [ %14, %13 ]
  %52 = phi i32 [ %67, %64 ], [ 0, %13 ]
  %53 = fptosi double %51 to i64
  %54 = sdiv i64 %53, %2
  %55 = sdiv i64 %54, %3
  %56 = sdiv i64 %55, %4
  %57 = sdiv i64 %56, %5
  %58 = icmp eq i64 %57, 0
  br i1 %58, label %64, label %59

59:                                               ; preds = %49
  %60 = load i32, ptr @current_test, align 4, !tbaa !9
  %61 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %60)
  %62 = load double, ptr @init_value, align 8, !tbaa !28
  %63 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %64

64:                                               ; preds = %49, %59
  %65 = phi i32 [ %50, %49 ], [ %63, %59 ]
  %66 = phi double [ %51, %49 ], [ %62, %59 ]
  %67 = add nuw nsw i32 %52, 1
  %68 = icmp slt i32 %67, %65
  br i1 %68, label %49, label %69, !llvm.loop !414

69:                                               ; preds = %64, %24, %7
  %70 = tail call i64 @clock() #17
  store i64 %70, ptr @end_time, align 8, !tbaa !26
  %71 = load i64, ptr @start_time, align 8, !tbaa !26
  %72 = load ptr, ptr @results, align 8, !tbaa !5
  %73 = icmp eq ptr %72, null
  br i1 %73, label %74, label %76

74:                                               ; preds = %69
  %75 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %80

76:                                               ; preds = %69
  %77 = load i32, ptr @current_test, align 4, !tbaa !9
  %78 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %79 = icmp slt i32 %77, %78
  br i1 %79, label %92, label %80

80:                                               ; preds = %76, %74
  %81 = phi i32 [ %75, %74 ], [ %78, %76 ]
  %82 = add nsw i32 %81, 10
  store i32 %82, ptr @allocated_results, align 4, !tbaa !9
  %83 = sext i32 %82 to i64
  %84 = shl nsw i64 %83, 4
  %85 = tail call ptr @realloc(ptr noundef %72, i64 noundef %84) #14
  store ptr %85, ptr @results, align 8, !tbaa !5
  %86 = icmp eq ptr %85, null
  br i1 %86, label %89, label %87

87:                                               ; preds = %80
  %88 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %92

89:                                               ; preds = %80
  %90 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %91 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %90)
  tail call void @exit(i32 noundef -1) #15
  unreachable

92:                                               ; preds = %76, %87
  %93 = phi i32 [ %88, %87 ], [ %77, %76 ]
  %94 = phi ptr [ %85, %87 ], [ %72, %76 ]
  %95 = sub nsw i64 %70, %71
  %96 = sitofp i64 %95 to double
  %97 = fdiv double %96, 1.000000e+06
  %98 = sext i32 %93 to i64
  %99 = getelementptr inbounds %struct.one_result, ptr %94, i64 %98
  store double %97, ptr %99, align 8, !tbaa !11
  %100 = getelementptr inbounds %struct.one_result, ptr %94, i64 %98, i32 1
  store ptr %6, ptr %100, align 8, !tbaa !14
  %101 = add nsw i32 %93, 1
  store i32 %101, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Il32custom_divide_multiple_variable2IlEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i64 noundef %2, i64 noundef %3, i64 noundef %4, i64 noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !26
  %9 = load i32, ptr @iterations, align 4, !tbaa !9
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %91

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  %13 = sdiv i64 %2, %3
  %14 = sdiv i64 %13, %4
  %15 = sdiv i64 %14, %5
  br i1 %12, label %18, label %16

16:                                               ; preds = %11
  %17 = load double, ptr @init_value, align 8, !tbaa !28
  br label %74

18:                                               ; preds = %11
  %19 = zext i32 %1 to i64
  %20 = icmp ult i32 %1, 4
  %21 = and i64 %19, 4294967292
  %22 = insertelement <2 x i64> poison, i64 %15, i64 0
  %23 = shufflevector <2 x i64> %22, <2 x i64> poison, <2 x i32> zeroinitializer
  %24 = insertelement <2 x i64> poison, i64 %15, i64 0
  %25 = shufflevector <2 x i64> %24, <2 x i64> poison, <2 x i32> zeroinitializer
  %26 = icmp eq i64 %21, %19
  br label %27

27:                                               ; preds = %54, %18
  %28 = phi i32 [ %9, %18 ], [ %55, %54 ]
  %29 = phi i32 [ 0, %18 ], [ %56, %54 ]
  br i1 %20, label %47, label %30

30:                                               ; preds = %27, %30
  %31 = phi i64 [ %42, %30 ], [ 0, %27 ]
  %32 = phi <2 x i64> [ %40, %30 ], [ zeroinitializer, %27 ]
  %33 = phi <2 x i64> [ %41, %30 ], [ zeroinitializer, %27 ]
  %34 = getelementptr inbounds i64, ptr %0, i64 %31
  %35 = load <2 x i64>, ptr %34, align 8, !tbaa !26
  %36 = getelementptr inbounds i64, ptr %34, i64 2
  %37 = load <2 x i64>, ptr %36, align 8, !tbaa !26
  %38 = add <2 x i64> %35, %32
  %39 = add <2 x i64> %37, %33
  %40 = add <2 x i64> %38, %23
  %41 = add <2 x i64> %39, %25
  %42 = add nuw i64 %31, 4
  %43 = icmp eq i64 %42, %21
  br i1 %43, label %44, label %30, !llvm.loop !416

44:                                               ; preds = %30
  %45 = add <2 x i64> %41, %40
  %46 = tail call i64 @llvm.vector.reduce.add.v2i64(<2 x i64> %45)
  br i1 %26, label %67, label %47

47:                                               ; preds = %27, %44
  %48 = phi i64 [ 0, %27 ], [ %21, %44 ]
  %49 = phi i64 [ 0, %27 ], [ %46, %44 ]
  br label %58

50:                                               ; preds = %67
  %51 = load i32, ptr @current_test, align 4, !tbaa !9
  %52 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %51)
  %53 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %54

54:                                               ; preds = %50, %67
  %55 = phi i32 [ %53, %50 ], [ %28, %67 ]
  %56 = add nuw nsw i32 %29, 1
  %57 = icmp slt i32 %56, %55
  br i1 %57, label %27, label %91, !llvm.loop !417

58:                                               ; preds = %47, %58
  %59 = phi i64 [ %65, %58 ], [ %48, %47 ]
  %60 = phi i64 [ %64, %58 ], [ %49, %47 ]
  %61 = getelementptr inbounds i64, ptr %0, i64 %59
  %62 = load i64, ptr %61, align 8, !tbaa !26
  %63 = add i64 %62, %60
  %64 = add i64 %63, %15
  %65 = add nuw nsw i64 %59, 1
  %66 = icmp eq i64 %65, %19
  br i1 %66, label %67, label %58, !llvm.loop !418

67:                                               ; preds = %58, %44
  %68 = phi i64 [ %46, %44 ], [ %64, %58 ]
  %69 = load double, ptr @init_value, align 8, !tbaa !28
  %70 = fptosi double %69 to i64
  %71 = add nsw i64 %15, %70
  %72 = mul nsw i64 %71, 8000
  %73 = icmp eq i64 %72, %68
  br i1 %73, label %54, label %50

74:                                               ; preds = %16, %86
  %75 = phi i32 [ %87, %86 ], [ %9, %16 ]
  %76 = phi double [ %88, %86 ], [ %17, %16 ]
  %77 = phi i32 [ %89, %86 ], [ 0, %16 ]
  %78 = fptosi double %76 to i64
  %79 = sub i64 0, %78
  %80 = icmp eq i64 %15, %79
  br i1 %80, label %86, label %81

81:                                               ; preds = %74
  %82 = load i32, ptr @current_test, align 4, !tbaa !9
  %83 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %82)
  %84 = load double, ptr @init_value, align 8, !tbaa !28
  %85 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %86

86:                                               ; preds = %74, %81
  %87 = phi i32 [ %75, %74 ], [ %85, %81 ]
  %88 = phi double [ %76, %74 ], [ %84, %81 ]
  %89 = add nuw nsw i32 %77, 1
  %90 = icmp slt i32 %89, %87
  br i1 %90, label %74, label %91, !llvm.loop !417

91:                                               ; preds = %86, %54, %7
  %92 = tail call i64 @clock() #17
  store i64 %92, ptr @end_time, align 8, !tbaa !26
  %93 = load i64, ptr @start_time, align 8, !tbaa !26
  %94 = load ptr, ptr @results, align 8, !tbaa !5
  %95 = icmp eq ptr %94, null
  br i1 %95, label %96, label %98

96:                                               ; preds = %91
  %97 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %102

98:                                               ; preds = %91
  %99 = load i32, ptr @current_test, align 4, !tbaa !9
  %100 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %101 = icmp slt i32 %99, %100
  br i1 %101, label %114, label %102

102:                                              ; preds = %98, %96
  %103 = phi i32 [ %97, %96 ], [ %100, %98 ]
  %104 = add nsw i32 %103, 10
  store i32 %104, ptr @allocated_results, align 4, !tbaa !9
  %105 = sext i32 %104 to i64
  %106 = shl nsw i64 %105, 4
  %107 = tail call ptr @realloc(ptr noundef %94, i64 noundef %106) #14
  store ptr %107, ptr @results, align 8, !tbaa !5
  %108 = icmp eq ptr %107, null
  br i1 %108, label %111, label %109

109:                                              ; preds = %102
  %110 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %114

111:                                              ; preds = %102
  %112 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %113 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %112)
  tail call void @exit(i32 noundef -1) #15
  unreachable

114:                                              ; preds = %98, %109
  %115 = phi i32 [ %110, %109 ], [ %99, %98 ]
  %116 = phi ptr [ %107, %109 ], [ %94, %98 ]
  %117 = sub nsw i64 %92, %93
  %118 = sitofp i64 %117 to double
  %119 = fdiv double %118, 1.000000e+06
  %120 = sext i32 %115 to i64
  %121 = getelementptr inbounds %struct.one_result, ptr %116, i64 %120
  store double %119, ptr %121, align 8, !tbaa !11
  %122 = getelementptr inbounds %struct.one_result, ptr %116, i64 %120, i32 1
  store ptr %6, ptr %122, align 8, !tbaa !14
  %123 = add nsw i32 %115, 1
  store i32 %123, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Il30custom_mixed_multiple_variableIlEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i64 noundef %2, i64 noundef %3, i64 noundef %4, i64 noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !26
  %9 = load i32, ptr @iterations, align 4, !tbaa !9
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %98

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  %13 = mul nsw i64 %4, %3
  %14 = sdiv i64 %13, %5
  br i1 %12, label %17, label %15

15:                                               ; preds = %11
  %16 = load double, ptr @init_value, align 8, !tbaa !28
  br label %81

17:                                               ; preds = %11
  %18 = zext i32 %1 to i64
  %19 = icmp ult i32 %1, 4
  %20 = and i64 %18, 4294967292
  %21 = insertelement <2 x i64> poison, i64 %2, i64 0
  %22 = shufflevector <2 x i64> %21, <2 x i64> poison, <2 x i32> zeroinitializer
  %23 = insertelement <2 x i64> poison, i64 %2, i64 0
  %24 = shufflevector <2 x i64> %23, <2 x i64> poison, <2 x i32> zeroinitializer
  %25 = insertelement <2 x i64> poison, i64 %14, i64 0
  %26 = shufflevector <2 x i64> %25, <2 x i64> poison, <2 x i32> zeroinitializer
  %27 = insertelement <2 x i64> poison, i64 %14, i64 0
  %28 = shufflevector <2 x i64> %27, <2 x i64> poison, <2 x i32> zeroinitializer
  %29 = icmp eq i64 %20, %18
  br label %30

30:                                               ; preds = %59, %17
  %31 = phi i32 [ %9, %17 ], [ %60, %59 ]
  %32 = phi i32 [ 0, %17 ], [ %61, %59 ]
  br i1 %19, label %52, label %33

33:                                               ; preds = %30, %33
  %34 = phi i64 [ %47, %33 ], [ 0, %30 ]
  %35 = phi <2 x i64> [ %45, %33 ], [ zeroinitializer, %30 ]
  %36 = phi <2 x i64> [ %46, %33 ], [ zeroinitializer, %30 ]
  %37 = getelementptr inbounds i64, ptr %0, i64 %34
  %38 = load <2 x i64>, ptr %37, align 8, !tbaa !26
  %39 = getelementptr inbounds i64, ptr %37, i64 2
  %40 = load <2 x i64>, ptr %39, align 8, !tbaa !26
  %41 = add <2 x i64> %35, %22
  %42 = add <2 x i64> %36, %24
  %43 = add <2 x i64> %41, %38
  %44 = add <2 x i64> %42, %40
  %45 = sub <2 x i64> %43, %26
  %46 = sub <2 x i64> %44, %28
  %47 = add nuw i64 %34, 4
  %48 = icmp eq i64 %47, %20
  br i1 %48, label %49, label %33, !llvm.loop !419

49:                                               ; preds = %33
  %50 = add <2 x i64> %46, %45
  %51 = tail call i64 @llvm.vector.reduce.add.v2i64(<2 x i64> %50)
  br i1 %29, label %73, label %52

52:                                               ; preds = %30, %49
  %53 = phi i64 [ 0, %30 ], [ %20, %49 ]
  %54 = phi i64 [ 0, %30 ], [ %51, %49 ]
  br label %63

55:                                               ; preds = %73
  %56 = load i32, ptr @current_test, align 4, !tbaa !9
  %57 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %56)
  %58 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %59

59:                                               ; preds = %55, %73
  %60 = phi i32 [ %58, %55 ], [ %31, %73 ]
  %61 = add nuw nsw i32 %32, 1
  %62 = icmp slt i32 %61, %60
  br i1 %62, label %30, label %98, !llvm.loop !420

63:                                               ; preds = %52, %63
  %64 = phi i64 [ %71, %63 ], [ %53, %52 ]
  %65 = phi i64 [ %70, %63 ], [ %54, %52 ]
  %66 = getelementptr inbounds i64, ptr %0, i64 %64
  %67 = load i64, ptr %66, align 8, !tbaa !26
  %68 = add i64 %65, %2
  %69 = add i64 %68, %67
  %70 = sub i64 %69, %14
  %71 = add nuw nsw i64 %64, 1
  %72 = icmp eq i64 %71, %18
  br i1 %72, label %73, label %63, !llvm.loop !421

73:                                               ; preds = %63, %49
  %74 = phi i64 [ %51, %49 ], [ %70, %63 ]
  %75 = load double, ptr @init_value, align 8, !tbaa !28
  %76 = fptosi double %75 to i64
  %77 = add nsw i64 %76, %2
  %78 = sub i64 %77, %14
  %79 = mul nsw i64 %78, 8000
  %80 = icmp eq i64 %79, %74
  br i1 %80, label %59, label %55

81:                                               ; preds = %15, %93
  %82 = phi i32 [ %94, %93 ], [ %9, %15 ]
  %83 = phi double [ %95, %93 ], [ %16, %15 ]
  %84 = phi i32 [ %96, %93 ], [ 0, %15 ]
  %85 = fptosi double %83 to i64
  %86 = add nsw i64 %85, %2
  %87 = icmp eq i64 %86, %14
  br i1 %87, label %93, label %88

88:                                               ; preds = %81
  %89 = load i32, ptr @current_test, align 4, !tbaa !9
  %90 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %89)
  %91 = load double, ptr @init_value, align 8, !tbaa !28
  %92 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %93

93:                                               ; preds = %81, %88
  %94 = phi i32 [ %82, %81 ], [ %92, %88 ]
  %95 = phi double [ %83, %81 ], [ %91, %88 ]
  %96 = add nuw nsw i32 %84, 1
  %97 = icmp slt i32 %96, %94
  br i1 %97, label %81, label %98, !llvm.loop !420

98:                                               ; preds = %93, %59, %7
  %99 = tail call i64 @clock() #17
  store i64 %99, ptr @end_time, align 8, !tbaa !26
  %100 = load i64, ptr @start_time, align 8, !tbaa !26
  %101 = load ptr, ptr @results, align 8, !tbaa !5
  %102 = icmp eq ptr %101, null
  br i1 %102, label %103, label %105

103:                                              ; preds = %98
  %104 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %109

105:                                              ; preds = %98
  %106 = load i32, ptr @current_test, align 4, !tbaa !9
  %107 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %108 = icmp slt i32 %106, %107
  br i1 %108, label %121, label %109

109:                                              ; preds = %105, %103
  %110 = phi i32 [ %104, %103 ], [ %107, %105 ]
  %111 = add nsw i32 %110, 10
  store i32 %111, ptr @allocated_results, align 4, !tbaa !9
  %112 = sext i32 %111 to i64
  %113 = shl nsw i64 %112, 4
  %114 = tail call ptr @realloc(ptr noundef %101, i64 noundef %113) #14
  store ptr %114, ptr @results, align 8, !tbaa !5
  %115 = icmp eq ptr %114, null
  br i1 %115, label %118, label %116

116:                                              ; preds = %109
  %117 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %121

118:                                              ; preds = %109
  %119 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %120 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %119)
  tail call void @exit(i32 noundef -1) #15
  unreachable

121:                                              ; preds = %105, %116
  %122 = phi i32 [ %117, %116 ], [ %106, %105 ]
  %123 = phi ptr [ %114, %116 ], [ %101, %105 ]
  %124 = sub nsw i64 %99, %100
  %125 = sitofp i64 %124 to double
  %126 = fdiv double %125, 1.000000e+06
  %127 = sext i32 %122 to i64
  %128 = getelementptr inbounds %struct.one_result, ptr %123, i64 %127
  store double %126, ptr %128, align 8, !tbaa !11
  %129 = getelementptr inbounds %struct.one_result, ptr %123, i64 %127, i32 1
  store ptr %6, ptr %129, align 8, !tbaa !14
  %130 = add nsw i32 %122, 1
  store i32 %130, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1Il19custom_variable_andIlEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i64 noundef %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !26
  %6 = load i32, ptr @iterations, align 4, !tbaa !9
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %85

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  br i1 %9, label %12, label %10

10:                                               ; preds = %8
  %11 = load double, ptr @init_value, align 8, !tbaa !28
  br label %68

12:                                               ; preds = %8
  %13 = zext i32 %1 to i64
  %14 = icmp ult i32 %1, 4
  %15 = and i64 %13, 4294967292
  %16 = insertelement <2 x i64> poison, i64 %2, i64 0
  %17 = shufflevector <2 x i64> %16, <2 x i64> poison, <2 x i32> zeroinitializer
  %18 = insertelement <2 x i64> poison, i64 %2, i64 0
  %19 = shufflevector <2 x i64> %18, <2 x i64> poison, <2 x i32> zeroinitializer
  %20 = icmp eq i64 %15, %13
  br label %21

21:                                               ; preds = %12, %48
  %22 = phi i32 [ %49, %48 ], [ %6, %12 ]
  %23 = phi i32 [ %50, %48 ], [ 0, %12 ]
  br i1 %14, label %41, label %24

24:                                               ; preds = %21, %24
  %25 = phi i64 [ %36, %24 ], [ 0, %21 ]
  %26 = phi <2 x i64> [ %34, %24 ], [ zeroinitializer, %21 ]
  %27 = phi <2 x i64> [ %35, %24 ], [ zeroinitializer, %21 ]
  %28 = getelementptr inbounds i64, ptr %0, i64 %25
  %29 = load <2 x i64>, ptr %28, align 8, !tbaa !26
  %30 = getelementptr inbounds i64, ptr %28, i64 2
  %31 = load <2 x i64>, ptr %30, align 8, !tbaa !26
  %32 = and <2 x i64> %29, %17
  %33 = and <2 x i64> %31, %19
  %34 = add <2 x i64> %32, %26
  %35 = add <2 x i64> %33, %27
  %36 = add nuw i64 %25, 4
  %37 = icmp eq i64 %36, %15
  br i1 %37, label %38, label %24, !llvm.loop !422

38:                                               ; preds = %24
  %39 = add <2 x i64> %35, %34
  %40 = tail call i64 @llvm.vector.reduce.add.v2i64(<2 x i64> %39)
  br i1 %20, label %61, label %41

41:                                               ; preds = %21, %38
  %42 = phi i64 [ 0, %21 ], [ %15, %38 ]
  %43 = phi i64 [ 0, %21 ], [ %40, %38 ]
  br label %52

44:                                               ; preds = %61
  %45 = load i32, ptr @current_test, align 4, !tbaa !9
  %46 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %45)
  %47 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %48

48:                                               ; preds = %44, %61
  %49 = phi i32 [ %47, %44 ], [ %22, %61 ]
  %50 = add nuw nsw i32 %23, 1
  %51 = icmp slt i32 %50, %49
  br i1 %51, label %21, label %85, !llvm.loop !423

52:                                               ; preds = %41, %52
  %53 = phi i64 [ %59, %52 ], [ %42, %41 ]
  %54 = phi i64 [ %58, %52 ], [ %43, %41 ]
  %55 = getelementptr inbounds i64, ptr %0, i64 %53
  %56 = load i64, ptr %55, align 8, !tbaa !26
  %57 = and i64 %56, %2
  %58 = add nsw i64 %57, %54
  %59 = add nuw nsw i64 %53, 1
  %60 = icmp eq i64 %59, %13
  br i1 %60, label %61, label %52, !llvm.loop !424

61:                                               ; preds = %52, %38
  %62 = phi i64 [ %40, %38 ], [ %58, %52 ]
  %63 = load double, ptr @init_value, align 8, !tbaa !28
  %64 = fptosi double %63 to i64
  %65 = and i64 %64, %2
  %66 = mul nsw i64 %65, 8000
  %67 = icmp eq i64 %66, %62
  br i1 %67, label %48, label %44

68:                                               ; preds = %10, %80
  %69 = phi i32 [ %81, %80 ], [ %6, %10 ]
  %70 = phi double [ %82, %80 ], [ %11, %10 ]
  %71 = phi i32 [ %83, %80 ], [ 0, %10 ]
  %72 = fptosi double %70 to i64
  %73 = and i64 %72, %2
  %74 = icmp eq i64 %73, 0
  br i1 %74, label %80, label %75

75:                                               ; preds = %68
  %76 = load i32, ptr @current_test, align 4, !tbaa !9
  %77 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %76)
  %78 = load double, ptr @init_value, align 8, !tbaa !28
  %79 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %80

80:                                               ; preds = %68, %75
  %81 = phi i32 [ %69, %68 ], [ %79, %75 ]
  %82 = phi double [ %70, %68 ], [ %78, %75 ]
  %83 = add nuw nsw i32 %71, 1
  %84 = icmp slt i32 %83, %81
  br i1 %84, label %68, label %85, !llvm.loop !423

85:                                               ; preds = %80, %48, %4
  %86 = tail call i64 @clock() #17
  store i64 %86, ptr @end_time, align 8, !tbaa !26
  %87 = load i64, ptr @start_time, align 8, !tbaa !26
  %88 = load ptr, ptr @results, align 8, !tbaa !5
  %89 = icmp eq ptr %88, null
  br i1 %89, label %90, label %92

90:                                               ; preds = %85
  %91 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %96

92:                                               ; preds = %85
  %93 = load i32, ptr @current_test, align 4, !tbaa !9
  %94 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %95 = icmp slt i32 %93, %94
  br i1 %95, label %108, label %96

96:                                               ; preds = %92, %90
  %97 = phi i32 [ %91, %90 ], [ %94, %92 ]
  %98 = add nsw i32 %97, 10
  store i32 %98, ptr @allocated_results, align 4, !tbaa !9
  %99 = sext i32 %98 to i64
  %100 = shl nsw i64 %99, 4
  %101 = tail call ptr @realloc(ptr noundef %88, i64 noundef %100) #14
  store ptr %101, ptr @results, align 8, !tbaa !5
  %102 = icmp eq ptr %101, null
  br i1 %102, label %105, label %103

103:                                              ; preds = %96
  %104 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %108

105:                                              ; preds = %96
  %106 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %107 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %106)
  tail call void @exit(i32 noundef -1) #15
  unreachable

108:                                              ; preds = %92, %103
  %109 = phi i32 [ %104, %103 ], [ %93, %92 ]
  %110 = phi ptr [ %101, %103 ], [ %88, %92 ]
  %111 = sub nsw i64 %86, %87
  %112 = sitofp i64 %111 to double
  %113 = fdiv double %112, 1.000000e+06
  %114 = sext i32 %109 to i64
  %115 = getelementptr inbounds %struct.one_result, ptr %110, i64 %114
  store double %113, ptr %115, align 8, !tbaa !11
  %116 = getelementptr inbounds %struct.one_result, ptr %110, i64 %114, i32 1
  store ptr %3, ptr %116, align 8, !tbaa !14
  %117 = add nsw i32 %109, 1
  store i32 %117, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Il28custom_multiple_variable_andIlEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i64 noundef %2, i64 noundef %3, i64 noundef %4, i64 noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !26
  %9 = load i32, ptr @iterations, align 4, !tbaa !9
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %100

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  %13 = and i64 %3, %2
  %14 = and i64 %13, %4
  %15 = and i64 %14, %5
  br i1 %12, label %18, label %16

16:                                               ; preds = %11
  %17 = load double, ptr @init_value, align 8, !tbaa !28
  br label %83

18:                                               ; preds = %11
  %19 = zext i32 %1 to i64
  %20 = icmp ult i32 %1, 4
  %21 = and i64 %19, 4294967292
  %22 = and i64 %3, %2
  %23 = and i64 %3, %2
  %24 = and i64 %22, %4
  %25 = and i64 %23, %4
  %26 = and i64 %24, %5
  %27 = insertelement <2 x i64> poison, i64 %26, i64 0
  %28 = shufflevector <2 x i64> %27, <2 x i64> poison, <2 x i32> zeroinitializer
  %29 = and i64 %25, %5
  %30 = insertelement <2 x i64> poison, i64 %29, i64 0
  %31 = shufflevector <2 x i64> %30, <2 x i64> poison, <2 x i32> zeroinitializer
  %32 = icmp eq i64 %21, %19
  br label %33

33:                                               ; preds = %18, %60
  %34 = phi i32 [ %61, %60 ], [ %9, %18 ]
  %35 = phi i32 [ %62, %60 ], [ 0, %18 ]
  br i1 %20, label %53, label %36

36:                                               ; preds = %33, %36
  %37 = phi i64 [ %48, %36 ], [ 0, %33 ]
  %38 = phi <2 x i64> [ %46, %36 ], [ zeroinitializer, %33 ]
  %39 = phi <2 x i64> [ %47, %36 ], [ zeroinitializer, %33 ]
  %40 = getelementptr inbounds i64, ptr %0, i64 %37
  %41 = load <2 x i64>, ptr %40, align 8, !tbaa !26
  %42 = getelementptr inbounds i64, ptr %40, i64 2
  %43 = load <2 x i64>, ptr %42, align 8, !tbaa !26
  %44 = and <2 x i64> %28, %41
  %45 = and <2 x i64> %31, %43
  %46 = add <2 x i64> %44, %38
  %47 = add <2 x i64> %45, %39
  %48 = add nuw i64 %37, 4
  %49 = icmp eq i64 %48, %21
  br i1 %49, label %50, label %36, !llvm.loop !425

50:                                               ; preds = %36
  %51 = add <2 x i64> %47, %46
  %52 = tail call i64 @llvm.vector.reduce.add.v2i64(<2 x i64> %51)
  br i1 %32, label %76, label %53

53:                                               ; preds = %33, %50
  %54 = phi i64 [ 0, %33 ], [ %21, %50 ]
  %55 = phi i64 [ 0, %33 ], [ %52, %50 ]
  br label %64

56:                                               ; preds = %76
  %57 = load i32, ptr @current_test, align 4, !tbaa !9
  %58 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %57)
  %59 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %60

60:                                               ; preds = %56, %76
  %61 = phi i32 [ %59, %56 ], [ %34, %76 ]
  %62 = add nuw nsw i32 %35, 1
  %63 = icmp slt i32 %62, %61
  br i1 %63, label %33, label %100, !llvm.loop !426

64:                                               ; preds = %53, %64
  %65 = phi i64 [ %74, %64 ], [ %54, %53 ]
  %66 = phi i64 [ %73, %64 ], [ %55, %53 ]
  %67 = getelementptr inbounds i64, ptr %0, i64 %65
  %68 = load i64, ptr %67, align 8, !tbaa !26
  %69 = and i64 %68, %2
  %70 = and i64 %69, %3
  %71 = and i64 %70, %4
  %72 = and i64 %71, %5
  %73 = add nsw i64 %72, %66
  %74 = add nuw nsw i64 %65, 1
  %75 = icmp eq i64 %74, %19
  br i1 %75, label %76, label %64, !llvm.loop !427

76:                                               ; preds = %64, %50
  %77 = phi i64 [ %52, %50 ], [ %73, %64 ]
  %78 = load double, ptr @init_value, align 8, !tbaa !28
  %79 = fptosi double %78 to i64
  %80 = and i64 %15, %79
  %81 = mul nsw i64 %80, 8000
  %82 = icmp eq i64 %81, %77
  br i1 %82, label %60, label %56

83:                                               ; preds = %16, %95
  %84 = phi i32 [ %96, %95 ], [ %9, %16 ]
  %85 = phi double [ %97, %95 ], [ %17, %16 ]
  %86 = phi i32 [ %98, %95 ], [ 0, %16 ]
  %87 = fptosi double %85 to i64
  %88 = and i64 %15, %87
  %89 = icmp eq i64 %88, 0
  br i1 %89, label %95, label %90

90:                                               ; preds = %83
  %91 = load i32, ptr @current_test, align 4, !tbaa !9
  %92 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %91)
  %93 = load double, ptr @init_value, align 8, !tbaa !28
  %94 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %95

95:                                               ; preds = %83, %90
  %96 = phi i32 [ %84, %83 ], [ %94, %90 ]
  %97 = phi double [ %85, %83 ], [ %93, %90 ]
  %98 = add nuw nsw i32 %86, 1
  %99 = icmp slt i32 %98, %96
  br i1 %99, label %83, label %100, !llvm.loop !426

100:                                              ; preds = %95, %60, %7
  %101 = tail call i64 @clock() #17
  store i64 %101, ptr @end_time, align 8, !tbaa !26
  %102 = load i64, ptr @start_time, align 8, !tbaa !26
  %103 = load ptr, ptr @results, align 8, !tbaa !5
  %104 = icmp eq ptr %103, null
  br i1 %104, label %105, label %107

105:                                              ; preds = %100
  %106 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %111

107:                                              ; preds = %100
  %108 = load i32, ptr @current_test, align 4, !tbaa !9
  %109 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %110 = icmp slt i32 %108, %109
  br i1 %110, label %123, label %111

111:                                              ; preds = %107, %105
  %112 = phi i32 [ %106, %105 ], [ %109, %107 ]
  %113 = add nsw i32 %112, 10
  store i32 %113, ptr @allocated_results, align 4, !tbaa !9
  %114 = sext i32 %113 to i64
  %115 = shl nsw i64 %114, 4
  %116 = tail call ptr @realloc(ptr noundef %103, i64 noundef %115) #14
  store ptr %116, ptr @results, align 8, !tbaa !5
  %117 = icmp eq ptr %116, null
  br i1 %117, label %120, label %118

118:                                              ; preds = %111
  %119 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %123

120:                                              ; preds = %111
  %121 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %122 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %121)
  tail call void @exit(i32 noundef -1) #15
  unreachable

123:                                              ; preds = %107, %118
  %124 = phi i32 [ %119, %118 ], [ %108, %107 ]
  %125 = phi ptr [ %116, %118 ], [ %103, %107 ]
  %126 = sub nsw i64 %101, %102
  %127 = sitofp i64 %126 to double
  %128 = fdiv double %127, 1.000000e+06
  %129 = sext i32 %124 to i64
  %130 = getelementptr inbounds %struct.one_result, ptr %125, i64 %129
  store double %128, ptr %130, align 8, !tbaa !11
  %131 = getelementptr inbounds %struct.one_result, ptr %125, i64 %129, i32 1
  store ptr %6, ptr %131, align 8, !tbaa !14
  %132 = add nsw i32 %124, 1
  store i32 %132, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1Il18custom_variable_orIlEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i64 noundef %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !26
  %6 = load i32, ptr @iterations, align 4, !tbaa !9
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %85

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  br i1 %9, label %12, label %10

10:                                               ; preds = %8
  %11 = load double, ptr @init_value, align 8, !tbaa !28
  br label %68

12:                                               ; preds = %8
  %13 = zext i32 %1 to i64
  %14 = icmp ult i32 %1, 4
  %15 = and i64 %13, 4294967292
  %16 = insertelement <2 x i64> poison, i64 %2, i64 0
  %17 = shufflevector <2 x i64> %16, <2 x i64> poison, <2 x i32> zeroinitializer
  %18 = insertelement <2 x i64> poison, i64 %2, i64 0
  %19 = shufflevector <2 x i64> %18, <2 x i64> poison, <2 x i32> zeroinitializer
  %20 = icmp eq i64 %15, %13
  br label %21

21:                                               ; preds = %12, %48
  %22 = phi i32 [ %49, %48 ], [ %6, %12 ]
  %23 = phi i32 [ %50, %48 ], [ 0, %12 ]
  br i1 %14, label %41, label %24

24:                                               ; preds = %21, %24
  %25 = phi i64 [ %36, %24 ], [ 0, %21 ]
  %26 = phi <2 x i64> [ %34, %24 ], [ zeroinitializer, %21 ]
  %27 = phi <2 x i64> [ %35, %24 ], [ zeroinitializer, %21 ]
  %28 = getelementptr inbounds i64, ptr %0, i64 %25
  %29 = load <2 x i64>, ptr %28, align 8, !tbaa !26
  %30 = getelementptr inbounds i64, ptr %28, i64 2
  %31 = load <2 x i64>, ptr %30, align 8, !tbaa !26
  %32 = or <2 x i64> %29, %17
  %33 = or <2 x i64> %31, %19
  %34 = add <2 x i64> %32, %26
  %35 = add <2 x i64> %33, %27
  %36 = add nuw i64 %25, 4
  %37 = icmp eq i64 %36, %15
  br i1 %37, label %38, label %24, !llvm.loop !428

38:                                               ; preds = %24
  %39 = add <2 x i64> %35, %34
  %40 = tail call i64 @llvm.vector.reduce.add.v2i64(<2 x i64> %39)
  br i1 %20, label %61, label %41

41:                                               ; preds = %21, %38
  %42 = phi i64 [ 0, %21 ], [ %15, %38 ]
  %43 = phi i64 [ 0, %21 ], [ %40, %38 ]
  br label %52

44:                                               ; preds = %61
  %45 = load i32, ptr @current_test, align 4, !tbaa !9
  %46 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %45)
  %47 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %48

48:                                               ; preds = %44, %61
  %49 = phi i32 [ %47, %44 ], [ %22, %61 ]
  %50 = add nuw nsw i32 %23, 1
  %51 = icmp slt i32 %50, %49
  br i1 %51, label %21, label %85, !llvm.loop !429

52:                                               ; preds = %41, %52
  %53 = phi i64 [ %59, %52 ], [ %42, %41 ]
  %54 = phi i64 [ %58, %52 ], [ %43, %41 ]
  %55 = getelementptr inbounds i64, ptr %0, i64 %53
  %56 = load i64, ptr %55, align 8, !tbaa !26
  %57 = or i64 %56, %2
  %58 = add nsw i64 %57, %54
  %59 = add nuw nsw i64 %53, 1
  %60 = icmp eq i64 %59, %13
  br i1 %60, label %61, label %52, !llvm.loop !430

61:                                               ; preds = %52, %38
  %62 = phi i64 [ %40, %38 ], [ %58, %52 ]
  %63 = load double, ptr @init_value, align 8, !tbaa !28
  %64 = fptosi double %63 to i64
  %65 = or i64 %64, %2
  %66 = mul nsw i64 %65, 8000
  %67 = icmp eq i64 %66, %62
  br i1 %67, label %48, label %44

68:                                               ; preds = %10, %80
  %69 = phi i32 [ %81, %80 ], [ %6, %10 ]
  %70 = phi double [ %82, %80 ], [ %11, %10 ]
  %71 = phi i32 [ %83, %80 ], [ 0, %10 ]
  %72 = fptosi double %70 to i64
  %73 = or i64 %72, %2
  %74 = icmp eq i64 %73, 0
  br i1 %74, label %80, label %75

75:                                               ; preds = %68
  %76 = load i32, ptr @current_test, align 4, !tbaa !9
  %77 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %76)
  %78 = load double, ptr @init_value, align 8, !tbaa !28
  %79 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %80

80:                                               ; preds = %68, %75
  %81 = phi i32 [ %69, %68 ], [ %79, %75 ]
  %82 = phi double [ %70, %68 ], [ %78, %75 ]
  %83 = add nuw nsw i32 %71, 1
  %84 = icmp slt i32 %83, %81
  br i1 %84, label %68, label %85, !llvm.loop !429

85:                                               ; preds = %80, %48, %4
  %86 = tail call i64 @clock() #17
  store i64 %86, ptr @end_time, align 8, !tbaa !26
  %87 = load i64, ptr @start_time, align 8, !tbaa !26
  %88 = load ptr, ptr @results, align 8, !tbaa !5
  %89 = icmp eq ptr %88, null
  br i1 %89, label %90, label %92

90:                                               ; preds = %85
  %91 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %96

92:                                               ; preds = %85
  %93 = load i32, ptr @current_test, align 4, !tbaa !9
  %94 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %95 = icmp slt i32 %93, %94
  br i1 %95, label %108, label %96

96:                                               ; preds = %92, %90
  %97 = phi i32 [ %91, %90 ], [ %94, %92 ]
  %98 = add nsw i32 %97, 10
  store i32 %98, ptr @allocated_results, align 4, !tbaa !9
  %99 = sext i32 %98 to i64
  %100 = shl nsw i64 %99, 4
  %101 = tail call ptr @realloc(ptr noundef %88, i64 noundef %100) #14
  store ptr %101, ptr @results, align 8, !tbaa !5
  %102 = icmp eq ptr %101, null
  br i1 %102, label %105, label %103

103:                                              ; preds = %96
  %104 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %108

105:                                              ; preds = %96
  %106 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %107 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %106)
  tail call void @exit(i32 noundef -1) #15
  unreachable

108:                                              ; preds = %92, %103
  %109 = phi i32 [ %104, %103 ], [ %93, %92 ]
  %110 = phi ptr [ %101, %103 ], [ %88, %92 ]
  %111 = sub nsw i64 %86, %87
  %112 = sitofp i64 %111 to double
  %113 = fdiv double %112, 1.000000e+06
  %114 = sext i32 %109 to i64
  %115 = getelementptr inbounds %struct.one_result, ptr %110, i64 %114
  store double %113, ptr %115, align 8, !tbaa !11
  %116 = getelementptr inbounds %struct.one_result, ptr %110, i64 %114, i32 1
  store ptr %3, ptr %116, align 8, !tbaa !14
  %117 = add nsw i32 %109, 1
  store i32 %117, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Il27custom_multiple_variable_orIlEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i64 noundef %2, i64 noundef %3, i64 noundef %4, i64 noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !26
  %9 = load i32, ptr @iterations, align 4, !tbaa !9
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %100

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  %13 = or i64 %3, %2
  %14 = or i64 %13, %4
  %15 = or i64 %14, %5
  br i1 %12, label %18, label %16

16:                                               ; preds = %11
  %17 = load double, ptr @init_value, align 8, !tbaa !28
  br label %83

18:                                               ; preds = %11
  %19 = zext i32 %1 to i64
  %20 = icmp ult i32 %1, 4
  %21 = and i64 %19, 4294967292
  %22 = or i64 %3, %2
  %23 = or i64 %3, %2
  %24 = or i64 %22, %4
  %25 = or i64 %23, %4
  %26 = or i64 %24, %5
  %27 = insertelement <2 x i64> poison, i64 %26, i64 0
  %28 = shufflevector <2 x i64> %27, <2 x i64> poison, <2 x i32> zeroinitializer
  %29 = or i64 %25, %5
  %30 = insertelement <2 x i64> poison, i64 %29, i64 0
  %31 = shufflevector <2 x i64> %30, <2 x i64> poison, <2 x i32> zeroinitializer
  %32 = icmp eq i64 %21, %19
  br label %33

33:                                               ; preds = %18, %60
  %34 = phi i32 [ %61, %60 ], [ %9, %18 ]
  %35 = phi i32 [ %62, %60 ], [ 0, %18 ]
  br i1 %20, label %53, label %36

36:                                               ; preds = %33, %36
  %37 = phi i64 [ %48, %36 ], [ 0, %33 ]
  %38 = phi <2 x i64> [ %46, %36 ], [ zeroinitializer, %33 ]
  %39 = phi <2 x i64> [ %47, %36 ], [ zeroinitializer, %33 ]
  %40 = getelementptr inbounds i64, ptr %0, i64 %37
  %41 = load <2 x i64>, ptr %40, align 8, !tbaa !26
  %42 = getelementptr inbounds i64, ptr %40, i64 2
  %43 = load <2 x i64>, ptr %42, align 8, !tbaa !26
  %44 = or <2 x i64> %28, %41
  %45 = or <2 x i64> %31, %43
  %46 = add <2 x i64> %44, %38
  %47 = add <2 x i64> %45, %39
  %48 = add nuw i64 %37, 4
  %49 = icmp eq i64 %48, %21
  br i1 %49, label %50, label %36, !llvm.loop !431

50:                                               ; preds = %36
  %51 = add <2 x i64> %47, %46
  %52 = tail call i64 @llvm.vector.reduce.add.v2i64(<2 x i64> %51)
  br i1 %32, label %76, label %53

53:                                               ; preds = %33, %50
  %54 = phi i64 [ 0, %33 ], [ %21, %50 ]
  %55 = phi i64 [ 0, %33 ], [ %52, %50 ]
  br label %64

56:                                               ; preds = %76
  %57 = load i32, ptr @current_test, align 4, !tbaa !9
  %58 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %57)
  %59 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %60

60:                                               ; preds = %56, %76
  %61 = phi i32 [ %59, %56 ], [ %34, %76 ]
  %62 = add nuw nsw i32 %35, 1
  %63 = icmp slt i32 %62, %61
  br i1 %63, label %33, label %100, !llvm.loop !432

64:                                               ; preds = %53, %64
  %65 = phi i64 [ %74, %64 ], [ %54, %53 ]
  %66 = phi i64 [ %73, %64 ], [ %55, %53 ]
  %67 = getelementptr inbounds i64, ptr %0, i64 %65
  %68 = load i64, ptr %67, align 8, !tbaa !26
  %69 = or i64 %68, %2
  %70 = or i64 %69, %3
  %71 = or i64 %70, %4
  %72 = or i64 %71, %5
  %73 = add nsw i64 %72, %66
  %74 = add nuw nsw i64 %65, 1
  %75 = icmp eq i64 %74, %19
  br i1 %75, label %76, label %64, !llvm.loop !433

76:                                               ; preds = %64, %50
  %77 = phi i64 [ %52, %50 ], [ %73, %64 ]
  %78 = load double, ptr @init_value, align 8, !tbaa !28
  %79 = fptosi double %78 to i64
  %80 = or i64 %15, %79
  %81 = mul nsw i64 %80, 8000
  %82 = icmp eq i64 %81, %77
  br i1 %82, label %60, label %56

83:                                               ; preds = %16, %95
  %84 = phi i32 [ %96, %95 ], [ %9, %16 ]
  %85 = phi double [ %97, %95 ], [ %17, %16 ]
  %86 = phi i32 [ %98, %95 ], [ 0, %16 ]
  %87 = fptosi double %85 to i64
  %88 = or i64 %15, %87
  %89 = icmp eq i64 %88, 0
  br i1 %89, label %95, label %90

90:                                               ; preds = %83
  %91 = load i32, ptr @current_test, align 4, !tbaa !9
  %92 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %91)
  %93 = load double, ptr @init_value, align 8, !tbaa !28
  %94 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %95

95:                                               ; preds = %83, %90
  %96 = phi i32 [ %84, %83 ], [ %94, %90 ]
  %97 = phi double [ %85, %83 ], [ %93, %90 ]
  %98 = add nuw nsw i32 %86, 1
  %99 = icmp slt i32 %98, %96
  br i1 %99, label %83, label %100, !llvm.loop !432

100:                                              ; preds = %95, %60, %7
  %101 = tail call i64 @clock() #17
  store i64 %101, ptr @end_time, align 8, !tbaa !26
  %102 = load i64, ptr @start_time, align 8, !tbaa !26
  %103 = load ptr, ptr @results, align 8, !tbaa !5
  %104 = icmp eq ptr %103, null
  br i1 %104, label %105, label %107

105:                                              ; preds = %100
  %106 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %111

107:                                              ; preds = %100
  %108 = load i32, ptr @current_test, align 4, !tbaa !9
  %109 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %110 = icmp slt i32 %108, %109
  br i1 %110, label %123, label %111

111:                                              ; preds = %107, %105
  %112 = phi i32 [ %106, %105 ], [ %109, %107 ]
  %113 = add nsw i32 %112, 10
  store i32 %113, ptr @allocated_results, align 4, !tbaa !9
  %114 = sext i32 %113 to i64
  %115 = shl nsw i64 %114, 4
  %116 = tail call ptr @realloc(ptr noundef %103, i64 noundef %115) #14
  store ptr %116, ptr @results, align 8, !tbaa !5
  %117 = icmp eq ptr %116, null
  br i1 %117, label %120, label %118

118:                                              ; preds = %111
  %119 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %123

120:                                              ; preds = %111
  %121 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %122 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %121)
  tail call void @exit(i32 noundef -1) #15
  unreachable

123:                                              ; preds = %107, %118
  %124 = phi i32 [ %119, %118 ], [ %108, %107 ]
  %125 = phi ptr [ %116, %118 ], [ %103, %107 ]
  %126 = sub nsw i64 %101, %102
  %127 = sitofp i64 %126 to double
  %128 = fdiv double %127, 1.000000e+06
  %129 = sext i32 %124 to i64
  %130 = getelementptr inbounds %struct.one_result, ptr %125, i64 %129
  store double %128, ptr %130, align 8, !tbaa !11
  %131 = getelementptr inbounds %struct.one_result, ptr %125, i64 %129, i32 1
  store ptr %6, ptr %131, align 8, !tbaa !14
  %132 = add nsw i32 %124, 1
  store i32 %132, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1Il19custom_variable_xorIlEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i64 noundef %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !26
  %6 = load i32, ptr @iterations, align 4, !tbaa !9
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %84

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  br i1 %9, label %12, label %10

10:                                               ; preds = %8
  %11 = load double, ptr @init_value, align 8, !tbaa !28
  br label %68

12:                                               ; preds = %8
  %13 = zext i32 %1 to i64
  %14 = icmp ult i32 %1, 4
  %15 = and i64 %13, 4294967292
  %16 = insertelement <2 x i64> poison, i64 %2, i64 0
  %17 = shufflevector <2 x i64> %16, <2 x i64> poison, <2 x i32> zeroinitializer
  %18 = insertelement <2 x i64> poison, i64 %2, i64 0
  %19 = shufflevector <2 x i64> %18, <2 x i64> poison, <2 x i32> zeroinitializer
  %20 = icmp eq i64 %15, %13
  br label %21

21:                                               ; preds = %12, %48
  %22 = phi i32 [ %49, %48 ], [ %6, %12 ]
  %23 = phi i32 [ %50, %48 ], [ 0, %12 ]
  br i1 %14, label %41, label %24

24:                                               ; preds = %21, %24
  %25 = phi i64 [ %36, %24 ], [ 0, %21 ]
  %26 = phi <2 x i64> [ %34, %24 ], [ zeroinitializer, %21 ]
  %27 = phi <2 x i64> [ %35, %24 ], [ zeroinitializer, %21 ]
  %28 = getelementptr inbounds i64, ptr %0, i64 %25
  %29 = load <2 x i64>, ptr %28, align 8, !tbaa !26
  %30 = getelementptr inbounds i64, ptr %28, i64 2
  %31 = load <2 x i64>, ptr %30, align 8, !tbaa !26
  %32 = xor <2 x i64> %29, %17
  %33 = xor <2 x i64> %31, %19
  %34 = add <2 x i64> %32, %26
  %35 = add <2 x i64> %33, %27
  %36 = add nuw i64 %25, 4
  %37 = icmp eq i64 %36, %15
  br i1 %37, label %38, label %24, !llvm.loop !434

38:                                               ; preds = %24
  %39 = add <2 x i64> %35, %34
  %40 = tail call i64 @llvm.vector.reduce.add.v2i64(<2 x i64> %39)
  br i1 %20, label %61, label %41

41:                                               ; preds = %21, %38
  %42 = phi i64 [ 0, %21 ], [ %15, %38 ]
  %43 = phi i64 [ 0, %21 ], [ %40, %38 ]
  br label %52

44:                                               ; preds = %61
  %45 = load i32, ptr @current_test, align 4, !tbaa !9
  %46 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %45)
  %47 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %48

48:                                               ; preds = %44, %61
  %49 = phi i32 [ %47, %44 ], [ %22, %61 ]
  %50 = add nuw nsw i32 %23, 1
  %51 = icmp slt i32 %50, %49
  br i1 %51, label %21, label %84, !llvm.loop !435

52:                                               ; preds = %41, %52
  %53 = phi i64 [ %59, %52 ], [ %42, %41 ]
  %54 = phi i64 [ %58, %52 ], [ %43, %41 ]
  %55 = getelementptr inbounds i64, ptr %0, i64 %53
  %56 = load i64, ptr %55, align 8, !tbaa !26
  %57 = xor i64 %56, %2
  %58 = add nsw i64 %57, %54
  %59 = add nuw nsw i64 %53, 1
  %60 = icmp eq i64 %59, %13
  br i1 %60, label %61, label %52, !llvm.loop !436

61:                                               ; preds = %52, %38
  %62 = phi i64 [ %40, %38 ], [ %58, %52 ]
  %63 = load double, ptr @init_value, align 8, !tbaa !28
  %64 = fptosi double %63 to i64
  %65 = xor i64 %64, %2
  %66 = mul nsw i64 %65, 8000
  %67 = icmp eq i64 %66, %62
  br i1 %67, label %48, label %44

68:                                               ; preds = %10, %79
  %69 = phi i32 [ %80, %79 ], [ %6, %10 ]
  %70 = phi double [ %81, %79 ], [ %11, %10 ]
  %71 = phi i32 [ %82, %79 ], [ 0, %10 ]
  %72 = fptosi double %70 to i64
  %73 = icmp eq i64 %72, %2
  br i1 %73, label %79, label %74

74:                                               ; preds = %68
  %75 = load i32, ptr @current_test, align 4, !tbaa !9
  %76 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %75)
  %77 = load double, ptr @init_value, align 8, !tbaa !28
  %78 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %79

79:                                               ; preds = %68, %74
  %80 = phi i32 [ %69, %68 ], [ %78, %74 ]
  %81 = phi double [ %70, %68 ], [ %77, %74 ]
  %82 = add nuw nsw i32 %71, 1
  %83 = icmp slt i32 %82, %80
  br i1 %83, label %68, label %84, !llvm.loop !435

84:                                               ; preds = %79, %48, %4
  %85 = tail call i64 @clock() #17
  store i64 %85, ptr @end_time, align 8, !tbaa !26
  %86 = load i64, ptr @start_time, align 8, !tbaa !26
  %87 = load ptr, ptr @results, align 8, !tbaa !5
  %88 = icmp eq ptr %87, null
  br i1 %88, label %89, label %91

89:                                               ; preds = %84
  %90 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %95

91:                                               ; preds = %84
  %92 = load i32, ptr @current_test, align 4, !tbaa !9
  %93 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %94 = icmp slt i32 %92, %93
  br i1 %94, label %107, label %95

95:                                               ; preds = %91, %89
  %96 = phi i32 [ %90, %89 ], [ %93, %91 ]
  %97 = add nsw i32 %96, 10
  store i32 %97, ptr @allocated_results, align 4, !tbaa !9
  %98 = sext i32 %97 to i64
  %99 = shl nsw i64 %98, 4
  %100 = tail call ptr @realloc(ptr noundef %87, i64 noundef %99) #14
  store ptr %100, ptr @results, align 8, !tbaa !5
  %101 = icmp eq ptr %100, null
  br i1 %101, label %104, label %102

102:                                              ; preds = %95
  %103 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %107

104:                                              ; preds = %95
  %105 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %106 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %105)
  tail call void @exit(i32 noundef -1) #15
  unreachable

107:                                              ; preds = %91, %102
  %108 = phi i32 [ %103, %102 ], [ %92, %91 ]
  %109 = phi ptr [ %100, %102 ], [ %87, %91 ]
  %110 = sub nsw i64 %85, %86
  %111 = sitofp i64 %110 to double
  %112 = fdiv double %111, 1.000000e+06
  %113 = sext i32 %108 to i64
  %114 = getelementptr inbounds %struct.one_result, ptr %109, i64 %113
  store double %112, ptr %114, align 8, !tbaa !11
  %115 = getelementptr inbounds %struct.one_result, ptr %109, i64 %113, i32 1
  store ptr %3, ptr %115, align 8, !tbaa !14
  %116 = add nsw i32 %108, 1
  store i32 %116, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Il28custom_multiple_variable_xorIlEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i64 noundef %2, i64 noundef %3, i64 noundef %4, i64 noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !26
  %9 = load i32, ptr @iterations, align 4, !tbaa !9
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %99

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  %13 = xor i64 %3, %2
  %14 = xor i64 %13, %4
  %15 = xor i64 %14, %5
  br i1 %12, label %18, label %16

16:                                               ; preds = %11
  %17 = load double, ptr @init_value, align 8, !tbaa !28
  br label %83

18:                                               ; preds = %11
  %19 = zext i32 %1 to i64
  %20 = icmp ult i32 %1, 4
  %21 = and i64 %19, 4294967292
  %22 = xor i64 %3, %2
  %23 = xor i64 %3, %2
  %24 = xor i64 %22, %4
  %25 = xor i64 %23, %4
  %26 = xor i64 %24, %5
  %27 = insertelement <2 x i64> poison, i64 %26, i64 0
  %28 = shufflevector <2 x i64> %27, <2 x i64> poison, <2 x i32> zeroinitializer
  %29 = xor i64 %25, %5
  %30 = insertelement <2 x i64> poison, i64 %29, i64 0
  %31 = shufflevector <2 x i64> %30, <2 x i64> poison, <2 x i32> zeroinitializer
  %32 = icmp eq i64 %21, %19
  br label %33

33:                                               ; preds = %18, %60
  %34 = phi i32 [ %61, %60 ], [ %9, %18 ]
  %35 = phi i32 [ %62, %60 ], [ 0, %18 ]
  br i1 %20, label %53, label %36

36:                                               ; preds = %33, %36
  %37 = phi i64 [ %48, %36 ], [ 0, %33 ]
  %38 = phi <2 x i64> [ %46, %36 ], [ zeroinitializer, %33 ]
  %39 = phi <2 x i64> [ %47, %36 ], [ zeroinitializer, %33 ]
  %40 = getelementptr inbounds i64, ptr %0, i64 %37
  %41 = load <2 x i64>, ptr %40, align 8, !tbaa !26
  %42 = getelementptr inbounds i64, ptr %40, i64 2
  %43 = load <2 x i64>, ptr %42, align 8, !tbaa !26
  %44 = xor <2 x i64> %28, %41
  %45 = xor <2 x i64> %31, %43
  %46 = add <2 x i64> %44, %38
  %47 = add <2 x i64> %45, %39
  %48 = add nuw i64 %37, 4
  %49 = icmp eq i64 %48, %21
  br i1 %49, label %50, label %36, !llvm.loop !437

50:                                               ; preds = %36
  %51 = add <2 x i64> %47, %46
  %52 = tail call i64 @llvm.vector.reduce.add.v2i64(<2 x i64> %51)
  br i1 %32, label %76, label %53

53:                                               ; preds = %33, %50
  %54 = phi i64 [ 0, %33 ], [ %21, %50 ]
  %55 = phi i64 [ 0, %33 ], [ %52, %50 ]
  br label %64

56:                                               ; preds = %76
  %57 = load i32, ptr @current_test, align 4, !tbaa !9
  %58 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %57)
  %59 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %60

60:                                               ; preds = %56, %76
  %61 = phi i32 [ %59, %56 ], [ %34, %76 ]
  %62 = add nuw nsw i32 %35, 1
  %63 = icmp slt i32 %62, %61
  br i1 %63, label %33, label %99, !llvm.loop !438

64:                                               ; preds = %53, %64
  %65 = phi i64 [ %74, %64 ], [ %54, %53 ]
  %66 = phi i64 [ %73, %64 ], [ %55, %53 ]
  %67 = getelementptr inbounds i64, ptr %0, i64 %65
  %68 = load i64, ptr %67, align 8, !tbaa !26
  %69 = xor i64 %68, %2
  %70 = xor i64 %69, %3
  %71 = xor i64 %70, %4
  %72 = xor i64 %71, %5
  %73 = add nsw i64 %72, %66
  %74 = add nuw nsw i64 %65, 1
  %75 = icmp eq i64 %74, %19
  br i1 %75, label %76, label %64, !llvm.loop !439

76:                                               ; preds = %64, %50
  %77 = phi i64 [ %52, %50 ], [ %73, %64 ]
  %78 = load double, ptr @init_value, align 8, !tbaa !28
  %79 = fptosi double %78 to i64
  %80 = xor i64 %15, %79
  %81 = mul nsw i64 %80, 8000
  %82 = icmp eq i64 %81, %77
  br i1 %82, label %60, label %56

83:                                               ; preds = %16, %94
  %84 = phi i32 [ %95, %94 ], [ %9, %16 ]
  %85 = phi double [ %96, %94 ], [ %17, %16 ]
  %86 = phi i32 [ %97, %94 ], [ 0, %16 ]
  %87 = fptosi double %85 to i64
  %88 = icmp eq i64 %15, %87
  br i1 %88, label %94, label %89

89:                                               ; preds = %83
  %90 = load i32, ptr @current_test, align 4, !tbaa !9
  %91 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %90)
  %92 = load double, ptr @init_value, align 8, !tbaa !28
  %93 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %94

94:                                               ; preds = %83, %89
  %95 = phi i32 [ %84, %83 ], [ %93, %89 ]
  %96 = phi double [ %85, %83 ], [ %92, %89 ]
  %97 = add nuw nsw i32 %86, 1
  %98 = icmp slt i32 %97, %95
  br i1 %98, label %83, label %99, !llvm.loop !438

99:                                               ; preds = %94, %60, %7
  %100 = tail call i64 @clock() #17
  store i64 %100, ptr @end_time, align 8, !tbaa !26
  %101 = load i64, ptr @start_time, align 8, !tbaa !26
  %102 = load ptr, ptr @results, align 8, !tbaa !5
  %103 = icmp eq ptr %102, null
  br i1 %103, label %104, label %106

104:                                              ; preds = %99
  %105 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %110

106:                                              ; preds = %99
  %107 = load i32, ptr @current_test, align 4, !tbaa !9
  %108 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %109 = icmp slt i32 %107, %108
  br i1 %109, label %122, label %110

110:                                              ; preds = %106, %104
  %111 = phi i32 [ %105, %104 ], [ %108, %106 ]
  %112 = add nsw i32 %111, 10
  store i32 %112, ptr @allocated_results, align 4, !tbaa !9
  %113 = sext i32 %112 to i64
  %114 = shl nsw i64 %113, 4
  %115 = tail call ptr @realloc(ptr noundef %102, i64 noundef %114) #14
  store ptr %115, ptr @results, align 8, !tbaa !5
  %116 = icmp eq ptr %115, null
  br i1 %116, label %119, label %117

117:                                              ; preds = %110
  %118 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %122

119:                                              ; preds = %110
  %120 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %121 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %120)
  tail call void @exit(i32 noundef -1) #15
  unreachable

122:                                              ; preds = %106, %117
  %123 = phi i32 [ %118, %117 ], [ %107, %106 ]
  %124 = phi ptr [ %115, %117 ], [ %102, %106 ]
  %125 = sub nsw i64 %100, %101
  %126 = sitofp i64 %125 to double
  %127 = fdiv double %126, 1.000000e+06
  %128 = sext i32 %123 to i64
  %129 = getelementptr inbounds %struct.one_result, ptr %124, i64 %128
  store double %127, ptr %129, align 8, !tbaa !11
  %130 = getelementptr inbounds %struct.one_result, ptr %124, i64 %128, i32 1
  store ptr %6, ptr %130, align 8, !tbaa !14
  %131 = add nsw i32 %123, 1
  store i32 %131, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1Im19custom_add_variableImEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i64 noundef %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !26
  %6 = load i32, ptr @iterations, align 4, !tbaa !9
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %86

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  br i1 %9, label %12, label %10

10:                                               ; preds = %8
  %11 = load double, ptr @init_value, align 8, !tbaa !28
  br label %68

12:                                               ; preds = %8
  %13 = zext i32 %1 to i64
  %14 = icmp ult i32 %1, 4
  %15 = and i64 %13, 4294967292
  %16 = insertelement <2 x i64> poison, i64 %2, i64 0
  %17 = shufflevector <2 x i64> %16, <2 x i64> poison, <2 x i32> zeroinitializer
  %18 = insertelement <2 x i64> poison, i64 %2, i64 0
  %19 = shufflevector <2 x i64> %18, <2 x i64> poison, <2 x i32> zeroinitializer
  %20 = icmp eq i64 %15, %13
  br label %21

21:                                               ; preds = %12, %48
  %22 = phi i32 [ %49, %48 ], [ %6, %12 ]
  %23 = phi i32 [ %50, %48 ], [ 0, %12 ]
  br i1 %14, label %41, label %24

24:                                               ; preds = %21, %24
  %25 = phi i64 [ %36, %24 ], [ 0, %21 ]
  %26 = phi <2 x i64> [ %34, %24 ], [ zeroinitializer, %21 ]
  %27 = phi <2 x i64> [ %35, %24 ], [ zeroinitializer, %21 ]
  %28 = getelementptr inbounds i64, ptr %0, i64 %25
  %29 = load <2 x i64>, ptr %28, align 8, !tbaa !26
  %30 = getelementptr inbounds i64, ptr %28, i64 2
  %31 = load <2 x i64>, ptr %30, align 8, !tbaa !26
  %32 = add <2 x i64> %26, %17
  %33 = add <2 x i64> %27, %19
  %34 = add <2 x i64> %32, %29
  %35 = add <2 x i64> %33, %31
  %36 = add nuw i64 %25, 4
  %37 = icmp eq i64 %36, %15
  br i1 %37, label %38, label %24, !llvm.loop !440

38:                                               ; preds = %24
  %39 = add <2 x i64> %35, %34
  %40 = tail call i64 @llvm.vector.reduce.add.v2i64(<2 x i64> %39)
  br i1 %20, label %61, label %41

41:                                               ; preds = %21, %38
  %42 = phi i64 [ 0, %21 ], [ %15, %38 ]
  %43 = phi i64 [ 0, %21 ], [ %40, %38 ]
  br label %52

44:                                               ; preds = %61
  %45 = load i32, ptr @current_test, align 4, !tbaa !9
  %46 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %45)
  %47 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %48

48:                                               ; preds = %44, %61
  %49 = phi i32 [ %47, %44 ], [ %22, %61 ]
  %50 = add nuw nsw i32 %23, 1
  %51 = icmp slt i32 %50, %49
  br i1 %51, label %21, label %86, !llvm.loop !441

52:                                               ; preds = %41, %52
  %53 = phi i64 [ %59, %52 ], [ %42, %41 ]
  %54 = phi i64 [ %58, %52 ], [ %43, %41 ]
  %55 = getelementptr inbounds i64, ptr %0, i64 %53
  %56 = load i64, ptr %55, align 8, !tbaa !26
  %57 = add i64 %54, %2
  %58 = add i64 %57, %56
  %59 = add nuw nsw i64 %53, 1
  %60 = icmp eq i64 %59, %13
  br i1 %60, label %61, label %52, !llvm.loop !442

61:                                               ; preds = %52, %38
  %62 = phi i64 [ %40, %38 ], [ %58, %52 ]
  %63 = load double, ptr @init_value, align 8, !tbaa !28
  %64 = fptoui double %63 to i64
  %65 = add i64 %64, %2
  %66 = mul i64 %65, 8000
  %67 = icmp eq i64 %66, %62
  br i1 %67, label %48, label %44

68:                                               ; preds = %10, %81
  %69 = phi i32 [ %82, %81 ], [ %6, %10 ]
  %70 = phi double [ %83, %81 ], [ %11, %10 ]
  %71 = phi i32 [ %84, %81 ], [ 0, %10 ]
  %72 = fptoui double %70 to i64
  %73 = add i64 %72, %2
  %74 = mul i64 %73, 8000
  %75 = icmp eq i64 %74, 0
  br i1 %75, label %81, label %76

76:                                               ; preds = %68
  %77 = load i32, ptr @current_test, align 4, !tbaa !9
  %78 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %77)
  %79 = load double, ptr @init_value, align 8, !tbaa !28
  %80 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %81

81:                                               ; preds = %68, %76
  %82 = phi i32 [ %69, %68 ], [ %80, %76 ]
  %83 = phi double [ %70, %68 ], [ %79, %76 ]
  %84 = add nuw nsw i32 %71, 1
  %85 = icmp slt i32 %84, %82
  br i1 %85, label %68, label %86, !llvm.loop !441

86:                                               ; preds = %81, %48, %4
  %87 = tail call i64 @clock() #17
  store i64 %87, ptr @end_time, align 8, !tbaa !26
  %88 = load i64, ptr @start_time, align 8, !tbaa !26
  %89 = load ptr, ptr @results, align 8, !tbaa !5
  %90 = icmp eq ptr %89, null
  br i1 %90, label %91, label %93

91:                                               ; preds = %86
  %92 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %97

93:                                               ; preds = %86
  %94 = load i32, ptr @current_test, align 4, !tbaa !9
  %95 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %96 = icmp slt i32 %94, %95
  br i1 %96, label %109, label %97

97:                                               ; preds = %93, %91
  %98 = phi i32 [ %92, %91 ], [ %95, %93 ]
  %99 = add nsw i32 %98, 10
  store i32 %99, ptr @allocated_results, align 4, !tbaa !9
  %100 = sext i32 %99 to i64
  %101 = shl nsw i64 %100, 4
  %102 = tail call ptr @realloc(ptr noundef %89, i64 noundef %101) #14
  store ptr %102, ptr @results, align 8, !tbaa !5
  %103 = icmp eq ptr %102, null
  br i1 %103, label %106, label %104

104:                                              ; preds = %97
  %105 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %109

106:                                              ; preds = %97
  %107 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %108 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %107)
  tail call void @exit(i32 noundef -1) #15
  unreachable

109:                                              ; preds = %93, %104
  %110 = phi i32 [ %105, %104 ], [ %94, %93 ]
  %111 = phi ptr [ %102, %104 ], [ %89, %93 ]
  %112 = sub nsw i64 %87, %88
  %113 = sitofp i64 %112 to double
  %114 = fdiv double %113, 1.000000e+06
  %115 = sext i32 %110 to i64
  %116 = getelementptr inbounds %struct.one_result, ptr %111, i64 %115
  store double %114, ptr %116, align 8, !tbaa !11
  %117 = getelementptr inbounds %struct.one_result, ptr %111, i64 %115, i32 1
  store ptr %3, ptr %117, align 8, !tbaa !14
  %118 = add nsw i32 %110, 1
  store i32 %118, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z22test_hoisted_variable1Im19custom_add_variableImEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i64 noundef %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !26
  %6 = load i32, ptr @iterations, align 4, !tbaa !9
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %82

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  %10 = sext i32 %1 to i64
  %11 = mul i64 %10, %2
  br i1 %9, label %14, label %12

12:                                               ; preds = %8
  %13 = load double, ptr @init_value, align 8, !tbaa !28
  br label %64

14:                                               ; preds = %8
  %15 = zext i32 %1 to i64
  %16 = icmp ult i32 %1, 4
  %17 = and i64 %15, 4294967292
  %18 = icmp eq i64 %17, %15
  br label %19

19:                                               ; preds = %14, %44
  %20 = phi i32 [ %45, %44 ], [ %6, %14 ]
  %21 = phi i32 [ %46, %44 ], [ 0, %14 ]
  br i1 %16, label %37, label %22

22:                                               ; preds = %19, %22
  %23 = phi i64 [ %32, %22 ], [ 0, %19 ]
  %24 = phi <2 x i64> [ %30, %22 ], [ zeroinitializer, %19 ]
  %25 = phi <2 x i64> [ %31, %22 ], [ zeroinitializer, %19 ]
  %26 = getelementptr inbounds i64, ptr %0, i64 %23
  %27 = load <2 x i64>, ptr %26, align 8, !tbaa !26
  %28 = getelementptr inbounds i64, ptr %26, i64 2
  %29 = load <2 x i64>, ptr %28, align 8, !tbaa !26
  %30 = add <2 x i64> %27, %24
  %31 = add <2 x i64> %29, %25
  %32 = add nuw i64 %23, 4
  %33 = icmp eq i64 %32, %17
  br i1 %33, label %34, label %22, !llvm.loop !443

34:                                               ; preds = %22
  %35 = add <2 x i64> %31, %30
  %36 = tail call i64 @llvm.vector.reduce.add.v2i64(<2 x i64> %35)
  br i1 %18, label %56, label %37

37:                                               ; preds = %19, %34
  %38 = phi i64 [ 0, %19 ], [ %17, %34 ]
  %39 = phi i64 [ 0, %19 ], [ %36, %34 ]
  br label %48

40:                                               ; preds = %56
  %41 = load i32, ptr @current_test, align 4, !tbaa !9
  %42 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %41)
  %43 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %44

44:                                               ; preds = %40, %56
  %45 = phi i32 [ %43, %40 ], [ %20, %56 ]
  %46 = add nuw nsw i32 %21, 1
  %47 = icmp slt i32 %46, %45
  br i1 %47, label %19, label %82, !llvm.loop !444

48:                                               ; preds = %37, %48
  %49 = phi i64 [ %54, %48 ], [ %38, %37 ]
  %50 = phi i64 [ %53, %48 ], [ %39, %37 ]
  %51 = getelementptr inbounds i64, ptr %0, i64 %49
  %52 = load i64, ptr %51, align 8, !tbaa !26
  %53 = add i64 %52, %50
  %54 = add nuw nsw i64 %49, 1
  %55 = icmp eq i64 %54, %15
  br i1 %55, label %56, label %48, !llvm.loop !445

56:                                               ; preds = %48, %34
  %57 = phi i64 [ %36, %34 ], [ %53, %48 ]
  %58 = add i64 %57, %11
  %59 = load double, ptr @init_value, align 8, !tbaa !28
  %60 = fptoui double %59 to i64
  %61 = add i64 %60, %2
  %62 = mul i64 %61, 8000
  %63 = icmp eq i64 %62, %58
  br i1 %63, label %44, label %40

64:                                               ; preds = %12, %77
  %65 = phi i32 [ %78, %77 ], [ %6, %12 ]
  %66 = phi double [ %79, %77 ], [ %13, %12 ]
  %67 = phi i32 [ %80, %77 ], [ 0, %12 ]
  %68 = fptoui double %66 to i64
  %69 = add i64 %68, %2
  %70 = mul i64 %69, 8000
  %71 = icmp eq i64 %70, %11
  br i1 %71, label %77, label %72

72:                                               ; preds = %64
  %73 = load i32, ptr @current_test, align 4, !tbaa !9
  %74 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %73)
  %75 = load double, ptr @init_value, align 8, !tbaa !28
  %76 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %77

77:                                               ; preds = %64, %72
  %78 = phi i32 [ %65, %64 ], [ %76, %72 ]
  %79 = phi double [ %66, %64 ], [ %75, %72 ]
  %80 = add nuw nsw i32 %67, 1
  %81 = icmp slt i32 %80, %78
  br i1 %81, label %64, label %82, !llvm.loop !444

82:                                               ; preds = %77, %44, %4
  %83 = tail call i64 @clock() #17
  store i64 %83, ptr @end_time, align 8, !tbaa !26
  %84 = load i64, ptr @start_time, align 8, !tbaa !26
  %85 = load ptr, ptr @results, align 8, !tbaa !5
  %86 = icmp eq ptr %85, null
  br i1 %86, label %87, label %89

87:                                               ; preds = %82
  %88 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %93

89:                                               ; preds = %82
  %90 = load i32, ptr @current_test, align 4, !tbaa !9
  %91 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %92 = icmp slt i32 %90, %91
  br i1 %92, label %105, label %93

93:                                               ; preds = %89, %87
  %94 = phi i32 [ %88, %87 ], [ %91, %89 ]
  %95 = add nsw i32 %94, 10
  store i32 %95, ptr @allocated_results, align 4, !tbaa !9
  %96 = sext i32 %95 to i64
  %97 = shl nsw i64 %96, 4
  %98 = tail call ptr @realloc(ptr noundef %85, i64 noundef %97) #14
  store ptr %98, ptr @results, align 8, !tbaa !5
  %99 = icmp eq ptr %98, null
  br i1 %99, label %102, label %100

100:                                              ; preds = %93
  %101 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %105

102:                                              ; preds = %93
  %103 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %104 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %103)
  tail call void @exit(i32 noundef -1) #15
  unreachable

105:                                              ; preds = %89, %100
  %106 = phi i32 [ %101, %100 ], [ %90, %89 ]
  %107 = phi ptr [ %98, %100 ], [ %85, %89 ]
  %108 = sub nsw i64 %83, %84
  %109 = sitofp i64 %108 to double
  %110 = fdiv double %109, 1.000000e+06
  %111 = sext i32 %106 to i64
  %112 = getelementptr inbounds %struct.one_result, ptr %107, i64 %111
  store double %110, ptr %112, align 8, !tbaa !11
  %113 = getelementptr inbounds %struct.one_result, ptr %107, i64 %111, i32 1
  store ptr %3, ptr %113, align 8, !tbaa !14
  %114 = add nsw i32 %106, 1
  store i32 %114, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Im28custom_add_multiple_variableImEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i64 noundef %2, i64 noundef %3, i64 noundef %4, i64 noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !26
  %9 = load i32, ptr @iterations, align 4, !tbaa !9
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %92

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  %13 = add i64 %3, %2
  %14 = add i64 %13, %4
  %15 = add i64 %14, %5
  br i1 %12, label %18, label %16

16:                                               ; preds = %11
  %17 = load double, ptr @init_value, align 8, !tbaa !28
  br label %74

18:                                               ; preds = %11
  %19 = zext i32 %1 to i64
  %20 = icmp ult i32 %1, 4
  %21 = and i64 %19, 4294967292
  %22 = insertelement <2 x i64> poison, i64 %15, i64 0
  %23 = shufflevector <2 x i64> %22, <2 x i64> poison, <2 x i32> zeroinitializer
  %24 = insertelement <2 x i64> poison, i64 %15, i64 0
  %25 = shufflevector <2 x i64> %24, <2 x i64> poison, <2 x i32> zeroinitializer
  %26 = icmp eq i64 %21, %19
  br label %27

27:                                               ; preds = %18, %54
  %28 = phi i32 [ %55, %54 ], [ %9, %18 ]
  %29 = phi i32 [ %56, %54 ], [ 0, %18 ]
  br i1 %20, label %47, label %30

30:                                               ; preds = %27, %30
  %31 = phi i64 [ %42, %30 ], [ 0, %27 ]
  %32 = phi <2 x i64> [ %40, %30 ], [ zeroinitializer, %27 ]
  %33 = phi <2 x i64> [ %41, %30 ], [ zeroinitializer, %27 ]
  %34 = getelementptr inbounds i64, ptr %0, i64 %31
  %35 = load <2 x i64>, ptr %34, align 8, !tbaa !26
  %36 = getelementptr inbounds i64, ptr %34, i64 2
  %37 = load <2 x i64>, ptr %36, align 8, !tbaa !26
  %38 = add <2 x i64> %23, %32
  %39 = add <2 x i64> %25, %33
  %40 = add <2 x i64> %38, %35
  %41 = add <2 x i64> %39, %37
  %42 = add nuw i64 %31, 4
  %43 = icmp eq i64 %42, %21
  br i1 %43, label %44, label %30, !llvm.loop !446

44:                                               ; preds = %30
  %45 = add <2 x i64> %41, %40
  %46 = tail call i64 @llvm.vector.reduce.add.v2i64(<2 x i64> %45)
  br i1 %26, label %67, label %47

47:                                               ; preds = %27, %44
  %48 = phi i64 [ 0, %27 ], [ %21, %44 ]
  %49 = phi i64 [ 0, %27 ], [ %46, %44 ]
  br label %58

50:                                               ; preds = %67
  %51 = load i32, ptr @current_test, align 4, !tbaa !9
  %52 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %51)
  %53 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %54

54:                                               ; preds = %50, %67
  %55 = phi i32 [ %53, %50 ], [ %28, %67 ]
  %56 = add nuw nsw i32 %29, 1
  %57 = icmp slt i32 %56, %55
  br i1 %57, label %27, label %92, !llvm.loop !447

58:                                               ; preds = %47, %58
  %59 = phi i64 [ %65, %58 ], [ %48, %47 ]
  %60 = phi i64 [ %64, %58 ], [ %49, %47 ]
  %61 = getelementptr inbounds i64, ptr %0, i64 %59
  %62 = load i64, ptr %61, align 8, !tbaa !26
  %63 = add i64 %15, %60
  %64 = add i64 %63, %62
  %65 = add nuw nsw i64 %59, 1
  %66 = icmp eq i64 %65, %19
  br i1 %66, label %67, label %58, !llvm.loop !448

67:                                               ; preds = %58, %44
  %68 = phi i64 [ %46, %44 ], [ %64, %58 ]
  %69 = load double, ptr @init_value, align 8, !tbaa !28
  %70 = fptoui double %69 to i64
  %71 = add i64 %15, %70
  %72 = mul i64 %71, 8000
  %73 = icmp eq i64 %72, %68
  br i1 %73, label %54, label %50

74:                                               ; preds = %16, %87
  %75 = phi i32 [ %88, %87 ], [ %9, %16 ]
  %76 = phi double [ %89, %87 ], [ %17, %16 ]
  %77 = phi i32 [ %90, %87 ], [ 0, %16 ]
  %78 = fptoui double %76 to i64
  %79 = add i64 %15, %78
  %80 = mul i64 %79, 8000
  %81 = icmp eq i64 %80, 0
  br i1 %81, label %87, label %82

82:                                               ; preds = %74
  %83 = load i32, ptr @current_test, align 4, !tbaa !9
  %84 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %83)
  %85 = load double, ptr @init_value, align 8, !tbaa !28
  %86 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %87

87:                                               ; preds = %74, %82
  %88 = phi i32 [ %75, %74 ], [ %86, %82 ]
  %89 = phi double [ %76, %74 ], [ %85, %82 ]
  %90 = add nuw nsw i32 %77, 1
  %91 = icmp slt i32 %90, %88
  br i1 %91, label %74, label %92, !llvm.loop !447

92:                                               ; preds = %87, %54, %7
  %93 = tail call i64 @clock() #17
  store i64 %93, ptr @end_time, align 8, !tbaa !26
  %94 = load i64, ptr @start_time, align 8, !tbaa !26
  %95 = load ptr, ptr @results, align 8, !tbaa !5
  %96 = icmp eq ptr %95, null
  br i1 %96, label %97, label %99

97:                                               ; preds = %92
  %98 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %103

99:                                               ; preds = %92
  %100 = load i32, ptr @current_test, align 4, !tbaa !9
  %101 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %102 = icmp slt i32 %100, %101
  br i1 %102, label %115, label %103

103:                                              ; preds = %99, %97
  %104 = phi i32 [ %98, %97 ], [ %101, %99 ]
  %105 = add nsw i32 %104, 10
  store i32 %105, ptr @allocated_results, align 4, !tbaa !9
  %106 = sext i32 %105 to i64
  %107 = shl nsw i64 %106, 4
  %108 = tail call ptr @realloc(ptr noundef %95, i64 noundef %107) #14
  store ptr %108, ptr @results, align 8, !tbaa !5
  %109 = icmp eq ptr %108, null
  br i1 %109, label %112, label %110

110:                                              ; preds = %103
  %111 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %115

112:                                              ; preds = %103
  %113 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %114 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %113)
  tail call void @exit(i32 noundef -1) #15
  unreachable

115:                                              ; preds = %99, %110
  %116 = phi i32 [ %111, %110 ], [ %100, %99 ]
  %117 = phi ptr [ %108, %110 ], [ %95, %99 ]
  %118 = sub nsw i64 %93, %94
  %119 = sitofp i64 %118 to double
  %120 = fdiv double %119, 1.000000e+06
  %121 = sext i32 %116 to i64
  %122 = getelementptr inbounds %struct.one_result, ptr %117, i64 %121
  store double %120, ptr %122, align 8, !tbaa !11
  %123 = getelementptr inbounds %struct.one_result, ptr %117, i64 %121, i32 1
  store ptr %6, ptr %123, align 8, !tbaa !14
  %124 = add nsw i32 %116, 1
  store i32 %124, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1Im19custom_sub_variableImEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i64 noundef %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !26
  %6 = load i32, ptr @iterations, align 4, !tbaa !9
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %86

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  br i1 %9, label %12, label %10

10:                                               ; preds = %8
  %11 = load double, ptr @init_value, align 8, !tbaa !28
  br label %68

12:                                               ; preds = %8
  %13 = zext i32 %1 to i64
  %14 = icmp ult i32 %1, 4
  %15 = and i64 %13, 4294967292
  %16 = insertelement <2 x i64> poison, i64 %2, i64 0
  %17 = shufflevector <2 x i64> %16, <2 x i64> poison, <2 x i32> zeroinitializer
  %18 = insertelement <2 x i64> poison, i64 %2, i64 0
  %19 = shufflevector <2 x i64> %18, <2 x i64> poison, <2 x i32> zeroinitializer
  %20 = icmp eq i64 %15, %13
  br label %21

21:                                               ; preds = %12, %48
  %22 = phi i32 [ %49, %48 ], [ %6, %12 ]
  %23 = phi i32 [ %50, %48 ], [ 0, %12 ]
  br i1 %14, label %41, label %24

24:                                               ; preds = %21, %24
  %25 = phi i64 [ %36, %24 ], [ 0, %21 ]
  %26 = phi <2 x i64> [ %34, %24 ], [ zeroinitializer, %21 ]
  %27 = phi <2 x i64> [ %35, %24 ], [ zeroinitializer, %21 ]
  %28 = getelementptr inbounds i64, ptr %0, i64 %25
  %29 = load <2 x i64>, ptr %28, align 8, !tbaa !26
  %30 = getelementptr inbounds i64, ptr %28, i64 2
  %31 = load <2 x i64>, ptr %30, align 8, !tbaa !26
  %32 = sub <2 x i64> %26, %17
  %33 = sub <2 x i64> %27, %19
  %34 = add <2 x i64> %32, %29
  %35 = add <2 x i64> %33, %31
  %36 = add nuw i64 %25, 4
  %37 = icmp eq i64 %36, %15
  br i1 %37, label %38, label %24, !llvm.loop !449

38:                                               ; preds = %24
  %39 = add <2 x i64> %35, %34
  %40 = tail call i64 @llvm.vector.reduce.add.v2i64(<2 x i64> %39)
  br i1 %20, label %61, label %41

41:                                               ; preds = %21, %38
  %42 = phi i64 [ 0, %21 ], [ %15, %38 ]
  %43 = phi i64 [ 0, %21 ], [ %40, %38 ]
  br label %52

44:                                               ; preds = %61
  %45 = load i32, ptr @current_test, align 4, !tbaa !9
  %46 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %45)
  %47 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %48

48:                                               ; preds = %44, %61
  %49 = phi i32 [ %47, %44 ], [ %22, %61 ]
  %50 = add nuw nsw i32 %23, 1
  %51 = icmp slt i32 %50, %49
  br i1 %51, label %21, label %86, !llvm.loop !450

52:                                               ; preds = %41, %52
  %53 = phi i64 [ %59, %52 ], [ %42, %41 ]
  %54 = phi i64 [ %58, %52 ], [ %43, %41 ]
  %55 = getelementptr inbounds i64, ptr %0, i64 %53
  %56 = load i64, ptr %55, align 8, !tbaa !26
  %57 = sub i64 %54, %2
  %58 = add i64 %57, %56
  %59 = add nuw nsw i64 %53, 1
  %60 = icmp eq i64 %59, %13
  br i1 %60, label %61, label %52, !llvm.loop !451

61:                                               ; preds = %52, %38
  %62 = phi i64 [ %40, %38 ], [ %58, %52 ]
  %63 = load double, ptr @init_value, align 8, !tbaa !28
  %64 = fptoui double %63 to i64
  %65 = sub i64 %64, %2
  %66 = mul i64 %65, 8000
  %67 = icmp eq i64 %66, %62
  br i1 %67, label %48, label %44

68:                                               ; preds = %10, %81
  %69 = phi i32 [ %82, %81 ], [ %6, %10 ]
  %70 = phi double [ %83, %81 ], [ %11, %10 ]
  %71 = phi i32 [ %84, %81 ], [ 0, %10 ]
  %72 = fptoui double %70 to i64
  %73 = sub i64 %72, %2
  %74 = mul i64 %73, 8000
  %75 = icmp eq i64 %74, 0
  br i1 %75, label %81, label %76

76:                                               ; preds = %68
  %77 = load i32, ptr @current_test, align 4, !tbaa !9
  %78 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %77)
  %79 = load double, ptr @init_value, align 8, !tbaa !28
  %80 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %81

81:                                               ; preds = %68, %76
  %82 = phi i32 [ %69, %68 ], [ %80, %76 ]
  %83 = phi double [ %70, %68 ], [ %79, %76 ]
  %84 = add nuw nsw i32 %71, 1
  %85 = icmp slt i32 %84, %82
  br i1 %85, label %68, label %86, !llvm.loop !450

86:                                               ; preds = %81, %48, %4
  %87 = tail call i64 @clock() #17
  store i64 %87, ptr @end_time, align 8, !tbaa !26
  %88 = load i64, ptr @start_time, align 8, !tbaa !26
  %89 = load ptr, ptr @results, align 8, !tbaa !5
  %90 = icmp eq ptr %89, null
  br i1 %90, label %91, label %93

91:                                               ; preds = %86
  %92 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %97

93:                                               ; preds = %86
  %94 = load i32, ptr @current_test, align 4, !tbaa !9
  %95 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %96 = icmp slt i32 %94, %95
  br i1 %96, label %109, label %97

97:                                               ; preds = %93, %91
  %98 = phi i32 [ %92, %91 ], [ %95, %93 ]
  %99 = add nsw i32 %98, 10
  store i32 %99, ptr @allocated_results, align 4, !tbaa !9
  %100 = sext i32 %99 to i64
  %101 = shl nsw i64 %100, 4
  %102 = tail call ptr @realloc(ptr noundef %89, i64 noundef %101) #14
  store ptr %102, ptr @results, align 8, !tbaa !5
  %103 = icmp eq ptr %102, null
  br i1 %103, label %106, label %104

104:                                              ; preds = %97
  %105 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %109

106:                                              ; preds = %97
  %107 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %108 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %107)
  tail call void @exit(i32 noundef -1) #15
  unreachable

109:                                              ; preds = %93, %104
  %110 = phi i32 [ %105, %104 ], [ %94, %93 ]
  %111 = phi ptr [ %102, %104 ], [ %89, %93 ]
  %112 = sub nsw i64 %87, %88
  %113 = sitofp i64 %112 to double
  %114 = fdiv double %113, 1.000000e+06
  %115 = sext i32 %110 to i64
  %116 = getelementptr inbounds %struct.one_result, ptr %111, i64 %115
  store double %114, ptr %116, align 8, !tbaa !11
  %117 = getelementptr inbounds %struct.one_result, ptr %111, i64 %115, i32 1
  store ptr %3, ptr %117, align 8, !tbaa !14
  %118 = add nsw i32 %110, 1
  store i32 %118, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Im28custom_sub_multiple_variableImEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i64 noundef %2, i64 noundef %3, i64 noundef %4, i64 noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !26
  %9 = load i32, ptr @iterations, align 4, !tbaa !9
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %92

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  %13 = add i64 %3, %2
  %14 = add i64 %13, %4
  %15 = add i64 %14, %5
  br i1 %12, label %18, label %16

16:                                               ; preds = %11
  %17 = load double, ptr @init_value, align 8, !tbaa !28
  br label %74

18:                                               ; preds = %11
  %19 = zext i32 %1 to i64
  %20 = icmp ult i32 %1, 4
  %21 = and i64 %19, 4294967292
  %22 = insertelement <2 x i64> poison, i64 %15, i64 0
  %23 = shufflevector <2 x i64> %22, <2 x i64> poison, <2 x i32> zeroinitializer
  %24 = insertelement <2 x i64> poison, i64 %15, i64 0
  %25 = shufflevector <2 x i64> %24, <2 x i64> poison, <2 x i32> zeroinitializer
  %26 = icmp eq i64 %21, %19
  br label %27

27:                                               ; preds = %18, %54
  %28 = phi i32 [ %55, %54 ], [ %9, %18 ]
  %29 = phi i32 [ %56, %54 ], [ 0, %18 ]
  br i1 %20, label %47, label %30

30:                                               ; preds = %27, %30
  %31 = phi i64 [ %42, %30 ], [ 0, %27 ]
  %32 = phi <2 x i64> [ %40, %30 ], [ zeroinitializer, %27 ]
  %33 = phi <2 x i64> [ %41, %30 ], [ zeroinitializer, %27 ]
  %34 = getelementptr inbounds i64, ptr %0, i64 %31
  %35 = load <2 x i64>, ptr %34, align 8, !tbaa !26
  %36 = getelementptr inbounds i64, ptr %34, i64 2
  %37 = load <2 x i64>, ptr %36, align 8, !tbaa !26
  %38 = sub <2 x i64> %32, %23
  %39 = sub <2 x i64> %33, %25
  %40 = add <2 x i64> %38, %35
  %41 = add <2 x i64> %39, %37
  %42 = add nuw i64 %31, 4
  %43 = icmp eq i64 %42, %21
  br i1 %43, label %44, label %30, !llvm.loop !452

44:                                               ; preds = %30
  %45 = add <2 x i64> %41, %40
  %46 = tail call i64 @llvm.vector.reduce.add.v2i64(<2 x i64> %45)
  br i1 %26, label %67, label %47

47:                                               ; preds = %27, %44
  %48 = phi i64 [ 0, %27 ], [ %21, %44 ]
  %49 = phi i64 [ 0, %27 ], [ %46, %44 ]
  br label %58

50:                                               ; preds = %67
  %51 = load i32, ptr @current_test, align 4, !tbaa !9
  %52 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %51)
  %53 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %54

54:                                               ; preds = %50, %67
  %55 = phi i32 [ %53, %50 ], [ %28, %67 ]
  %56 = add nuw nsw i32 %29, 1
  %57 = icmp slt i32 %56, %55
  br i1 %57, label %27, label %92, !llvm.loop !453

58:                                               ; preds = %47, %58
  %59 = phi i64 [ %65, %58 ], [ %48, %47 ]
  %60 = phi i64 [ %64, %58 ], [ %49, %47 ]
  %61 = getelementptr inbounds i64, ptr %0, i64 %59
  %62 = load i64, ptr %61, align 8, !tbaa !26
  %63 = sub i64 %60, %15
  %64 = add i64 %63, %62
  %65 = add nuw nsw i64 %59, 1
  %66 = icmp eq i64 %65, %19
  br i1 %66, label %67, label %58, !llvm.loop !454

67:                                               ; preds = %58, %44
  %68 = phi i64 [ %46, %44 ], [ %64, %58 ]
  %69 = load double, ptr @init_value, align 8, !tbaa !28
  %70 = fptoui double %69 to i64
  %71 = sub i64 %70, %15
  %72 = mul i64 %71, 8000
  %73 = icmp eq i64 %72, %68
  br i1 %73, label %54, label %50

74:                                               ; preds = %16, %87
  %75 = phi i32 [ %88, %87 ], [ %9, %16 ]
  %76 = phi double [ %89, %87 ], [ %17, %16 ]
  %77 = phi i32 [ %90, %87 ], [ 0, %16 ]
  %78 = fptoui double %76 to i64
  %79 = sub i64 %78, %15
  %80 = mul i64 %79, 8000
  %81 = icmp eq i64 %80, 0
  br i1 %81, label %87, label %82

82:                                               ; preds = %74
  %83 = load i32, ptr @current_test, align 4, !tbaa !9
  %84 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %83)
  %85 = load double, ptr @init_value, align 8, !tbaa !28
  %86 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %87

87:                                               ; preds = %74, %82
  %88 = phi i32 [ %75, %74 ], [ %86, %82 ]
  %89 = phi double [ %76, %74 ], [ %85, %82 ]
  %90 = add nuw nsw i32 %77, 1
  %91 = icmp slt i32 %90, %88
  br i1 %91, label %74, label %92, !llvm.loop !453

92:                                               ; preds = %87, %54, %7
  %93 = tail call i64 @clock() #17
  store i64 %93, ptr @end_time, align 8, !tbaa !26
  %94 = load i64, ptr @start_time, align 8, !tbaa !26
  %95 = load ptr, ptr @results, align 8, !tbaa !5
  %96 = icmp eq ptr %95, null
  br i1 %96, label %97, label %99

97:                                               ; preds = %92
  %98 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %103

99:                                               ; preds = %92
  %100 = load i32, ptr @current_test, align 4, !tbaa !9
  %101 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %102 = icmp slt i32 %100, %101
  br i1 %102, label %115, label %103

103:                                              ; preds = %99, %97
  %104 = phi i32 [ %98, %97 ], [ %101, %99 ]
  %105 = add nsw i32 %104, 10
  store i32 %105, ptr @allocated_results, align 4, !tbaa !9
  %106 = sext i32 %105 to i64
  %107 = shl nsw i64 %106, 4
  %108 = tail call ptr @realloc(ptr noundef %95, i64 noundef %107) #14
  store ptr %108, ptr @results, align 8, !tbaa !5
  %109 = icmp eq ptr %108, null
  br i1 %109, label %112, label %110

110:                                              ; preds = %103
  %111 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %115

112:                                              ; preds = %103
  %113 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %114 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %113)
  tail call void @exit(i32 noundef -1) #15
  unreachable

115:                                              ; preds = %99, %110
  %116 = phi i32 [ %111, %110 ], [ %100, %99 ]
  %117 = phi ptr [ %108, %110 ], [ %95, %99 ]
  %118 = sub nsw i64 %93, %94
  %119 = sitofp i64 %118 to double
  %120 = fdiv double %119, 1.000000e+06
  %121 = sext i32 %116 to i64
  %122 = getelementptr inbounds %struct.one_result, ptr %117, i64 %121
  store double %120, ptr %122, align 8, !tbaa !11
  %123 = getelementptr inbounds %struct.one_result, ptr %117, i64 %121, i32 1
  store ptr %6, ptr %123, align 8, !tbaa !14
  %124 = add nsw i32 %116, 1
  store i32 %124, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1Im24custom_multiply_variableImEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i64 noundef %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !26
  %6 = load i32, ptr @iterations, align 4, !tbaa !9
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %94

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  %10 = mul i64 %2, 8000
  br i1 %9, label %13, label %11

11:                                               ; preds = %8
  %12 = load double, ptr @init_value, align 8, !tbaa !28
  br label %77

13:                                               ; preds = %8
  %14 = zext i32 %1 to i64
  %15 = and i64 %14, 3
  %16 = icmp ult i32 %1, 4
  %17 = and i64 %14, 4294967292
  %18 = icmp eq i64 %15, 0
  br label %19

19:                                               ; preds = %13, %26
  %20 = phi i32 [ %27, %26 ], [ %6, %13 ]
  %21 = phi i32 [ %28, %26 ], [ 0, %13 ]
  br i1 %16, label %56, label %30

22:                                               ; preds = %71
  %23 = load i32, ptr @current_test, align 4, !tbaa !9
  %24 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %23)
  %25 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %26

26:                                               ; preds = %22, %71
  %27 = phi i32 [ %25, %22 ], [ %20, %71 ]
  %28 = add nuw nsw i32 %21, 1
  %29 = icmp slt i32 %28, %27
  br i1 %29, label %19, label %94, !llvm.loop !455

30:                                               ; preds = %19, %30
  %31 = phi i64 [ %53, %30 ], [ 0, %19 ]
  %32 = phi i64 [ %52, %30 ], [ 0, %19 ]
  %33 = phi i64 [ %54, %30 ], [ 0, %19 ]
  %34 = getelementptr inbounds i64, ptr %0, i64 %31
  %35 = load i64, ptr %34, align 8, !tbaa !26
  %36 = mul i64 %35, %2
  %37 = add i64 %36, %32
  %38 = or i64 %31, 1
  %39 = getelementptr inbounds i64, ptr %0, i64 %38
  %40 = load i64, ptr %39, align 8, !tbaa !26
  %41 = mul i64 %40, %2
  %42 = add i64 %41, %37
  %43 = or i64 %31, 2
  %44 = getelementptr inbounds i64, ptr %0, i64 %43
  %45 = load i64, ptr %44, align 8, !tbaa !26
  %46 = mul i64 %45, %2
  %47 = add i64 %46, %42
  %48 = or i64 %31, 3
  %49 = getelementptr inbounds i64, ptr %0, i64 %48
  %50 = load i64, ptr %49, align 8, !tbaa !26
  %51 = mul i64 %50, %2
  %52 = add i64 %51, %47
  %53 = add nuw nsw i64 %31, 4
  %54 = add i64 %33, 4
  %55 = icmp eq i64 %54, %17
  br i1 %55, label %56, label %30, !llvm.loop !456

56:                                               ; preds = %30, %19
  %57 = phi i64 [ undef, %19 ], [ %52, %30 ]
  %58 = phi i64 [ 0, %19 ], [ %53, %30 ]
  %59 = phi i64 [ 0, %19 ], [ %52, %30 ]
  br i1 %18, label %71, label %60

60:                                               ; preds = %56, %60
  %61 = phi i64 [ %68, %60 ], [ %58, %56 ]
  %62 = phi i64 [ %67, %60 ], [ %59, %56 ]
  %63 = phi i64 [ %69, %60 ], [ 0, %56 ]
  %64 = getelementptr inbounds i64, ptr %0, i64 %61
  %65 = load i64, ptr %64, align 8, !tbaa !26
  %66 = mul i64 %65, %2
  %67 = add i64 %66, %62
  %68 = add nuw nsw i64 %61, 1
  %69 = add i64 %63, 1
  %70 = icmp eq i64 %69, %15
  br i1 %70, label %71, label %60, !llvm.loop !457

71:                                               ; preds = %60, %56
  %72 = phi i64 [ %57, %56 ], [ %67, %60 ]
  %73 = load double, ptr @init_value, align 8, !tbaa !28
  %74 = fptoui double %73 to i64
  %75 = mul i64 %10, %74
  %76 = icmp eq i64 %75, %72
  br i1 %76, label %26, label %22

77:                                               ; preds = %11, %89
  %78 = phi i32 [ %90, %89 ], [ %6, %11 ]
  %79 = phi double [ %91, %89 ], [ %12, %11 ]
  %80 = phi i32 [ %92, %89 ], [ 0, %11 ]
  %81 = fptoui double %79 to i64
  %82 = mul i64 %10, %81
  %83 = icmp eq i64 %82, 0
  br i1 %83, label %89, label %84

84:                                               ; preds = %77
  %85 = load i32, ptr @current_test, align 4, !tbaa !9
  %86 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %85)
  %87 = load double, ptr @init_value, align 8, !tbaa !28
  %88 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %89

89:                                               ; preds = %77, %84
  %90 = phi i32 [ %78, %77 ], [ %88, %84 ]
  %91 = phi double [ %79, %77 ], [ %87, %84 ]
  %92 = add nuw nsw i32 %80, 1
  %93 = icmp slt i32 %92, %90
  br i1 %93, label %77, label %94, !llvm.loop !455

94:                                               ; preds = %89, %26, %4
  %95 = tail call i64 @clock() #17
  store i64 %95, ptr @end_time, align 8, !tbaa !26
  %96 = load i64, ptr @start_time, align 8, !tbaa !26
  %97 = load ptr, ptr @results, align 8, !tbaa !5
  %98 = icmp eq ptr %97, null
  br i1 %98, label %99, label %101

99:                                               ; preds = %94
  %100 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %105

101:                                              ; preds = %94
  %102 = load i32, ptr @current_test, align 4, !tbaa !9
  %103 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %104 = icmp slt i32 %102, %103
  br i1 %104, label %117, label %105

105:                                              ; preds = %101, %99
  %106 = phi i32 [ %100, %99 ], [ %103, %101 ]
  %107 = add nsw i32 %106, 10
  store i32 %107, ptr @allocated_results, align 4, !tbaa !9
  %108 = sext i32 %107 to i64
  %109 = shl nsw i64 %108, 4
  %110 = tail call ptr @realloc(ptr noundef %97, i64 noundef %109) #14
  store ptr %110, ptr @results, align 8, !tbaa !5
  %111 = icmp eq ptr %110, null
  br i1 %111, label %114, label %112

112:                                              ; preds = %105
  %113 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %117

114:                                              ; preds = %105
  %115 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %116 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %115)
  tail call void @exit(i32 noundef -1) #15
  unreachable

117:                                              ; preds = %101, %112
  %118 = phi i32 [ %113, %112 ], [ %102, %101 ]
  %119 = phi ptr [ %110, %112 ], [ %97, %101 ]
  %120 = sub nsw i64 %95, %96
  %121 = sitofp i64 %120 to double
  %122 = fdiv double %121, 1.000000e+06
  %123 = sext i32 %118 to i64
  %124 = getelementptr inbounds %struct.one_result, ptr %119, i64 %123
  store double %122, ptr %124, align 8, !tbaa !11
  %125 = getelementptr inbounds %struct.one_result, ptr %119, i64 %123, i32 1
  store ptr %3, ptr %125, align 8, !tbaa !14
  %126 = add nsw i32 %118, 1
  store i32 %126, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Im33custom_multiply_multiple_variableImEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i64 noundef %2, i64 noundef %3, i64 noundef %4, i64 noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !26
  %9 = load i32, ptr @iterations, align 4, !tbaa !9
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %102

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  %13 = mul i64 %3, %2
  %14 = mul i64 %13, %4
  %15 = mul i64 %14, %5
  %16 = mul i64 %13, 8000
  %17 = mul i64 %16, %4
  %18 = mul i64 %17, %5
  br i1 %12, label %21, label %19

19:                                               ; preds = %11
  %20 = load double, ptr @init_value, align 8, !tbaa !28
  br label %85

21:                                               ; preds = %11
  %22 = zext i32 %1 to i64
  %23 = and i64 %22, 3
  %24 = icmp ult i32 %1, 4
  %25 = and i64 %22, 4294967292
  %26 = icmp eq i64 %23, 0
  br label %27

27:                                               ; preds = %21, %34
  %28 = phi i32 [ %35, %34 ], [ %9, %21 ]
  %29 = phi i32 [ %36, %34 ], [ 0, %21 ]
  br i1 %24, label %64, label %38

30:                                               ; preds = %79
  %31 = load i32, ptr @current_test, align 4, !tbaa !9
  %32 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %31)
  %33 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %34

34:                                               ; preds = %30, %79
  %35 = phi i32 [ %33, %30 ], [ %28, %79 ]
  %36 = add nuw nsw i32 %29, 1
  %37 = icmp slt i32 %36, %35
  br i1 %37, label %27, label %102, !llvm.loop !458

38:                                               ; preds = %27, %38
  %39 = phi i64 [ %61, %38 ], [ 0, %27 ]
  %40 = phi i64 [ %60, %38 ], [ 0, %27 ]
  %41 = phi i64 [ %62, %38 ], [ 0, %27 ]
  %42 = getelementptr inbounds i64, ptr %0, i64 %39
  %43 = load i64, ptr %42, align 8, !tbaa !26
  %44 = mul i64 %15, %43
  %45 = add i64 %44, %40
  %46 = or i64 %39, 1
  %47 = getelementptr inbounds i64, ptr %0, i64 %46
  %48 = load i64, ptr %47, align 8, !tbaa !26
  %49 = mul i64 %15, %48
  %50 = add i64 %49, %45
  %51 = or i64 %39, 2
  %52 = getelementptr inbounds i64, ptr %0, i64 %51
  %53 = load i64, ptr %52, align 8, !tbaa !26
  %54 = mul i64 %15, %53
  %55 = add i64 %54, %50
  %56 = or i64 %39, 3
  %57 = getelementptr inbounds i64, ptr %0, i64 %56
  %58 = load i64, ptr %57, align 8, !tbaa !26
  %59 = mul i64 %15, %58
  %60 = add i64 %59, %55
  %61 = add nuw nsw i64 %39, 4
  %62 = add i64 %41, 4
  %63 = icmp eq i64 %62, %25
  br i1 %63, label %64, label %38, !llvm.loop !459

64:                                               ; preds = %38, %27
  %65 = phi i64 [ undef, %27 ], [ %60, %38 ]
  %66 = phi i64 [ 0, %27 ], [ %61, %38 ]
  %67 = phi i64 [ 0, %27 ], [ %60, %38 ]
  br i1 %26, label %79, label %68

68:                                               ; preds = %64, %68
  %69 = phi i64 [ %76, %68 ], [ %66, %64 ]
  %70 = phi i64 [ %75, %68 ], [ %67, %64 ]
  %71 = phi i64 [ %77, %68 ], [ 0, %64 ]
  %72 = getelementptr inbounds i64, ptr %0, i64 %69
  %73 = load i64, ptr %72, align 8, !tbaa !26
  %74 = mul i64 %15, %73
  %75 = add i64 %74, %70
  %76 = add nuw nsw i64 %69, 1
  %77 = add i64 %71, 1
  %78 = icmp eq i64 %77, %23
  br i1 %78, label %79, label %68, !llvm.loop !460

79:                                               ; preds = %68, %64
  %80 = phi i64 [ %65, %64 ], [ %75, %68 ]
  %81 = load double, ptr @init_value, align 8, !tbaa !28
  %82 = fptoui double %81 to i64
  %83 = mul i64 %18, %82
  %84 = icmp eq i64 %83, %80
  br i1 %84, label %34, label %30

85:                                               ; preds = %19, %97
  %86 = phi i32 [ %98, %97 ], [ %9, %19 ]
  %87 = phi double [ %99, %97 ], [ %20, %19 ]
  %88 = phi i32 [ %100, %97 ], [ 0, %19 ]
  %89 = fptoui double %87 to i64
  %90 = mul i64 %18, %89
  %91 = icmp eq i64 %90, 0
  br i1 %91, label %97, label %92

92:                                               ; preds = %85
  %93 = load i32, ptr @current_test, align 4, !tbaa !9
  %94 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %93)
  %95 = load double, ptr @init_value, align 8, !tbaa !28
  %96 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %97

97:                                               ; preds = %85, %92
  %98 = phi i32 [ %86, %85 ], [ %96, %92 ]
  %99 = phi double [ %87, %85 ], [ %95, %92 ]
  %100 = add nuw nsw i32 %88, 1
  %101 = icmp slt i32 %100, %98
  br i1 %101, label %85, label %102, !llvm.loop !458

102:                                              ; preds = %97, %34, %7
  %103 = tail call i64 @clock() #17
  store i64 %103, ptr @end_time, align 8, !tbaa !26
  %104 = load i64, ptr @start_time, align 8, !tbaa !26
  %105 = load ptr, ptr @results, align 8, !tbaa !5
  %106 = icmp eq ptr %105, null
  br i1 %106, label %107, label %109

107:                                              ; preds = %102
  %108 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %113

109:                                              ; preds = %102
  %110 = load i32, ptr @current_test, align 4, !tbaa !9
  %111 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %112 = icmp slt i32 %110, %111
  br i1 %112, label %125, label %113

113:                                              ; preds = %109, %107
  %114 = phi i32 [ %108, %107 ], [ %111, %109 ]
  %115 = add nsw i32 %114, 10
  store i32 %115, ptr @allocated_results, align 4, !tbaa !9
  %116 = sext i32 %115 to i64
  %117 = shl nsw i64 %116, 4
  %118 = tail call ptr @realloc(ptr noundef %105, i64 noundef %117) #14
  store ptr %118, ptr @results, align 8, !tbaa !5
  %119 = icmp eq ptr %118, null
  br i1 %119, label %122, label %120

120:                                              ; preds = %113
  %121 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %125

122:                                              ; preds = %113
  %123 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %124 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %123)
  tail call void @exit(i32 noundef -1) #15
  unreachable

125:                                              ; preds = %109, %120
  %126 = phi i32 [ %121, %120 ], [ %110, %109 ]
  %127 = phi ptr [ %118, %120 ], [ %105, %109 ]
  %128 = sub nsw i64 %103, %104
  %129 = sitofp i64 %128 to double
  %130 = fdiv double %129, 1.000000e+06
  %131 = sext i32 %126 to i64
  %132 = getelementptr inbounds %struct.one_result, ptr %127, i64 %131
  store double %130, ptr %132, align 8, !tbaa !11
  %133 = getelementptr inbounds %struct.one_result, ptr %127, i64 %131, i32 1
  store ptr %6, ptr %133, align 8, !tbaa !14
  %134 = add nsw i32 %126, 1
  store i32 %134, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Im34custom_multiply_multiple_variable2ImEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i64 noundef %2, i64 noundef %3, i64 noundef %4, i64 noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !26
  %9 = load i32, ptr @iterations, align 4, !tbaa !9
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %92

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  %13 = mul i64 %3, %2
  %14 = mul i64 %13, %4
  %15 = mul i64 %14, %5
  br i1 %12, label %18, label %16

16:                                               ; preds = %11
  %17 = load double, ptr @init_value, align 8, !tbaa !28
  br label %74

18:                                               ; preds = %11
  %19 = zext i32 %1 to i64
  %20 = icmp ult i32 %1, 4
  %21 = and i64 %19, 4294967292
  %22 = insertelement <2 x i64> poison, i64 %15, i64 0
  %23 = shufflevector <2 x i64> %22, <2 x i64> poison, <2 x i32> zeroinitializer
  %24 = insertelement <2 x i64> poison, i64 %15, i64 0
  %25 = shufflevector <2 x i64> %24, <2 x i64> poison, <2 x i32> zeroinitializer
  %26 = icmp eq i64 %21, %19
  br label %27

27:                                               ; preds = %18, %54
  %28 = phi i32 [ %55, %54 ], [ %9, %18 ]
  %29 = phi i32 [ %56, %54 ], [ 0, %18 ]
  br i1 %20, label %47, label %30

30:                                               ; preds = %27, %30
  %31 = phi i64 [ %42, %30 ], [ 0, %27 ]
  %32 = phi <2 x i64> [ %40, %30 ], [ zeroinitializer, %27 ]
  %33 = phi <2 x i64> [ %41, %30 ], [ zeroinitializer, %27 ]
  %34 = getelementptr inbounds i64, ptr %0, i64 %31
  %35 = load <2 x i64>, ptr %34, align 8, !tbaa !26
  %36 = getelementptr inbounds i64, ptr %34, i64 2
  %37 = load <2 x i64>, ptr %36, align 8, !tbaa !26
  %38 = add <2 x i64> %32, %23
  %39 = add <2 x i64> %33, %25
  %40 = add <2 x i64> %38, %35
  %41 = add <2 x i64> %39, %37
  %42 = add nuw i64 %31, 4
  %43 = icmp eq i64 %42, %21
  br i1 %43, label %44, label %30, !llvm.loop !461

44:                                               ; preds = %30
  %45 = add <2 x i64> %41, %40
  %46 = tail call i64 @llvm.vector.reduce.add.v2i64(<2 x i64> %45)
  br i1 %26, label %67, label %47

47:                                               ; preds = %27, %44
  %48 = phi i64 [ 0, %27 ], [ %21, %44 ]
  %49 = phi i64 [ 0, %27 ], [ %46, %44 ]
  br label %58

50:                                               ; preds = %67
  %51 = load i32, ptr @current_test, align 4, !tbaa !9
  %52 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %51)
  %53 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %54

54:                                               ; preds = %50, %67
  %55 = phi i32 [ %53, %50 ], [ %28, %67 ]
  %56 = add nuw nsw i32 %29, 1
  %57 = icmp slt i32 %56, %55
  br i1 %57, label %27, label %92, !llvm.loop !462

58:                                               ; preds = %47, %58
  %59 = phi i64 [ %65, %58 ], [ %48, %47 ]
  %60 = phi i64 [ %64, %58 ], [ %49, %47 ]
  %61 = getelementptr inbounds i64, ptr %0, i64 %59
  %62 = load i64, ptr %61, align 8, !tbaa !26
  %63 = add i64 %60, %15
  %64 = add i64 %63, %62
  %65 = add nuw nsw i64 %59, 1
  %66 = icmp eq i64 %65, %19
  br i1 %66, label %67, label %58, !llvm.loop !463

67:                                               ; preds = %58, %44
  %68 = phi i64 [ %46, %44 ], [ %64, %58 ]
  %69 = load double, ptr @init_value, align 8, !tbaa !28
  %70 = fptoui double %69 to i64
  %71 = add i64 %15, %70
  %72 = mul i64 %71, 8000
  %73 = icmp eq i64 %72, %68
  br i1 %73, label %54, label %50

74:                                               ; preds = %16, %87
  %75 = phi i32 [ %88, %87 ], [ %9, %16 ]
  %76 = phi double [ %89, %87 ], [ %17, %16 ]
  %77 = phi i32 [ %90, %87 ], [ 0, %16 ]
  %78 = fptoui double %76 to i64
  %79 = add i64 %15, %78
  %80 = mul i64 %79, 8000
  %81 = icmp eq i64 %80, 0
  br i1 %81, label %87, label %82

82:                                               ; preds = %74
  %83 = load i32, ptr @current_test, align 4, !tbaa !9
  %84 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %83)
  %85 = load double, ptr @init_value, align 8, !tbaa !28
  %86 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %87

87:                                               ; preds = %74, %82
  %88 = phi i32 [ %75, %74 ], [ %86, %82 ]
  %89 = phi double [ %76, %74 ], [ %85, %82 ]
  %90 = add nuw nsw i32 %77, 1
  %91 = icmp slt i32 %90, %88
  br i1 %91, label %74, label %92, !llvm.loop !462

92:                                               ; preds = %87, %54, %7
  %93 = tail call i64 @clock() #17
  store i64 %93, ptr @end_time, align 8, !tbaa !26
  %94 = load i64, ptr @start_time, align 8, !tbaa !26
  %95 = load ptr, ptr @results, align 8, !tbaa !5
  %96 = icmp eq ptr %95, null
  br i1 %96, label %97, label %99

97:                                               ; preds = %92
  %98 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %103

99:                                               ; preds = %92
  %100 = load i32, ptr @current_test, align 4, !tbaa !9
  %101 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %102 = icmp slt i32 %100, %101
  br i1 %102, label %115, label %103

103:                                              ; preds = %99, %97
  %104 = phi i32 [ %98, %97 ], [ %101, %99 ]
  %105 = add nsw i32 %104, 10
  store i32 %105, ptr @allocated_results, align 4, !tbaa !9
  %106 = sext i32 %105 to i64
  %107 = shl nsw i64 %106, 4
  %108 = tail call ptr @realloc(ptr noundef %95, i64 noundef %107) #14
  store ptr %108, ptr @results, align 8, !tbaa !5
  %109 = icmp eq ptr %108, null
  br i1 %109, label %112, label %110

110:                                              ; preds = %103
  %111 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %115

112:                                              ; preds = %103
  %113 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %114 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %113)
  tail call void @exit(i32 noundef -1) #15
  unreachable

115:                                              ; preds = %99, %110
  %116 = phi i32 [ %111, %110 ], [ %100, %99 ]
  %117 = phi ptr [ %108, %110 ], [ %95, %99 ]
  %118 = sub nsw i64 %93, %94
  %119 = sitofp i64 %118 to double
  %120 = fdiv double %119, 1.000000e+06
  %121 = sext i32 %116 to i64
  %122 = getelementptr inbounds %struct.one_result, ptr %117, i64 %121
  store double %120, ptr %122, align 8, !tbaa !11
  %123 = getelementptr inbounds %struct.one_result, ptr %117, i64 %121, i32 1
  store ptr %6, ptr %123, align 8, !tbaa !14
  %124 = add nsw i32 %116, 1
  store i32 %124, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1Im22custom_divide_variableImEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i64 noundef %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !26
  %6 = load i32, ptr @iterations, align 4, !tbaa !9
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %79

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  br i1 %9, label %12, label %10

10:                                               ; preds = %8
  %11 = load double, ptr @init_value, align 8, !tbaa !28
  br label %61

12:                                               ; preds = %8
  %13 = zext i32 %1 to i64
  %14 = and i64 %13, 1
  %15 = icmp eq i32 %1, 1
  %16 = and i64 %13, 4294967294
  %17 = icmp eq i64 %14, 0
  br label %18

18:                                               ; preds = %12, %25
  %19 = phi i32 [ %26, %25 ], [ %6, %12 ]
  %20 = phi i32 [ %27, %25 ], [ 0, %12 ]
  br i1 %15, label %45, label %29

21:                                               ; preds = %54
  %22 = load i32, ptr @current_test, align 4, !tbaa !9
  %23 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %22)
  %24 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %25

25:                                               ; preds = %21, %54
  %26 = phi i32 [ %24, %21 ], [ %19, %54 ]
  %27 = add nuw nsw i32 %20, 1
  %28 = icmp slt i32 %27, %26
  br i1 %28, label %18, label %79, !llvm.loop !464

29:                                               ; preds = %18, %29
  %30 = phi i64 [ %42, %29 ], [ 0, %18 ]
  %31 = phi i64 [ %41, %29 ], [ 0, %18 ]
  %32 = phi i64 [ %43, %29 ], [ 0, %18 ]
  %33 = getelementptr inbounds i64, ptr %0, i64 %30
  %34 = load i64, ptr %33, align 8, !tbaa !26
  %35 = udiv i64 %34, %2
  %36 = add i64 %35, %31
  %37 = or i64 %30, 1
  %38 = getelementptr inbounds i64, ptr %0, i64 %37
  %39 = load i64, ptr %38, align 8, !tbaa !26
  %40 = udiv i64 %39, %2
  %41 = add i64 %40, %36
  %42 = add nuw nsw i64 %30, 2
  %43 = add i64 %32, 2
  %44 = icmp eq i64 %43, %16
  br i1 %44, label %45, label %29, !llvm.loop !465

45:                                               ; preds = %29, %18
  %46 = phi i64 [ undef, %18 ], [ %41, %29 ]
  %47 = phi i64 [ 0, %18 ], [ %42, %29 ]
  %48 = phi i64 [ 0, %18 ], [ %41, %29 ]
  br i1 %17, label %54, label %49

49:                                               ; preds = %45
  %50 = getelementptr inbounds i64, ptr %0, i64 %47
  %51 = load i64, ptr %50, align 8, !tbaa !26
  %52 = udiv i64 %51, %2
  %53 = add i64 %52, %48
  br label %54

54:                                               ; preds = %45, %49
  %55 = phi i64 [ %46, %45 ], [ %53, %49 ]
  %56 = load double, ptr @init_value, align 8, !tbaa !28
  %57 = fptoui double %56 to i64
  %58 = udiv i64 %57, %2
  %59 = mul i64 %58, 8000
  %60 = icmp eq i64 %59, %55
  br i1 %60, label %25, label %21

61:                                               ; preds = %10, %74
  %62 = phi i32 [ %75, %74 ], [ %6, %10 ]
  %63 = phi double [ %76, %74 ], [ %11, %10 ]
  %64 = phi i32 [ %77, %74 ], [ 0, %10 ]
  %65 = fptoui double %63 to i64
  %66 = udiv i64 %65, %2
  %67 = mul i64 %66, 8000
  %68 = icmp eq i64 %67, 0
  br i1 %68, label %74, label %69

69:                                               ; preds = %61
  %70 = load i32, ptr @current_test, align 4, !tbaa !9
  %71 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %70)
  %72 = load double, ptr @init_value, align 8, !tbaa !28
  %73 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %74

74:                                               ; preds = %61, %69
  %75 = phi i32 [ %62, %61 ], [ %73, %69 ]
  %76 = phi double [ %63, %61 ], [ %72, %69 ]
  %77 = add nuw nsw i32 %64, 1
  %78 = icmp slt i32 %77, %75
  br i1 %78, label %61, label %79, !llvm.loop !464

79:                                               ; preds = %74, %25, %4
  %80 = tail call i64 @clock() #17
  store i64 %80, ptr @end_time, align 8, !tbaa !26
  %81 = load i64, ptr @start_time, align 8, !tbaa !26
  %82 = load ptr, ptr @results, align 8, !tbaa !5
  %83 = icmp eq ptr %82, null
  br i1 %83, label %84, label %86

84:                                               ; preds = %79
  %85 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %90

86:                                               ; preds = %79
  %87 = load i32, ptr @current_test, align 4, !tbaa !9
  %88 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %89 = icmp slt i32 %87, %88
  br i1 %89, label %102, label %90

90:                                               ; preds = %86, %84
  %91 = phi i32 [ %85, %84 ], [ %88, %86 ]
  %92 = add nsw i32 %91, 10
  store i32 %92, ptr @allocated_results, align 4, !tbaa !9
  %93 = sext i32 %92 to i64
  %94 = shl nsw i64 %93, 4
  %95 = tail call ptr @realloc(ptr noundef %82, i64 noundef %94) #14
  store ptr %95, ptr @results, align 8, !tbaa !5
  %96 = icmp eq ptr %95, null
  br i1 %96, label %99, label %97

97:                                               ; preds = %90
  %98 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %102

99:                                               ; preds = %90
  %100 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %101 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %100)
  tail call void @exit(i32 noundef -1) #15
  unreachable

102:                                              ; preds = %86, %97
  %103 = phi i32 [ %98, %97 ], [ %87, %86 ]
  %104 = phi ptr [ %95, %97 ], [ %82, %86 ]
  %105 = sub nsw i64 %80, %81
  %106 = sitofp i64 %105 to double
  %107 = fdiv double %106, 1.000000e+06
  %108 = sext i32 %103 to i64
  %109 = getelementptr inbounds %struct.one_result, ptr %104, i64 %108
  store double %107, ptr %109, align 8, !tbaa !11
  %110 = getelementptr inbounds %struct.one_result, ptr %104, i64 %108, i32 1
  store ptr %3, ptr %110, align 8, !tbaa !14
  %111 = add nsw i32 %103, 1
  store i32 %111, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Im31custom_divide_multiple_variableImEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i64 noundef %2, i64 noundef %3, i64 noundef %4, i64 noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !26
  %9 = load i32, ptr @iterations, align 4, !tbaa !9
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %70

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  br i1 %12, label %15, label %13

13:                                               ; preds = %11
  %14 = load double, ptr @init_value, align 8, !tbaa !28
  br label %49

15:                                               ; preds = %11
  %16 = zext i32 %1 to i64
  br label %17

17:                                               ; preds = %15, %24
  %18 = phi i32 [ %25, %24 ], [ %9, %15 ]
  %19 = phi i32 [ %26, %24 ], [ 0, %15 ]
  br label %28

20:                                               ; preds = %40
  %21 = load i32, ptr @current_test, align 4, !tbaa !9
  %22 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %21)
  %23 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %24

24:                                               ; preds = %20, %40
  %25 = phi i32 [ %23, %20 ], [ %18, %40 ]
  %26 = add nuw nsw i32 %19, 1
  %27 = icmp slt i32 %26, %25
  br i1 %27, label %17, label %70, !llvm.loop !466

28:                                               ; preds = %17, %28
  %29 = phi i64 [ 0, %17 ], [ %38, %28 ]
  %30 = phi i64 [ 0, %17 ], [ %37, %28 ]
  %31 = getelementptr inbounds i64, ptr %0, i64 %29
  %32 = load i64, ptr %31, align 8, !tbaa !26
  %33 = udiv i64 %32, %2
  %34 = udiv i64 %33, %3
  %35 = udiv i64 %34, %4
  %36 = udiv i64 %35, %5
  %37 = add i64 %36, %30
  %38 = add nuw nsw i64 %29, 1
  %39 = icmp eq i64 %38, %16
  br i1 %39, label %40, label %28, !llvm.loop !467

40:                                               ; preds = %28
  %41 = load double, ptr @init_value, align 8, !tbaa !28
  %42 = fptoui double %41 to i64
  %43 = udiv i64 %42, %2
  %44 = udiv i64 %43, %3
  %45 = udiv i64 %44, %4
  %46 = udiv i64 %45, %5
  %47 = mul i64 %46, 8000
  %48 = icmp eq i64 %47, %37
  br i1 %48, label %24, label %20

49:                                               ; preds = %13, %65
  %50 = phi i32 [ %66, %65 ], [ %9, %13 ]
  %51 = phi double [ %67, %65 ], [ %14, %13 ]
  %52 = phi i32 [ %68, %65 ], [ 0, %13 ]
  %53 = fptoui double %51 to i64
  %54 = udiv i64 %53, %2
  %55 = udiv i64 %54, %3
  %56 = udiv i64 %55, %4
  %57 = udiv i64 %56, %5
  %58 = mul i64 %57, 8000
  %59 = icmp eq i64 %58, 0
  br i1 %59, label %65, label %60

60:                                               ; preds = %49
  %61 = load i32, ptr @current_test, align 4, !tbaa !9
  %62 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %61)
  %63 = load double, ptr @init_value, align 8, !tbaa !28
  %64 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %65

65:                                               ; preds = %49, %60
  %66 = phi i32 [ %50, %49 ], [ %64, %60 ]
  %67 = phi double [ %51, %49 ], [ %63, %60 ]
  %68 = add nuw nsw i32 %52, 1
  %69 = icmp slt i32 %68, %66
  br i1 %69, label %49, label %70, !llvm.loop !466

70:                                               ; preds = %65, %24, %7
  %71 = tail call i64 @clock() #17
  store i64 %71, ptr @end_time, align 8, !tbaa !26
  %72 = load i64, ptr @start_time, align 8, !tbaa !26
  %73 = load ptr, ptr @results, align 8, !tbaa !5
  %74 = icmp eq ptr %73, null
  br i1 %74, label %75, label %77

75:                                               ; preds = %70
  %76 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %81

77:                                               ; preds = %70
  %78 = load i32, ptr @current_test, align 4, !tbaa !9
  %79 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %80 = icmp slt i32 %78, %79
  br i1 %80, label %93, label %81

81:                                               ; preds = %77, %75
  %82 = phi i32 [ %76, %75 ], [ %79, %77 ]
  %83 = add nsw i32 %82, 10
  store i32 %83, ptr @allocated_results, align 4, !tbaa !9
  %84 = sext i32 %83 to i64
  %85 = shl nsw i64 %84, 4
  %86 = tail call ptr @realloc(ptr noundef %73, i64 noundef %85) #14
  store ptr %86, ptr @results, align 8, !tbaa !5
  %87 = icmp eq ptr %86, null
  br i1 %87, label %90, label %88

88:                                               ; preds = %81
  %89 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %93

90:                                               ; preds = %81
  %91 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %92 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %91)
  tail call void @exit(i32 noundef -1) #15
  unreachable

93:                                               ; preds = %77, %88
  %94 = phi i32 [ %89, %88 ], [ %78, %77 ]
  %95 = phi ptr [ %86, %88 ], [ %73, %77 ]
  %96 = sub nsw i64 %71, %72
  %97 = sitofp i64 %96 to double
  %98 = fdiv double %97, 1.000000e+06
  %99 = sext i32 %94 to i64
  %100 = getelementptr inbounds %struct.one_result, ptr %95, i64 %99
  store double %98, ptr %100, align 8, !tbaa !11
  %101 = getelementptr inbounds %struct.one_result, ptr %95, i64 %99, i32 1
  store ptr %6, ptr %101, align 8, !tbaa !14
  %102 = add nsw i32 %94, 1
  store i32 %102, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Im32custom_divide_multiple_variable2ImEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i64 noundef %2, i64 noundef %3, i64 noundef %4, i64 noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !26
  %9 = load i32, ptr @iterations, align 4, !tbaa !9
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %92

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  %13 = udiv i64 %2, %3
  %14 = udiv i64 %13, %4
  %15 = udiv i64 %14, %5
  br i1 %12, label %18, label %16

16:                                               ; preds = %11
  %17 = load double, ptr @init_value, align 8, !tbaa !28
  br label %74

18:                                               ; preds = %11
  %19 = zext i32 %1 to i64
  %20 = icmp ult i32 %1, 4
  %21 = and i64 %19, 4294967292
  %22 = insertelement <2 x i64> poison, i64 %15, i64 0
  %23 = shufflevector <2 x i64> %22, <2 x i64> poison, <2 x i32> zeroinitializer
  %24 = insertelement <2 x i64> poison, i64 %15, i64 0
  %25 = shufflevector <2 x i64> %24, <2 x i64> poison, <2 x i32> zeroinitializer
  %26 = icmp eq i64 %21, %19
  br label %27

27:                                               ; preds = %54, %18
  %28 = phi i32 [ %9, %18 ], [ %55, %54 ]
  %29 = phi i32 [ 0, %18 ], [ %56, %54 ]
  br i1 %20, label %47, label %30

30:                                               ; preds = %27, %30
  %31 = phi i64 [ %42, %30 ], [ 0, %27 ]
  %32 = phi <2 x i64> [ %40, %30 ], [ zeroinitializer, %27 ]
  %33 = phi <2 x i64> [ %41, %30 ], [ zeroinitializer, %27 ]
  %34 = getelementptr inbounds i64, ptr %0, i64 %31
  %35 = load <2 x i64>, ptr %34, align 8, !tbaa !26
  %36 = getelementptr inbounds i64, ptr %34, i64 2
  %37 = load <2 x i64>, ptr %36, align 8, !tbaa !26
  %38 = add <2 x i64> %35, %32
  %39 = add <2 x i64> %37, %33
  %40 = add <2 x i64> %38, %23
  %41 = add <2 x i64> %39, %25
  %42 = add nuw i64 %31, 4
  %43 = icmp eq i64 %42, %21
  br i1 %43, label %44, label %30, !llvm.loop !468

44:                                               ; preds = %30
  %45 = add <2 x i64> %41, %40
  %46 = tail call i64 @llvm.vector.reduce.add.v2i64(<2 x i64> %45)
  br i1 %26, label %67, label %47

47:                                               ; preds = %27, %44
  %48 = phi i64 [ 0, %27 ], [ %21, %44 ]
  %49 = phi i64 [ 0, %27 ], [ %46, %44 ]
  br label %58

50:                                               ; preds = %67
  %51 = load i32, ptr @current_test, align 4, !tbaa !9
  %52 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %51)
  %53 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %54

54:                                               ; preds = %50, %67
  %55 = phi i32 [ %53, %50 ], [ %28, %67 ]
  %56 = add nuw nsw i32 %29, 1
  %57 = icmp slt i32 %56, %55
  br i1 %57, label %27, label %92, !llvm.loop !469

58:                                               ; preds = %47, %58
  %59 = phi i64 [ %65, %58 ], [ %48, %47 ]
  %60 = phi i64 [ %64, %58 ], [ %49, %47 ]
  %61 = getelementptr inbounds i64, ptr %0, i64 %59
  %62 = load i64, ptr %61, align 8, !tbaa !26
  %63 = add i64 %62, %60
  %64 = add i64 %63, %15
  %65 = add nuw nsw i64 %59, 1
  %66 = icmp eq i64 %65, %19
  br i1 %66, label %67, label %58, !llvm.loop !470

67:                                               ; preds = %58, %44
  %68 = phi i64 [ %46, %44 ], [ %64, %58 ]
  %69 = load double, ptr @init_value, align 8, !tbaa !28
  %70 = fptoui double %69 to i64
  %71 = add i64 %15, %70
  %72 = mul i64 %71, 8000
  %73 = icmp eq i64 %72, %68
  br i1 %73, label %54, label %50

74:                                               ; preds = %16, %87
  %75 = phi i32 [ %88, %87 ], [ %9, %16 ]
  %76 = phi double [ %89, %87 ], [ %17, %16 ]
  %77 = phi i32 [ %90, %87 ], [ 0, %16 ]
  %78 = fptoui double %76 to i64
  %79 = add i64 %15, %78
  %80 = mul i64 %79, 8000
  %81 = icmp eq i64 %80, 0
  br i1 %81, label %87, label %82

82:                                               ; preds = %74
  %83 = load i32, ptr @current_test, align 4, !tbaa !9
  %84 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %83)
  %85 = load double, ptr @init_value, align 8, !tbaa !28
  %86 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %87

87:                                               ; preds = %74, %82
  %88 = phi i32 [ %75, %74 ], [ %86, %82 ]
  %89 = phi double [ %76, %74 ], [ %85, %82 ]
  %90 = add nuw nsw i32 %77, 1
  %91 = icmp slt i32 %90, %88
  br i1 %91, label %74, label %92, !llvm.loop !469

92:                                               ; preds = %87, %54, %7
  %93 = tail call i64 @clock() #17
  store i64 %93, ptr @end_time, align 8, !tbaa !26
  %94 = load i64, ptr @start_time, align 8, !tbaa !26
  %95 = load ptr, ptr @results, align 8, !tbaa !5
  %96 = icmp eq ptr %95, null
  br i1 %96, label %97, label %99

97:                                               ; preds = %92
  %98 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %103

99:                                               ; preds = %92
  %100 = load i32, ptr @current_test, align 4, !tbaa !9
  %101 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %102 = icmp slt i32 %100, %101
  br i1 %102, label %115, label %103

103:                                              ; preds = %99, %97
  %104 = phi i32 [ %98, %97 ], [ %101, %99 ]
  %105 = add nsw i32 %104, 10
  store i32 %105, ptr @allocated_results, align 4, !tbaa !9
  %106 = sext i32 %105 to i64
  %107 = shl nsw i64 %106, 4
  %108 = tail call ptr @realloc(ptr noundef %95, i64 noundef %107) #14
  store ptr %108, ptr @results, align 8, !tbaa !5
  %109 = icmp eq ptr %108, null
  br i1 %109, label %112, label %110

110:                                              ; preds = %103
  %111 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %115

112:                                              ; preds = %103
  %113 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %114 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %113)
  tail call void @exit(i32 noundef -1) #15
  unreachable

115:                                              ; preds = %99, %110
  %116 = phi i32 [ %111, %110 ], [ %100, %99 ]
  %117 = phi ptr [ %108, %110 ], [ %95, %99 ]
  %118 = sub nsw i64 %93, %94
  %119 = sitofp i64 %118 to double
  %120 = fdiv double %119, 1.000000e+06
  %121 = sext i32 %116 to i64
  %122 = getelementptr inbounds %struct.one_result, ptr %117, i64 %121
  store double %120, ptr %122, align 8, !tbaa !11
  %123 = getelementptr inbounds %struct.one_result, ptr %117, i64 %121, i32 1
  store ptr %6, ptr %123, align 8, !tbaa !14
  %124 = add nsw i32 %116, 1
  store i32 %124, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Im30custom_mixed_multiple_variableImEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i64 noundef %2, i64 noundef %3, i64 noundef %4, i64 noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !26
  %9 = load i32, ptr @iterations, align 4, !tbaa !9
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %100

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  %13 = mul i64 %4, %3
  %14 = udiv i64 %13, %5
  br i1 %12, label %17, label %15

15:                                               ; preds = %11
  %16 = load double, ptr @init_value, align 8, !tbaa !28
  br label %81

17:                                               ; preds = %11
  %18 = zext i32 %1 to i64
  %19 = icmp ult i32 %1, 4
  %20 = and i64 %18, 4294967292
  %21 = insertelement <2 x i64> poison, i64 %2, i64 0
  %22 = shufflevector <2 x i64> %21, <2 x i64> poison, <2 x i32> zeroinitializer
  %23 = insertelement <2 x i64> poison, i64 %2, i64 0
  %24 = shufflevector <2 x i64> %23, <2 x i64> poison, <2 x i32> zeroinitializer
  %25 = insertelement <2 x i64> poison, i64 %14, i64 0
  %26 = shufflevector <2 x i64> %25, <2 x i64> poison, <2 x i32> zeroinitializer
  %27 = insertelement <2 x i64> poison, i64 %14, i64 0
  %28 = shufflevector <2 x i64> %27, <2 x i64> poison, <2 x i32> zeroinitializer
  %29 = icmp eq i64 %20, %18
  br label %30

30:                                               ; preds = %59, %17
  %31 = phi i32 [ %9, %17 ], [ %60, %59 ]
  %32 = phi i32 [ 0, %17 ], [ %61, %59 ]
  br i1 %19, label %52, label %33

33:                                               ; preds = %30, %33
  %34 = phi i64 [ %47, %33 ], [ 0, %30 ]
  %35 = phi <2 x i64> [ %45, %33 ], [ zeroinitializer, %30 ]
  %36 = phi <2 x i64> [ %46, %33 ], [ zeroinitializer, %30 ]
  %37 = getelementptr inbounds i64, ptr %0, i64 %34
  %38 = load <2 x i64>, ptr %37, align 8, !tbaa !26
  %39 = getelementptr inbounds i64, ptr %37, i64 2
  %40 = load <2 x i64>, ptr %39, align 8, !tbaa !26
  %41 = add <2 x i64> %35, %22
  %42 = add <2 x i64> %36, %24
  %43 = add <2 x i64> %41, %38
  %44 = add <2 x i64> %42, %40
  %45 = sub <2 x i64> %43, %26
  %46 = sub <2 x i64> %44, %28
  %47 = add nuw i64 %34, 4
  %48 = icmp eq i64 %47, %20
  br i1 %48, label %49, label %33, !llvm.loop !471

49:                                               ; preds = %33
  %50 = add <2 x i64> %46, %45
  %51 = tail call i64 @llvm.vector.reduce.add.v2i64(<2 x i64> %50)
  br i1 %29, label %73, label %52

52:                                               ; preds = %30, %49
  %53 = phi i64 [ 0, %30 ], [ %20, %49 ]
  %54 = phi i64 [ 0, %30 ], [ %51, %49 ]
  br label %63

55:                                               ; preds = %73
  %56 = load i32, ptr @current_test, align 4, !tbaa !9
  %57 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %56)
  %58 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %59

59:                                               ; preds = %55, %73
  %60 = phi i32 [ %58, %55 ], [ %31, %73 ]
  %61 = add nuw nsw i32 %32, 1
  %62 = icmp slt i32 %61, %60
  br i1 %62, label %30, label %100, !llvm.loop !472

63:                                               ; preds = %52, %63
  %64 = phi i64 [ %71, %63 ], [ %53, %52 ]
  %65 = phi i64 [ %70, %63 ], [ %54, %52 ]
  %66 = getelementptr inbounds i64, ptr %0, i64 %64
  %67 = load i64, ptr %66, align 8, !tbaa !26
  %68 = add i64 %65, %2
  %69 = add i64 %68, %67
  %70 = sub i64 %69, %14
  %71 = add nuw nsw i64 %64, 1
  %72 = icmp eq i64 %71, %18
  br i1 %72, label %73, label %63, !llvm.loop !473

73:                                               ; preds = %63, %49
  %74 = phi i64 [ %51, %49 ], [ %70, %63 ]
  %75 = load double, ptr @init_value, align 8, !tbaa !28
  %76 = fptoui double %75 to i64
  %77 = add i64 %76, %2
  %78 = sub i64 %77, %14
  %79 = mul i64 %78, 8000
  %80 = icmp eq i64 %79, %74
  br i1 %80, label %59, label %55

81:                                               ; preds = %15, %95
  %82 = phi i32 [ %96, %95 ], [ %9, %15 ]
  %83 = phi double [ %97, %95 ], [ %16, %15 ]
  %84 = phi i32 [ %98, %95 ], [ 0, %15 ]
  %85 = fptoui double %83 to i64
  %86 = add i64 %85, %2
  %87 = sub i64 %86, %14
  %88 = mul i64 %87, 8000
  %89 = icmp eq i64 %88, 0
  br i1 %89, label %95, label %90

90:                                               ; preds = %81
  %91 = load i32, ptr @current_test, align 4, !tbaa !9
  %92 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %91)
  %93 = load double, ptr @init_value, align 8, !tbaa !28
  %94 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %95

95:                                               ; preds = %81, %90
  %96 = phi i32 [ %82, %81 ], [ %94, %90 ]
  %97 = phi double [ %83, %81 ], [ %93, %90 ]
  %98 = add nuw nsw i32 %84, 1
  %99 = icmp slt i32 %98, %96
  br i1 %99, label %81, label %100, !llvm.loop !472

100:                                              ; preds = %95, %59, %7
  %101 = tail call i64 @clock() #17
  store i64 %101, ptr @end_time, align 8, !tbaa !26
  %102 = load i64, ptr @start_time, align 8, !tbaa !26
  %103 = load ptr, ptr @results, align 8, !tbaa !5
  %104 = icmp eq ptr %103, null
  br i1 %104, label %105, label %107

105:                                              ; preds = %100
  %106 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %111

107:                                              ; preds = %100
  %108 = load i32, ptr @current_test, align 4, !tbaa !9
  %109 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %110 = icmp slt i32 %108, %109
  br i1 %110, label %123, label %111

111:                                              ; preds = %107, %105
  %112 = phi i32 [ %106, %105 ], [ %109, %107 ]
  %113 = add nsw i32 %112, 10
  store i32 %113, ptr @allocated_results, align 4, !tbaa !9
  %114 = sext i32 %113 to i64
  %115 = shl nsw i64 %114, 4
  %116 = tail call ptr @realloc(ptr noundef %103, i64 noundef %115) #14
  store ptr %116, ptr @results, align 8, !tbaa !5
  %117 = icmp eq ptr %116, null
  br i1 %117, label %120, label %118

118:                                              ; preds = %111
  %119 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %123

120:                                              ; preds = %111
  %121 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %122 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %121)
  tail call void @exit(i32 noundef -1) #15
  unreachable

123:                                              ; preds = %107, %118
  %124 = phi i32 [ %119, %118 ], [ %108, %107 ]
  %125 = phi ptr [ %116, %118 ], [ %103, %107 ]
  %126 = sub nsw i64 %101, %102
  %127 = sitofp i64 %126 to double
  %128 = fdiv double %127, 1.000000e+06
  %129 = sext i32 %124 to i64
  %130 = getelementptr inbounds %struct.one_result, ptr %125, i64 %129
  store double %128, ptr %130, align 8, !tbaa !11
  %131 = getelementptr inbounds %struct.one_result, ptr %125, i64 %129, i32 1
  store ptr %6, ptr %131, align 8, !tbaa !14
  %132 = add nsw i32 %124, 1
  store i32 %132, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1Im19custom_variable_andImEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i64 noundef %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !26
  %6 = load i32, ptr @iterations, align 4, !tbaa !9
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %86

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  br i1 %9, label %12, label %10

10:                                               ; preds = %8
  %11 = load double, ptr @init_value, align 8, !tbaa !28
  br label %68

12:                                               ; preds = %8
  %13 = zext i32 %1 to i64
  %14 = icmp ult i32 %1, 4
  %15 = and i64 %13, 4294967292
  %16 = insertelement <2 x i64> poison, i64 %2, i64 0
  %17 = shufflevector <2 x i64> %16, <2 x i64> poison, <2 x i32> zeroinitializer
  %18 = insertelement <2 x i64> poison, i64 %2, i64 0
  %19 = shufflevector <2 x i64> %18, <2 x i64> poison, <2 x i32> zeroinitializer
  %20 = icmp eq i64 %15, %13
  br label %21

21:                                               ; preds = %12, %48
  %22 = phi i32 [ %49, %48 ], [ %6, %12 ]
  %23 = phi i32 [ %50, %48 ], [ 0, %12 ]
  br i1 %14, label %41, label %24

24:                                               ; preds = %21, %24
  %25 = phi i64 [ %36, %24 ], [ 0, %21 ]
  %26 = phi <2 x i64> [ %34, %24 ], [ zeroinitializer, %21 ]
  %27 = phi <2 x i64> [ %35, %24 ], [ zeroinitializer, %21 ]
  %28 = getelementptr inbounds i64, ptr %0, i64 %25
  %29 = load <2 x i64>, ptr %28, align 8, !tbaa !26
  %30 = getelementptr inbounds i64, ptr %28, i64 2
  %31 = load <2 x i64>, ptr %30, align 8, !tbaa !26
  %32 = and <2 x i64> %29, %17
  %33 = and <2 x i64> %31, %19
  %34 = add <2 x i64> %32, %26
  %35 = add <2 x i64> %33, %27
  %36 = add nuw i64 %25, 4
  %37 = icmp eq i64 %36, %15
  br i1 %37, label %38, label %24, !llvm.loop !474

38:                                               ; preds = %24
  %39 = add <2 x i64> %35, %34
  %40 = tail call i64 @llvm.vector.reduce.add.v2i64(<2 x i64> %39)
  br i1 %20, label %61, label %41

41:                                               ; preds = %21, %38
  %42 = phi i64 [ 0, %21 ], [ %15, %38 ]
  %43 = phi i64 [ 0, %21 ], [ %40, %38 ]
  br label %52

44:                                               ; preds = %61
  %45 = load i32, ptr @current_test, align 4, !tbaa !9
  %46 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %45)
  %47 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %48

48:                                               ; preds = %44, %61
  %49 = phi i32 [ %47, %44 ], [ %22, %61 ]
  %50 = add nuw nsw i32 %23, 1
  %51 = icmp slt i32 %50, %49
  br i1 %51, label %21, label %86, !llvm.loop !475

52:                                               ; preds = %41, %52
  %53 = phi i64 [ %59, %52 ], [ %42, %41 ]
  %54 = phi i64 [ %58, %52 ], [ %43, %41 ]
  %55 = getelementptr inbounds i64, ptr %0, i64 %53
  %56 = load i64, ptr %55, align 8, !tbaa !26
  %57 = and i64 %56, %2
  %58 = add i64 %57, %54
  %59 = add nuw nsw i64 %53, 1
  %60 = icmp eq i64 %59, %13
  br i1 %60, label %61, label %52, !llvm.loop !476

61:                                               ; preds = %52, %38
  %62 = phi i64 [ %40, %38 ], [ %58, %52 ]
  %63 = load double, ptr @init_value, align 8, !tbaa !28
  %64 = fptoui double %63 to i64
  %65 = and i64 %64, %2
  %66 = mul i64 %65, 8000
  %67 = icmp eq i64 %66, %62
  br i1 %67, label %48, label %44

68:                                               ; preds = %10, %81
  %69 = phi i32 [ %82, %81 ], [ %6, %10 ]
  %70 = phi double [ %83, %81 ], [ %11, %10 ]
  %71 = phi i32 [ %84, %81 ], [ 0, %10 ]
  %72 = fptoui double %70 to i64
  %73 = and i64 %72, %2
  %74 = mul i64 %73, 8000
  %75 = icmp eq i64 %74, 0
  br i1 %75, label %81, label %76

76:                                               ; preds = %68
  %77 = load i32, ptr @current_test, align 4, !tbaa !9
  %78 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %77)
  %79 = load double, ptr @init_value, align 8, !tbaa !28
  %80 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %81

81:                                               ; preds = %68, %76
  %82 = phi i32 [ %69, %68 ], [ %80, %76 ]
  %83 = phi double [ %70, %68 ], [ %79, %76 ]
  %84 = add nuw nsw i32 %71, 1
  %85 = icmp slt i32 %84, %82
  br i1 %85, label %68, label %86, !llvm.loop !475

86:                                               ; preds = %81, %48, %4
  %87 = tail call i64 @clock() #17
  store i64 %87, ptr @end_time, align 8, !tbaa !26
  %88 = load i64, ptr @start_time, align 8, !tbaa !26
  %89 = load ptr, ptr @results, align 8, !tbaa !5
  %90 = icmp eq ptr %89, null
  br i1 %90, label %91, label %93

91:                                               ; preds = %86
  %92 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %97

93:                                               ; preds = %86
  %94 = load i32, ptr @current_test, align 4, !tbaa !9
  %95 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %96 = icmp slt i32 %94, %95
  br i1 %96, label %109, label %97

97:                                               ; preds = %93, %91
  %98 = phi i32 [ %92, %91 ], [ %95, %93 ]
  %99 = add nsw i32 %98, 10
  store i32 %99, ptr @allocated_results, align 4, !tbaa !9
  %100 = sext i32 %99 to i64
  %101 = shl nsw i64 %100, 4
  %102 = tail call ptr @realloc(ptr noundef %89, i64 noundef %101) #14
  store ptr %102, ptr @results, align 8, !tbaa !5
  %103 = icmp eq ptr %102, null
  br i1 %103, label %106, label %104

104:                                              ; preds = %97
  %105 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %109

106:                                              ; preds = %97
  %107 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %108 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %107)
  tail call void @exit(i32 noundef -1) #15
  unreachable

109:                                              ; preds = %93, %104
  %110 = phi i32 [ %105, %104 ], [ %94, %93 ]
  %111 = phi ptr [ %102, %104 ], [ %89, %93 ]
  %112 = sub nsw i64 %87, %88
  %113 = sitofp i64 %112 to double
  %114 = fdiv double %113, 1.000000e+06
  %115 = sext i32 %110 to i64
  %116 = getelementptr inbounds %struct.one_result, ptr %111, i64 %115
  store double %114, ptr %116, align 8, !tbaa !11
  %117 = getelementptr inbounds %struct.one_result, ptr %111, i64 %115, i32 1
  store ptr %3, ptr %117, align 8, !tbaa !14
  %118 = add nsw i32 %110, 1
  store i32 %118, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Im28custom_multiple_variable_andImEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i64 noundef %2, i64 noundef %3, i64 noundef %4, i64 noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !26
  %9 = load i32, ptr @iterations, align 4, !tbaa !9
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %101

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  %13 = and i64 %3, %2
  %14 = and i64 %13, %4
  %15 = and i64 %14, %5
  br i1 %12, label %18, label %16

16:                                               ; preds = %11
  %17 = load double, ptr @init_value, align 8, !tbaa !28
  br label %83

18:                                               ; preds = %11
  %19 = zext i32 %1 to i64
  %20 = icmp ult i32 %1, 4
  %21 = and i64 %19, 4294967292
  %22 = and i64 %3, %2
  %23 = and i64 %3, %2
  %24 = and i64 %22, %4
  %25 = and i64 %23, %4
  %26 = and i64 %24, %5
  %27 = insertelement <2 x i64> poison, i64 %26, i64 0
  %28 = shufflevector <2 x i64> %27, <2 x i64> poison, <2 x i32> zeroinitializer
  %29 = and i64 %25, %5
  %30 = insertelement <2 x i64> poison, i64 %29, i64 0
  %31 = shufflevector <2 x i64> %30, <2 x i64> poison, <2 x i32> zeroinitializer
  %32 = icmp eq i64 %21, %19
  br label %33

33:                                               ; preds = %18, %60
  %34 = phi i32 [ %61, %60 ], [ %9, %18 ]
  %35 = phi i32 [ %62, %60 ], [ 0, %18 ]
  br i1 %20, label %53, label %36

36:                                               ; preds = %33, %36
  %37 = phi i64 [ %48, %36 ], [ 0, %33 ]
  %38 = phi <2 x i64> [ %46, %36 ], [ zeroinitializer, %33 ]
  %39 = phi <2 x i64> [ %47, %36 ], [ zeroinitializer, %33 ]
  %40 = getelementptr inbounds i64, ptr %0, i64 %37
  %41 = load <2 x i64>, ptr %40, align 8, !tbaa !26
  %42 = getelementptr inbounds i64, ptr %40, i64 2
  %43 = load <2 x i64>, ptr %42, align 8, !tbaa !26
  %44 = and <2 x i64> %28, %41
  %45 = and <2 x i64> %31, %43
  %46 = add <2 x i64> %44, %38
  %47 = add <2 x i64> %45, %39
  %48 = add nuw i64 %37, 4
  %49 = icmp eq i64 %48, %21
  br i1 %49, label %50, label %36, !llvm.loop !477

50:                                               ; preds = %36
  %51 = add <2 x i64> %47, %46
  %52 = tail call i64 @llvm.vector.reduce.add.v2i64(<2 x i64> %51)
  br i1 %32, label %76, label %53

53:                                               ; preds = %33, %50
  %54 = phi i64 [ 0, %33 ], [ %21, %50 ]
  %55 = phi i64 [ 0, %33 ], [ %52, %50 ]
  br label %64

56:                                               ; preds = %76
  %57 = load i32, ptr @current_test, align 4, !tbaa !9
  %58 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %57)
  %59 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %60

60:                                               ; preds = %56, %76
  %61 = phi i32 [ %59, %56 ], [ %34, %76 ]
  %62 = add nuw nsw i32 %35, 1
  %63 = icmp slt i32 %62, %61
  br i1 %63, label %33, label %101, !llvm.loop !478

64:                                               ; preds = %53, %64
  %65 = phi i64 [ %74, %64 ], [ %54, %53 ]
  %66 = phi i64 [ %73, %64 ], [ %55, %53 ]
  %67 = getelementptr inbounds i64, ptr %0, i64 %65
  %68 = load i64, ptr %67, align 8, !tbaa !26
  %69 = and i64 %68, %2
  %70 = and i64 %69, %3
  %71 = and i64 %70, %4
  %72 = and i64 %71, %5
  %73 = add i64 %72, %66
  %74 = add nuw nsw i64 %65, 1
  %75 = icmp eq i64 %74, %19
  br i1 %75, label %76, label %64, !llvm.loop !479

76:                                               ; preds = %64, %50
  %77 = phi i64 [ %52, %50 ], [ %73, %64 ]
  %78 = load double, ptr @init_value, align 8, !tbaa !28
  %79 = fptoui double %78 to i64
  %80 = and i64 %15, %79
  %81 = mul i64 %80, 8000
  %82 = icmp eq i64 %81, %77
  br i1 %82, label %60, label %56

83:                                               ; preds = %16, %96
  %84 = phi i32 [ %97, %96 ], [ %9, %16 ]
  %85 = phi double [ %98, %96 ], [ %17, %16 ]
  %86 = phi i32 [ %99, %96 ], [ 0, %16 ]
  %87 = fptoui double %85 to i64
  %88 = and i64 %15, %87
  %89 = mul i64 %88, 8000
  %90 = icmp eq i64 %89, 0
  br i1 %90, label %96, label %91

91:                                               ; preds = %83
  %92 = load i32, ptr @current_test, align 4, !tbaa !9
  %93 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %92)
  %94 = load double, ptr @init_value, align 8, !tbaa !28
  %95 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %96

96:                                               ; preds = %83, %91
  %97 = phi i32 [ %84, %83 ], [ %95, %91 ]
  %98 = phi double [ %85, %83 ], [ %94, %91 ]
  %99 = add nuw nsw i32 %86, 1
  %100 = icmp slt i32 %99, %97
  br i1 %100, label %83, label %101, !llvm.loop !478

101:                                              ; preds = %96, %60, %7
  %102 = tail call i64 @clock() #17
  store i64 %102, ptr @end_time, align 8, !tbaa !26
  %103 = load i64, ptr @start_time, align 8, !tbaa !26
  %104 = load ptr, ptr @results, align 8, !tbaa !5
  %105 = icmp eq ptr %104, null
  br i1 %105, label %106, label %108

106:                                              ; preds = %101
  %107 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %112

108:                                              ; preds = %101
  %109 = load i32, ptr @current_test, align 4, !tbaa !9
  %110 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %111 = icmp slt i32 %109, %110
  br i1 %111, label %124, label %112

112:                                              ; preds = %108, %106
  %113 = phi i32 [ %107, %106 ], [ %110, %108 ]
  %114 = add nsw i32 %113, 10
  store i32 %114, ptr @allocated_results, align 4, !tbaa !9
  %115 = sext i32 %114 to i64
  %116 = shl nsw i64 %115, 4
  %117 = tail call ptr @realloc(ptr noundef %104, i64 noundef %116) #14
  store ptr %117, ptr @results, align 8, !tbaa !5
  %118 = icmp eq ptr %117, null
  br i1 %118, label %121, label %119

119:                                              ; preds = %112
  %120 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %124

121:                                              ; preds = %112
  %122 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %123 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %122)
  tail call void @exit(i32 noundef -1) #15
  unreachable

124:                                              ; preds = %108, %119
  %125 = phi i32 [ %120, %119 ], [ %109, %108 ]
  %126 = phi ptr [ %117, %119 ], [ %104, %108 ]
  %127 = sub nsw i64 %102, %103
  %128 = sitofp i64 %127 to double
  %129 = fdiv double %128, 1.000000e+06
  %130 = sext i32 %125 to i64
  %131 = getelementptr inbounds %struct.one_result, ptr %126, i64 %130
  store double %129, ptr %131, align 8, !tbaa !11
  %132 = getelementptr inbounds %struct.one_result, ptr %126, i64 %130, i32 1
  store ptr %6, ptr %132, align 8, !tbaa !14
  %133 = add nsw i32 %125, 1
  store i32 %133, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1Im18custom_variable_orImEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i64 noundef %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !26
  %6 = load i32, ptr @iterations, align 4, !tbaa !9
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %86

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  br i1 %9, label %12, label %10

10:                                               ; preds = %8
  %11 = load double, ptr @init_value, align 8, !tbaa !28
  br label %68

12:                                               ; preds = %8
  %13 = zext i32 %1 to i64
  %14 = icmp ult i32 %1, 4
  %15 = and i64 %13, 4294967292
  %16 = insertelement <2 x i64> poison, i64 %2, i64 0
  %17 = shufflevector <2 x i64> %16, <2 x i64> poison, <2 x i32> zeroinitializer
  %18 = insertelement <2 x i64> poison, i64 %2, i64 0
  %19 = shufflevector <2 x i64> %18, <2 x i64> poison, <2 x i32> zeroinitializer
  %20 = icmp eq i64 %15, %13
  br label %21

21:                                               ; preds = %12, %48
  %22 = phi i32 [ %49, %48 ], [ %6, %12 ]
  %23 = phi i32 [ %50, %48 ], [ 0, %12 ]
  br i1 %14, label %41, label %24

24:                                               ; preds = %21, %24
  %25 = phi i64 [ %36, %24 ], [ 0, %21 ]
  %26 = phi <2 x i64> [ %34, %24 ], [ zeroinitializer, %21 ]
  %27 = phi <2 x i64> [ %35, %24 ], [ zeroinitializer, %21 ]
  %28 = getelementptr inbounds i64, ptr %0, i64 %25
  %29 = load <2 x i64>, ptr %28, align 8, !tbaa !26
  %30 = getelementptr inbounds i64, ptr %28, i64 2
  %31 = load <2 x i64>, ptr %30, align 8, !tbaa !26
  %32 = or <2 x i64> %29, %17
  %33 = or <2 x i64> %31, %19
  %34 = add <2 x i64> %32, %26
  %35 = add <2 x i64> %33, %27
  %36 = add nuw i64 %25, 4
  %37 = icmp eq i64 %36, %15
  br i1 %37, label %38, label %24, !llvm.loop !480

38:                                               ; preds = %24
  %39 = add <2 x i64> %35, %34
  %40 = tail call i64 @llvm.vector.reduce.add.v2i64(<2 x i64> %39)
  br i1 %20, label %61, label %41

41:                                               ; preds = %21, %38
  %42 = phi i64 [ 0, %21 ], [ %15, %38 ]
  %43 = phi i64 [ 0, %21 ], [ %40, %38 ]
  br label %52

44:                                               ; preds = %61
  %45 = load i32, ptr @current_test, align 4, !tbaa !9
  %46 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %45)
  %47 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %48

48:                                               ; preds = %44, %61
  %49 = phi i32 [ %47, %44 ], [ %22, %61 ]
  %50 = add nuw nsw i32 %23, 1
  %51 = icmp slt i32 %50, %49
  br i1 %51, label %21, label %86, !llvm.loop !481

52:                                               ; preds = %41, %52
  %53 = phi i64 [ %59, %52 ], [ %42, %41 ]
  %54 = phi i64 [ %58, %52 ], [ %43, %41 ]
  %55 = getelementptr inbounds i64, ptr %0, i64 %53
  %56 = load i64, ptr %55, align 8, !tbaa !26
  %57 = or i64 %56, %2
  %58 = add i64 %57, %54
  %59 = add nuw nsw i64 %53, 1
  %60 = icmp eq i64 %59, %13
  br i1 %60, label %61, label %52, !llvm.loop !482

61:                                               ; preds = %52, %38
  %62 = phi i64 [ %40, %38 ], [ %58, %52 ]
  %63 = load double, ptr @init_value, align 8, !tbaa !28
  %64 = fptoui double %63 to i64
  %65 = or i64 %64, %2
  %66 = mul i64 %65, 8000
  %67 = icmp eq i64 %66, %62
  br i1 %67, label %48, label %44

68:                                               ; preds = %10, %81
  %69 = phi i32 [ %82, %81 ], [ %6, %10 ]
  %70 = phi double [ %83, %81 ], [ %11, %10 ]
  %71 = phi i32 [ %84, %81 ], [ 0, %10 ]
  %72 = fptoui double %70 to i64
  %73 = or i64 %72, %2
  %74 = mul i64 %73, 8000
  %75 = icmp eq i64 %74, 0
  br i1 %75, label %81, label %76

76:                                               ; preds = %68
  %77 = load i32, ptr @current_test, align 4, !tbaa !9
  %78 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %77)
  %79 = load double, ptr @init_value, align 8, !tbaa !28
  %80 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %81

81:                                               ; preds = %68, %76
  %82 = phi i32 [ %69, %68 ], [ %80, %76 ]
  %83 = phi double [ %70, %68 ], [ %79, %76 ]
  %84 = add nuw nsw i32 %71, 1
  %85 = icmp slt i32 %84, %82
  br i1 %85, label %68, label %86, !llvm.loop !481

86:                                               ; preds = %81, %48, %4
  %87 = tail call i64 @clock() #17
  store i64 %87, ptr @end_time, align 8, !tbaa !26
  %88 = load i64, ptr @start_time, align 8, !tbaa !26
  %89 = load ptr, ptr @results, align 8, !tbaa !5
  %90 = icmp eq ptr %89, null
  br i1 %90, label %91, label %93

91:                                               ; preds = %86
  %92 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %97

93:                                               ; preds = %86
  %94 = load i32, ptr @current_test, align 4, !tbaa !9
  %95 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %96 = icmp slt i32 %94, %95
  br i1 %96, label %109, label %97

97:                                               ; preds = %93, %91
  %98 = phi i32 [ %92, %91 ], [ %95, %93 ]
  %99 = add nsw i32 %98, 10
  store i32 %99, ptr @allocated_results, align 4, !tbaa !9
  %100 = sext i32 %99 to i64
  %101 = shl nsw i64 %100, 4
  %102 = tail call ptr @realloc(ptr noundef %89, i64 noundef %101) #14
  store ptr %102, ptr @results, align 8, !tbaa !5
  %103 = icmp eq ptr %102, null
  br i1 %103, label %106, label %104

104:                                              ; preds = %97
  %105 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %109

106:                                              ; preds = %97
  %107 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %108 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %107)
  tail call void @exit(i32 noundef -1) #15
  unreachable

109:                                              ; preds = %93, %104
  %110 = phi i32 [ %105, %104 ], [ %94, %93 ]
  %111 = phi ptr [ %102, %104 ], [ %89, %93 ]
  %112 = sub nsw i64 %87, %88
  %113 = sitofp i64 %112 to double
  %114 = fdiv double %113, 1.000000e+06
  %115 = sext i32 %110 to i64
  %116 = getelementptr inbounds %struct.one_result, ptr %111, i64 %115
  store double %114, ptr %116, align 8, !tbaa !11
  %117 = getelementptr inbounds %struct.one_result, ptr %111, i64 %115, i32 1
  store ptr %3, ptr %117, align 8, !tbaa !14
  %118 = add nsw i32 %110, 1
  store i32 %118, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Im27custom_multiple_variable_orImEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i64 noundef %2, i64 noundef %3, i64 noundef %4, i64 noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !26
  %9 = load i32, ptr @iterations, align 4, !tbaa !9
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %101

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  %13 = or i64 %3, %2
  %14 = or i64 %13, %4
  %15 = or i64 %14, %5
  br i1 %12, label %18, label %16

16:                                               ; preds = %11
  %17 = load double, ptr @init_value, align 8, !tbaa !28
  br label %83

18:                                               ; preds = %11
  %19 = zext i32 %1 to i64
  %20 = icmp ult i32 %1, 4
  %21 = and i64 %19, 4294967292
  %22 = or i64 %3, %2
  %23 = or i64 %3, %2
  %24 = or i64 %22, %4
  %25 = or i64 %23, %4
  %26 = or i64 %24, %5
  %27 = insertelement <2 x i64> poison, i64 %26, i64 0
  %28 = shufflevector <2 x i64> %27, <2 x i64> poison, <2 x i32> zeroinitializer
  %29 = or i64 %25, %5
  %30 = insertelement <2 x i64> poison, i64 %29, i64 0
  %31 = shufflevector <2 x i64> %30, <2 x i64> poison, <2 x i32> zeroinitializer
  %32 = icmp eq i64 %21, %19
  br label %33

33:                                               ; preds = %18, %60
  %34 = phi i32 [ %61, %60 ], [ %9, %18 ]
  %35 = phi i32 [ %62, %60 ], [ 0, %18 ]
  br i1 %20, label %53, label %36

36:                                               ; preds = %33, %36
  %37 = phi i64 [ %48, %36 ], [ 0, %33 ]
  %38 = phi <2 x i64> [ %46, %36 ], [ zeroinitializer, %33 ]
  %39 = phi <2 x i64> [ %47, %36 ], [ zeroinitializer, %33 ]
  %40 = getelementptr inbounds i64, ptr %0, i64 %37
  %41 = load <2 x i64>, ptr %40, align 8, !tbaa !26
  %42 = getelementptr inbounds i64, ptr %40, i64 2
  %43 = load <2 x i64>, ptr %42, align 8, !tbaa !26
  %44 = or <2 x i64> %28, %41
  %45 = or <2 x i64> %31, %43
  %46 = add <2 x i64> %44, %38
  %47 = add <2 x i64> %45, %39
  %48 = add nuw i64 %37, 4
  %49 = icmp eq i64 %48, %21
  br i1 %49, label %50, label %36, !llvm.loop !483

50:                                               ; preds = %36
  %51 = add <2 x i64> %47, %46
  %52 = tail call i64 @llvm.vector.reduce.add.v2i64(<2 x i64> %51)
  br i1 %32, label %76, label %53

53:                                               ; preds = %33, %50
  %54 = phi i64 [ 0, %33 ], [ %21, %50 ]
  %55 = phi i64 [ 0, %33 ], [ %52, %50 ]
  br label %64

56:                                               ; preds = %76
  %57 = load i32, ptr @current_test, align 4, !tbaa !9
  %58 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %57)
  %59 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %60

60:                                               ; preds = %56, %76
  %61 = phi i32 [ %59, %56 ], [ %34, %76 ]
  %62 = add nuw nsw i32 %35, 1
  %63 = icmp slt i32 %62, %61
  br i1 %63, label %33, label %101, !llvm.loop !484

64:                                               ; preds = %53, %64
  %65 = phi i64 [ %74, %64 ], [ %54, %53 ]
  %66 = phi i64 [ %73, %64 ], [ %55, %53 ]
  %67 = getelementptr inbounds i64, ptr %0, i64 %65
  %68 = load i64, ptr %67, align 8, !tbaa !26
  %69 = or i64 %68, %2
  %70 = or i64 %69, %3
  %71 = or i64 %70, %4
  %72 = or i64 %71, %5
  %73 = add i64 %72, %66
  %74 = add nuw nsw i64 %65, 1
  %75 = icmp eq i64 %74, %19
  br i1 %75, label %76, label %64, !llvm.loop !485

76:                                               ; preds = %64, %50
  %77 = phi i64 [ %52, %50 ], [ %73, %64 ]
  %78 = load double, ptr @init_value, align 8, !tbaa !28
  %79 = fptoui double %78 to i64
  %80 = or i64 %15, %79
  %81 = mul i64 %80, 8000
  %82 = icmp eq i64 %81, %77
  br i1 %82, label %60, label %56

83:                                               ; preds = %16, %96
  %84 = phi i32 [ %97, %96 ], [ %9, %16 ]
  %85 = phi double [ %98, %96 ], [ %17, %16 ]
  %86 = phi i32 [ %99, %96 ], [ 0, %16 ]
  %87 = fptoui double %85 to i64
  %88 = or i64 %15, %87
  %89 = mul i64 %88, 8000
  %90 = icmp eq i64 %89, 0
  br i1 %90, label %96, label %91

91:                                               ; preds = %83
  %92 = load i32, ptr @current_test, align 4, !tbaa !9
  %93 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %92)
  %94 = load double, ptr @init_value, align 8, !tbaa !28
  %95 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %96

96:                                               ; preds = %83, %91
  %97 = phi i32 [ %84, %83 ], [ %95, %91 ]
  %98 = phi double [ %85, %83 ], [ %94, %91 ]
  %99 = add nuw nsw i32 %86, 1
  %100 = icmp slt i32 %99, %97
  br i1 %100, label %83, label %101, !llvm.loop !484

101:                                              ; preds = %96, %60, %7
  %102 = tail call i64 @clock() #17
  store i64 %102, ptr @end_time, align 8, !tbaa !26
  %103 = load i64, ptr @start_time, align 8, !tbaa !26
  %104 = load ptr, ptr @results, align 8, !tbaa !5
  %105 = icmp eq ptr %104, null
  br i1 %105, label %106, label %108

106:                                              ; preds = %101
  %107 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %112

108:                                              ; preds = %101
  %109 = load i32, ptr @current_test, align 4, !tbaa !9
  %110 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %111 = icmp slt i32 %109, %110
  br i1 %111, label %124, label %112

112:                                              ; preds = %108, %106
  %113 = phi i32 [ %107, %106 ], [ %110, %108 ]
  %114 = add nsw i32 %113, 10
  store i32 %114, ptr @allocated_results, align 4, !tbaa !9
  %115 = sext i32 %114 to i64
  %116 = shl nsw i64 %115, 4
  %117 = tail call ptr @realloc(ptr noundef %104, i64 noundef %116) #14
  store ptr %117, ptr @results, align 8, !tbaa !5
  %118 = icmp eq ptr %117, null
  br i1 %118, label %121, label %119

119:                                              ; preds = %112
  %120 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %124

121:                                              ; preds = %112
  %122 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %123 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %122)
  tail call void @exit(i32 noundef -1) #15
  unreachable

124:                                              ; preds = %108, %119
  %125 = phi i32 [ %120, %119 ], [ %109, %108 ]
  %126 = phi ptr [ %117, %119 ], [ %104, %108 ]
  %127 = sub nsw i64 %102, %103
  %128 = sitofp i64 %127 to double
  %129 = fdiv double %128, 1.000000e+06
  %130 = sext i32 %125 to i64
  %131 = getelementptr inbounds %struct.one_result, ptr %126, i64 %130
  store double %129, ptr %131, align 8, !tbaa !11
  %132 = getelementptr inbounds %struct.one_result, ptr %126, i64 %130, i32 1
  store ptr %6, ptr %132, align 8, !tbaa !14
  %133 = add nsw i32 %125, 1
  store i32 %133, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1Im19custom_variable_xorImEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, i64 noundef %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !26
  %6 = load i32, ptr @iterations, align 4, !tbaa !9
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %86

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  br i1 %9, label %12, label %10

10:                                               ; preds = %8
  %11 = load double, ptr @init_value, align 8, !tbaa !28
  br label %68

12:                                               ; preds = %8
  %13 = zext i32 %1 to i64
  %14 = icmp ult i32 %1, 4
  %15 = and i64 %13, 4294967292
  %16 = insertelement <2 x i64> poison, i64 %2, i64 0
  %17 = shufflevector <2 x i64> %16, <2 x i64> poison, <2 x i32> zeroinitializer
  %18 = insertelement <2 x i64> poison, i64 %2, i64 0
  %19 = shufflevector <2 x i64> %18, <2 x i64> poison, <2 x i32> zeroinitializer
  %20 = icmp eq i64 %15, %13
  br label %21

21:                                               ; preds = %12, %48
  %22 = phi i32 [ %49, %48 ], [ %6, %12 ]
  %23 = phi i32 [ %50, %48 ], [ 0, %12 ]
  br i1 %14, label %41, label %24

24:                                               ; preds = %21, %24
  %25 = phi i64 [ %36, %24 ], [ 0, %21 ]
  %26 = phi <2 x i64> [ %34, %24 ], [ zeroinitializer, %21 ]
  %27 = phi <2 x i64> [ %35, %24 ], [ zeroinitializer, %21 ]
  %28 = getelementptr inbounds i64, ptr %0, i64 %25
  %29 = load <2 x i64>, ptr %28, align 8, !tbaa !26
  %30 = getelementptr inbounds i64, ptr %28, i64 2
  %31 = load <2 x i64>, ptr %30, align 8, !tbaa !26
  %32 = xor <2 x i64> %29, %17
  %33 = xor <2 x i64> %31, %19
  %34 = add <2 x i64> %32, %26
  %35 = add <2 x i64> %33, %27
  %36 = add nuw i64 %25, 4
  %37 = icmp eq i64 %36, %15
  br i1 %37, label %38, label %24, !llvm.loop !486

38:                                               ; preds = %24
  %39 = add <2 x i64> %35, %34
  %40 = tail call i64 @llvm.vector.reduce.add.v2i64(<2 x i64> %39)
  br i1 %20, label %61, label %41

41:                                               ; preds = %21, %38
  %42 = phi i64 [ 0, %21 ], [ %15, %38 ]
  %43 = phi i64 [ 0, %21 ], [ %40, %38 ]
  br label %52

44:                                               ; preds = %61
  %45 = load i32, ptr @current_test, align 4, !tbaa !9
  %46 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %45)
  %47 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %48

48:                                               ; preds = %44, %61
  %49 = phi i32 [ %47, %44 ], [ %22, %61 ]
  %50 = add nuw nsw i32 %23, 1
  %51 = icmp slt i32 %50, %49
  br i1 %51, label %21, label %86, !llvm.loop !487

52:                                               ; preds = %41, %52
  %53 = phi i64 [ %59, %52 ], [ %42, %41 ]
  %54 = phi i64 [ %58, %52 ], [ %43, %41 ]
  %55 = getelementptr inbounds i64, ptr %0, i64 %53
  %56 = load i64, ptr %55, align 8, !tbaa !26
  %57 = xor i64 %56, %2
  %58 = add i64 %57, %54
  %59 = add nuw nsw i64 %53, 1
  %60 = icmp eq i64 %59, %13
  br i1 %60, label %61, label %52, !llvm.loop !488

61:                                               ; preds = %52, %38
  %62 = phi i64 [ %40, %38 ], [ %58, %52 ]
  %63 = load double, ptr @init_value, align 8, !tbaa !28
  %64 = fptoui double %63 to i64
  %65 = xor i64 %64, %2
  %66 = mul i64 %65, 8000
  %67 = icmp eq i64 %66, %62
  br i1 %67, label %48, label %44

68:                                               ; preds = %10, %81
  %69 = phi i32 [ %82, %81 ], [ %6, %10 ]
  %70 = phi double [ %83, %81 ], [ %11, %10 ]
  %71 = phi i32 [ %84, %81 ], [ 0, %10 ]
  %72 = fptoui double %70 to i64
  %73 = xor i64 %72, %2
  %74 = mul i64 %73, 8000
  %75 = icmp eq i64 %74, 0
  br i1 %75, label %81, label %76

76:                                               ; preds = %68
  %77 = load i32, ptr @current_test, align 4, !tbaa !9
  %78 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %77)
  %79 = load double, ptr @init_value, align 8, !tbaa !28
  %80 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %81

81:                                               ; preds = %68, %76
  %82 = phi i32 [ %69, %68 ], [ %80, %76 ]
  %83 = phi double [ %70, %68 ], [ %79, %76 ]
  %84 = add nuw nsw i32 %71, 1
  %85 = icmp slt i32 %84, %82
  br i1 %85, label %68, label %86, !llvm.loop !487

86:                                               ; preds = %81, %48, %4
  %87 = tail call i64 @clock() #17
  store i64 %87, ptr @end_time, align 8, !tbaa !26
  %88 = load i64, ptr @start_time, align 8, !tbaa !26
  %89 = load ptr, ptr @results, align 8, !tbaa !5
  %90 = icmp eq ptr %89, null
  br i1 %90, label %91, label %93

91:                                               ; preds = %86
  %92 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %97

93:                                               ; preds = %86
  %94 = load i32, ptr @current_test, align 4, !tbaa !9
  %95 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %96 = icmp slt i32 %94, %95
  br i1 %96, label %109, label %97

97:                                               ; preds = %93, %91
  %98 = phi i32 [ %92, %91 ], [ %95, %93 ]
  %99 = add nsw i32 %98, 10
  store i32 %99, ptr @allocated_results, align 4, !tbaa !9
  %100 = sext i32 %99 to i64
  %101 = shl nsw i64 %100, 4
  %102 = tail call ptr @realloc(ptr noundef %89, i64 noundef %101) #14
  store ptr %102, ptr @results, align 8, !tbaa !5
  %103 = icmp eq ptr %102, null
  br i1 %103, label %106, label %104

104:                                              ; preds = %97
  %105 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %109

106:                                              ; preds = %97
  %107 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %108 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %107)
  tail call void @exit(i32 noundef -1) #15
  unreachable

109:                                              ; preds = %93, %104
  %110 = phi i32 [ %105, %104 ], [ %94, %93 ]
  %111 = phi ptr [ %102, %104 ], [ %89, %93 ]
  %112 = sub nsw i64 %87, %88
  %113 = sitofp i64 %112 to double
  %114 = fdiv double %113, 1.000000e+06
  %115 = sext i32 %110 to i64
  %116 = getelementptr inbounds %struct.one_result, ptr %111, i64 %115
  store double %114, ptr %116, align 8, !tbaa !11
  %117 = getelementptr inbounds %struct.one_result, ptr %111, i64 %115, i32 1
  store ptr %3, ptr %117, align 8, !tbaa !14
  %118 = add nsw i32 %110, 1
  store i32 %118, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Im28custom_multiple_variable_xorImEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, i64 noundef %2, i64 noundef %3, i64 noundef %4, i64 noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !26
  %9 = load i32, ptr @iterations, align 4, !tbaa !9
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %101

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  %13 = xor i64 %3, %2
  %14 = xor i64 %13, %4
  %15 = xor i64 %14, %5
  br i1 %12, label %18, label %16

16:                                               ; preds = %11
  %17 = load double, ptr @init_value, align 8, !tbaa !28
  br label %83

18:                                               ; preds = %11
  %19 = zext i32 %1 to i64
  %20 = icmp ult i32 %1, 4
  %21 = and i64 %19, 4294967292
  %22 = xor i64 %3, %2
  %23 = xor i64 %3, %2
  %24 = xor i64 %22, %4
  %25 = xor i64 %23, %4
  %26 = xor i64 %24, %5
  %27 = insertelement <2 x i64> poison, i64 %26, i64 0
  %28 = shufflevector <2 x i64> %27, <2 x i64> poison, <2 x i32> zeroinitializer
  %29 = xor i64 %25, %5
  %30 = insertelement <2 x i64> poison, i64 %29, i64 0
  %31 = shufflevector <2 x i64> %30, <2 x i64> poison, <2 x i32> zeroinitializer
  %32 = icmp eq i64 %21, %19
  br label %33

33:                                               ; preds = %18, %60
  %34 = phi i32 [ %61, %60 ], [ %9, %18 ]
  %35 = phi i32 [ %62, %60 ], [ 0, %18 ]
  br i1 %20, label %53, label %36

36:                                               ; preds = %33, %36
  %37 = phi i64 [ %48, %36 ], [ 0, %33 ]
  %38 = phi <2 x i64> [ %46, %36 ], [ zeroinitializer, %33 ]
  %39 = phi <2 x i64> [ %47, %36 ], [ zeroinitializer, %33 ]
  %40 = getelementptr inbounds i64, ptr %0, i64 %37
  %41 = load <2 x i64>, ptr %40, align 8, !tbaa !26
  %42 = getelementptr inbounds i64, ptr %40, i64 2
  %43 = load <2 x i64>, ptr %42, align 8, !tbaa !26
  %44 = xor <2 x i64> %28, %41
  %45 = xor <2 x i64> %31, %43
  %46 = add <2 x i64> %44, %38
  %47 = add <2 x i64> %45, %39
  %48 = add nuw i64 %37, 4
  %49 = icmp eq i64 %48, %21
  br i1 %49, label %50, label %36, !llvm.loop !489

50:                                               ; preds = %36
  %51 = add <2 x i64> %47, %46
  %52 = tail call i64 @llvm.vector.reduce.add.v2i64(<2 x i64> %51)
  br i1 %32, label %76, label %53

53:                                               ; preds = %33, %50
  %54 = phi i64 [ 0, %33 ], [ %21, %50 ]
  %55 = phi i64 [ 0, %33 ], [ %52, %50 ]
  br label %64

56:                                               ; preds = %76
  %57 = load i32, ptr @current_test, align 4, !tbaa !9
  %58 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %57)
  %59 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %60

60:                                               ; preds = %56, %76
  %61 = phi i32 [ %59, %56 ], [ %34, %76 ]
  %62 = add nuw nsw i32 %35, 1
  %63 = icmp slt i32 %62, %61
  br i1 %63, label %33, label %101, !llvm.loop !490

64:                                               ; preds = %53, %64
  %65 = phi i64 [ %74, %64 ], [ %54, %53 ]
  %66 = phi i64 [ %73, %64 ], [ %55, %53 ]
  %67 = getelementptr inbounds i64, ptr %0, i64 %65
  %68 = load i64, ptr %67, align 8, !tbaa !26
  %69 = xor i64 %68, %2
  %70 = xor i64 %69, %3
  %71 = xor i64 %70, %4
  %72 = xor i64 %71, %5
  %73 = add i64 %72, %66
  %74 = add nuw nsw i64 %65, 1
  %75 = icmp eq i64 %74, %19
  br i1 %75, label %76, label %64, !llvm.loop !491

76:                                               ; preds = %64, %50
  %77 = phi i64 [ %52, %50 ], [ %73, %64 ]
  %78 = load double, ptr @init_value, align 8, !tbaa !28
  %79 = fptoui double %78 to i64
  %80 = xor i64 %15, %79
  %81 = mul i64 %80, 8000
  %82 = icmp eq i64 %81, %77
  br i1 %82, label %60, label %56

83:                                               ; preds = %16, %96
  %84 = phi i32 [ %97, %96 ], [ %9, %16 ]
  %85 = phi double [ %98, %96 ], [ %17, %16 ]
  %86 = phi i32 [ %99, %96 ], [ 0, %16 ]
  %87 = fptoui double %85 to i64
  %88 = xor i64 %15, %87
  %89 = mul i64 %88, 8000
  %90 = icmp eq i64 %89, 0
  br i1 %90, label %96, label %91

91:                                               ; preds = %83
  %92 = load i32, ptr @current_test, align 4, !tbaa !9
  %93 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %92)
  %94 = load double, ptr @init_value, align 8, !tbaa !28
  %95 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %96

96:                                               ; preds = %83, %91
  %97 = phi i32 [ %84, %83 ], [ %95, %91 ]
  %98 = phi double [ %85, %83 ], [ %94, %91 ]
  %99 = add nuw nsw i32 %86, 1
  %100 = icmp slt i32 %99, %97
  br i1 %100, label %83, label %101, !llvm.loop !490

101:                                              ; preds = %96, %60, %7
  %102 = tail call i64 @clock() #17
  store i64 %102, ptr @end_time, align 8, !tbaa !26
  %103 = load i64, ptr @start_time, align 8, !tbaa !26
  %104 = load ptr, ptr @results, align 8, !tbaa !5
  %105 = icmp eq ptr %104, null
  br i1 %105, label %106, label %108

106:                                              ; preds = %101
  %107 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %112

108:                                              ; preds = %101
  %109 = load i32, ptr @current_test, align 4, !tbaa !9
  %110 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %111 = icmp slt i32 %109, %110
  br i1 %111, label %124, label %112

112:                                              ; preds = %108, %106
  %113 = phi i32 [ %107, %106 ], [ %110, %108 ]
  %114 = add nsw i32 %113, 10
  store i32 %114, ptr @allocated_results, align 4, !tbaa !9
  %115 = sext i32 %114 to i64
  %116 = shl nsw i64 %115, 4
  %117 = tail call ptr @realloc(ptr noundef %104, i64 noundef %116) #14
  store ptr %117, ptr @results, align 8, !tbaa !5
  %118 = icmp eq ptr %117, null
  br i1 %118, label %121, label %119

119:                                              ; preds = %112
  %120 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %124

121:                                              ; preds = %112
  %122 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %123 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %122)
  tail call void @exit(i32 noundef -1) #15
  unreachable

124:                                              ; preds = %108, %119
  %125 = phi i32 [ %120, %119 ], [ %109, %108 ]
  %126 = phi ptr [ %117, %119 ], [ %104, %108 ]
  %127 = sub nsw i64 %102, %103
  %128 = sitofp i64 %127 to double
  %129 = fdiv double %128, 1.000000e+06
  %130 = sext i32 %125 to i64
  %131 = getelementptr inbounds %struct.one_result, ptr %126, i64 %130
  store double %129, ptr %131, align 8, !tbaa !11
  %132 = getelementptr inbounds %struct.one_result, ptr %126, i64 %130, i32 1
  store ptr %6, ptr %132, align 8, !tbaa !14
  %133 = add nsw i32 %125, 1
  store i32 %133, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1If19custom_add_variableIfEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, float noundef %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !26
  %6 = load i32, ptr @iterations, align 4, !tbaa !9
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %106

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  br i1 %9, label %12, label %10

10:                                               ; preds = %8
  %11 = load double, ptr @init_value, align 8, !tbaa !28
  br label %85

12:                                               ; preds = %8
  %13 = zext i32 %1 to i64
  %14 = and i64 %13, 3
  %15 = icmp ult i32 %1, 4
  %16 = and i64 %13, 4294967292
  %17 = icmp eq i64 %14, 0
  br label %18

18:                                               ; preds = %12, %25
  %19 = phi i32 [ %26, %25 ], [ %6, %12 ]
  %20 = phi i32 [ %27, %25 ], [ 0, %12 ]
  br i1 %15, label %55, label %29

21:                                               ; preds = %70
  %22 = load i32, ptr @current_test, align 4, !tbaa !9
  %23 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %22)
  %24 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %25

25:                                               ; preds = %21, %70
  %26 = phi i32 [ %24, %21 ], [ %19, %70 ]
  %27 = add nuw nsw i32 %20, 1
  %28 = icmp slt i32 %27, %26
  br i1 %28, label %18, label %106, !llvm.loop !492

29:                                               ; preds = %18, %29
  %30 = phi i64 [ %52, %29 ], [ 0, %18 ]
  %31 = phi float [ %51, %29 ], [ 0.000000e+00, %18 ]
  %32 = phi i64 [ %53, %29 ], [ 0, %18 ]
  %33 = getelementptr inbounds float, ptr %0, i64 %30
  %34 = load float, ptr %33, align 4, !tbaa !40
  %35 = fadd float %34, %2
  %36 = fadd float %31, %35
  %37 = or i64 %30, 1
  %38 = getelementptr inbounds float, ptr %0, i64 %37
  %39 = load float, ptr %38, align 4, !tbaa !40
  %40 = fadd float %39, %2
  %41 = fadd float %36, %40
  %42 = or i64 %30, 2
  %43 = getelementptr inbounds float, ptr %0, i64 %42
  %44 = load float, ptr %43, align 4, !tbaa !40
  %45 = fadd float %44, %2
  %46 = fadd float %41, %45
  %47 = or i64 %30, 3
  %48 = getelementptr inbounds float, ptr %0, i64 %47
  %49 = load float, ptr %48, align 4, !tbaa !40
  %50 = fadd float %49, %2
  %51 = fadd float %46, %50
  %52 = add nuw nsw i64 %30, 4
  %53 = add i64 %32, 4
  %54 = icmp eq i64 %53, %16
  br i1 %54, label %55, label %29, !llvm.loop !493

55:                                               ; preds = %29, %18
  %56 = phi float [ undef, %18 ], [ %51, %29 ]
  %57 = phi i64 [ 0, %18 ], [ %52, %29 ]
  %58 = phi float [ 0.000000e+00, %18 ], [ %51, %29 ]
  br i1 %17, label %70, label %59

59:                                               ; preds = %55, %59
  %60 = phi i64 [ %67, %59 ], [ %57, %55 ]
  %61 = phi float [ %66, %59 ], [ %58, %55 ]
  %62 = phi i64 [ %68, %59 ], [ 0, %55 ]
  %63 = getelementptr inbounds float, ptr %0, i64 %60
  %64 = load float, ptr %63, align 4, !tbaa !40
  %65 = fadd float %64, %2
  %66 = fadd float %61, %65
  %67 = add nuw nsw i64 %60, 1
  %68 = add i64 %62, 1
  %69 = icmp eq i64 %68, %14
  br i1 %69, label %70, label %59, !llvm.loop !494

70:                                               ; preds = %59, %55
  %71 = phi float [ %56, %55 ], [ %66, %59 ]
  %72 = load double, ptr @init_value, align 8, !tbaa !28
  %73 = fptrunc double %72 to float
  %74 = fadd float %73, %2
  %75 = fmul float %74, 8.000000e+03
  %76 = fsub float %71, %75
  %77 = tail call float @llvm.fabs.f32(float %71)
  %78 = fpext float %77 to double
  %79 = fcmp ogt double %78, 1.000000e-04
  %80 = select i1 %79, float %71, float 1.000000e+00
  %81 = fdiv float %76, %80
  %82 = tail call float @llvm.fabs.f32(float %81)
  %83 = fpext float %82 to double
  %84 = fcmp olt double %83, 1.000000e-03
  br i1 %84, label %25, label %21

85:                                               ; preds = %10, %101
  %86 = phi i32 [ %102, %101 ], [ %6, %10 ]
  %87 = phi double [ %103, %101 ], [ %11, %10 ]
  %88 = phi i32 [ %104, %101 ], [ 0, %10 ]
  %89 = fptrunc double %87 to float
  %90 = fadd float %89, %2
  %91 = fmul float %90, 8.000000e+03
  %92 = fsub float 0.000000e+00, %91
  %93 = tail call float @llvm.fabs.f32(float %92)
  %94 = fpext float %93 to double
  %95 = fcmp olt double %94, 1.000000e-03
  br i1 %95, label %101, label %96

96:                                               ; preds = %85
  %97 = load i32, ptr @current_test, align 4, !tbaa !9
  %98 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %97)
  %99 = load double, ptr @init_value, align 8, !tbaa !28
  %100 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %101

101:                                              ; preds = %85, %96
  %102 = phi i32 [ %86, %85 ], [ %100, %96 ]
  %103 = phi double [ %87, %85 ], [ %99, %96 ]
  %104 = add nuw nsw i32 %88, 1
  %105 = icmp slt i32 %104, %102
  br i1 %105, label %85, label %106, !llvm.loop !492

106:                                              ; preds = %101, %25, %4
  %107 = tail call i64 @clock() #17
  store i64 %107, ptr @end_time, align 8, !tbaa !26
  %108 = load i64, ptr @start_time, align 8, !tbaa !26
  %109 = load ptr, ptr @results, align 8, !tbaa !5
  %110 = icmp eq ptr %109, null
  br i1 %110, label %111, label %113

111:                                              ; preds = %106
  %112 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %117

113:                                              ; preds = %106
  %114 = load i32, ptr @current_test, align 4, !tbaa !9
  %115 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %116 = icmp slt i32 %114, %115
  br i1 %116, label %129, label %117

117:                                              ; preds = %113, %111
  %118 = phi i32 [ %112, %111 ], [ %115, %113 ]
  %119 = add nsw i32 %118, 10
  store i32 %119, ptr @allocated_results, align 4, !tbaa !9
  %120 = sext i32 %119 to i64
  %121 = shl nsw i64 %120, 4
  %122 = tail call ptr @realloc(ptr noundef %109, i64 noundef %121) #14
  store ptr %122, ptr @results, align 8, !tbaa !5
  %123 = icmp eq ptr %122, null
  br i1 %123, label %126, label %124

124:                                              ; preds = %117
  %125 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %129

126:                                              ; preds = %117
  %127 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %128 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %127)
  tail call void @exit(i32 noundef -1) #15
  unreachable

129:                                              ; preds = %113, %124
  %130 = phi i32 [ %125, %124 ], [ %114, %113 ]
  %131 = phi ptr [ %122, %124 ], [ %109, %113 ]
  %132 = sub nsw i64 %107, %108
  %133 = sitofp i64 %132 to double
  %134 = fdiv double %133, 1.000000e+06
  %135 = sext i32 %130 to i64
  %136 = getelementptr inbounds %struct.one_result, ptr %131, i64 %135
  store double %134, ptr %136, align 8, !tbaa !11
  %137 = getelementptr inbounds %struct.one_result, ptr %131, i64 %135, i32 1
  store ptr %3, ptr %137, align 8, !tbaa !14
  %138 = add nsw i32 %130, 1
  store i32 %138, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z22test_hoisted_variable1If19custom_add_variableIfEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, float noundef %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !26
  %6 = load i32, ptr @iterations, align 4, !tbaa !9
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %125

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  %10 = sitofp i32 %1 to float
  br i1 %9, label %11, label %96

11:                                               ; preds = %8
  %12 = zext i32 %1 to i64
  %13 = and i64 %12, 7
  %14 = icmp ult i32 %1, 8
  %15 = and i64 %12, 4294967288
  %16 = icmp eq i64 %13, 0
  br label %17

17:                                               ; preds = %11, %24
  %18 = phi i32 [ %25, %24 ], [ %6, %11 ]
  %19 = phi i32 [ %26, %24 ], [ 0, %11 ]
  br i1 %14, label %66, label %28

20:                                               ; preds = %80
  %21 = load i32, ptr @current_test, align 4, !tbaa !9
  %22 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %21)
  %23 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %24

24:                                               ; preds = %20, %80
  %25 = phi i32 [ %23, %20 ], [ %18, %80 ]
  %26 = add nuw nsw i32 %19, 1
  %27 = icmp slt i32 %26, %25
  br i1 %27, label %17, label %125, !llvm.loop !495

28:                                               ; preds = %17, %28
  %29 = phi i64 [ %63, %28 ], [ 0, %17 ]
  %30 = phi float [ %62, %28 ], [ 0.000000e+00, %17 ]
  %31 = phi i64 [ %64, %28 ], [ 0, %17 ]
  %32 = getelementptr inbounds float, ptr %0, i64 %29
  %33 = load float, ptr %32, align 4, !tbaa !40
  %34 = fadd float %30, %33
  %35 = or i64 %29, 1
  %36 = getelementptr inbounds float, ptr %0, i64 %35
  %37 = load float, ptr %36, align 4, !tbaa !40
  %38 = fadd float %34, %37
  %39 = or i64 %29, 2
  %40 = getelementptr inbounds float, ptr %0, i64 %39
  %41 = load float, ptr %40, align 4, !tbaa !40
  %42 = fadd float %38, %41
  %43 = or i64 %29, 3
  %44 = getelementptr inbounds float, ptr %0, i64 %43
  %45 = load float, ptr %44, align 4, !tbaa !40
  %46 = fadd float %42, %45
  %47 = or i64 %29, 4
  %48 = getelementptr inbounds float, ptr %0, i64 %47
  %49 = load float, ptr %48, align 4, !tbaa !40
  %50 = fadd float %46, %49
  %51 = or i64 %29, 5
  %52 = getelementptr inbounds float, ptr %0, i64 %51
  %53 = load float, ptr %52, align 4, !tbaa !40
  %54 = fadd float %50, %53
  %55 = or i64 %29, 6
  %56 = getelementptr inbounds float, ptr %0, i64 %55
  %57 = load float, ptr %56, align 4, !tbaa !40
  %58 = fadd float %54, %57
  %59 = or i64 %29, 7
  %60 = getelementptr inbounds float, ptr %0, i64 %59
  %61 = load float, ptr %60, align 4, !tbaa !40
  %62 = fadd float %58, %61
  %63 = add nuw nsw i64 %29, 8
  %64 = add i64 %31, 8
  %65 = icmp eq i64 %64, %15
  br i1 %65, label %66, label %28, !llvm.loop !496

66:                                               ; preds = %28, %17
  %67 = phi float [ undef, %17 ], [ %62, %28 ]
  %68 = phi i64 [ 0, %17 ], [ %63, %28 ]
  %69 = phi float [ 0.000000e+00, %17 ], [ %62, %28 ]
  br i1 %16, label %80, label %70

70:                                               ; preds = %66, %70
  %71 = phi i64 [ %77, %70 ], [ %68, %66 ]
  %72 = phi float [ %76, %70 ], [ %69, %66 ]
  %73 = phi i64 [ %78, %70 ], [ 0, %66 ]
  %74 = getelementptr inbounds float, ptr %0, i64 %71
  %75 = load float, ptr %74, align 4, !tbaa !40
  %76 = fadd float %72, %75
  %77 = add nuw nsw i64 %71, 1
  %78 = add i64 %73, 1
  %79 = icmp eq i64 %78, %13
  br i1 %79, label %80, label %70, !llvm.loop !497

80:                                               ; preds = %70, %66
  %81 = phi float [ %67, %66 ], [ %76, %70 ]
  %82 = tail call float @llvm.fmuladd.f32(float %10, float %2, float %81)
  %83 = load double, ptr @init_value, align 8, !tbaa !28
  %84 = fptrunc double %83 to float
  %85 = fadd float %84, %2
  %86 = fmul float %85, 8.000000e+03
  %87 = fsub float %82, %86
  %88 = tail call float @llvm.fabs.f32(float %82)
  %89 = fpext float %88 to double
  %90 = fcmp ogt double %89, 1.000000e-04
  %91 = select i1 %90, float %82, float 1.000000e+00
  %92 = fdiv float %87, %91
  %93 = tail call float @llvm.fabs.f32(float %92)
  %94 = fpext float %93 to double
  %95 = fcmp olt double %94, 1.000000e-03
  br i1 %95, label %24, label %20

96:                                               ; preds = %8
  %97 = tail call float @llvm.fmuladd.f32(float %10, float %2, float 0.000000e+00)
  %98 = tail call float @llvm.fabs.f32(float %97)
  %99 = fpext float %98 to double
  %100 = fcmp ogt double %99, 1.000000e-04
  %101 = select i1 %100, float %97, float 1.000000e+00
  %102 = load double, ptr @init_value, align 8, !tbaa !28
  br label %103

103:                                              ; preds = %96, %120
  %104 = phi i32 [ %6, %96 ], [ %121, %120 ]
  %105 = phi double [ %102, %96 ], [ %122, %120 ]
  %106 = phi i32 [ 0, %96 ], [ %123, %120 ]
  %107 = fptrunc double %105 to float
  %108 = fadd float %107, %2
  %109 = fmul float %108, 8.000000e+03
  %110 = fsub float %97, %109
  %111 = fdiv float %110, %101
  %112 = tail call float @llvm.fabs.f32(float %111)
  %113 = fpext float %112 to double
  %114 = fcmp olt double %113, 1.000000e-03
  br i1 %114, label %120, label %115

115:                                              ; preds = %103
  %116 = load i32, ptr @current_test, align 4, !tbaa !9
  %117 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %116)
  %118 = load double, ptr @init_value, align 8, !tbaa !28
  %119 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %120

120:                                              ; preds = %103, %115
  %121 = phi i32 [ %104, %103 ], [ %119, %115 ]
  %122 = phi double [ %105, %103 ], [ %118, %115 ]
  %123 = add nuw nsw i32 %106, 1
  %124 = icmp slt i32 %123, %121
  br i1 %124, label %103, label %125, !llvm.loop !495

125:                                              ; preds = %120, %24, %4
  %126 = tail call i64 @clock() #17
  store i64 %126, ptr @end_time, align 8, !tbaa !26
  %127 = load i64, ptr @start_time, align 8, !tbaa !26
  %128 = load ptr, ptr @results, align 8, !tbaa !5
  %129 = icmp eq ptr %128, null
  br i1 %129, label %130, label %132

130:                                              ; preds = %125
  %131 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %136

132:                                              ; preds = %125
  %133 = load i32, ptr @current_test, align 4, !tbaa !9
  %134 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %135 = icmp slt i32 %133, %134
  br i1 %135, label %148, label %136

136:                                              ; preds = %132, %130
  %137 = phi i32 [ %131, %130 ], [ %134, %132 ]
  %138 = add nsw i32 %137, 10
  store i32 %138, ptr @allocated_results, align 4, !tbaa !9
  %139 = sext i32 %138 to i64
  %140 = shl nsw i64 %139, 4
  %141 = tail call ptr @realloc(ptr noundef %128, i64 noundef %140) #14
  store ptr %141, ptr @results, align 8, !tbaa !5
  %142 = icmp eq ptr %141, null
  br i1 %142, label %145, label %143

143:                                              ; preds = %136
  %144 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %148

145:                                              ; preds = %136
  %146 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %147 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %146)
  tail call void @exit(i32 noundef -1) #15
  unreachable

148:                                              ; preds = %132, %143
  %149 = phi i32 [ %144, %143 ], [ %133, %132 ]
  %150 = phi ptr [ %141, %143 ], [ %128, %132 ]
  %151 = sub nsw i64 %126, %127
  %152 = sitofp i64 %151 to double
  %153 = fdiv double %152, 1.000000e+06
  %154 = sext i32 %149 to i64
  %155 = getelementptr inbounds %struct.one_result, ptr %150, i64 %154
  store double %153, ptr %155, align 8, !tbaa !11
  %156 = getelementptr inbounds %struct.one_result, ptr %150, i64 %154, i32 1
  store ptr %3, ptr %156, align 8, !tbaa !14
  %157 = add nsw i32 %149, 1
  store i32 %157, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4If28custom_add_multiple_variableIfEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, float noundef %2, float noundef %3, float noundef %4, float noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !26
  %9 = load i32, ptr @iterations, align 4, !tbaa !9
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %108

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  br i1 %12, label %15, label %13

13:                                               ; preds = %11
  %14 = load double, ptr @init_value, align 8, !tbaa !28
  br label %84

15:                                               ; preds = %11
  %16 = zext i32 %1 to i64
  %17 = and i64 %16, 1
  %18 = icmp eq i32 %1, 1
  %19 = and i64 %16, 4294967294
  %20 = icmp eq i64 %17, 0
  br label %21

21:                                               ; preds = %15, %28
  %22 = phi i32 [ %29, %28 ], [ %9, %15 ]
  %23 = phi i32 [ %30, %28 ], [ 0, %15 ]
  br i1 %18, label %54, label %32

24:                                               ; preds = %66
  %25 = load i32, ptr @current_test, align 4, !tbaa !9
  %26 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %25)
  %27 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %28

28:                                               ; preds = %24, %66
  %29 = phi i32 [ %27, %24 ], [ %22, %66 ]
  %30 = add nuw nsw i32 %23, 1
  %31 = icmp slt i32 %30, %29
  br i1 %31, label %21, label %108, !llvm.loop !498

32:                                               ; preds = %21, %32
  %33 = phi i64 [ %51, %32 ], [ 0, %21 ]
  %34 = phi float [ %50, %32 ], [ 0.000000e+00, %21 ]
  %35 = phi i64 [ %52, %32 ], [ 0, %21 ]
  %36 = getelementptr inbounds float, ptr %0, i64 %33
  %37 = load float, ptr %36, align 4, !tbaa !40
  %38 = fadd float %37, %2
  %39 = fadd float %38, %3
  %40 = fadd float %39, %4
  %41 = fadd float %40, %5
  %42 = fadd float %34, %41
  %43 = or i64 %33, 1
  %44 = getelementptr inbounds float, ptr %0, i64 %43
  %45 = load float, ptr %44, align 4, !tbaa !40
  %46 = fadd float %45, %2
  %47 = fadd float %46, %3
  %48 = fadd float %47, %4
  %49 = fadd float %48, %5
  %50 = fadd float %42, %49
  %51 = add nuw nsw i64 %33, 2
  %52 = add i64 %35, 2
  %53 = icmp eq i64 %52, %19
  br i1 %53, label %54, label %32, !llvm.loop !499

54:                                               ; preds = %32, %21
  %55 = phi float [ undef, %21 ], [ %50, %32 ]
  %56 = phi i64 [ 0, %21 ], [ %51, %32 ]
  %57 = phi float [ 0.000000e+00, %21 ], [ %50, %32 ]
  br i1 %20, label %66, label %58

58:                                               ; preds = %54
  %59 = getelementptr inbounds float, ptr %0, i64 %56
  %60 = load float, ptr %59, align 4, !tbaa !40
  %61 = fadd float %60, %2
  %62 = fadd float %61, %3
  %63 = fadd float %62, %4
  %64 = fadd float %63, %5
  %65 = fadd float %57, %64
  br label %66

66:                                               ; preds = %54, %58
  %67 = phi float [ %55, %54 ], [ %65, %58 ]
  %68 = load double, ptr @init_value, align 8, !tbaa !28
  %69 = fptrunc double %68 to float
  %70 = fadd float %69, %2
  %71 = fadd float %70, %3
  %72 = fadd float %71, %4
  %73 = fadd float %72, %5
  %74 = fmul float %73, 8.000000e+03
  %75 = fsub float %67, %74
  %76 = tail call float @llvm.fabs.f32(float %67)
  %77 = fpext float %76 to double
  %78 = fcmp ogt double %77, 1.000000e-04
  %79 = select i1 %78, float %67, float 1.000000e+00
  %80 = fdiv float %75, %79
  %81 = tail call float @llvm.fabs.f32(float %80)
  %82 = fpext float %81 to double
  %83 = fcmp olt double %82, 1.000000e-03
  br i1 %83, label %28, label %24

84:                                               ; preds = %13, %103
  %85 = phi i32 [ %104, %103 ], [ %9, %13 ]
  %86 = phi double [ %105, %103 ], [ %14, %13 ]
  %87 = phi i32 [ %106, %103 ], [ 0, %13 ]
  %88 = fptrunc double %86 to float
  %89 = fadd float %88, %2
  %90 = fadd float %89, %3
  %91 = fadd float %90, %4
  %92 = fadd float %91, %5
  %93 = fmul float %92, 8.000000e+03
  %94 = fsub float 0.000000e+00, %93
  %95 = tail call float @llvm.fabs.f32(float %94)
  %96 = fpext float %95 to double
  %97 = fcmp olt double %96, 1.000000e-03
  br i1 %97, label %103, label %98

98:                                               ; preds = %84
  %99 = load i32, ptr @current_test, align 4, !tbaa !9
  %100 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %99)
  %101 = load double, ptr @init_value, align 8, !tbaa !28
  %102 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %103

103:                                              ; preds = %84, %98
  %104 = phi i32 [ %85, %84 ], [ %102, %98 ]
  %105 = phi double [ %86, %84 ], [ %101, %98 ]
  %106 = add nuw nsw i32 %87, 1
  %107 = icmp slt i32 %106, %104
  br i1 %107, label %84, label %108, !llvm.loop !498

108:                                              ; preds = %103, %28, %7
  %109 = tail call i64 @clock() #17
  store i64 %109, ptr @end_time, align 8, !tbaa !26
  %110 = load i64, ptr @start_time, align 8, !tbaa !26
  %111 = load ptr, ptr @results, align 8, !tbaa !5
  %112 = icmp eq ptr %111, null
  br i1 %112, label %113, label %115

113:                                              ; preds = %108
  %114 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %119

115:                                              ; preds = %108
  %116 = load i32, ptr @current_test, align 4, !tbaa !9
  %117 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %118 = icmp slt i32 %116, %117
  br i1 %118, label %131, label %119

119:                                              ; preds = %115, %113
  %120 = phi i32 [ %114, %113 ], [ %117, %115 ]
  %121 = add nsw i32 %120, 10
  store i32 %121, ptr @allocated_results, align 4, !tbaa !9
  %122 = sext i32 %121 to i64
  %123 = shl nsw i64 %122, 4
  %124 = tail call ptr @realloc(ptr noundef %111, i64 noundef %123) #14
  store ptr %124, ptr @results, align 8, !tbaa !5
  %125 = icmp eq ptr %124, null
  br i1 %125, label %128, label %126

126:                                              ; preds = %119
  %127 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %131

128:                                              ; preds = %119
  %129 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %130 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %129)
  tail call void @exit(i32 noundef -1) #15
  unreachable

131:                                              ; preds = %115, %126
  %132 = phi i32 [ %127, %126 ], [ %116, %115 ]
  %133 = phi ptr [ %124, %126 ], [ %111, %115 ]
  %134 = sub nsw i64 %109, %110
  %135 = sitofp i64 %134 to double
  %136 = fdiv double %135, 1.000000e+06
  %137 = sext i32 %132 to i64
  %138 = getelementptr inbounds %struct.one_result, ptr %133, i64 %137
  store double %136, ptr %138, align 8, !tbaa !11
  %139 = getelementptr inbounds %struct.one_result, ptr %133, i64 %137, i32 1
  store ptr %6, ptr %139, align 8, !tbaa !14
  %140 = add nsw i32 %132, 1
  store i32 %140, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1If19custom_sub_variableIfEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, float noundef %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !26
  %6 = load i32, ptr @iterations, align 4, !tbaa !9
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %106

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  br i1 %9, label %12, label %10

10:                                               ; preds = %8
  %11 = load double, ptr @init_value, align 8, !tbaa !28
  br label %85

12:                                               ; preds = %8
  %13 = zext i32 %1 to i64
  %14 = and i64 %13, 3
  %15 = icmp ult i32 %1, 4
  %16 = and i64 %13, 4294967292
  %17 = icmp eq i64 %14, 0
  br label %18

18:                                               ; preds = %12, %25
  %19 = phi i32 [ %26, %25 ], [ %6, %12 ]
  %20 = phi i32 [ %27, %25 ], [ 0, %12 ]
  br i1 %15, label %55, label %29

21:                                               ; preds = %70
  %22 = load i32, ptr @current_test, align 4, !tbaa !9
  %23 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %22)
  %24 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %25

25:                                               ; preds = %21, %70
  %26 = phi i32 [ %24, %21 ], [ %19, %70 ]
  %27 = add nuw nsw i32 %20, 1
  %28 = icmp slt i32 %27, %26
  br i1 %28, label %18, label %106, !llvm.loop !500

29:                                               ; preds = %18, %29
  %30 = phi i64 [ %52, %29 ], [ 0, %18 ]
  %31 = phi float [ %51, %29 ], [ 0.000000e+00, %18 ]
  %32 = phi i64 [ %53, %29 ], [ 0, %18 ]
  %33 = getelementptr inbounds float, ptr %0, i64 %30
  %34 = load float, ptr %33, align 4, !tbaa !40
  %35 = fsub float %34, %2
  %36 = fadd float %31, %35
  %37 = or i64 %30, 1
  %38 = getelementptr inbounds float, ptr %0, i64 %37
  %39 = load float, ptr %38, align 4, !tbaa !40
  %40 = fsub float %39, %2
  %41 = fadd float %36, %40
  %42 = or i64 %30, 2
  %43 = getelementptr inbounds float, ptr %0, i64 %42
  %44 = load float, ptr %43, align 4, !tbaa !40
  %45 = fsub float %44, %2
  %46 = fadd float %41, %45
  %47 = or i64 %30, 3
  %48 = getelementptr inbounds float, ptr %0, i64 %47
  %49 = load float, ptr %48, align 4, !tbaa !40
  %50 = fsub float %49, %2
  %51 = fadd float %46, %50
  %52 = add nuw nsw i64 %30, 4
  %53 = add i64 %32, 4
  %54 = icmp eq i64 %53, %16
  br i1 %54, label %55, label %29, !llvm.loop !501

55:                                               ; preds = %29, %18
  %56 = phi float [ undef, %18 ], [ %51, %29 ]
  %57 = phi i64 [ 0, %18 ], [ %52, %29 ]
  %58 = phi float [ 0.000000e+00, %18 ], [ %51, %29 ]
  br i1 %17, label %70, label %59

59:                                               ; preds = %55, %59
  %60 = phi i64 [ %67, %59 ], [ %57, %55 ]
  %61 = phi float [ %66, %59 ], [ %58, %55 ]
  %62 = phi i64 [ %68, %59 ], [ 0, %55 ]
  %63 = getelementptr inbounds float, ptr %0, i64 %60
  %64 = load float, ptr %63, align 4, !tbaa !40
  %65 = fsub float %64, %2
  %66 = fadd float %61, %65
  %67 = add nuw nsw i64 %60, 1
  %68 = add i64 %62, 1
  %69 = icmp eq i64 %68, %14
  br i1 %69, label %70, label %59, !llvm.loop !502

70:                                               ; preds = %59, %55
  %71 = phi float [ %56, %55 ], [ %66, %59 ]
  %72 = load double, ptr @init_value, align 8, !tbaa !28
  %73 = fptrunc double %72 to float
  %74 = fsub float %73, %2
  %75 = fmul float %74, 8.000000e+03
  %76 = fsub float %71, %75
  %77 = tail call float @llvm.fabs.f32(float %71)
  %78 = fpext float %77 to double
  %79 = fcmp ogt double %78, 1.000000e-04
  %80 = select i1 %79, float %71, float 1.000000e+00
  %81 = fdiv float %76, %80
  %82 = tail call float @llvm.fabs.f32(float %81)
  %83 = fpext float %82 to double
  %84 = fcmp olt double %83, 1.000000e-03
  br i1 %84, label %25, label %21

85:                                               ; preds = %10, %101
  %86 = phi i32 [ %102, %101 ], [ %6, %10 ]
  %87 = phi double [ %103, %101 ], [ %11, %10 ]
  %88 = phi i32 [ %104, %101 ], [ 0, %10 ]
  %89 = fptrunc double %87 to float
  %90 = fsub float %89, %2
  %91 = fmul float %90, 8.000000e+03
  %92 = fsub float 0.000000e+00, %91
  %93 = tail call float @llvm.fabs.f32(float %92)
  %94 = fpext float %93 to double
  %95 = fcmp olt double %94, 1.000000e-03
  br i1 %95, label %101, label %96

96:                                               ; preds = %85
  %97 = load i32, ptr @current_test, align 4, !tbaa !9
  %98 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %97)
  %99 = load double, ptr @init_value, align 8, !tbaa !28
  %100 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %101

101:                                              ; preds = %85, %96
  %102 = phi i32 [ %86, %85 ], [ %100, %96 ]
  %103 = phi double [ %87, %85 ], [ %99, %96 ]
  %104 = add nuw nsw i32 %88, 1
  %105 = icmp slt i32 %104, %102
  br i1 %105, label %85, label %106, !llvm.loop !500

106:                                              ; preds = %101, %25, %4
  %107 = tail call i64 @clock() #17
  store i64 %107, ptr @end_time, align 8, !tbaa !26
  %108 = load i64, ptr @start_time, align 8, !tbaa !26
  %109 = load ptr, ptr @results, align 8, !tbaa !5
  %110 = icmp eq ptr %109, null
  br i1 %110, label %111, label %113

111:                                              ; preds = %106
  %112 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %117

113:                                              ; preds = %106
  %114 = load i32, ptr @current_test, align 4, !tbaa !9
  %115 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %116 = icmp slt i32 %114, %115
  br i1 %116, label %129, label %117

117:                                              ; preds = %113, %111
  %118 = phi i32 [ %112, %111 ], [ %115, %113 ]
  %119 = add nsw i32 %118, 10
  store i32 %119, ptr @allocated_results, align 4, !tbaa !9
  %120 = sext i32 %119 to i64
  %121 = shl nsw i64 %120, 4
  %122 = tail call ptr @realloc(ptr noundef %109, i64 noundef %121) #14
  store ptr %122, ptr @results, align 8, !tbaa !5
  %123 = icmp eq ptr %122, null
  br i1 %123, label %126, label %124

124:                                              ; preds = %117
  %125 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %129

126:                                              ; preds = %117
  %127 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %128 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %127)
  tail call void @exit(i32 noundef -1) #15
  unreachable

129:                                              ; preds = %113, %124
  %130 = phi i32 [ %125, %124 ], [ %114, %113 ]
  %131 = phi ptr [ %122, %124 ], [ %109, %113 ]
  %132 = sub nsw i64 %107, %108
  %133 = sitofp i64 %132 to double
  %134 = fdiv double %133, 1.000000e+06
  %135 = sext i32 %130 to i64
  %136 = getelementptr inbounds %struct.one_result, ptr %131, i64 %135
  store double %134, ptr %136, align 8, !tbaa !11
  %137 = getelementptr inbounds %struct.one_result, ptr %131, i64 %135, i32 1
  store ptr %3, ptr %137, align 8, !tbaa !14
  %138 = add nsw i32 %130, 1
  store i32 %138, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4If28custom_sub_multiple_variableIfEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, float noundef %2, float noundef %3, float noundef %4, float noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !26
  %9 = load i32, ptr @iterations, align 4, !tbaa !9
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %108

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  br i1 %12, label %15, label %13

13:                                               ; preds = %11
  %14 = load double, ptr @init_value, align 8, !tbaa !28
  br label %84

15:                                               ; preds = %11
  %16 = zext i32 %1 to i64
  %17 = and i64 %16, 1
  %18 = icmp eq i32 %1, 1
  %19 = and i64 %16, 4294967294
  %20 = icmp eq i64 %17, 0
  br label %21

21:                                               ; preds = %15, %28
  %22 = phi i32 [ %29, %28 ], [ %9, %15 ]
  %23 = phi i32 [ %30, %28 ], [ 0, %15 ]
  br i1 %18, label %54, label %32

24:                                               ; preds = %66
  %25 = load i32, ptr @current_test, align 4, !tbaa !9
  %26 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %25)
  %27 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %28

28:                                               ; preds = %24, %66
  %29 = phi i32 [ %27, %24 ], [ %22, %66 ]
  %30 = add nuw nsw i32 %23, 1
  %31 = icmp slt i32 %30, %29
  br i1 %31, label %21, label %108, !llvm.loop !503

32:                                               ; preds = %21, %32
  %33 = phi i64 [ %51, %32 ], [ 0, %21 ]
  %34 = phi float [ %50, %32 ], [ 0.000000e+00, %21 ]
  %35 = phi i64 [ %52, %32 ], [ 0, %21 ]
  %36 = getelementptr inbounds float, ptr %0, i64 %33
  %37 = load float, ptr %36, align 4, !tbaa !40
  %38 = fsub float %37, %2
  %39 = fsub float %38, %3
  %40 = fsub float %39, %4
  %41 = fsub float %40, %5
  %42 = fadd float %34, %41
  %43 = or i64 %33, 1
  %44 = getelementptr inbounds float, ptr %0, i64 %43
  %45 = load float, ptr %44, align 4, !tbaa !40
  %46 = fsub float %45, %2
  %47 = fsub float %46, %3
  %48 = fsub float %47, %4
  %49 = fsub float %48, %5
  %50 = fadd float %42, %49
  %51 = add nuw nsw i64 %33, 2
  %52 = add i64 %35, 2
  %53 = icmp eq i64 %52, %19
  br i1 %53, label %54, label %32, !llvm.loop !504

54:                                               ; preds = %32, %21
  %55 = phi float [ undef, %21 ], [ %50, %32 ]
  %56 = phi i64 [ 0, %21 ], [ %51, %32 ]
  %57 = phi float [ 0.000000e+00, %21 ], [ %50, %32 ]
  br i1 %20, label %66, label %58

58:                                               ; preds = %54
  %59 = getelementptr inbounds float, ptr %0, i64 %56
  %60 = load float, ptr %59, align 4, !tbaa !40
  %61 = fsub float %60, %2
  %62 = fsub float %61, %3
  %63 = fsub float %62, %4
  %64 = fsub float %63, %5
  %65 = fadd float %57, %64
  br label %66

66:                                               ; preds = %54, %58
  %67 = phi float [ %55, %54 ], [ %65, %58 ]
  %68 = load double, ptr @init_value, align 8, !tbaa !28
  %69 = fptrunc double %68 to float
  %70 = fsub float %69, %2
  %71 = fsub float %70, %3
  %72 = fsub float %71, %4
  %73 = fsub float %72, %5
  %74 = fmul float %73, 8.000000e+03
  %75 = fsub float %67, %74
  %76 = tail call float @llvm.fabs.f32(float %67)
  %77 = fpext float %76 to double
  %78 = fcmp ogt double %77, 1.000000e-04
  %79 = select i1 %78, float %67, float 1.000000e+00
  %80 = fdiv float %75, %79
  %81 = tail call float @llvm.fabs.f32(float %80)
  %82 = fpext float %81 to double
  %83 = fcmp olt double %82, 1.000000e-03
  br i1 %83, label %28, label %24

84:                                               ; preds = %13, %103
  %85 = phi i32 [ %104, %103 ], [ %9, %13 ]
  %86 = phi double [ %105, %103 ], [ %14, %13 ]
  %87 = phi i32 [ %106, %103 ], [ 0, %13 ]
  %88 = fptrunc double %86 to float
  %89 = fsub float %88, %2
  %90 = fsub float %89, %3
  %91 = fsub float %90, %4
  %92 = fsub float %91, %5
  %93 = fmul float %92, 8.000000e+03
  %94 = fsub float 0.000000e+00, %93
  %95 = tail call float @llvm.fabs.f32(float %94)
  %96 = fpext float %95 to double
  %97 = fcmp olt double %96, 1.000000e-03
  br i1 %97, label %103, label %98

98:                                               ; preds = %84
  %99 = load i32, ptr @current_test, align 4, !tbaa !9
  %100 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %99)
  %101 = load double, ptr @init_value, align 8, !tbaa !28
  %102 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %103

103:                                              ; preds = %84, %98
  %104 = phi i32 [ %85, %84 ], [ %102, %98 ]
  %105 = phi double [ %86, %84 ], [ %101, %98 ]
  %106 = add nuw nsw i32 %87, 1
  %107 = icmp slt i32 %106, %104
  br i1 %107, label %84, label %108, !llvm.loop !503

108:                                              ; preds = %103, %28, %7
  %109 = tail call i64 @clock() #17
  store i64 %109, ptr @end_time, align 8, !tbaa !26
  %110 = load i64, ptr @start_time, align 8, !tbaa !26
  %111 = load ptr, ptr @results, align 8, !tbaa !5
  %112 = icmp eq ptr %111, null
  br i1 %112, label %113, label %115

113:                                              ; preds = %108
  %114 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %119

115:                                              ; preds = %108
  %116 = load i32, ptr @current_test, align 4, !tbaa !9
  %117 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %118 = icmp slt i32 %116, %117
  br i1 %118, label %131, label %119

119:                                              ; preds = %115, %113
  %120 = phi i32 [ %114, %113 ], [ %117, %115 ]
  %121 = add nsw i32 %120, 10
  store i32 %121, ptr @allocated_results, align 4, !tbaa !9
  %122 = sext i32 %121 to i64
  %123 = shl nsw i64 %122, 4
  %124 = tail call ptr @realloc(ptr noundef %111, i64 noundef %123) #14
  store ptr %124, ptr @results, align 8, !tbaa !5
  %125 = icmp eq ptr %124, null
  br i1 %125, label %128, label %126

126:                                              ; preds = %119
  %127 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %131

128:                                              ; preds = %119
  %129 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %130 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %129)
  tail call void @exit(i32 noundef -1) #15
  unreachable

131:                                              ; preds = %115, %126
  %132 = phi i32 [ %127, %126 ], [ %116, %115 ]
  %133 = phi ptr [ %124, %126 ], [ %111, %115 ]
  %134 = sub nsw i64 %109, %110
  %135 = sitofp i64 %134 to double
  %136 = fdiv double %135, 1.000000e+06
  %137 = sext i32 %132 to i64
  %138 = getelementptr inbounds %struct.one_result, ptr %133, i64 %137
  store double %136, ptr %138, align 8, !tbaa !11
  %139 = getelementptr inbounds %struct.one_result, ptr %133, i64 %137, i32 1
  store ptr %6, ptr %139, align 8, !tbaa !14
  %140 = add nsw i32 %132, 1
  store i32 %140, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1If24custom_multiply_variableIfEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, float noundef %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !26
  %6 = load i32, ptr @iterations, align 4, !tbaa !9
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %106

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  br i1 %9, label %12, label %10

10:                                               ; preds = %8
  %11 = load double, ptr @init_value, align 8, !tbaa !28
  br label %85

12:                                               ; preds = %8
  %13 = zext i32 %1 to i64
  %14 = and i64 %13, 3
  %15 = icmp ult i32 %1, 4
  %16 = and i64 %13, 4294967292
  %17 = icmp eq i64 %14, 0
  br label %18

18:                                               ; preds = %12, %25
  %19 = phi i32 [ %26, %25 ], [ %6, %12 ]
  %20 = phi i32 [ %27, %25 ], [ 0, %12 ]
  br i1 %15, label %55, label %29

21:                                               ; preds = %70
  %22 = load i32, ptr @current_test, align 4, !tbaa !9
  %23 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %22)
  %24 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %25

25:                                               ; preds = %21, %70
  %26 = phi i32 [ %24, %21 ], [ %19, %70 ]
  %27 = add nuw nsw i32 %20, 1
  %28 = icmp slt i32 %27, %26
  br i1 %28, label %18, label %106, !llvm.loop !505

29:                                               ; preds = %18, %29
  %30 = phi i64 [ %52, %29 ], [ 0, %18 ]
  %31 = phi float [ %51, %29 ], [ 0.000000e+00, %18 ]
  %32 = phi i64 [ %53, %29 ], [ 0, %18 ]
  %33 = getelementptr inbounds float, ptr %0, i64 %30
  %34 = load float, ptr %33, align 4, !tbaa !40
  %35 = fmul float %34, %2
  %36 = fadd float %31, %35
  %37 = or i64 %30, 1
  %38 = getelementptr inbounds float, ptr %0, i64 %37
  %39 = load float, ptr %38, align 4, !tbaa !40
  %40 = fmul float %39, %2
  %41 = fadd float %36, %40
  %42 = or i64 %30, 2
  %43 = getelementptr inbounds float, ptr %0, i64 %42
  %44 = load float, ptr %43, align 4, !tbaa !40
  %45 = fmul float %44, %2
  %46 = fadd float %41, %45
  %47 = or i64 %30, 3
  %48 = getelementptr inbounds float, ptr %0, i64 %47
  %49 = load float, ptr %48, align 4, !tbaa !40
  %50 = fmul float %49, %2
  %51 = fadd float %46, %50
  %52 = add nuw nsw i64 %30, 4
  %53 = add i64 %32, 4
  %54 = icmp eq i64 %53, %16
  br i1 %54, label %55, label %29, !llvm.loop !506

55:                                               ; preds = %29, %18
  %56 = phi float [ undef, %18 ], [ %51, %29 ]
  %57 = phi i64 [ 0, %18 ], [ %52, %29 ]
  %58 = phi float [ 0.000000e+00, %18 ], [ %51, %29 ]
  br i1 %17, label %70, label %59

59:                                               ; preds = %55, %59
  %60 = phi i64 [ %67, %59 ], [ %57, %55 ]
  %61 = phi float [ %66, %59 ], [ %58, %55 ]
  %62 = phi i64 [ %68, %59 ], [ 0, %55 ]
  %63 = getelementptr inbounds float, ptr %0, i64 %60
  %64 = load float, ptr %63, align 4, !tbaa !40
  %65 = fmul float %64, %2
  %66 = fadd float %61, %65
  %67 = add nuw nsw i64 %60, 1
  %68 = add i64 %62, 1
  %69 = icmp eq i64 %68, %14
  br i1 %69, label %70, label %59, !llvm.loop !507

70:                                               ; preds = %59, %55
  %71 = phi float [ %56, %55 ], [ %66, %59 ]
  %72 = load double, ptr @init_value, align 8, !tbaa !28
  %73 = fptrunc double %72 to float
  %74 = fmul float %73, %2
  %75 = fmul float %74, 8.000000e+03
  %76 = fsub float %71, %75
  %77 = tail call float @llvm.fabs.f32(float %71)
  %78 = fpext float %77 to double
  %79 = fcmp ogt double %78, 1.000000e-04
  %80 = select i1 %79, float %71, float 1.000000e+00
  %81 = fdiv float %76, %80
  %82 = tail call float @llvm.fabs.f32(float %81)
  %83 = fpext float %82 to double
  %84 = fcmp olt double %83, 1.000000e-03
  br i1 %84, label %25, label %21

85:                                               ; preds = %10, %101
  %86 = phi i32 [ %102, %101 ], [ %6, %10 ]
  %87 = phi double [ %103, %101 ], [ %11, %10 ]
  %88 = phi i32 [ %104, %101 ], [ 0, %10 ]
  %89 = fptrunc double %87 to float
  %90 = fmul float %89, %2
  %91 = fmul float %90, 8.000000e+03
  %92 = fsub float 0.000000e+00, %91
  %93 = tail call float @llvm.fabs.f32(float %92)
  %94 = fpext float %93 to double
  %95 = fcmp olt double %94, 1.000000e-03
  br i1 %95, label %101, label %96

96:                                               ; preds = %85
  %97 = load i32, ptr @current_test, align 4, !tbaa !9
  %98 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %97)
  %99 = load double, ptr @init_value, align 8, !tbaa !28
  %100 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %101

101:                                              ; preds = %85, %96
  %102 = phi i32 [ %86, %85 ], [ %100, %96 ]
  %103 = phi double [ %87, %85 ], [ %99, %96 ]
  %104 = add nuw nsw i32 %88, 1
  %105 = icmp slt i32 %104, %102
  br i1 %105, label %85, label %106, !llvm.loop !505

106:                                              ; preds = %101, %25, %4
  %107 = tail call i64 @clock() #17
  store i64 %107, ptr @end_time, align 8, !tbaa !26
  %108 = load i64, ptr @start_time, align 8, !tbaa !26
  %109 = load ptr, ptr @results, align 8, !tbaa !5
  %110 = icmp eq ptr %109, null
  br i1 %110, label %111, label %113

111:                                              ; preds = %106
  %112 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %117

113:                                              ; preds = %106
  %114 = load i32, ptr @current_test, align 4, !tbaa !9
  %115 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %116 = icmp slt i32 %114, %115
  br i1 %116, label %129, label %117

117:                                              ; preds = %113, %111
  %118 = phi i32 [ %112, %111 ], [ %115, %113 ]
  %119 = add nsw i32 %118, 10
  store i32 %119, ptr @allocated_results, align 4, !tbaa !9
  %120 = sext i32 %119 to i64
  %121 = shl nsw i64 %120, 4
  %122 = tail call ptr @realloc(ptr noundef %109, i64 noundef %121) #14
  store ptr %122, ptr @results, align 8, !tbaa !5
  %123 = icmp eq ptr %122, null
  br i1 %123, label %126, label %124

124:                                              ; preds = %117
  %125 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %129

126:                                              ; preds = %117
  %127 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %128 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %127)
  tail call void @exit(i32 noundef -1) #15
  unreachable

129:                                              ; preds = %113, %124
  %130 = phi i32 [ %125, %124 ], [ %114, %113 ]
  %131 = phi ptr [ %122, %124 ], [ %109, %113 ]
  %132 = sub nsw i64 %107, %108
  %133 = sitofp i64 %132 to double
  %134 = fdiv double %133, 1.000000e+06
  %135 = sext i32 %130 to i64
  %136 = getelementptr inbounds %struct.one_result, ptr %131, i64 %135
  store double %134, ptr %136, align 8, !tbaa !11
  %137 = getelementptr inbounds %struct.one_result, ptr %131, i64 %135, i32 1
  store ptr %3, ptr %137, align 8, !tbaa !14
  %138 = add nsw i32 %130, 1
  store i32 %138, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4If33custom_multiply_multiple_variableIfEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, float noundef %2, float noundef %3, float noundef %4, float noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !26
  %9 = load i32, ptr @iterations, align 4, !tbaa !9
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %108

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  br i1 %12, label %15, label %13

13:                                               ; preds = %11
  %14 = load double, ptr @init_value, align 8, !tbaa !28
  br label %84

15:                                               ; preds = %11
  %16 = zext i32 %1 to i64
  %17 = and i64 %16, 1
  %18 = icmp eq i32 %1, 1
  %19 = and i64 %16, 4294967294
  %20 = icmp eq i64 %17, 0
  br label %21

21:                                               ; preds = %15, %28
  %22 = phi i32 [ %29, %28 ], [ %9, %15 ]
  %23 = phi i32 [ %30, %28 ], [ 0, %15 ]
  br i1 %18, label %54, label %32

24:                                               ; preds = %66
  %25 = load i32, ptr @current_test, align 4, !tbaa !9
  %26 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %25)
  %27 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %28

28:                                               ; preds = %24, %66
  %29 = phi i32 [ %27, %24 ], [ %22, %66 ]
  %30 = add nuw nsw i32 %23, 1
  %31 = icmp slt i32 %30, %29
  br i1 %31, label %21, label %108, !llvm.loop !508

32:                                               ; preds = %21, %32
  %33 = phi i64 [ %51, %32 ], [ 0, %21 ]
  %34 = phi float [ %50, %32 ], [ 0.000000e+00, %21 ]
  %35 = phi i64 [ %52, %32 ], [ 0, %21 ]
  %36 = getelementptr inbounds float, ptr %0, i64 %33
  %37 = load float, ptr %36, align 4, !tbaa !40
  %38 = fmul float %37, %2
  %39 = fmul float %38, %3
  %40 = fmul float %39, %4
  %41 = fmul float %40, %5
  %42 = fadd float %34, %41
  %43 = or i64 %33, 1
  %44 = getelementptr inbounds float, ptr %0, i64 %43
  %45 = load float, ptr %44, align 4, !tbaa !40
  %46 = fmul float %45, %2
  %47 = fmul float %46, %3
  %48 = fmul float %47, %4
  %49 = fmul float %48, %5
  %50 = fadd float %42, %49
  %51 = add nuw nsw i64 %33, 2
  %52 = add i64 %35, 2
  %53 = icmp eq i64 %52, %19
  br i1 %53, label %54, label %32, !llvm.loop !509

54:                                               ; preds = %32, %21
  %55 = phi float [ undef, %21 ], [ %50, %32 ]
  %56 = phi i64 [ 0, %21 ], [ %51, %32 ]
  %57 = phi float [ 0.000000e+00, %21 ], [ %50, %32 ]
  br i1 %20, label %66, label %58

58:                                               ; preds = %54
  %59 = getelementptr inbounds float, ptr %0, i64 %56
  %60 = load float, ptr %59, align 4, !tbaa !40
  %61 = fmul float %60, %2
  %62 = fmul float %61, %3
  %63 = fmul float %62, %4
  %64 = fmul float %63, %5
  %65 = fadd float %57, %64
  br label %66

66:                                               ; preds = %54, %58
  %67 = phi float [ %55, %54 ], [ %65, %58 ]
  %68 = load double, ptr @init_value, align 8, !tbaa !28
  %69 = fptrunc double %68 to float
  %70 = fmul float %69, %2
  %71 = fmul float %70, %3
  %72 = fmul float %71, %4
  %73 = fmul float %72, %5
  %74 = fmul float %73, 8.000000e+03
  %75 = fsub float %67, %74
  %76 = tail call float @llvm.fabs.f32(float %67)
  %77 = fpext float %76 to double
  %78 = fcmp ogt double %77, 1.000000e-04
  %79 = select i1 %78, float %67, float 1.000000e+00
  %80 = fdiv float %75, %79
  %81 = tail call float @llvm.fabs.f32(float %80)
  %82 = fpext float %81 to double
  %83 = fcmp olt double %82, 1.000000e-03
  br i1 %83, label %28, label %24

84:                                               ; preds = %13, %103
  %85 = phi i32 [ %104, %103 ], [ %9, %13 ]
  %86 = phi double [ %105, %103 ], [ %14, %13 ]
  %87 = phi i32 [ %106, %103 ], [ 0, %13 ]
  %88 = fptrunc double %86 to float
  %89 = fmul float %88, %2
  %90 = fmul float %89, %3
  %91 = fmul float %90, %4
  %92 = fmul float %91, %5
  %93 = fmul float %92, 8.000000e+03
  %94 = fsub float 0.000000e+00, %93
  %95 = tail call float @llvm.fabs.f32(float %94)
  %96 = fpext float %95 to double
  %97 = fcmp olt double %96, 1.000000e-03
  br i1 %97, label %103, label %98

98:                                               ; preds = %84
  %99 = load i32, ptr @current_test, align 4, !tbaa !9
  %100 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %99)
  %101 = load double, ptr @init_value, align 8, !tbaa !28
  %102 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %103

103:                                              ; preds = %84, %98
  %104 = phi i32 [ %85, %84 ], [ %102, %98 ]
  %105 = phi double [ %86, %84 ], [ %101, %98 ]
  %106 = add nuw nsw i32 %87, 1
  %107 = icmp slt i32 %106, %104
  br i1 %107, label %84, label %108, !llvm.loop !508

108:                                              ; preds = %103, %28, %7
  %109 = tail call i64 @clock() #17
  store i64 %109, ptr @end_time, align 8, !tbaa !26
  %110 = load i64, ptr @start_time, align 8, !tbaa !26
  %111 = load ptr, ptr @results, align 8, !tbaa !5
  %112 = icmp eq ptr %111, null
  br i1 %112, label %113, label %115

113:                                              ; preds = %108
  %114 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %119

115:                                              ; preds = %108
  %116 = load i32, ptr @current_test, align 4, !tbaa !9
  %117 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %118 = icmp slt i32 %116, %117
  br i1 %118, label %131, label %119

119:                                              ; preds = %115, %113
  %120 = phi i32 [ %114, %113 ], [ %117, %115 ]
  %121 = add nsw i32 %120, 10
  store i32 %121, ptr @allocated_results, align 4, !tbaa !9
  %122 = sext i32 %121 to i64
  %123 = shl nsw i64 %122, 4
  %124 = tail call ptr @realloc(ptr noundef %111, i64 noundef %123) #14
  store ptr %124, ptr @results, align 8, !tbaa !5
  %125 = icmp eq ptr %124, null
  br i1 %125, label %128, label %126

126:                                              ; preds = %119
  %127 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %131

128:                                              ; preds = %119
  %129 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %130 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %129)
  tail call void @exit(i32 noundef -1) #15
  unreachable

131:                                              ; preds = %115, %126
  %132 = phi i32 [ %127, %126 ], [ %116, %115 ]
  %133 = phi ptr [ %124, %126 ], [ %111, %115 ]
  %134 = sub nsw i64 %109, %110
  %135 = sitofp i64 %134 to double
  %136 = fdiv double %135, 1.000000e+06
  %137 = sext i32 %132 to i64
  %138 = getelementptr inbounds %struct.one_result, ptr %133, i64 %137
  store double %136, ptr %138, align 8, !tbaa !11
  %139 = getelementptr inbounds %struct.one_result, ptr %133, i64 %137, i32 1
  store ptr %6, ptr %139, align 8, !tbaa !14
  %140 = add nsw i32 %132, 1
  store i32 %140, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4If34custom_multiply_multiple_variable2IfEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, float noundef %2, float noundef %3, float noundef %4, float noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !26
  %9 = load i32, ptr @iterations, align 4, !tbaa !9
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %111

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  %13 = fmul float %2, %3
  %14 = fmul float %13, %4
  br i1 %12, label %17, label %15

15:                                               ; preds = %11
  %16 = load double, ptr @init_value, align 8, !tbaa !28
  br label %90

17:                                               ; preds = %11
  %18 = zext i32 %1 to i64
  %19 = and i64 %18, 3
  %20 = icmp ult i32 %1, 4
  %21 = and i64 %18, 4294967292
  %22 = icmp eq i64 %19, 0
  br label %23

23:                                               ; preds = %17, %30
  %24 = phi i32 [ %31, %30 ], [ %9, %17 ]
  %25 = phi i32 [ %32, %30 ], [ 0, %17 ]
  br i1 %20, label %60, label %34

26:                                               ; preds = %75
  %27 = load i32, ptr @current_test, align 4, !tbaa !9
  %28 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %27)
  %29 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %30

30:                                               ; preds = %26, %75
  %31 = phi i32 [ %29, %26 ], [ %24, %75 ]
  %32 = add nuw nsw i32 %25, 1
  %33 = icmp slt i32 %32, %31
  br i1 %33, label %23, label %111, !llvm.loop !510

34:                                               ; preds = %23, %34
  %35 = phi i64 [ %57, %34 ], [ 0, %23 ]
  %36 = phi float [ %56, %34 ], [ 0.000000e+00, %23 ]
  %37 = phi i64 [ %58, %34 ], [ 0, %23 ]
  %38 = getelementptr inbounds float, ptr %0, i64 %35
  %39 = load float, ptr %38, align 4, !tbaa !40
  %40 = tail call float @llvm.fmuladd.f32(float %14, float %5, float %39)
  %41 = fadd float %36, %40
  %42 = or i64 %35, 1
  %43 = getelementptr inbounds float, ptr %0, i64 %42
  %44 = load float, ptr %43, align 4, !tbaa !40
  %45 = tail call float @llvm.fmuladd.f32(float %14, float %5, float %44)
  %46 = fadd float %41, %45
  %47 = or i64 %35, 2
  %48 = getelementptr inbounds float, ptr %0, i64 %47
  %49 = load float, ptr %48, align 4, !tbaa !40
  %50 = tail call float @llvm.fmuladd.f32(float %14, float %5, float %49)
  %51 = fadd float %46, %50
  %52 = or i64 %35, 3
  %53 = getelementptr inbounds float, ptr %0, i64 %52
  %54 = load float, ptr %53, align 4, !tbaa !40
  %55 = tail call float @llvm.fmuladd.f32(float %14, float %5, float %54)
  %56 = fadd float %51, %55
  %57 = add nuw nsw i64 %35, 4
  %58 = add i64 %37, 4
  %59 = icmp eq i64 %58, %21
  br i1 %59, label %60, label %34, !llvm.loop !511

60:                                               ; preds = %34, %23
  %61 = phi float [ undef, %23 ], [ %56, %34 ]
  %62 = phi i64 [ 0, %23 ], [ %57, %34 ]
  %63 = phi float [ 0.000000e+00, %23 ], [ %56, %34 ]
  br i1 %22, label %75, label %64

64:                                               ; preds = %60, %64
  %65 = phi i64 [ %72, %64 ], [ %62, %60 ]
  %66 = phi float [ %71, %64 ], [ %63, %60 ]
  %67 = phi i64 [ %73, %64 ], [ 0, %60 ]
  %68 = getelementptr inbounds float, ptr %0, i64 %65
  %69 = load float, ptr %68, align 4, !tbaa !40
  %70 = tail call float @llvm.fmuladd.f32(float %14, float %5, float %69)
  %71 = fadd float %66, %70
  %72 = add nuw nsw i64 %65, 1
  %73 = add i64 %67, 1
  %74 = icmp eq i64 %73, %19
  br i1 %74, label %75, label %64, !llvm.loop !512

75:                                               ; preds = %64, %60
  %76 = phi float [ %61, %60 ], [ %71, %64 ]
  %77 = load double, ptr @init_value, align 8, !tbaa !28
  %78 = fptrunc double %77 to float
  %79 = tail call float @llvm.fmuladd.f32(float %14, float %5, float %78)
  %80 = fmul float %79, 8.000000e+03
  %81 = fsub float %76, %80
  %82 = tail call float @llvm.fabs.f32(float %76)
  %83 = fpext float %82 to double
  %84 = fcmp ogt double %83, 1.000000e-04
  %85 = select i1 %84, float %76, float 1.000000e+00
  %86 = fdiv float %81, %85
  %87 = tail call float @llvm.fabs.f32(float %86)
  %88 = fpext float %87 to double
  %89 = fcmp olt double %88, 1.000000e-03
  br i1 %89, label %30, label %26

90:                                               ; preds = %15, %106
  %91 = phi i32 [ %107, %106 ], [ %9, %15 ]
  %92 = phi double [ %108, %106 ], [ %16, %15 ]
  %93 = phi i32 [ %109, %106 ], [ 0, %15 ]
  %94 = fptrunc double %92 to float
  %95 = tail call float @llvm.fmuladd.f32(float %14, float %5, float %94)
  %96 = fmul float %95, 8.000000e+03
  %97 = fsub float 0.000000e+00, %96
  %98 = tail call float @llvm.fabs.f32(float %97)
  %99 = fpext float %98 to double
  %100 = fcmp olt double %99, 1.000000e-03
  br i1 %100, label %106, label %101

101:                                              ; preds = %90
  %102 = load i32, ptr @current_test, align 4, !tbaa !9
  %103 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %102)
  %104 = load double, ptr @init_value, align 8, !tbaa !28
  %105 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %106

106:                                              ; preds = %90, %101
  %107 = phi i32 [ %91, %90 ], [ %105, %101 ]
  %108 = phi double [ %92, %90 ], [ %104, %101 ]
  %109 = add nuw nsw i32 %93, 1
  %110 = icmp slt i32 %109, %107
  br i1 %110, label %90, label %111, !llvm.loop !510

111:                                              ; preds = %106, %30, %7
  %112 = tail call i64 @clock() #17
  store i64 %112, ptr @end_time, align 8, !tbaa !26
  %113 = load i64, ptr @start_time, align 8, !tbaa !26
  %114 = load ptr, ptr @results, align 8, !tbaa !5
  %115 = icmp eq ptr %114, null
  br i1 %115, label %116, label %118

116:                                              ; preds = %111
  %117 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %122

118:                                              ; preds = %111
  %119 = load i32, ptr @current_test, align 4, !tbaa !9
  %120 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %121 = icmp slt i32 %119, %120
  br i1 %121, label %134, label %122

122:                                              ; preds = %118, %116
  %123 = phi i32 [ %117, %116 ], [ %120, %118 ]
  %124 = add nsw i32 %123, 10
  store i32 %124, ptr @allocated_results, align 4, !tbaa !9
  %125 = sext i32 %124 to i64
  %126 = shl nsw i64 %125, 4
  %127 = tail call ptr @realloc(ptr noundef %114, i64 noundef %126) #14
  store ptr %127, ptr @results, align 8, !tbaa !5
  %128 = icmp eq ptr %127, null
  br i1 %128, label %131, label %129

129:                                              ; preds = %122
  %130 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %134

131:                                              ; preds = %122
  %132 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %133 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %132)
  tail call void @exit(i32 noundef -1) #15
  unreachable

134:                                              ; preds = %118, %129
  %135 = phi i32 [ %130, %129 ], [ %119, %118 ]
  %136 = phi ptr [ %127, %129 ], [ %114, %118 ]
  %137 = sub nsw i64 %112, %113
  %138 = sitofp i64 %137 to double
  %139 = fdiv double %138, 1.000000e+06
  %140 = sext i32 %135 to i64
  %141 = getelementptr inbounds %struct.one_result, ptr %136, i64 %140
  store double %139, ptr %141, align 8, !tbaa !11
  %142 = getelementptr inbounds %struct.one_result, ptr %136, i64 %140, i32 1
  store ptr %6, ptr %142, align 8, !tbaa !14
  %143 = add nsw i32 %135, 1
  store i32 %143, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1If22custom_divide_variableIfEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, float noundef %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !26
  %6 = load i32, ptr @iterations, align 4, !tbaa !9
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %106

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  br i1 %9, label %12, label %10

10:                                               ; preds = %8
  %11 = load double, ptr @init_value, align 8, !tbaa !28
  br label %85

12:                                               ; preds = %8
  %13 = zext i32 %1 to i64
  %14 = and i64 %13, 3
  %15 = icmp ult i32 %1, 4
  %16 = and i64 %13, 4294967292
  %17 = icmp eq i64 %14, 0
  br label %18

18:                                               ; preds = %12, %25
  %19 = phi i32 [ %26, %25 ], [ %6, %12 ]
  %20 = phi i32 [ %27, %25 ], [ 0, %12 ]
  br i1 %15, label %55, label %29

21:                                               ; preds = %70
  %22 = load i32, ptr @current_test, align 4, !tbaa !9
  %23 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %22)
  %24 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %25

25:                                               ; preds = %21, %70
  %26 = phi i32 [ %24, %21 ], [ %19, %70 ]
  %27 = add nuw nsw i32 %20, 1
  %28 = icmp slt i32 %27, %26
  br i1 %28, label %18, label %106, !llvm.loop !513

29:                                               ; preds = %18, %29
  %30 = phi i64 [ %52, %29 ], [ 0, %18 ]
  %31 = phi float [ %51, %29 ], [ 0.000000e+00, %18 ]
  %32 = phi i64 [ %53, %29 ], [ 0, %18 ]
  %33 = getelementptr inbounds float, ptr %0, i64 %30
  %34 = load float, ptr %33, align 4, !tbaa !40
  %35 = fdiv float %34, %2
  %36 = fadd float %31, %35
  %37 = or i64 %30, 1
  %38 = getelementptr inbounds float, ptr %0, i64 %37
  %39 = load float, ptr %38, align 4, !tbaa !40
  %40 = fdiv float %39, %2
  %41 = fadd float %36, %40
  %42 = or i64 %30, 2
  %43 = getelementptr inbounds float, ptr %0, i64 %42
  %44 = load float, ptr %43, align 4, !tbaa !40
  %45 = fdiv float %44, %2
  %46 = fadd float %41, %45
  %47 = or i64 %30, 3
  %48 = getelementptr inbounds float, ptr %0, i64 %47
  %49 = load float, ptr %48, align 4, !tbaa !40
  %50 = fdiv float %49, %2
  %51 = fadd float %46, %50
  %52 = add nuw nsw i64 %30, 4
  %53 = add i64 %32, 4
  %54 = icmp eq i64 %53, %16
  br i1 %54, label %55, label %29, !llvm.loop !514

55:                                               ; preds = %29, %18
  %56 = phi float [ undef, %18 ], [ %51, %29 ]
  %57 = phi i64 [ 0, %18 ], [ %52, %29 ]
  %58 = phi float [ 0.000000e+00, %18 ], [ %51, %29 ]
  br i1 %17, label %70, label %59

59:                                               ; preds = %55, %59
  %60 = phi i64 [ %67, %59 ], [ %57, %55 ]
  %61 = phi float [ %66, %59 ], [ %58, %55 ]
  %62 = phi i64 [ %68, %59 ], [ 0, %55 ]
  %63 = getelementptr inbounds float, ptr %0, i64 %60
  %64 = load float, ptr %63, align 4, !tbaa !40
  %65 = fdiv float %64, %2
  %66 = fadd float %61, %65
  %67 = add nuw nsw i64 %60, 1
  %68 = add i64 %62, 1
  %69 = icmp eq i64 %68, %14
  br i1 %69, label %70, label %59, !llvm.loop !515

70:                                               ; preds = %59, %55
  %71 = phi float [ %56, %55 ], [ %66, %59 ]
  %72 = load double, ptr @init_value, align 8, !tbaa !28
  %73 = fptrunc double %72 to float
  %74 = fdiv float %73, %2
  %75 = fmul float %74, 8.000000e+03
  %76 = fsub float %71, %75
  %77 = tail call float @llvm.fabs.f32(float %71)
  %78 = fpext float %77 to double
  %79 = fcmp ogt double %78, 1.000000e-04
  %80 = select i1 %79, float %71, float 1.000000e+00
  %81 = fdiv float %76, %80
  %82 = tail call float @llvm.fabs.f32(float %81)
  %83 = fpext float %82 to double
  %84 = fcmp olt double %83, 1.000000e-03
  br i1 %84, label %25, label %21

85:                                               ; preds = %10, %101
  %86 = phi i32 [ %102, %101 ], [ %6, %10 ]
  %87 = phi double [ %103, %101 ], [ %11, %10 ]
  %88 = phi i32 [ %104, %101 ], [ 0, %10 ]
  %89 = fptrunc double %87 to float
  %90 = fdiv float %89, %2
  %91 = fmul float %90, 8.000000e+03
  %92 = fsub float 0.000000e+00, %91
  %93 = tail call float @llvm.fabs.f32(float %92)
  %94 = fpext float %93 to double
  %95 = fcmp olt double %94, 1.000000e-03
  br i1 %95, label %101, label %96

96:                                               ; preds = %85
  %97 = load i32, ptr @current_test, align 4, !tbaa !9
  %98 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %97)
  %99 = load double, ptr @init_value, align 8, !tbaa !28
  %100 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %101

101:                                              ; preds = %85, %96
  %102 = phi i32 [ %86, %85 ], [ %100, %96 ]
  %103 = phi double [ %87, %85 ], [ %99, %96 ]
  %104 = add nuw nsw i32 %88, 1
  %105 = icmp slt i32 %104, %102
  br i1 %105, label %85, label %106, !llvm.loop !513

106:                                              ; preds = %101, %25, %4
  %107 = tail call i64 @clock() #17
  store i64 %107, ptr @end_time, align 8, !tbaa !26
  %108 = load i64, ptr @start_time, align 8, !tbaa !26
  %109 = load ptr, ptr @results, align 8, !tbaa !5
  %110 = icmp eq ptr %109, null
  br i1 %110, label %111, label %113

111:                                              ; preds = %106
  %112 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %117

113:                                              ; preds = %106
  %114 = load i32, ptr @current_test, align 4, !tbaa !9
  %115 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %116 = icmp slt i32 %114, %115
  br i1 %116, label %129, label %117

117:                                              ; preds = %113, %111
  %118 = phi i32 [ %112, %111 ], [ %115, %113 ]
  %119 = add nsw i32 %118, 10
  store i32 %119, ptr @allocated_results, align 4, !tbaa !9
  %120 = sext i32 %119 to i64
  %121 = shl nsw i64 %120, 4
  %122 = tail call ptr @realloc(ptr noundef %109, i64 noundef %121) #14
  store ptr %122, ptr @results, align 8, !tbaa !5
  %123 = icmp eq ptr %122, null
  br i1 %123, label %126, label %124

124:                                              ; preds = %117
  %125 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %129

126:                                              ; preds = %117
  %127 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %128 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %127)
  tail call void @exit(i32 noundef -1) #15
  unreachable

129:                                              ; preds = %113, %124
  %130 = phi i32 [ %125, %124 ], [ %114, %113 ]
  %131 = phi ptr [ %122, %124 ], [ %109, %113 ]
  %132 = sub nsw i64 %107, %108
  %133 = sitofp i64 %132 to double
  %134 = fdiv double %133, 1.000000e+06
  %135 = sext i32 %130 to i64
  %136 = getelementptr inbounds %struct.one_result, ptr %131, i64 %135
  store double %134, ptr %136, align 8, !tbaa !11
  %137 = getelementptr inbounds %struct.one_result, ptr %131, i64 %135, i32 1
  store ptr %3, ptr %137, align 8, !tbaa !14
  %138 = add nsw i32 %130, 1
  store i32 %138, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4If31custom_divide_multiple_variableIfEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, float noundef %2, float noundef %3, float noundef %4, float noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !26
  %9 = load i32, ptr @iterations, align 4, !tbaa !9
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %108

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  br i1 %12, label %15, label %13

13:                                               ; preds = %11
  %14 = load double, ptr @init_value, align 8, !tbaa !28
  br label %84

15:                                               ; preds = %11
  %16 = zext i32 %1 to i64
  %17 = and i64 %16, 1
  %18 = icmp eq i32 %1, 1
  %19 = and i64 %16, 4294967294
  %20 = icmp eq i64 %17, 0
  br label %21

21:                                               ; preds = %15, %28
  %22 = phi i32 [ %29, %28 ], [ %9, %15 ]
  %23 = phi i32 [ %30, %28 ], [ 0, %15 ]
  br i1 %18, label %54, label %32

24:                                               ; preds = %66
  %25 = load i32, ptr @current_test, align 4, !tbaa !9
  %26 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %25)
  %27 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %28

28:                                               ; preds = %24, %66
  %29 = phi i32 [ %27, %24 ], [ %22, %66 ]
  %30 = add nuw nsw i32 %23, 1
  %31 = icmp slt i32 %30, %29
  br i1 %31, label %21, label %108, !llvm.loop !516

32:                                               ; preds = %21, %32
  %33 = phi i64 [ %51, %32 ], [ 0, %21 ]
  %34 = phi float [ %50, %32 ], [ 0.000000e+00, %21 ]
  %35 = phi i64 [ %52, %32 ], [ 0, %21 ]
  %36 = getelementptr inbounds float, ptr %0, i64 %33
  %37 = load float, ptr %36, align 4, !tbaa !40
  %38 = fdiv float %37, %2
  %39 = fdiv float %38, %3
  %40 = fdiv float %39, %4
  %41 = fdiv float %40, %5
  %42 = fadd float %34, %41
  %43 = or i64 %33, 1
  %44 = getelementptr inbounds float, ptr %0, i64 %43
  %45 = load float, ptr %44, align 4, !tbaa !40
  %46 = fdiv float %45, %2
  %47 = fdiv float %46, %3
  %48 = fdiv float %47, %4
  %49 = fdiv float %48, %5
  %50 = fadd float %42, %49
  %51 = add nuw nsw i64 %33, 2
  %52 = add i64 %35, 2
  %53 = icmp eq i64 %52, %19
  br i1 %53, label %54, label %32, !llvm.loop !517

54:                                               ; preds = %32, %21
  %55 = phi float [ undef, %21 ], [ %50, %32 ]
  %56 = phi i64 [ 0, %21 ], [ %51, %32 ]
  %57 = phi float [ 0.000000e+00, %21 ], [ %50, %32 ]
  br i1 %20, label %66, label %58

58:                                               ; preds = %54
  %59 = getelementptr inbounds float, ptr %0, i64 %56
  %60 = load float, ptr %59, align 4, !tbaa !40
  %61 = fdiv float %60, %2
  %62 = fdiv float %61, %3
  %63 = fdiv float %62, %4
  %64 = fdiv float %63, %5
  %65 = fadd float %57, %64
  br label %66

66:                                               ; preds = %54, %58
  %67 = phi float [ %55, %54 ], [ %65, %58 ]
  %68 = load double, ptr @init_value, align 8, !tbaa !28
  %69 = fptrunc double %68 to float
  %70 = fdiv float %69, %2
  %71 = fdiv float %70, %3
  %72 = fdiv float %71, %4
  %73 = fdiv float %72, %5
  %74 = fmul float %73, 8.000000e+03
  %75 = fsub float %67, %74
  %76 = tail call float @llvm.fabs.f32(float %67)
  %77 = fpext float %76 to double
  %78 = fcmp ogt double %77, 1.000000e-04
  %79 = select i1 %78, float %67, float 1.000000e+00
  %80 = fdiv float %75, %79
  %81 = tail call float @llvm.fabs.f32(float %80)
  %82 = fpext float %81 to double
  %83 = fcmp olt double %82, 1.000000e-03
  br i1 %83, label %28, label %24

84:                                               ; preds = %13, %103
  %85 = phi i32 [ %104, %103 ], [ %9, %13 ]
  %86 = phi double [ %105, %103 ], [ %14, %13 ]
  %87 = phi i32 [ %106, %103 ], [ 0, %13 ]
  %88 = fptrunc double %86 to float
  %89 = fdiv float %88, %2
  %90 = fdiv float %89, %3
  %91 = fdiv float %90, %4
  %92 = fdiv float %91, %5
  %93 = fmul float %92, 8.000000e+03
  %94 = fsub float 0.000000e+00, %93
  %95 = tail call float @llvm.fabs.f32(float %94)
  %96 = fpext float %95 to double
  %97 = fcmp olt double %96, 1.000000e-03
  br i1 %97, label %103, label %98

98:                                               ; preds = %84
  %99 = load i32, ptr @current_test, align 4, !tbaa !9
  %100 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %99)
  %101 = load double, ptr @init_value, align 8, !tbaa !28
  %102 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %103

103:                                              ; preds = %84, %98
  %104 = phi i32 [ %85, %84 ], [ %102, %98 ]
  %105 = phi double [ %86, %84 ], [ %101, %98 ]
  %106 = add nuw nsw i32 %87, 1
  %107 = icmp slt i32 %106, %104
  br i1 %107, label %84, label %108, !llvm.loop !516

108:                                              ; preds = %103, %28, %7
  %109 = tail call i64 @clock() #17
  store i64 %109, ptr @end_time, align 8, !tbaa !26
  %110 = load i64, ptr @start_time, align 8, !tbaa !26
  %111 = load ptr, ptr @results, align 8, !tbaa !5
  %112 = icmp eq ptr %111, null
  br i1 %112, label %113, label %115

113:                                              ; preds = %108
  %114 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %119

115:                                              ; preds = %108
  %116 = load i32, ptr @current_test, align 4, !tbaa !9
  %117 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %118 = icmp slt i32 %116, %117
  br i1 %118, label %131, label %119

119:                                              ; preds = %115, %113
  %120 = phi i32 [ %114, %113 ], [ %117, %115 ]
  %121 = add nsw i32 %120, 10
  store i32 %121, ptr @allocated_results, align 4, !tbaa !9
  %122 = sext i32 %121 to i64
  %123 = shl nsw i64 %122, 4
  %124 = tail call ptr @realloc(ptr noundef %111, i64 noundef %123) #14
  store ptr %124, ptr @results, align 8, !tbaa !5
  %125 = icmp eq ptr %124, null
  br i1 %125, label %128, label %126

126:                                              ; preds = %119
  %127 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %131

128:                                              ; preds = %119
  %129 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %130 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %129)
  tail call void @exit(i32 noundef -1) #15
  unreachable

131:                                              ; preds = %115, %126
  %132 = phi i32 [ %127, %126 ], [ %116, %115 ]
  %133 = phi ptr [ %124, %126 ], [ %111, %115 ]
  %134 = sub nsw i64 %109, %110
  %135 = sitofp i64 %134 to double
  %136 = fdiv double %135, 1.000000e+06
  %137 = sext i32 %132 to i64
  %138 = getelementptr inbounds %struct.one_result, ptr %133, i64 %137
  store double %136, ptr %138, align 8, !tbaa !11
  %139 = getelementptr inbounds %struct.one_result, ptr %133, i64 %137, i32 1
  store ptr %6, ptr %139, align 8, !tbaa !14
  %140 = add nsw i32 %132, 1
  store i32 %140, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4If32custom_divide_multiple_variable2IfEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, float noundef %2, float noundef %3, float noundef %4, float noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !26
  %9 = load i32, ptr @iterations, align 4, !tbaa !9
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %112

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  %13 = fdiv float %2, %3
  %14 = fdiv float %13, %4
  %15 = fdiv float %14, %5
  br i1 %12, label %18, label %16

16:                                               ; preds = %11
  %17 = load double, ptr @init_value, align 8, !tbaa !28
  br label %91

18:                                               ; preds = %11
  %19 = zext i32 %1 to i64
  %20 = and i64 %19, 3
  %21 = icmp ult i32 %1, 4
  %22 = and i64 %19, 4294967292
  %23 = icmp eq i64 %20, 0
  br label %24

24:                                               ; preds = %18, %31
  %25 = phi i32 [ %32, %31 ], [ %9, %18 ]
  %26 = phi i32 [ %33, %31 ], [ 0, %18 ]
  br i1 %21, label %61, label %35

27:                                               ; preds = %76
  %28 = load i32, ptr @current_test, align 4, !tbaa !9
  %29 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %28)
  %30 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %31

31:                                               ; preds = %27, %76
  %32 = phi i32 [ %30, %27 ], [ %25, %76 ]
  %33 = add nuw nsw i32 %26, 1
  %34 = icmp slt i32 %33, %32
  br i1 %34, label %24, label %112, !llvm.loop !518

35:                                               ; preds = %24, %35
  %36 = phi i64 [ %58, %35 ], [ 0, %24 ]
  %37 = phi float [ %57, %35 ], [ 0.000000e+00, %24 ]
  %38 = phi i64 [ %59, %35 ], [ 0, %24 ]
  %39 = getelementptr inbounds float, ptr %0, i64 %36
  %40 = load float, ptr %39, align 4, !tbaa !40
  %41 = fadd float %15, %40
  %42 = fadd float %37, %41
  %43 = or i64 %36, 1
  %44 = getelementptr inbounds float, ptr %0, i64 %43
  %45 = load float, ptr %44, align 4, !tbaa !40
  %46 = fadd float %15, %45
  %47 = fadd float %42, %46
  %48 = or i64 %36, 2
  %49 = getelementptr inbounds float, ptr %0, i64 %48
  %50 = load float, ptr %49, align 4, !tbaa !40
  %51 = fadd float %15, %50
  %52 = fadd float %47, %51
  %53 = or i64 %36, 3
  %54 = getelementptr inbounds float, ptr %0, i64 %53
  %55 = load float, ptr %54, align 4, !tbaa !40
  %56 = fadd float %15, %55
  %57 = fadd float %52, %56
  %58 = add nuw nsw i64 %36, 4
  %59 = add i64 %38, 4
  %60 = icmp eq i64 %59, %22
  br i1 %60, label %61, label %35, !llvm.loop !519

61:                                               ; preds = %35, %24
  %62 = phi float [ undef, %24 ], [ %57, %35 ]
  %63 = phi i64 [ 0, %24 ], [ %58, %35 ]
  %64 = phi float [ 0.000000e+00, %24 ], [ %57, %35 ]
  br i1 %23, label %76, label %65

65:                                               ; preds = %61, %65
  %66 = phi i64 [ %73, %65 ], [ %63, %61 ]
  %67 = phi float [ %72, %65 ], [ %64, %61 ]
  %68 = phi i64 [ %74, %65 ], [ 0, %61 ]
  %69 = getelementptr inbounds float, ptr %0, i64 %66
  %70 = load float, ptr %69, align 4, !tbaa !40
  %71 = fadd float %15, %70
  %72 = fadd float %67, %71
  %73 = add nuw nsw i64 %66, 1
  %74 = add i64 %68, 1
  %75 = icmp eq i64 %74, %20
  br i1 %75, label %76, label %65, !llvm.loop !520

76:                                               ; preds = %65, %61
  %77 = phi float [ %62, %61 ], [ %72, %65 ]
  %78 = load double, ptr @init_value, align 8, !tbaa !28
  %79 = fptrunc double %78 to float
  %80 = fadd float %15, %79
  %81 = fmul float %80, 8.000000e+03
  %82 = fsub float %77, %81
  %83 = tail call float @llvm.fabs.f32(float %77)
  %84 = fpext float %83 to double
  %85 = fcmp ogt double %84, 1.000000e-04
  %86 = select i1 %85, float %77, float 1.000000e+00
  %87 = fdiv float %82, %86
  %88 = tail call float @llvm.fabs.f32(float %87)
  %89 = fpext float %88 to double
  %90 = fcmp olt double %89, 1.000000e-03
  br i1 %90, label %31, label %27

91:                                               ; preds = %16, %107
  %92 = phi i32 [ %108, %107 ], [ %9, %16 ]
  %93 = phi double [ %109, %107 ], [ %17, %16 ]
  %94 = phi i32 [ %110, %107 ], [ 0, %16 ]
  %95 = fptrunc double %93 to float
  %96 = fadd float %15, %95
  %97 = fmul float %96, 8.000000e+03
  %98 = fsub float 0.000000e+00, %97
  %99 = tail call float @llvm.fabs.f32(float %98)
  %100 = fpext float %99 to double
  %101 = fcmp olt double %100, 1.000000e-03
  br i1 %101, label %107, label %102

102:                                              ; preds = %91
  %103 = load i32, ptr @current_test, align 4, !tbaa !9
  %104 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %103)
  %105 = load double, ptr @init_value, align 8, !tbaa !28
  %106 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %107

107:                                              ; preds = %91, %102
  %108 = phi i32 [ %92, %91 ], [ %106, %102 ]
  %109 = phi double [ %93, %91 ], [ %105, %102 ]
  %110 = add nuw nsw i32 %94, 1
  %111 = icmp slt i32 %110, %108
  br i1 %111, label %91, label %112, !llvm.loop !518

112:                                              ; preds = %107, %31, %7
  %113 = tail call i64 @clock() #17
  store i64 %113, ptr @end_time, align 8, !tbaa !26
  %114 = load i64, ptr @start_time, align 8, !tbaa !26
  %115 = load ptr, ptr @results, align 8, !tbaa !5
  %116 = icmp eq ptr %115, null
  br i1 %116, label %117, label %119

117:                                              ; preds = %112
  %118 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %123

119:                                              ; preds = %112
  %120 = load i32, ptr @current_test, align 4, !tbaa !9
  %121 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %122 = icmp slt i32 %120, %121
  br i1 %122, label %135, label %123

123:                                              ; preds = %119, %117
  %124 = phi i32 [ %118, %117 ], [ %121, %119 ]
  %125 = add nsw i32 %124, 10
  store i32 %125, ptr @allocated_results, align 4, !tbaa !9
  %126 = sext i32 %125 to i64
  %127 = shl nsw i64 %126, 4
  %128 = tail call ptr @realloc(ptr noundef %115, i64 noundef %127) #14
  store ptr %128, ptr @results, align 8, !tbaa !5
  %129 = icmp eq ptr %128, null
  br i1 %129, label %132, label %130

130:                                              ; preds = %123
  %131 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %135

132:                                              ; preds = %123
  %133 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %134 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %133)
  tail call void @exit(i32 noundef -1) #15
  unreachable

135:                                              ; preds = %119, %130
  %136 = phi i32 [ %131, %130 ], [ %120, %119 ]
  %137 = phi ptr [ %128, %130 ], [ %115, %119 ]
  %138 = sub nsw i64 %113, %114
  %139 = sitofp i64 %138 to double
  %140 = fdiv double %139, 1.000000e+06
  %141 = sext i32 %136 to i64
  %142 = getelementptr inbounds %struct.one_result, ptr %137, i64 %141
  store double %140, ptr %142, align 8, !tbaa !11
  %143 = getelementptr inbounds %struct.one_result, ptr %137, i64 %141, i32 1
  store ptr %6, ptr %143, align 8, !tbaa !14
  %144 = add nsw i32 %136, 1
  store i32 %144, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4If30custom_mixed_multiple_variableIfEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, float noundef %2, float noundef %3, float noundef %4, float noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !26
  %9 = load i32, ptr @iterations, align 4, !tbaa !9
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %118

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  %13 = fmul float %3, %4
  %14 = fdiv float %13, %5
  br i1 %12, label %17, label %15

15:                                               ; preds = %11
  %16 = load double, ptr @init_value, align 8, !tbaa !28
  br label %96

17:                                               ; preds = %11
  %18 = zext i32 %1 to i64
  %19 = and i64 %18, 3
  %20 = icmp ult i32 %1, 4
  %21 = and i64 %18, 4294967292
  %22 = icmp eq i64 %19, 0
  br label %23

23:                                               ; preds = %17, %30
  %24 = phi i32 [ %31, %30 ], [ %9, %17 ]
  %25 = phi i32 [ %32, %30 ], [ 0, %17 ]
  br i1 %20, label %64, label %34

26:                                               ; preds = %80
  %27 = load i32, ptr @current_test, align 4, !tbaa !9
  %28 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %27)
  %29 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %30

30:                                               ; preds = %26, %80
  %31 = phi i32 [ %29, %26 ], [ %24, %80 ]
  %32 = add nuw nsw i32 %25, 1
  %33 = icmp slt i32 %32, %31
  br i1 %33, label %23, label %118, !llvm.loop !521

34:                                               ; preds = %23, %34
  %35 = phi i64 [ %61, %34 ], [ 0, %23 ]
  %36 = phi float [ %60, %34 ], [ 0.000000e+00, %23 ]
  %37 = phi i64 [ %62, %34 ], [ 0, %23 ]
  %38 = getelementptr inbounds float, ptr %0, i64 %35
  %39 = load float, ptr %38, align 4, !tbaa !40
  %40 = fadd float %39, %2
  %41 = fsub float %40, %14
  %42 = fadd float %36, %41
  %43 = or i64 %35, 1
  %44 = getelementptr inbounds float, ptr %0, i64 %43
  %45 = load float, ptr %44, align 4, !tbaa !40
  %46 = fadd float %45, %2
  %47 = fsub float %46, %14
  %48 = fadd float %42, %47
  %49 = or i64 %35, 2
  %50 = getelementptr inbounds float, ptr %0, i64 %49
  %51 = load float, ptr %50, align 4, !tbaa !40
  %52 = fadd float %51, %2
  %53 = fsub float %52, %14
  %54 = fadd float %48, %53
  %55 = or i64 %35, 3
  %56 = getelementptr inbounds float, ptr %0, i64 %55
  %57 = load float, ptr %56, align 4, !tbaa !40
  %58 = fadd float %57, %2
  %59 = fsub float %58, %14
  %60 = fadd float %54, %59
  %61 = add nuw nsw i64 %35, 4
  %62 = add i64 %37, 4
  %63 = icmp eq i64 %62, %21
  br i1 %63, label %64, label %34, !llvm.loop !522

64:                                               ; preds = %34, %23
  %65 = phi float [ undef, %23 ], [ %60, %34 ]
  %66 = phi i64 [ 0, %23 ], [ %61, %34 ]
  %67 = phi float [ 0.000000e+00, %23 ], [ %60, %34 ]
  br i1 %22, label %80, label %68

68:                                               ; preds = %64, %68
  %69 = phi i64 [ %77, %68 ], [ %66, %64 ]
  %70 = phi float [ %76, %68 ], [ %67, %64 ]
  %71 = phi i64 [ %78, %68 ], [ 0, %64 ]
  %72 = getelementptr inbounds float, ptr %0, i64 %69
  %73 = load float, ptr %72, align 4, !tbaa !40
  %74 = fadd float %73, %2
  %75 = fsub float %74, %14
  %76 = fadd float %70, %75
  %77 = add nuw nsw i64 %69, 1
  %78 = add i64 %71, 1
  %79 = icmp eq i64 %78, %19
  br i1 %79, label %80, label %68, !llvm.loop !523

80:                                               ; preds = %68, %64
  %81 = phi float [ %65, %64 ], [ %76, %68 ]
  %82 = load double, ptr @init_value, align 8, !tbaa !28
  %83 = fptrunc double %82 to float
  %84 = fadd float %83, %2
  %85 = fsub float %84, %14
  %86 = fmul float %85, 8.000000e+03
  %87 = fsub float %81, %86
  %88 = tail call float @llvm.fabs.f32(float %81)
  %89 = fpext float %88 to double
  %90 = fcmp ogt double %89, 1.000000e-04
  %91 = select i1 %90, float %81, float 1.000000e+00
  %92 = fdiv float %87, %91
  %93 = tail call float @llvm.fabs.f32(float %92)
  %94 = fpext float %93 to double
  %95 = fcmp olt double %94, 1.000000e-03
  br i1 %95, label %30, label %26

96:                                               ; preds = %15, %113
  %97 = phi i32 [ %114, %113 ], [ %9, %15 ]
  %98 = phi double [ %115, %113 ], [ %16, %15 ]
  %99 = phi i32 [ %116, %113 ], [ 0, %15 ]
  %100 = fptrunc double %98 to float
  %101 = fadd float %100, %2
  %102 = fsub float %101, %14
  %103 = fmul float %102, 8.000000e+03
  %104 = fsub float 0.000000e+00, %103
  %105 = tail call float @llvm.fabs.f32(float %104)
  %106 = fpext float %105 to double
  %107 = fcmp olt double %106, 1.000000e-03
  br i1 %107, label %113, label %108

108:                                              ; preds = %96
  %109 = load i32, ptr @current_test, align 4, !tbaa !9
  %110 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %109)
  %111 = load double, ptr @init_value, align 8, !tbaa !28
  %112 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %113

113:                                              ; preds = %96, %108
  %114 = phi i32 [ %97, %96 ], [ %112, %108 ]
  %115 = phi double [ %98, %96 ], [ %111, %108 ]
  %116 = add nuw nsw i32 %99, 1
  %117 = icmp slt i32 %116, %114
  br i1 %117, label %96, label %118, !llvm.loop !521

118:                                              ; preds = %113, %30, %7
  %119 = tail call i64 @clock() #17
  store i64 %119, ptr @end_time, align 8, !tbaa !26
  %120 = load i64, ptr @start_time, align 8, !tbaa !26
  %121 = load ptr, ptr @results, align 8, !tbaa !5
  %122 = icmp eq ptr %121, null
  br i1 %122, label %123, label %125

123:                                              ; preds = %118
  %124 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %129

125:                                              ; preds = %118
  %126 = load i32, ptr @current_test, align 4, !tbaa !9
  %127 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %128 = icmp slt i32 %126, %127
  br i1 %128, label %141, label %129

129:                                              ; preds = %125, %123
  %130 = phi i32 [ %124, %123 ], [ %127, %125 ]
  %131 = add nsw i32 %130, 10
  store i32 %131, ptr @allocated_results, align 4, !tbaa !9
  %132 = sext i32 %131 to i64
  %133 = shl nsw i64 %132, 4
  %134 = tail call ptr @realloc(ptr noundef %121, i64 noundef %133) #14
  store ptr %134, ptr @results, align 8, !tbaa !5
  %135 = icmp eq ptr %134, null
  br i1 %135, label %138, label %136

136:                                              ; preds = %129
  %137 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %141

138:                                              ; preds = %129
  %139 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %140 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %139)
  tail call void @exit(i32 noundef -1) #15
  unreachable

141:                                              ; preds = %125, %136
  %142 = phi i32 [ %137, %136 ], [ %126, %125 ]
  %143 = phi ptr [ %134, %136 ], [ %121, %125 ]
  %144 = sub nsw i64 %119, %120
  %145 = sitofp i64 %144 to double
  %146 = fdiv double %145, 1.000000e+06
  %147 = sext i32 %142 to i64
  %148 = getelementptr inbounds %struct.one_result, ptr %143, i64 %147
  store double %146, ptr %148, align 8, !tbaa !11
  %149 = getelementptr inbounds %struct.one_result, ptr %143, i64 %147, i32 1
  store ptr %6, ptr %149, align 8, !tbaa !14
  %150 = add nsw i32 %142, 1
  store i32 %150, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1Id19custom_add_variableIdEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, double noundef %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !26
  %6 = load i32, ptr @iterations, align 4, !tbaa !9
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %101

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  br i1 %9, label %12, label %10

10:                                               ; preds = %8
  %11 = load double, ptr @init_value, align 8, !tbaa !28
  br label %82

12:                                               ; preds = %8
  %13 = zext i32 %1 to i64
  %14 = and i64 %13, 3
  %15 = icmp ult i32 %1, 4
  %16 = and i64 %13, 4294967292
  %17 = icmp eq i64 %14, 0
  br label %18

18:                                               ; preds = %12, %25
  %19 = phi i32 [ %26, %25 ], [ %6, %12 ]
  %20 = phi i32 [ %27, %25 ], [ 0, %12 ]
  br i1 %15, label %55, label %29

21:                                               ; preds = %70
  %22 = load i32, ptr @current_test, align 4, !tbaa !9
  %23 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %22)
  %24 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %25

25:                                               ; preds = %21, %70
  %26 = phi i32 [ %24, %21 ], [ %19, %70 ]
  %27 = add nuw nsw i32 %20, 1
  %28 = icmp slt i32 %27, %26
  br i1 %28, label %18, label %101, !llvm.loop !524

29:                                               ; preds = %18, %29
  %30 = phi i64 [ %52, %29 ], [ 0, %18 ]
  %31 = phi double [ %51, %29 ], [ 0.000000e+00, %18 ]
  %32 = phi i64 [ %53, %29 ], [ 0, %18 ]
  %33 = getelementptr inbounds double, ptr %0, i64 %30
  %34 = load double, ptr %33, align 8, !tbaa !28
  %35 = fadd double %34, %2
  %36 = fadd double %31, %35
  %37 = or i64 %30, 1
  %38 = getelementptr inbounds double, ptr %0, i64 %37
  %39 = load double, ptr %38, align 8, !tbaa !28
  %40 = fadd double %39, %2
  %41 = fadd double %36, %40
  %42 = or i64 %30, 2
  %43 = getelementptr inbounds double, ptr %0, i64 %42
  %44 = load double, ptr %43, align 8, !tbaa !28
  %45 = fadd double %44, %2
  %46 = fadd double %41, %45
  %47 = or i64 %30, 3
  %48 = getelementptr inbounds double, ptr %0, i64 %47
  %49 = load double, ptr %48, align 8, !tbaa !28
  %50 = fadd double %49, %2
  %51 = fadd double %46, %50
  %52 = add nuw nsw i64 %30, 4
  %53 = add i64 %32, 4
  %54 = icmp eq i64 %53, %16
  br i1 %54, label %55, label %29, !llvm.loop !525

55:                                               ; preds = %29, %18
  %56 = phi double [ undef, %18 ], [ %51, %29 ]
  %57 = phi i64 [ 0, %18 ], [ %52, %29 ]
  %58 = phi double [ 0.000000e+00, %18 ], [ %51, %29 ]
  br i1 %17, label %70, label %59

59:                                               ; preds = %55, %59
  %60 = phi i64 [ %67, %59 ], [ %57, %55 ]
  %61 = phi double [ %66, %59 ], [ %58, %55 ]
  %62 = phi i64 [ %68, %59 ], [ 0, %55 ]
  %63 = getelementptr inbounds double, ptr %0, i64 %60
  %64 = load double, ptr %63, align 8, !tbaa !28
  %65 = fadd double %64, %2
  %66 = fadd double %61, %65
  %67 = add nuw nsw i64 %60, 1
  %68 = add i64 %62, 1
  %69 = icmp eq i64 %68, %14
  br i1 %69, label %70, label %59, !llvm.loop !526

70:                                               ; preds = %59, %55
  %71 = phi double [ %56, %55 ], [ %66, %59 ]
  %72 = load double, ptr @init_value, align 8, !tbaa !28
  %73 = fadd double %72, %2
  %74 = fmul double %73, 8.000000e+03
  %75 = fsub double %71, %74
  %76 = tail call double @llvm.fabs.f64(double %71)
  %77 = fcmp ogt double %76, 1.000000e-08
  %78 = select i1 %77, double %71, double 1.000000e+00
  %79 = fdiv double %75, %78
  %80 = tail call double @llvm.fabs.f64(double %79)
  %81 = fcmp olt double %80, 0x3EB0C6F7A0B5ED8D
  br i1 %81, label %25, label %21

82:                                               ; preds = %10, %96
  %83 = phi i32 [ %97, %96 ], [ %6, %10 ]
  %84 = phi double [ %98, %96 ], [ %11, %10 ]
  %85 = phi i32 [ %99, %96 ], [ 0, %10 ]
  %86 = fadd double %84, %2
  %87 = fmul double %86, 8.000000e+03
  %88 = fsub double 0.000000e+00, %87
  %89 = tail call double @llvm.fabs.f64(double %88)
  %90 = fcmp olt double %89, 0x3EB0C6F7A0B5ED8D
  br i1 %90, label %96, label %91

91:                                               ; preds = %82
  %92 = load i32, ptr @current_test, align 4, !tbaa !9
  %93 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %92)
  %94 = load double, ptr @init_value, align 8, !tbaa !28
  %95 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %96

96:                                               ; preds = %82, %91
  %97 = phi i32 [ %83, %82 ], [ %95, %91 ]
  %98 = phi double [ %84, %82 ], [ %94, %91 ]
  %99 = add nuw nsw i32 %85, 1
  %100 = icmp slt i32 %99, %97
  br i1 %100, label %82, label %101, !llvm.loop !524

101:                                              ; preds = %96, %25, %4
  %102 = tail call i64 @clock() #17
  store i64 %102, ptr @end_time, align 8, !tbaa !26
  %103 = load i64, ptr @start_time, align 8, !tbaa !26
  %104 = load ptr, ptr @results, align 8, !tbaa !5
  %105 = icmp eq ptr %104, null
  br i1 %105, label %106, label %108

106:                                              ; preds = %101
  %107 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %112

108:                                              ; preds = %101
  %109 = load i32, ptr @current_test, align 4, !tbaa !9
  %110 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %111 = icmp slt i32 %109, %110
  br i1 %111, label %124, label %112

112:                                              ; preds = %108, %106
  %113 = phi i32 [ %107, %106 ], [ %110, %108 ]
  %114 = add nsw i32 %113, 10
  store i32 %114, ptr @allocated_results, align 4, !tbaa !9
  %115 = sext i32 %114 to i64
  %116 = shl nsw i64 %115, 4
  %117 = tail call ptr @realloc(ptr noundef %104, i64 noundef %116) #14
  store ptr %117, ptr @results, align 8, !tbaa !5
  %118 = icmp eq ptr %117, null
  br i1 %118, label %121, label %119

119:                                              ; preds = %112
  %120 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %124

121:                                              ; preds = %112
  %122 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %123 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %122)
  tail call void @exit(i32 noundef -1) #15
  unreachable

124:                                              ; preds = %108, %119
  %125 = phi i32 [ %120, %119 ], [ %109, %108 ]
  %126 = phi ptr [ %117, %119 ], [ %104, %108 ]
  %127 = sub nsw i64 %102, %103
  %128 = sitofp i64 %127 to double
  %129 = fdiv double %128, 1.000000e+06
  %130 = sext i32 %125 to i64
  %131 = getelementptr inbounds %struct.one_result, ptr %126, i64 %130
  store double %129, ptr %131, align 8, !tbaa !11
  %132 = getelementptr inbounds %struct.one_result, ptr %126, i64 %130, i32 1
  store ptr %3, ptr %132, align 8, !tbaa !14
  %133 = add nsw i32 %125, 1
  store i32 %133, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z22test_hoisted_variable1Id19custom_add_variableIdEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, double noundef %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !26
  %6 = load i32, ptr @iterations, align 4, !tbaa !9
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %119

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  %10 = sitofp i32 %1 to double
  br i1 %9, label %11, label %93

11:                                               ; preds = %8
  %12 = zext i32 %1 to i64
  %13 = and i64 %12, 7
  %14 = icmp ult i32 %1, 8
  %15 = and i64 %12, 4294967288
  %16 = icmp eq i64 %13, 0
  br label %17

17:                                               ; preds = %11, %24
  %18 = phi i32 [ %25, %24 ], [ %6, %11 ]
  %19 = phi i32 [ %26, %24 ], [ 0, %11 ]
  br i1 %14, label %66, label %28

20:                                               ; preds = %80
  %21 = load i32, ptr @current_test, align 4, !tbaa !9
  %22 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %21)
  %23 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %24

24:                                               ; preds = %20, %80
  %25 = phi i32 [ %23, %20 ], [ %18, %80 ]
  %26 = add nuw nsw i32 %19, 1
  %27 = icmp slt i32 %26, %25
  br i1 %27, label %17, label %119, !llvm.loop !527

28:                                               ; preds = %17, %28
  %29 = phi i64 [ %63, %28 ], [ 0, %17 ]
  %30 = phi double [ %62, %28 ], [ 0.000000e+00, %17 ]
  %31 = phi i64 [ %64, %28 ], [ 0, %17 ]
  %32 = getelementptr inbounds double, ptr %0, i64 %29
  %33 = load double, ptr %32, align 8, !tbaa !28
  %34 = fadd double %30, %33
  %35 = or i64 %29, 1
  %36 = getelementptr inbounds double, ptr %0, i64 %35
  %37 = load double, ptr %36, align 8, !tbaa !28
  %38 = fadd double %34, %37
  %39 = or i64 %29, 2
  %40 = getelementptr inbounds double, ptr %0, i64 %39
  %41 = load double, ptr %40, align 8, !tbaa !28
  %42 = fadd double %38, %41
  %43 = or i64 %29, 3
  %44 = getelementptr inbounds double, ptr %0, i64 %43
  %45 = load double, ptr %44, align 8, !tbaa !28
  %46 = fadd double %42, %45
  %47 = or i64 %29, 4
  %48 = getelementptr inbounds double, ptr %0, i64 %47
  %49 = load double, ptr %48, align 8, !tbaa !28
  %50 = fadd double %46, %49
  %51 = or i64 %29, 5
  %52 = getelementptr inbounds double, ptr %0, i64 %51
  %53 = load double, ptr %52, align 8, !tbaa !28
  %54 = fadd double %50, %53
  %55 = or i64 %29, 6
  %56 = getelementptr inbounds double, ptr %0, i64 %55
  %57 = load double, ptr %56, align 8, !tbaa !28
  %58 = fadd double %54, %57
  %59 = or i64 %29, 7
  %60 = getelementptr inbounds double, ptr %0, i64 %59
  %61 = load double, ptr %60, align 8, !tbaa !28
  %62 = fadd double %58, %61
  %63 = add nuw nsw i64 %29, 8
  %64 = add i64 %31, 8
  %65 = icmp eq i64 %64, %15
  br i1 %65, label %66, label %28, !llvm.loop !528

66:                                               ; preds = %28, %17
  %67 = phi double [ undef, %17 ], [ %62, %28 ]
  %68 = phi i64 [ 0, %17 ], [ %63, %28 ]
  %69 = phi double [ 0.000000e+00, %17 ], [ %62, %28 ]
  br i1 %16, label %80, label %70

70:                                               ; preds = %66, %70
  %71 = phi i64 [ %77, %70 ], [ %68, %66 ]
  %72 = phi double [ %76, %70 ], [ %69, %66 ]
  %73 = phi i64 [ %78, %70 ], [ 0, %66 ]
  %74 = getelementptr inbounds double, ptr %0, i64 %71
  %75 = load double, ptr %74, align 8, !tbaa !28
  %76 = fadd double %72, %75
  %77 = add nuw nsw i64 %71, 1
  %78 = add i64 %73, 1
  %79 = icmp eq i64 %78, %13
  br i1 %79, label %80, label %70, !llvm.loop !529

80:                                               ; preds = %70, %66
  %81 = phi double [ %67, %66 ], [ %76, %70 ]
  %82 = tail call double @llvm.fmuladd.f64(double %10, double %2, double %81)
  %83 = load double, ptr @init_value, align 8, !tbaa !28
  %84 = fadd double %83, %2
  %85 = fmul double %84, 8.000000e+03
  %86 = fsub double %82, %85
  %87 = tail call double @llvm.fabs.f64(double %82)
  %88 = fcmp ogt double %87, 1.000000e-08
  %89 = select i1 %88, double %82, double 1.000000e+00
  %90 = fdiv double %86, %89
  %91 = tail call double @llvm.fabs.f64(double %90)
  %92 = fcmp olt double %91, 0x3EB0C6F7A0B5ED8D
  br i1 %92, label %24, label %20

93:                                               ; preds = %8
  %94 = tail call double @llvm.fmuladd.f64(double %10, double %2, double 0.000000e+00)
  %95 = tail call double @llvm.fabs.f64(double %94)
  %96 = fcmp ogt double %95, 1.000000e-08
  %97 = select i1 %96, double %94, double 1.000000e+00
  %98 = load double, ptr @init_value, align 8, !tbaa !28
  br label %99

99:                                               ; preds = %93, %114
  %100 = phi i32 [ %6, %93 ], [ %115, %114 ]
  %101 = phi double [ %98, %93 ], [ %116, %114 ]
  %102 = phi i32 [ 0, %93 ], [ %117, %114 ]
  %103 = fadd double %101, %2
  %104 = fmul double %103, 8.000000e+03
  %105 = fsub double %94, %104
  %106 = fdiv double %105, %97
  %107 = tail call double @llvm.fabs.f64(double %106)
  %108 = fcmp olt double %107, 0x3EB0C6F7A0B5ED8D
  br i1 %108, label %114, label %109

109:                                              ; preds = %99
  %110 = load i32, ptr @current_test, align 4, !tbaa !9
  %111 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %110)
  %112 = load double, ptr @init_value, align 8, !tbaa !28
  %113 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %114

114:                                              ; preds = %99, %109
  %115 = phi i32 [ %100, %99 ], [ %113, %109 ]
  %116 = phi double [ %101, %99 ], [ %112, %109 ]
  %117 = add nuw nsw i32 %102, 1
  %118 = icmp slt i32 %117, %115
  br i1 %118, label %99, label %119, !llvm.loop !527

119:                                              ; preds = %114, %24, %4
  %120 = tail call i64 @clock() #17
  store i64 %120, ptr @end_time, align 8, !tbaa !26
  %121 = load i64, ptr @start_time, align 8, !tbaa !26
  %122 = load ptr, ptr @results, align 8, !tbaa !5
  %123 = icmp eq ptr %122, null
  br i1 %123, label %124, label %126

124:                                              ; preds = %119
  %125 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %130

126:                                              ; preds = %119
  %127 = load i32, ptr @current_test, align 4, !tbaa !9
  %128 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %129 = icmp slt i32 %127, %128
  br i1 %129, label %142, label %130

130:                                              ; preds = %126, %124
  %131 = phi i32 [ %125, %124 ], [ %128, %126 ]
  %132 = add nsw i32 %131, 10
  store i32 %132, ptr @allocated_results, align 4, !tbaa !9
  %133 = sext i32 %132 to i64
  %134 = shl nsw i64 %133, 4
  %135 = tail call ptr @realloc(ptr noundef %122, i64 noundef %134) #14
  store ptr %135, ptr @results, align 8, !tbaa !5
  %136 = icmp eq ptr %135, null
  br i1 %136, label %139, label %137

137:                                              ; preds = %130
  %138 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %142

139:                                              ; preds = %130
  %140 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %141 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %140)
  tail call void @exit(i32 noundef -1) #15
  unreachable

142:                                              ; preds = %126, %137
  %143 = phi i32 [ %138, %137 ], [ %127, %126 ]
  %144 = phi ptr [ %135, %137 ], [ %122, %126 ]
  %145 = sub nsw i64 %120, %121
  %146 = sitofp i64 %145 to double
  %147 = fdiv double %146, 1.000000e+06
  %148 = sext i32 %143 to i64
  %149 = getelementptr inbounds %struct.one_result, ptr %144, i64 %148
  store double %147, ptr %149, align 8, !tbaa !11
  %150 = getelementptr inbounds %struct.one_result, ptr %144, i64 %148, i32 1
  store ptr %3, ptr %150, align 8, !tbaa !14
  %151 = add nsw i32 %143, 1
  store i32 %151, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Id28custom_add_multiple_variableIdEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, double noundef %2, double noundef %3, double noundef %4, double noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !26
  %9 = load i32, ptr @iterations, align 4, !tbaa !9
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %103

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  br i1 %12, label %15, label %13

13:                                               ; preds = %11
  %14 = load double, ptr @init_value, align 8, !tbaa !28
  br label %81

15:                                               ; preds = %11
  %16 = zext i32 %1 to i64
  %17 = and i64 %16, 1
  %18 = icmp eq i32 %1, 1
  %19 = and i64 %16, 4294967294
  %20 = icmp eq i64 %17, 0
  br label %21

21:                                               ; preds = %15, %28
  %22 = phi i32 [ %29, %28 ], [ %9, %15 ]
  %23 = phi i32 [ %30, %28 ], [ 0, %15 ]
  br i1 %18, label %54, label %32

24:                                               ; preds = %66
  %25 = load i32, ptr @current_test, align 4, !tbaa !9
  %26 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %25)
  %27 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %28

28:                                               ; preds = %24, %66
  %29 = phi i32 [ %27, %24 ], [ %22, %66 ]
  %30 = add nuw nsw i32 %23, 1
  %31 = icmp slt i32 %30, %29
  br i1 %31, label %21, label %103, !llvm.loop !530

32:                                               ; preds = %21, %32
  %33 = phi i64 [ %51, %32 ], [ 0, %21 ]
  %34 = phi double [ %50, %32 ], [ 0.000000e+00, %21 ]
  %35 = phi i64 [ %52, %32 ], [ 0, %21 ]
  %36 = getelementptr inbounds double, ptr %0, i64 %33
  %37 = load double, ptr %36, align 8, !tbaa !28
  %38 = fadd double %37, %2
  %39 = fadd double %38, %3
  %40 = fadd double %39, %4
  %41 = fadd double %40, %5
  %42 = fadd double %34, %41
  %43 = or i64 %33, 1
  %44 = getelementptr inbounds double, ptr %0, i64 %43
  %45 = load double, ptr %44, align 8, !tbaa !28
  %46 = fadd double %45, %2
  %47 = fadd double %46, %3
  %48 = fadd double %47, %4
  %49 = fadd double %48, %5
  %50 = fadd double %42, %49
  %51 = add nuw nsw i64 %33, 2
  %52 = add i64 %35, 2
  %53 = icmp eq i64 %52, %19
  br i1 %53, label %54, label %32, !llvm.loop !531

54:                                               ; preds = %32, %21
  %55 = phi double [ undef, %21 ], [ %50, %32 ]
  %56 = phi i64 [ 0, %21 ], [ %51, %32 ]
  %57 = phi double [ 0.000000e+00, %21 ], [ %50, %32 ]
  br i1 %20, label %66, label %58

58:                                               ; preds = %54
  %59 = getelementptr inbounds double, ptr %0, i64 %56
  %60 = load double, ptr %59, align 8, !tbaa !28
  %61 = fadd double %60, %2
  %62 = fadd double %61, %3
  %63 = fadd double %62, %4
  %64 = fadd double %63, %5
  %65 = fadd double %57, %64
  br label %66

66:                                               ; preds = %54, %58
  %67 = phi double [ %55, %54 ], [ %65, %58 ]
  %68 = load double, ptr @init_value, align 8, !tbaa !28
  %69 = fadd double %68, %2
  %70 = fadd double %69, %3
  %71 = fadd double %70, %4
  %72 = fadd double %71, %5
  %73 = fmul double %72, 8.000000e+03
  %74 = fsub double %67, %73
  %75 = tail call double @llvm.fabs.f64(double %67)
  %76 = fcmp ogt double %75, 1.000000e-08
  %77 = select i1 %76, double %67, double 1.000000e+00
  %78 = fdiv double %74, %77
  %79 = tail call double @llvm.fabs.f64(double %78)
  %80 = fcmp olt double %79, 0x3EB0C6F7A0B5ED8D
  br i1 %80, label %28, label %24

81:                                               ; preds = %13, %98
  %82 = phi i32 [ %99, %98 ], [ %9, %13 ]
  %83 = phi double [ %100, %98 ], [ %14, %13 ]
  %84 = phi i32 [ %101, %98 ], [ 0, %13 ]
  %85 = fadd double %83, %2
  %86 = fadd double %85, %3
  %87 = fadd double %86, %4
  %88 = fadd double %87, %5
  %89 = fmul double %88, 8.000000e+03
  %90 = fsub double 0.000000e+00, %89
  %91 = tail call double @llvm.fabs.f64(double %90)
  %92 = fcmp olt double %91, 0x3EB0C6F7A0B5ED8D
  br i1 %92, label %98, label %93

93:                                               ; preds = %81
  %94 = load i32, ptr @current_test, align 4, !tbaa !9
  %95 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %94)
  %96 = load double, ptr @init_value, align 8, !tbaa !28
  %97 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %98

98:                                               ; preds = %81, %93
  %99 = phi i32 [ %82, %81 ], [ %97, %93 ]
  %100 = phi double [ %83, %81 ], [ %96, %93 ]
  %101 = add nuw nsw i32 %84, 1
  %102 = icmp slt i32 %101, %99
  br i1 %102, label %81, label %103, !llvm.loop !530

103:                                              ; preds = %98, %28, %7
  %104 = tail call i64 @clock() #17
  store i64 %104, ptr @end_time, align 8, !tbaa !26
  %105 = load i64, ptr @start_time, align 8, !tbaa !26
  %106 = load ptr, ptr @results, align 8, !tbaa !5
  %107 = icmp eq ptr %106, null
  br i1 %107, label %108, label %110

108:                                              ; preds = %103
  %109 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %114

110:                                              ; preds = %103
  %111 = load i32, ptr @current_test, align 4, !tbaa !9
  %112 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %113 = icmp slt i32 %111, %112
  br i1 %113, label %126, label %114

114:                                              ; preds = %110, %108
  %115 = phi i32 [ %109, %108 ], [ %112, %110 ]
  %116 = add nsw i32 %115, 10
  store i32 %116, ptr @allocated_results, align 4, !tbaa !9
  %117 = sext i32 %116 to i64
  %118 = shl nsw i64 %117, 4
  %119 = tail call ptr @realloc(ptr noundef %106, i64 noundef %118) #14
  store ptr %119, ptr @results, align 8, !tbaa !5
  %120 = icmp eq ptr %119, null
  br i1 %120, label %123, label %121

121:                                              ; preds = %114
  %122 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %126

123:                                              ; preds = %114
  %124 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %125 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %124)
  tail call void @exit(i32 noundef -1) #15
  unreachable

126:                                              ; preds = %110, %121
  %127 = phi i32 [ %122, %121 ], [ %111, %110 ]
  %128 = phi ptr [ %119, %121 ], [ %106, %110 ]
  %129 = sub nsw i64 %104, %105
  %130 = sitofp i64 %129 to double
  %131 = fdiv double %130, 1.000000e+06
  %132 = sext i32 %127 to i64
  %133 = getelementptr inbounds %struct.one_result, ptr %128, i64 %132
  store double %131, ptr %133, align 8, !tbaa !11
  %134 = getelementptr inbounds %struct.one_result, ptr %128, i64 %132, i32 1
  store ptr %6, ptr %134, align 8, !tbaa !14
  %135 = add nsw i32 %127, 1
  store i32 %135, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1Id19custom_sub_variableIdEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, double noundef %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !26
  %6 = load i32, ptr @iterations, align 4, !tbaa !9
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %101

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  br i1 %9, label %12, label %10

10:                                               ; preds = %8
  %11 = load double, ptr @init_value, align 8, !tbaa !28
  br label %82

12:                                               ; preds = %8
  %13 = zext i32 %1 to i64
  %14 = and i64 %13, 3
  %15 = icmp ult i32 %1, 4
  %16 = and i64 %13, 4294967292
  %17 = icmp eq i64 %14, 0
  br label %18

18:                                               ; preds = %12, %25
  %19 = phi i32 [ %26, %25 ], [ %6, %12 ]
  %20 = phi i32 [ %27, %25 ], [ 0, %12 ]
  br i1 %15, label %55, label %29

21:                                               ; preds = %70
  %22 = load i32, ptr @current_test, align 4, !tbaa !9
  %23 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %22)
  %24 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %25

25:                                               ; preds = %21, %70
  %26 = phi i32 [ %24, %21 ], [ %19, %70 ]
  %27 = add nuw nsw i32 %20, 1
  %28 = icmp slt i32 %27, %26
  br i1 %28, label %18, label %101, !llvm.loop !532

29:                                               ; preds = %18, %29
  %30 = phi i64 [ %52, %29 ], [ 0, %18 ]
  %31 = phi double [ %51, %29 ], [ 0.000000e+00, %18 ]
  %32 = phi i64 [ %53, %29 ], [ 0, %18 ]
  %33 = getelementptr inbounds double, ptr %0, i64 %30
  %34 = load double, ptr %33, align 8, !tbaa !28
  %35 = fsub double %34, %2
  %36 = fadd double %31, %35
  %37 = or i64 %30, 1
  %38 = getelementptr inbounds double, ptr %0, i64 %37
  %39 = load double, ptr %38, align 8, !tbaa !28
  %40 = fsub double %39, %2
  %41 = fadd double %36, %40
  %42 = or i64 %30, 2
  %43 = getelementptr inbounds double, ptr %0, i64 %42
  %44 = load double, ptr %43, align 8, !tbaa !28
  %45 = fsub double %44, %2
  %46 = fadd double %41, %45
  %47 = or i64 %30, 3
  %48 = getelementptr inbounds double, ptr %0, i64 %47
  %49 = load double, ptr %48, align 8, !tbaa !28
  %50 = fsub double %49, %2
  %51 = fadd double %46, %50
  %52 = add nuw nsw i64 %30, 4
  %53 = add i64 %32, 4
  %54 = icmp eq i64 %53, %16
  br i1 %54, label %55, label %29, !llvm.loop !533

55:                                               ; preds = %29, %18
  %56 = phi double [ undef, %18 ], [ %51, %29 ]
  %57 = phi i64 [ 0, %18 ], [ %52, %29 ]
  %58 = phi double [ 0.000000e+00, %18 ], [ %51, %29 ]
  br i1 %17, label %70, label %59

59:                                               ; preds = %55, %59
  %60 = phi i64 [ %67, %59 ], [ %57, %55 ]
  %61 = phi double [ %66, %59 ], [ %58, %55 ]
  %62 = phi i64 [ %68, %59 ], [ 0, %55 ]
  %63 = getelementptr inbounds double, ptr %0, i64 %60
  %64 = load double, ptr %63, align 8, !tbaa !28
  %65 = fsub double %64, %2
  %66 = fadd double %61, %65
  %67 = add nuw nsw i64 %60, 1
  %68 = add i64 %62, 1
  %69 = icmp eq i64 %68, %14
  br i1 %69, label %70, label %59, !llvm.loop !534

70:                                               ; preds = %59, %55
  %71 = phi double [ %56, %55 ], [ %66, %59 ]
  %72 = load double, ptr @init_value, align 8, !tbaa !28
  %73 = fsub double %72, %2
  %74 = fmul double %73, 8.000000e+03
  %75 = fsub double %71, %74
  %76 = tail call double @llvm.fabs.f64(double %71)
  %77 = fcmp ogt double %76, 1.000000e-08
  %78 = select i1 %77, double %71, double 1.000000e+00
  %79 = fdiv double %75, %78
  %80 = tail call double @llvm.fabs.f64(double %79)
  %81 = fcmp olt double %80, 0x3EB0C6F7A0B5ED8D
  br i1 %81, label %25, label %21

82:                                               ; preds = %10, %96
  %83 = phi i32 [ %97, %96 ], [ %6, %10 ]
  %84 = phi double [ %98, %96 ], [ %11, %10 ]
  %85 = phi i32 [ %99, %96 ], [ 0, %10 ]
  %86 = fsub double %84, %2
  %87 = fmul double %86, 8.000000e+03
  %88 = fsub double 0.000000e+00, %87
  %89 = tail call double @llvm.fabs.f64(double %88)
  %90 = fcmp olt double %89, 0x3EB0C6F7A0B5ED8D
  br i1 %90, label %96, label %91

91:                                               ; preds = %82
  %92 = load i32, ptr @current_test, align 4, !tbaa !9
  %93 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %92)
  %94 = load double, ptr @init_value, align 8, !tbaa !28
  %95 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %96

96:                                               ; preds = %82, %91
  %97 = phi i32 [ %83, %82 ], [ %95, %91 ]
  %98 = phi double [ %84, %82 ], [ %94, %91 ]
  %99 = add nuw nsw i32 %85, 1
  %100 = icmp slt i32 %99, %97
  br i1 %100, label %82, label %101, !llvm.loop !532

101:                                              ; preds = %96, %25, %4
  %102 = tail call i64 @clock() #17
  store i64 %102, ptr @end_time, align 8, !tbaa !26
  %103 = load i64, ptr @start_time, align 8, !tbaa !26
  %104 = load ptr, ptr @results, align 8, !tbaa !5
  %105 = icmp eq ptr %104, null
  br i1 %105, label %106, label %108

106:                                              ; preds = %101
  %107 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %112

108:                                              ; preds = %101
  %109 = load i32, ptr @current_test, align 4, !tbaa !9
  %110 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %111 = icmp slt i32 %109, %110
  br i1 %111, label %124, label %112

112:                                              ; preds = %108, %106
  %113 = phi i32 [ %107, %106 ], [ %110, %108 ]
  %114 = add nsw i32 %113, 10
  store i32 %114, ptr @allocated_results, align 4, !tbaa !9
  %115 = sext i32 %114 to i64
  %116 = shl nsw i64 %115, 4
  %117 = tail call ptr @realloc(ptr noundef %104, i64 noundef %116) #14
  store ptr %117, ptr @results, align 8, !tbaa !5
  %118 = icmp eq ptr %117, null
  br i1 %118, label %121, label %119

119:                                              ; preds = %112
  %120 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %124

121:                                              ; preds = %112
  %122 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %123 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %122)
  tail call void @exit(i32 noundef -1) #15
  unreachable

124:                                              ; preds = %108, %119
  %125 = phi i32 [ %120, %119 ], [ %109, %108 ]
  %126 = phi ptr [ %117, %119 ], [ %104, %108 ]
  %127 = sub nsw i64 %102, %103
  %128 = sitofp i64 %127 to double
  %129 = fdiv double %128, 1.000000e+06
  %130 = sext i32 %125 to i64
  %131 = getelementptr inbounds %struct.one_result, ptr %126, i64 %130
  store double %129, ptr %131, align 8, !tbaa !11
  %132 = getelementptr inbounds %struct.one_result, ptr %126, i64 %130, i32 1
  store ptr %3, ptr %132, align 8, !tbaa !14
  %133 = add nsw i32 %125, 1
  store i32 %133, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Id28custom_sub_multiple_variableIdEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, double noundef %2, double noundef %3, double noundef %4, double noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !26
  %9 = load i32, ptr @iterations, align 4, !tbaa !9
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %103

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  br i1 %12, label %15, label %13

13:                                               ; preds = %11
  %14 = load double, ptr @init_value, align 8, !tbaa !28
  br label %81

15:                                               ; preds = %11
  %16 = zext i32 %1 to i64
  %17 = and i64 %16, 1
  %18 = icmp eq i32 %1, 1
  %19 = and i64 %16, 4294967294
  %20 = icmp eq i64 %17, 0
  br label %21

21:                                               ; preds = %15, %28
  %22 = phi i32 [ %29, %28 ], [ %9, %15 ]
  %23 = phi i32 [ %30, %28 ], [ 0, %15 ]
  br i1 %18, label %54, label %32

24:                                               ; preds = %66
  %25 = load i32, ptr @current_test, align 4, !tbaa !9
  %26 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %25)
  %27 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %28

28:                                               ; preds = %24, %66
  %29 = phi i32 [ %27, %24 ], [ %22, %66 ]
  %30 = add nuw nsw i32 %23, 1
  %31 = icmp slt i32 %30, %29
  br i1 %31, label %21, label %103, !llvm.loop !535

32:                                               ; preds = %21, %32
  %33 = phi i64 [ %51, %32 ], [ 0, %21 ]
  %34 = phi double [ %50, %32 ], [ 0.000000e+00, %21 ]
  %35 = phi i64 [ %52, %32 ], [ 0, %21 ]
  %36 = getelementptr inbounds double, ptr %0, i64 %33
  %37 = load double, ptr %36, align 8, !tbaa !28
  %38 = fsub double %37, %2
  %39 = fsub double %38, %3
  %40 = fsub double %39, %4
  %41 = fsub double %40, %5
  %42 = fadd double %34, %41
  %43 = or i64 %33, 1
  %44 = getelementptr inbounds double, ptr %0, i64 %43
  %45 = load double, ptr %44, align 8, !tbaa !28
  %46 = fsub double %45, %2
  %47 = fsub double %46, %3
  %48 = fsub double %47, %4
  %49 = fsub double %48, %5
  %50 = fadd double %42, %49
  %51 = add nuw nsw i64 %33, 2
  %52 = add i64 %35, 2
  %53 = icmp eq i64 %52, %19
  br i1 %53, label %54, label %32, !llvm.loop !536

54:                                               ; preds = %32, %21
  %55 = phi double [ undef, %21 ], [ %50, %32 ]
  %56 = phi i64 [ 0, %21 ], [ %51, %32 ]
  %57 = phi double [ 0.000000e+00, %21 ], [ %50, %32 ]
  br i1 %20, label %66, label %58

58:                                               ; preds = %54
  %59 = getelementptr inbounds double, ptr %0, i64 %56
  %60 = load double, ptr %59, align 8, !tbaa !28
  %61 = fsub double %60, %2
  %62 = fsub double %61, %3
  %63 = fsub double %62, %4
  %64 = fsub double %63, %5
  %65 = fadd double %57, %64
  br label %66

66:                                               ; preds = %54, %58
  %67 = phi double [ %55, %54 ], [ %65, %58 ]
  %68 = load double, ptr @init_value, align 8, !tbaa !28
  %69 = fsub double %68, %2
  %70 = fsub double %69, %3
  %71 = fsub double %70, %4
  %72 = fsub double %71, %5
  %73 = fmul double %72, 8.000000e+03
  %74 = fsub double %67, %73
  %75 = tail call double @llvm.fabs.f64(double %67)
  %76 = fcmp ogt double %75, 1.000000e-08
  %77 = select i1 %76, double %67, double 1.000000e+00
  %78 = fdiv double %74, %77
  %79 = tail call double @llvm.fabs.f64(double %78)
  %80 = fcmp olt double %79, 0x3EB0C6F7A0B5ED8D
  br i1 %80, label %28, label %24

81:                                               ; preds = %13, %98
  %82 = phi i32 [ %99, %98 ], [ %9, %13 ]
  %83 = phi double [ %100, %98 ], [ %14, %13 ]
  %84 = phi i32 [ %101, %98 ], [ 0, %13 ]
  %85 = fsub double %83, %2
  %86 = fsub double %85, %3
  %87 = fsub double %86, %4
  %88 = fsub double %87, %5
  %89 = fmul double %88, 8.000000e+03
  %90 = fsub double 0.000000e+00, %89
  %91 = tail call double @llvm.fabs.f64(double %90)
  %92 = fcmp olt double %91, 0x3EB0C6F7A0B5ED8D
  br i1 %92, label %98, label %93

93:                                               ; preds = %81
  %94 = load i32, ptr @current_test, align 4, !tbaa !9
  %95 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %94)
  %96 = load double, ptr @init_value, align 8, !tbaa !28
  %97 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %98

98:                                               ; preds = %81, %93
  %99 = phi i32 [ %82, %81 ], [ %97, %93 ]
  %100 = phi double [ %83, %81 ], [ %96, %93 ]
  %101 = add nuw nsw i32 %84, 1
  %102 = icmp slt i32 %101, %99
  br i1 %102, label %81, label %103, !llvm.loop !535

103:                                              ; preds = %98, %28, %7
  %104 = tail call i64 @clock() #17
  store i64 %104, ptr @end_time, align 8, !tbaa !26
  %105 = load i64, ptr @start_time, align 8, !tbaa !26
  %106 = load ptr, ptr @results, align 8, !tbaa !5
  %107 = icmp eq ptr %106, null
  br i1 %107, label %108, label %110

108:                                              ; preds = %103
  %109 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %114

110:                                              ; preds = %103
  %111 = load i32, ptr @current_test, align 4, !tbaa !9
  %112 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %113 = icmp slt i32 %111, %112
  br i1 %113, label %126, label %114

114:                                              ; preds = %110, %108
  %115 = phi i32 [ %109, %108 ], [ %112, %110 ]
  %116 = add nsw i32 %115, 10
  store i32 %116, ptr @allocated_results, align 4, !tbaa !9
  %117 = sext i32 %116 to i64
  %118 = shl nsw i64 %117, 4
  %119 = tail call ptr @realloc(ptr noundef %106, i64 noundef %118) #14
  store ptr %119, ptr @results, align 8, !tbaa !5
  %120 = icmp eq ptr %119, null
  br i1 %120, label %123, label %121

121:                                              ; preds = %114
  %122 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %126

123:                                              ; preds = %114
  %124 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %125 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %124)
  tail call void @exit(i32 noundef -1) #15
  unreachable

126:                                              ; preds = %110, %121
  %127 = phi i32 [ %122, %121 ], [ %111, %110 ]
  %128 = phi ptr [ %119, %121 ], [ %106, %110 ]
  %129 = sub nsw i64 %104, %105
  %130 = sitofp i64 %129 to double
  %131 = fdiv double %130, 1.000000e+06
  %132 = sext i32 %127 to i64
  %133 = getelementptr inbounds %struct.one_result, ptr %128, i64 %132
  store double %131, ptr %133, align 8, !tbaa !11
  %134 = getelementptr inbounds %struct.one_result, ptr %128, i64 %132, i32 1
  store ptr %6, ptr %134, align 8, !tbaa !14
  %135 = add nsw i32 %127, 1
  store i32 %135, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1Id24custom_multiply_variableIdEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, double noundef %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !26
  %6 = load i32, ptr @iterations, align 4, !tbaa !9
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %101

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  br i1 %9, label %12, label %10

10:                                               ; preds = %8
  %11 = load double, ptr @init_value, align 8, !tbaa !28
  br label %82

12:                                               ; preds = %8
  %13 = zext i32 %1 to i64
  %14 = and i64 %13, 3
  %15 = icmp ult i32 %1, 4
  %16 = and i64 %13, 4294967292
  %17 = icmp eq i64 %14, 0
  br label %18

18:                                               ; preds = %12, %25
  %19 = phi i32 [ %26, %25 ], [ %6, %12 ]
  %20 = phi i32 [ %27, %25 ], [ 0, %12 ]
  br i1 %15, label %55, label %29

21:                                               ; preds = %70
  %22 = load i32, ptr @current_test, align 4, !tbaa !9
  %23 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %22)
  %24 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %25

25:                                               ; preds = %21, %70
  %26 = phi i32 [ %24, %21 ], [ %19, %70 ]
  %27 = add nuw nsw i32 %20, 1
  %28 = icmp slt i32 %27, %26
  br i1 %28, label %18, label %101, !llvm.loop !537

29:                                               ; preds = %18, %29
  %30 = phi i64 [ %52, %29 ], [ 0, %18 ]
  %31 = phi double [ %51, %29 ], [ 0.000000e+00, %18 ]
  %32 = phi i64 [ %53, %29 ], [ 0, %18 ]
  %33 = getelementptr inbounds double, ptr %0, i64 %30
  %34 = load double, ptr %33, align 8, !tbaa !28
  %35 = fmul double %34, %2
  %36 = fadd double %31, %35
  %37 = or i64 %30, 1
  %38 = getelementptr inbounds double, ptr %0, i64 %37
  %39 = load double, ptr %38, align 8, !tbaa !28
  %40 = fmul double %39, %2
  %41 = fadd double %36, %40
  %42 = or i64 %30, 2
  %43 = getelementptr inbounds double, ptr %0, i64 %42
  %44 = load double, ptr %43, align 8, !tbaa !28
  %45 = fmul double %44, %2
  %46 = fadd double %41, %45
  %47 = or i64 %30, 3
  %48 = getelementptr inbounds double, ptr %0, i64 %47
  %49 = load double, ptr %48, align 8, !tbaa !28
  %50 = fmul double %49, %2
  %51 = fadd double %46, %50
  %52 = add nuw nsw i64 %30, 4
  %53 = add i64 %32, 4
  %54 = icmp eq i64 %53, %16
  br i1 %54, label %55, label %29, !llvm.loop !538

55:                                               ; preds = %29, %18
  %56 = phi double [ undef, %18 ], [ %51, %29 ]
  %57 = phi i64 [ 0, %18 ], [ %52, %29 ]
  %58 = phi double [ 0.000000e+00, %18 ], [ %51, %29 ]
  br i1 %17, label %70, label %59

59:                                               ; preds = %55, %59
  %60 = phi i64 [ %67, %59 ], [ %57, %55 ]
  %61 = phi double [ %66, %59 ], [ %58, %55 ]
  %62 = phi i64 [ %68, %59 ], [ 0, %55 ]
  %63 = getelementptr inbounds double, ptr %0, i64 %60
  %64 = load double, ptr %63, align 8, !tbaa !28
  %65 = fmul double %64, %2
  %66 = fadd double %61, %65
  %67 = add nuw nsw i64 %60, 1
  %68 = add i64 %62, 1
  %69 = icmp eq i64 %68, %14
  br i1 %69, label %70, label %59, !llvm.loop !539

70:                                               ; preds = %59, %55
  %71 = phi double [ %56, %55 ], [ %66, %59 ]
  %72 = load double, ptr @init_value, align 8, !tbaa !28
  %73 = fmul double %72, %2
  %74 = fmul double %73, 8.000000e+03
  %75 = fsub double %71, %74
  %76 = tail call double @llvm.fabs.f64(double %71)
  %77 = fcmp ogt double %76, 1.000000e-08
  %78 = select i1 %77, double %71, double 1.000000e+00
  %79 = fdiv double %75, %78
  %80 = tail call double @llvm.fabs.f64(double %79)
  %81 = fcmp olt double %80, 0x3EB0C6F7A0B5ED8D
  br i1 %81, label %25, label %21

82:                                               ; preds = %10, %96
  %83 = phi i32 [ %97, %96 ], [ %6, %10 ]
  %84 = phi double [ %98, %96 ], [ %11, %10 ]
  %85 = phi i32 [ %99, %96 ], [ 0, %10 ]
  %86 = fmul double %84, %2
  %87 = fmul double %86, 8.000000e+03
  %88 = fsub double 0.000000e+00, %87
  %89 = tail call double @llvm.fabs.f64(double %88)
  %90 = fcmp olt double %89, 0x3EB0C6F7A0B5ED8D
  br i1 %90, label %96, label %91

91:                                               ; preds = %82
  %92 = load i32, ptr @current_test, align 4, !tbaa !9
  %93 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %92)
  %94 = load double, ptr @init_value, align 8, !tbaa !28
  %95 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %96

96:                                               ; preds = %82, %91
  %97 = phi i32 [ %83, %82 ], [ %95, %91 ]
  %98 = phi double [ %84, %82 ], [ %94, %91 ]
  %99 = add nuw nsw i32 %85, 1
  %100 = icmp slt i32 %99, %97
  br i1 %100, label %82, label %101, !llvm.loop !537

101:                                              ; preds = %96, %25, %4
  %102 = tail call i64 @clock() #17
  store i64 %102, ptr @end_time, align 8, !tbaa !26
  %103 = load i64, ptr @start_time, align 8, !tbaa !26
  %104 = load ptr, ptr @results, align 8, !tbaa !5
  %105 = icmp eq ptr %104, null
  br i1 %105, label %106, label %108

106:                                              ; preds = %101
  %107 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %112

108:                                              ; preds = %101
  %109 = load i32, ptr @current_test, align 4, !tbaa !9
  %110 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %111 = icmp slt i32 %109, %110
  br i1 %111, label %124, label %112

112:                                              ; preds = %108, %106
  %113 = phi i32 [ %107, %106 ], [ %110, %108 ]
  %114 = add nsw i32 %113, 10
  store i32 %114, ptr @allocated_results, align 4, !tbaa !9
  %115 = sext i32 %114 to i64
  %116 = shl nsw i64 %115, 4
  %117 = tail call ptr @realloc(ptr noundef %104, i64 noundef %116) #14
  store ptr %117, ptr @results, align 8, !tbaa !5
  %118 = icmp eq ptr %117, null
  br i1 %118, label %121, label %119

119:                                              ; preds = %112
  %120 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %124

121:                                              ; preds = %112
  %122 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %123 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %122)
  tail call void @exit(i32 noundef -1) #15
  unreachable

124:                                              ; preds = %108, %119
  %125 = phi i32 [ %120, %119 ], [ %109, %108 ]
  %126 = phi ptr [ %117, %119 ], [ %104, %108 ]
  %127 = sub nsw i64 %102, %103
  %128 = sitofp i64 %127 to double
  %129 = fdiv double %128, 1.000000e+06
  %130 = sext i32 %125 to i64
  %131 = getelementptr inbounds %struct.one_result, ptr %126, i64 %130
  store double %129, ptr %131, align 8, !tbaa !11
  %132 = getelementptr inbounds %struct.one_result, ptr %126, i64 %130, i32 1
  store ptr %3, ptr %132, align 8, !tbaa !14
  %133 = add nsw i32 %125, 1
  store i32 %133, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Id33custom_multiply_multiple_variableIdEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, double noundef %2, double noundef %3, double noundef %4, double noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !26
  %9 = load i32, ptr @iterations, align 4, !tbaa !9
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %103

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  br i1 %12, label %15, label %13

13:                                               ; preds = %11
  %14 = load double, ptr @init_value, align 8, !tbaa !28
  br label %81

15:                                               ; preds = %11
  %16 = zext i32 %1 to i64
  %17 = and i64 %16, 1
  %18 = icmp eq i32 %1, 1
  %19 = and i64 %16, 4294967294
  %20 = icmp eq i64 %17, 0
  br label %21

21:                                               ; preds = %15, %28
  %22 = phi i32 [ %29, %28 ], [ %9, %15 ]
  %23 = phi i32 [ %30, %28 ], [ 0, %15 ]
  br i1 %18, label %54, label %32

24:                                               ; preds = %66
  %25 = load i32, ptr @current_test, align 4, !tbaa !9
  %26 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %25)
  %27 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %28

28:                                               ; preds = %24, %66
  %29 = phi i32 [ %27, %24 ], [ %22, %66 ]
  %30 = add nuw nsw i32 %23, 1
  %31 = icmp slt i32 %30, %29
  br i1 %31, label %21, label %103, !llvm.loop !540

32:                                               ; preds = %21, %32
  %33 = phi i64 [ %51, %32 ], [ 0, %21 ]
  %34 = phi double [ %50, %32 ], [ 0.000000e+00, %21 ]
  %35 = phi i64 [ %52, %32 ], [ 0, %21 ]
  %36 = getelementptr inbounds double, ptr %0, i64 %33
  %37 = load double, ptr %36, align 8, !tbaa !28
  %38 = fmul double %37, %2
  %39 = fmul double %38, %3
  %40 = fmul double %39, %4
  %41 = fmul double %40, %5
  %42 = fadd double %34, %41
  %43 = or i64 %33, 1
  %44 = getelementptr inbounds double, ptr %0, i64 %43
  %45 = load double, ptr %44, align 8, !tbaa !28
  %46 = fmul double %45, %2
  %47 = fmul double %46, %3
  %48 = fmul double %47, %4
  %49 = fmul double %48, %5
  %50 = fadd double %42, %49
  %51 = add nuw nsw i64 %33, 2
  %52 = add i64 %35, 2
  %53 = icmp eq i64 %52, %19
  br i1 %53, label %54, label %32, !llvm.loop !541

54:                                               ; preds = %32, %21
  %55 = phi double [ undef, %21 ], [ %50, %32 ]
  %56 = phi i64 [ 0, %21 ], [ %51, %32 ]
  %57 = phi double [ 0.000000e+00, %21 ], [ %50, %32 ]
  br i1 %20, label %66, label %58

58:                                               ; preds = %54
  %59 = getelementptr inbounds double, ptr %0, i64 %56
  %60 = load double, ptr %59, align 8, !tbaa !28
  %61 = fmul double %60, %2
  %62 = fmul double %61, %3
  %63 = fmul double %62, %4
  %64 = fmul double %63, %5
  %65 = fadd double %57, %64
  br label %66

66:                                               ; preds = %54, %58
  %67 = phi double [ %55, %54 ], [ %65, %58 ]
  %68 = load double, ptr @init_value, align 8, !tbaa !28
  %69 = fmul double %68, %2
  %70 = fmul double %69, %3
  %71 = fmul double %70, %4
  %72 = fmul double %71, %5
  %73 = fmul double %72, 8.000000e+03
  %74 = fsub double %67, %73
  %75 = tail call double @llvm.fabs.f64(double %67)
  %76 = fcmp ogt double %75, 1.000000e-08
  %77 = select i1 %76, double %67, double 1.000000e+00
  %78 = fdiv double %74, %77
  %79 = tail call double @llvm.fabs.f64(double %78)
  %80 = fcmp olt double %79, 0x3EB0C6F7A0B5ED8D
  br i1 %80, label %28, label %24

81:                                               ; preds = %13, %98
  %82 = phi i32 [ %99, %98 ], [ %9, %13 ]
  %83 = phi double [ %100, %98 ], [ %14, %13 ]
  %84 = phi i32 [ %101, %98 ], [ 0, %13 ]
  %85 = fmul double %83, %2
  %86 = fmul double %85, %3
  %87 = fmul double %86, %4
  %88 = fmul double %87, %5
  %89 = fmul double %88, 8.000000e+03
  %90 = fsub double 0.000000e+00, %89
  %91 = tail call double @llvm.fabs.f64(double %90)
  %92 = fcmp olt double %91, 0x3EB0C6F7A0B5ED8D
  br i1 %92, label %98, label %93

93:                                               ; preds = %81
  %94 = load i32, ptr @current_test, align 4, !tbaa !9
  %95 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %94)
  %96 = load double, ptr @init_value, align 8, !tbaa !28
  %97 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %98

98:                                               ; preds = %81, %93
  %99 = phi i32 [ %82, %81 ], [ %97, %93 ]
  %100 = phi double [ %83, %81 ], [ %96, %93 ]
  %101 = add nuw nsw i32 %84, 1
  %102 = icmp slt i32 %101, %99
  br i1 %102, label %81, label %103, !llvm.loop !540

103:                                              ; preds = %98, %28, %7
  %104 = tail call i64 @clock() #17
  store i64 %104, ptr @end_time, align 8, !tbaa !26
  %105 = load i64, ptr @start_time, align 8, !tbaa !26
  %106 = load ptr, ptr @results, align 8, !tbaa !5
  %107 = icmp eq ptr %106, null
  br i1 %107, label %108, label %110

108:                                              ; preds = %103
  %109 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %114

110:                                              ; preds = %103
  %111 = load i32, ptr @current_test, align 4, !tbaa !9
  %112 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %113 = icmp slt i32 %111, %112
  br i1 %113, label %126, label %114

114:                                              ; preds = %110, %108
  %115 = phi i32 [ %109, %108 ], [ %112, %110 ]
  %116 = add nsw i32 %115, 10
  store i32 %116, ptr @allocated_results, align 4, !tbaa !9
  %117 = sext i32 %116 to i64
  %118 = shl nsw i64 %117, 4
  %119 = tail call ptr @realloc(ptr noundef %106, i64 noundef %118) #14
  store ptr %119, ptr @results, align 8, !tbaa !5
  %120 = icmp eq ptr %119, null
  br i1 %120, label %123, label %121

121:                                              ; preds = %114
  %122 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %126

123:                                              ; preds = %114
  %124 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %125 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %124)
  tail call void @exit(i32 noundef -1) #15
  unreachable

126:                                              ; preds = %110, %121
  %127 = phi i32 [ %122, %121 ], [ %111, %110 ]
  %128 = phi ptr [ %119, %121 ], [ %106, %110 ]
  %129 = sub nsw i64 %104, %105
  %130 = sitofp i64 %129 to double
  %131 = fdiv double %130, 1.000000e+06
  %132 = sext i32 %127 to i64
  %133 = getelementptr inbounds %struct.one_result, ptr %128, i64 %132
  store double %131, ptr %133, align 8, !tbaa !11
  %134 = getelementptr inbounds %struct.one_result, ptr %128, i64 %132, i32 1
  store ptr %6, ptr %134, align 8, !tbaa !14
  %135 = add nsw i32 %127, 1
  store i32 %135, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Id34custom_multiply_multiple_variable2IdEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, double noundef %2, double noundef %3, double noundef %4, double noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !26
  %9 = load i32, ptr @iterations, align 4, !tbaa !9
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %106

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  %13 = fmul double %2, %3
  %14 = fmul double %13, %4
  br i1 %12, label %17, label %15

15:                                               ; preds = %11
  %16 = load double, ptr @init_value, align 8, !tbaa !28
  br label %87

17:                                               ; preds = %11
  %18 = zext i32 %1 to i64
  %19 = and i64 %18, 3
  %20 = icmp ult i32 %1, 4
  %21 = and i64 %18, 4294967292
  %22 = icmp eq i64 %19, 0
  br label %23

23:                                               ; preds = %17, %30
  %24 = phi i32 [ %31, %30 ], [ %9, %17 ]
  %25 = phi i32 [ %32, %30 ], [ 0, %17 ]
  br i1 %20, label %60, label %34

26:                                               ; preds = %75
  %27 = load i32, ptr @current_test, align 4, !tbaa !9
  %28 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %27)
  %29 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %30

30:                                               ; preds = %26, %75
  %31 = phi i32 [ %29, %26 ], [ %24, %75 ]
  %32 = add nuw nsw i32 %25, 1
  %33 = icmp slt i32 %32, %31
  br i1 %33, label %23, label %106, !llvm.loop !542

34:                                               ; preds = %23, %34
  %35 = phi i64 [ %57, %34 ], [ 0, %23 ]
  %36 = phi double [ %56, %34 ], [ 0.000000e+00, %23 ]
  %37 = phi i64 [ %58, %34 ], [ 0, %23 ]
  %38 = getelementptr inbounds double, ptr %0, i64 %35
  %39 = load double, ptr %38, align 8, !tbaa !28
  %40 = tail call double @llvm.fmuladd.f64(double %14, double %5, double %39)
  %41 = fadd double %36, %40
  %42 = or i64 %35, 1
  %43 = getelementptr inbounds double, ptr %0, i64 %42
  %44 = load double, ptr %43, align 8, !tbaa !28
  %45 = tail call double @llvm.fmuladd.f64(double %14, double %5, double %44)
  %46 = fadd double %41, %45
  %47 = or i64 %35, 2
  %48 = getelementptr inbounds double, ptr %0, i64 %47
  %49 = load double, ptr %48, align 8, !tbaa !28
  %50 = tail call double @llvm.fmuladd.f64(double %14, double %5, double %49)
  %51 = fadd double %46, %50
  %52 = or i64 %35, 3
  %53 = getelementptr inbounds double, ptr %0, i64 %52
  %54 = load double, ptr %53, align 8, !tbaa !28
  %55 = tail call double @llvm.fmuladd.f64(double %14, double %5, double %54)
  %56 = fadd double %51, %55
  %57 = add nuw nsw i64 %35, 4
  %58 = add i64 %37, 4
  %59 = icmp eq i64 %58, %21
  br i1 %59, label %60, label %34, !llvm.loop !543

60:                                               ; preds = %34, %23
  %61 = phi double [ undef, %23 ], [ %56, %34 ]
  %62 = phi i64 [ 0, %23 ], [ %57, %34 ]
  %63 = phi double [ 0.000000e+00, %23 ], [ %56, %34 ]
  br i1 %22, label %75, label %64

64:                                               ; preds = %60, %64
  %65 = phi i64 [ %72, %64 ], [ %62, %60 ]
  %66 = phi double [ %71, %64 ], [ %63, %60 ]
  %67 = phi i64 [ %73, %64 ], [ 0, %60 ]
  %68 = getelementptr inbounds double, ptr %0, i64 %65
  %69 = load double, ptr %68, align 8, !tbaa !28
  %70 = tail call double @llvm.fmuladd.f64(double %14, double %5, double %69)
  %71 = fadd double %66, %70
  %72 = add nuw nsw i64 %65, 1
  %73 = add i64 %67, 1
  %74 = icmp eq i64 %73, %19
  br i1 %74, label %75, label %64, !llvm.loop !544

75:                                               ; preds = %64, %60
  %76 = phi double [ %61, %60 ], [ %71, %64 ]
  %77 = load double, ptr @init_value, align 8, !tbaa !28
  %78 = tail call double @llvm.fmuladd.f64(double %14, double %5, double %77)
  %79 = fmul double %78, 8.000000e+03
  %80 = fsub double %76, %79
  %81 = tail call double @llvm.fabs.f64(double %76)
  %82 = fcmp ogt double %81, 1.000000e-08
  %83 = select i1 %82, double %76, double 1.000000e+00
  %84 = fdiv double %80, %83
  %85 = tail call double @llvm.fabs.f64(double %84)
  %86 = fcmp olt double %85, 0x3EB0C6F7A0B5ED8D
  br i1 %86, label %30, label %26

87:                                               ; preds = %15, %101
  %88 = phi i32 [ %102, %101 ], [ %9, %15 ]
  %89 = phi double [ %103, %101 ], [ %16, %15 ]
  %90 = phi i32 [ %104, %101 ], [ 0, %15 ]
  %91 = tail call double @llvm.fmuladd.f64(double %14, double %5, double %89)
  %92 = fmul double %91, 8.000000e+03
  %93 = fsub double 0.000000e+00, %92
  %94 = tail call double @llvm.fabs.f64(double %93)
  %95 = fcmp olt double %94, 0x3EB0C6F7A0B5ED8D
  br i1 %95, label %101, label %96

96:                                               ; preds = %87
  %97 = load i32, ptr @current_test, align 4, !tbaa !9
  %98 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %97)
  %99 = load double, ptr @init_value, align 8, !tbaa !28
  %100 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %101

101:                                              ; preds = %87, %96
  %102 = phi i32 [ %88, %87 ], [ %100, %96 ]
  %103 = phi double [ %89, %87 ], [ %99, %96 ]
  %104 = add nuw nsw i32 %90, 1
  %105 = icmp slt i32 %104, %102
  br i1 %105, label %87, label %106, !llvm.loop !542

106:                                              ; preds = %101, %30, %7
  %107 = tail call i64 @clock() #17
  store i64 %107, ptr @end_time, align 8, !tbaa !26
  %108 = load i64, ptr @start_time, align 8, !tbaa !26
  %109 = load ptr, ptr @results, align 8, !tbaa !5
  %110 = icmp eq ptr %109, null
  br i1 %110, label %111, label %113

111:                                              ; preds = %106
  %112 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %117

113:                                              ; preds = %106
  %114 = load i32, ptr @current_test, align 4, !tbaa !9
  %115 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %116 = icmp slt i32 %114, %115
  br i1 %116, label %129, label %117

117:                                              ; preds = %113, %111
  %118 = phi i32 [ %112, %111 ], [ %115, %113 ]
  %119 = add nsw i32 %118, 10
  store i32 %119, ptr @allocated_results, align 4, !tbaa !9
  %120 = sext i32 %119 to i64
  %121 = shl nsw i64 %120, 4
  %122 = tail call ptr @realloc(ptr noundef %109, i64 noundef %121) #14
  store ptr %122, ptr @results, align 8, !tbaa !5
  %123 = icmp eq ptr %122, null
  br i1 %123, label %126, label %124

124:                                              ; preds = %117
  %125 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %129

126:                                              ; preds = %117
  %127 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %128 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %127)
  tail call void @exit(i32 noundef -1) #15
  unreachable

129:                                              ; preds = %113, %124
  %130 = phi i32 [ %125, %124 ], [ %114, %113 ]
  %131 = phi ptr [ %122, %124 ], [ %109, %113 ]
  %132 = sub nsw i64 %107, %108
  %133 = sitofp i64 %132 to double
  %134 = fdiv double %133, 1.000000e+06
  %135 = sext i32 %130 to i64
  %136 = getelementptr inbounds %struct.one_result, ptr %131, i64 %135
  store double %134, ptr %136, align 8, !tbaa !11
  %137 = getelementptr inbounds %struct.one_result, ptr %131, i64 %135, i32 1
  store ptr %6, ptr %137, align 8, !tbaa !14
  %138 = add nsw i32 %130, 1
  store i32 %138, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable1Id22custom_divide_variableIdEEvPT_iS2_PKc(ptr noundef %0, i32 noundef %1, double noundef %2, ptr noundef %3) local_unnamed_addr #9 comdat {
  %5 = tail call i64 @clock() #17
  store i64 %5, ptr @start_time, align 8, !tbaa !26
  %6 = load i32, ptr @iterations, align 4, !tbaa !9
  %7 = icmp sgt i32 %6, 0
  br i1 %7, label %8, label %101

8:                                                ; preds = %4
  %9 = icmp sgt i32 %1, 0
  br i1 %9, label %12, label %10

10:                                               ; preds = %8
  %11 = load double, ptr @init_value, align 8, !tbaa !28
  br label %82

12:                                               ; preds = %8
  %13 = zext i32 %1 to i64
  %14 = and i64 %13, 3
  %15 = icmp ult i32 %1, 4
  %16 = and i64 %13, 4294967292
  %17 = icmp eq i64 %14, 0
  br label %18

18:                                               ; preds = %12, %25
  %19 = phi i32 [ %26, %25 ], [ %6, %12 ]
  %20 = phi i32 [ %27, %25 ], [ 0, %12 ]
  br i1 %15, label %55, label %29

21:                                               ; preds = %70
  %22 = load i32, ptr @current_test, align 4, !tbaa !9
  %23 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %22)
  %24 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %25

25:                                               ; preds = %21, %70
  %26 = phi i32 [ %24, %21 ], [ %19, %70 ]
  %27 = add nuw nsw i32 %20, 1
  %28 = icmp slt i32 %27, %26
  br i1 %28, label %18, label %101, !llvm.loop !545

29:                                               ; preds = %18, %29
  %30 = phi i64 [ %52, %29 ], [ 0, %18 ]
  %31 = phi double [ %51, %29 ], [ 0.000000e+00, %18 ]
  %32 = phi i64 [ %53, %29 ], [ 0, %18 ]
  %33 = getelementptr inbounds double, ptr %0, i64 %30
  %34 = load double, ptr %33, align 8, !tbaa !28
  %35 = fdiv double %34, %2
  %36 = fadd double %31, %35
  %37 = or i64 %30, 1
  %38 = getelementptr inbounds double, ptr %0, i64 %37
  %39 = load double, ptr %38, align 8, !tbaa !28
  %40 = fdiv double %39, %2
  %41 = fadd double %36, %40
  %42 = or i64 %30, 2
  %43 = getelementptr inbounds double, ptr %0, i64 %42
  %44 = load double, ptr %43, align 8, !tbaa !28
  %45 = fdiv double %44, %2
  %46 = fadd double %41, %45
  %47 = or i64 %30, 3
  %48 = getelementptr inbounds double, ptr %0, i64 %47
  %49 = load double, ptr %48, align 8, !tbaa !28
  %50 = fdiv double %49, %2
  %51 = fadd double %46, %50
  %52 = add nuw nsw i64 %30, 4
  %53 = add i64 %32, 4
  %54 = icmp eq i64 %53, %16
  br i1 %54, label %55, label %29, !llvm.loop !546

55:                                               ; preds = %29, %18
  %56 = phi double [ undef, %18 ], [ %51, %29 ]
  %57 = phi i64 [ 0, %18 ], [ %52, %29 ]
  %58 = phi double [ 0.000000e+00, %18 ], [ %51, %29 ]
  br i1 %17, label %70, label %59

59:                                               ; preds = %55, %59
  %60 = phi i64 [ %67, %59 ], [ %57, %55 ]
  %61 = phi double [ %66, %59 ], [ %58, %55 ]
  %62 = phi i64 [ %68, %59 ], [ 0, %55 ]
  %63 = getelementptr inbounds double, ptr %0, i64 %60
  %64 = load double, ptr %63, align 8, !tbaa !28
  %65 = fdiv double %64, %2
  %66 = fadd double %61, %65
  %67 = add nuw nsw i64 %60, 1
  %68 = add i64 %62, 1
  %69 = icmp eq i64 %68, %14
  br i1 %69, label %70, label %59, !llvm.loop !547

70:                                               ; preds = %59, %55
  %71 = phi double [ %56, %55 ], [ %66, %59 ]
  %72 = load double, ptr @init_value, align 8, !tbaa !28
  %73 = fdiv double %72, %2
  %74 = fmul double %73, 8.000000e+03
  %75 = fsub double %71, %74
  %76 = tail call double @llvm.fabs.f64(double %71)
  %77 = fcmp ogt double %76, 1.000000e-08
  %78 = select i1 %77, double %71, double 1.000000e+00
  %79 = fdiv double %75, %78
  %80 = tail call double @llvm.fabs.f64(double %79)
  %81 = fcmp olt double %80, 0x3EB0C6F7A0B5ED8D
  br i1 %81, label %25, label %21

82:                                               ; preds = %10, %96
  %83 = phi i32 [ %97, %96 ], [ %6, %10 ]
  %84 = phi double [ %98, %96 ], [ %11, %10 ]
  %85 = phi i32 [ %99, %96 ], [ 0, %10 ]
  %86 = fdiv double %84, %2
  %87 = fmul double %86, 8.000000e+03
  %88 = fsub double 0.000000e+00, %87
  %89 = tail call double @llvm.fabs.f64(double %88)
  %90 = fcmp olt double %89, 0x3EB0C6F7A0B5ED8D
  br i1 %90, label %96, label %91

91:                                               ; preds = %82
  %92 = load i32, ptr @current_test, align 4, !tbaa !9
  %93 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %92)
  %94 = load double, ptr @init_value, align 8, !tbaa !28
  %95 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %96

96:                                               ; preds = %82, %91
  %97 = phi i32 [ %83, %82 ], [ %95, %91 ]
  %98 = phi double [ %84, %82 ], [ %94, %91 ]
  %99 = add nuw nsw i32 %85, 1
  %100 = icmp slt i32 %99, %97
  br i1 %100, label %82, label %101, !llvm.loop !545

101:                                              ; preds = %96, %25, %4
  %102 = tail call i64 @clock() #17
  store i64 %102, ptr @end_time, align 8, !tbaa !26
  %103 = load i64, ptr @start_time, align 8, !tbaa !26
  %104 = load ptr, ptr @results, align 8, !tbaa !5
  %105 = icmp eq ptr %104, null
  br i1 %105, label %106, label %108

106:                                              ; preds = %101
  %107 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %112

108:                                              ; preds = %101
  %109 = load i32, ptr @current_test, align 4, !tbaa !9
  %110 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %111 = icmp slt i32 %109, %110
  br i1 %111, label %124, label %112

112:                                              ; preds = %108, %106
  %113 = phi i32 [ %107, %106 ], [ %110, %108 ]
  %114 = add nsw i32 %113, 10
  store i32 %114, ptr @allocated_results, align 4, !tbaa !9
  %115 = sext i32 %114 to i64
  %116 = shl nsw i64 %115, 4
  %117 = tail call ptr @realloc(ptr noundef %104, i64 noundef %116) #14
  store ptr %117, ptr @results, align 8, !tbaa !5
  %118 = icmp eq ptr %117, null
  br i1 %118, label %121, label %119

119:                                              ; preds = %112
  %120 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %124

121:                                              ; preds = %112
  %122 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %123 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %122)
  tail call void @exit(i32 noundef -1) #15
  unreachable

124:                                              ; preds = %108, %119
  %125 = phi i32 [ %120, %119 ], [ %109, %108 ]
  %126 = phi ptr [ %117, %119 ], [ %104, %108 ]
  %127 = sub nsw i64 %102, %103
  %128 = sitofp i64 %127 to double
  %129 = fdiv double %128, 1.000000e+06
  %130 = sext i32 %125 to i64
  %131 = getelementptr inbounds %struct.one_result, ptr %126, i64 %130
  store double %129, ptr %131, align 8, !tbaa !11
  %132 = getelementptr inbounds %struct.one_result, ptr %126, i64 %130, i32 1
  store ptr %3, ptr %132, align 8, !tbaa !14
  %133 = add nsw i32 %125, 1
  store i32 %133, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Id31custom_divide_multiple_variableIdEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, double noundef %2, double noundef %3, double noundef %4, double noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !26
  %9 = load i32, ptr @iterations, align 4, !tbaa !9
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %103

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  br i1 %12, label %15, label %13

13:                                               ; preds = %11
  %14 = load double, ptr @init_value, align 8, !tbaa !28
  br label %81

15:                                               ; preds = %11
  %16 = zext i32 %1 to i64
  %17 = and i64 %16, 1
  %18 = icmp eq i32 %1, 1
  %19 = and i64 %16, 4294967294
  %20 = icmp eq i64 %17, 0
  br label %21

21:                                               ; preds = %15, %28
  %22 = phi i32 [ %29, %28 ], [ %9, %15 ]
  %23 = phi i32 [ %30, %28 ], [ 0, %15 ]
  br i1 %18, label %54, label %32

24:                                               ; preds = %66
  %25 = load i32, ptr @current_test, align 4, !tbaa !9
  %26 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %25)
  %27 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %28

28:                                               ; preds = %24, %66
  %29 = phi i32 [ %27, %24 ], [ %22, %66 ]
  %30 = add nuw nsw i32 %23, 1
  %31 = icmp slt i32 %30, %29
  br i1 %31, label %21, label %103, !llvm.loop !548

32:                                               ; preds = %21, %32
  %33 = phi i64 [ %51, %32 ], [ 0, %21 ]
  %34 = phi double [ %50, %32 ], [ 0.000000e+00, %21 ]
  %35 = phi i64 [ %52, %32 ], [ 0, %21 ]
  %36 = getelementptr inbounds double, ptr %0, i64 %33
  %37 = load double, ptr %36, align 8, !tbaa !28
  %38 = fdiv double %37, %2
  %39 = fdiv double %38, %3
  %40 = fdiv double %39, %4
  %41 = fdiv double %40, %5
  %42 = fadd double %34, %41
  %43 = or i64 %33, 1
  %44 = getelementptr inbounds double, ptr %0, i64 %43
  %45 = load double, ptr %44, align 8, !tbaa !28
  %46 = fdiv double %45, %2
  %47 = fdiv double %46, %3
  %48 = fdiv double %47, %4
  %49 = fdiv double %48, %5
  %50 = fadd double %42, %49
  %51 = add nuw nsw i64 %33, 2
  %52 = add i64 %35, 2
  %53 = icmp eq i64 %52, %19
  br i1 %53, label %54, label %32, !llvm.loop !549

54:                                               ; preds = %32, %21
  %55 = phi double [ undef, %21 ], [ %50, %32 ]
  %56 = phi i64 [ 0, %21 ], [ %51, %32 ]
  %57 = phi double [ 0.000000e+00, %21 ], [ %50, %32 ]
  br i1 %20, label %66, label %58

58:                                               ; preds = %54
  %59 = getelementptr inbounds double, ptr %0, i64 %56
  %60 = load double, ptr %59, align 8, !tbaa !28
  %61 = fdiv double %60, %2
  %62 = fdiv double %61, %3
  %63 = fdiv double %62, %4
  %64 = fdiv double %63, %5
  %65 = fadd double %57, %64
  br label %66

66:                                               ; preds = %54, %58
  %67 = phi double [ %55, %54 ], [ %65, %58 ]
  %68 = load double, ptr @init_value, align 8, !tbaa !28
  %69 = fdiv double %68, %2
  %70 = fdiv double %69, %3
  %71 = fdiv double %70, %4
  %72 = fdiv double %71, %5
  %73 = fmul double %72, 8.000000e+03
  %74 = fsub double %67, %73
  %75 = tail call double @llvm.fabs.f64(double %67)
  %76 = fcmp ogt double %75, 1.000000e-08
  %77 = select i1 %76, double %67, double 1.000000e+00
  %78 = fdiv double %74, %77
  %79 = tail call double @llvm.fabs.f64(double %78)
  %80 = fcmp olt double %79, 0x3EB0C6F7A0B5ED8D
  br i1 %80, label %28, label %24

81:                                               ; preds = %13, %98
  %82 = phi i32 [ %99, %98 ], [ %9, %13 ]
  %83 = phi double [ %100, %98 ], [ %14, %13 ]
  %84 = phi i32 [ %101, %98 ], [ 0, %13 ]
  %85 = fdiv double %83, %2
  %86 = fdiv double %85, %3
  %87 = fdiv double %86, %4
  %88 = fdiv double %87, %5
  %89 = fmul double %88, 8.000000e+03
  %90 = fsub double 0.000000e+00, %89
  %91 = tail call double @llvm.fabs.f64(double %90)
  %92 = fcmp olt double %91, 0x3EB0C6F7A0B5ED8D
  br i1 %92, label %98, label %93

93:                                               ; preds = %81
  %94 = load i32, ptr @current_test, align 4, !tbaa !9
  %95 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %94)
  %96 = load double, ptr @init_value, align 8, !tbaa !28
  %97 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %98

98:                                               ; preds = %81, %93
  %99 = phi i32 [ %82, %81 ], [ %97, %93 ]
  %100 = phi double [ %83, %81 ], [ %96, %93 ]
  %101 = add nuw nsw i32 %84, 1
  %102 = icmp slt i32 %101, %99
  br i1 %102, label %81, label %103, !llvm.loop !548

103:                                              ; preds = %98, %28, %7
  %104 = tail call i64 @clock() #17
  store i64 %104, ptr @end_time, align 8, !tbaa !26
  %105 = load i64, ptr @start_time, align 8, !tbaa !26
  %106 = load ptr, ptr @results, align 8, !tbaa !5
  %107 = icmp eq ptr %106, null
  br i1 %107, label %108, label %110

108:                                              ; preds = %103
  %109 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %114

110:                                              ; preds = %103
  %111 = load i32, ptr @current_test, align 4, !tbaa !9
  %112 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %113 = icmp slt i32 %111, %112
  br i1 %113, label %126, label %114

114:                                              ; preds = %110, %108
  %115 = phi i32 [ %109, %108 ], [ %112, %110 ]
  %116 = add nsw i32 %115, 10
  store i32 %116, ptr @allocated_results, align 4, !tbaa !9
  %117 = sext i32 %116 to i64
  %118 = shl nsw i64 %117, 4
  %119 = tail call ptr @realloc(ptr noundef %106, i64 noundef %118) #14
  store ptr %119, ptr @results, align 8, !tbaa !5
  %120 = icmp eq ptr %119, null
  br i1 %120, label %123, label %121

121:                                              ; preds = %114
  %122 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %126

123:                                              ; preds = %114
  %124 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %125 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %124)
  tail call void @exit(i32 noundef -1) #15
  unreachable

126:                                              ; preds = %110, %121
  %127 = phi i32 [ %122, %121 ], [ %111, %110 ]
  %128 = phi ptr [ %119, %121 ], [ %106, %110 ]
  %129 = sub nsw i64 %104, %105
  %130 = sitofp i64 %129 to double
  %131 = fdiv double %130, 1.000000e+06
  %132 = sext i32 %127 to i64
  %133 = getelementptr inbounds %struct.one_result, ptr %128, i64 %132
  store double %131, ptr %133, align 8, !tbaa !11
  %134 = getelementptr inbounds %struct.one_result, ptr %128, i64 %132, i32 1
  store ptr %6, ptr %134, align 8, !tbaa !14
  %135 = add nsw i32 %127, 1
  store i32 %135, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Id32custom_divide_multiple_variable2IdEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, double noundef %2, double noundef %3, double noundef %4, double noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !26
  %9 = load i32, ptr @iterations, align 4, !tbaa !9
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %107

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  %13 = fdiv double %2, %3
  %14 = fdiv double %13, %4
  %15 = fdiv double %14, %5
  br i1 %12, label %18, label %16

16:                                               ; preds = %11
  %17 = load double, ptr @init_value, align 8, !tbaa !28
  br label %88

18:                                               ; preds = %11
  %19 = zext i32 %1 to i64
  %20 = and i64 %19, 3
  %21 = icmp ult i32 %1, 4
  %22 = and i64 %19, 4294967292
  %23 = icmp eq i64 %20, 0
  br label %24

24:                                               ; preds = %18, %31
  %25 = phi i32 [ %32, %31 ], [ %9, %18 ]
  %26 = phi i32 [ %33, %31 ], [ 0, %18 ]
  br i1 %21, label %61, label %35

27:                                               ; preds = %76
  %28 = load i32, ptr @current_test, align 4, !tbaa !9
  %29 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %28)
  %30 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %31

31:                                               ; preds = %27, %76
  %32 = phi i32 [ %30, %27 ], [ %25, %76 ]
  %33 = add nuw nsw i32 %26, 1
  %34 = icmp slt i32 %33, %32
  br i1 %34, label %24, label %107, !llvm.loop !550

35:                                               ; preds = %24, %35
  %36 = phi i64 [ %58, %35 ], [ 0, %24 ]
  %37 = phi double [ %57, %35 ], [ 0.000000e+00, %24 ]
  %38 = phi i64 [ %59, %35 ], [ 0, %24 ]
  %39 = getelementptr inbounds double, ptr %0, i64 %36
  %40 = load double, ptr %39, align 8, !tbaa !28
  %41 = fadd double %15, %40
  %42 = fadd double %37, %41
  %43 = or i64 %36, 1
  %44 = getelementptr inbounds double, ptr %0, i64 %43
  %45 = load double, ptr %44, align 8, !tbaa !28
  %46 = fadd double %15, %45
  %47 = fadd double %42, %46
  %48 = or i64 %36, 2
  %49 = getelementptr inbounds double, ptr %0, i64 %48
  %50 = load double, ptr %49, align 8, !tbaa !28
  %51 = fadd double %15, %50
  %52 = fadd double %47, %51
  %53 = or i64 %36, 3
  %54 = getelementptr inbounds double, ptr %0, i64 %53
  %55 = load double, ptr %54, align 8, !tbaa !28
  %56 = fadd double %15, %55
  %57 = fadd double %52, %56
  %58 = add nuw nsw i64 %36, 4
  %59 = add i64 %38, 4
  %60 = icmp eq i64 %59, %22
  br i1 %60, label %61, label %35, !llvm.loop !551

61:                                               ; preds = %35, %24
  %62 = phi double [ undef, %24 ], [ %57, %35 ]
  %63 = phi i64 [ 0, %24 ], [ %58, %35 ]
  %64 = phi double [ 0.000000e+00, %24 ], [ %57, %35 ]
  br i1 %23, label %76, label %65

65:                                               ; preds = %61, %65
  %66 = phi i64 [ %73, %65 ], [ %63, %61 ]
  %67 = phi double [ %72, %65 ], [ %64, %61 ]
  %68 = phi i64 [ %74, %65 ], [ 0, %61 ]
  %69 = getelementptr inbounds double, ptr %0, i64 %66
  %70 = load double, ptr %69, align 8, !tbaa !28
  %71 = fadd double %15, %70
  %72 = fadd double %67, %71
  %73 = add nuw nsw i64 %66, 1
  %74 = add i64 %68, 1
  %75 = icmp eq i64 %74, %20
  br i1 %75, label %76, label %65, !llvm.loop !552

76:                                               ; preds = %65, %61
  %77 = phi double [ %62, %61 ], [ %72, %65 ]
  %78 = load double, ptr @init_value, align 8, !tbaa !28
  %79 = fadd double %15, %78
  %80 = fmul double %79, 8.000000e+03
  %81 = fsub double %77, %80
  %82 = tail call double @llvm.fabs.f64(double %77)
  %83 = fcmp ogt double %82, 1.000000e-08
  %84 = select i1 %83, double %77, double 1.000000e+00
  %85 = fdiv double %81, %84
  %86 = tail call double @llvm.fabs.f64(double %85)
  %87 = fcmp olt double %86, 0x3EB0C6F7A0B5ED8D
  br i1 %87, label %31, label %27

88:                                               ; preds = %16, %102
  %89 = phi i32 [ %103, %102 ], [ %9, %16 ]
  %90 = phi double [ %104, %102 ], [ %17, %16 ]
  %91 = phi i32 [ %105, %102 ], [ 0, %16 ]
  %92 = fadd double %15, %90
  %93 = fmul double %92, 8.000000e+03
  %94 = fsub double 0.000000e+00, %93
  %95 = tail call double @llvm.fabs.f64(double %94)
  %96 = fcmp olt double %95, 0x3EB0C6F7A0B5ED8D
  br i1 %96, label %102, label %97

97:                                               ; preds = %88
  %98 = load i32, ptr @current_test, align 4, !tbaa !9
  %99 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %98)
  %100 = load double, ptr @init_value, align 8, !tbaa !28
  %101 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %102

102:                                              ; preds = %88, %97
  %103 = phi i32 [ %89, %88 ], [ %101, %97 ]
  %104 = phi double [ %90, %88 ], [ %100, %97 ]
  %105 = add nuw nsw i32 %91, 1
  %106 = icmp slt i32 %105, %103
  br i1 %106, label %88, label %107, !llvm.loop !550

107:                                              ; preds = %102, %31, %7
  %108 = tail call i64 @clock() #17
  store i64 %108, ptr @end_time, align 8, !tbaa !26
  %109 = load i64, ptr @start_time, align 8, !tbaa !26
  %110 = load ptr, ptr @results, align 8, !tbaa !5
  %111 = icmp eq ptr %110, null
  br i1 %111, label %112, label %114

112:                                              ; preds = %107
  %113 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %118

114:                                              ; preds = %107
  %115 = load i32, ptr @current_test, align 4, !tbaa !9
  %116 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %117 = icmp slt i32 %115, %116
  br i1 %117, label %130, label %118

118:                                              ; preds = %114, %112
  %119 = phi i32 [ %113, %112 ], [ %116, %114 ]
  %120 = add nsw i32 %119, 10
  store i32 %120, ptr @allocated_results, align 4, !tbaa !9
  %121 = sext i32 %120 to i64
  %122 = shl nsw i64 %121, 4
  %123 = tail call ptr @realloc(ptr noundef %110, i64 noundef %122) #14
  store ptr %123, ptr @results, align 8, !tbaa !5
  %124 = icmp eq ptr %123, null
  br i1 %124, label %127, label %125

125:                                              ; preds = %118
  %126 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %130

127:                                              ; preds = %118
  %128 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %129 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %128)
  tail call void @exit(i32 noundef -1) #15
  unreachable

130:                                              ; preds = %114, %125
  %131 = phi i32 [ %126, %125 ], [ %115, %114 ]
  %132 = phi ptr [ %123, %125 ], [ %110, %114 ]
  %133 = sub nsw i64 %108, %109
  %134 = sitofp i64 %133 to double
  %135 = fdiv double %134, 1.000000e+06
  %136 = sext i32 %131 to i64
  %137 = getelementptr inbounds %struct.one_result, ptr %132, i64 %136
  store double %135, ptr %137, align 8, !tbaa !11
  %138 = getelementptr inbounds %struct.one_result, ptr %132, i64 %136, i32 1
  store ptr %6, ptr %138, align 8, !tbaa !14
  %139 = add nsw i32 %131, 1
  store i32 %139, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_Z14test_variable4Id30custom_mixed_multiple_variableIdEEvPT_iS2_S2_S2_S2_PKc(ptr noundef %0, i32 noundef %1, double noundef %2, double noundef %3, double noundef %4, double noundef %5, ptr noundef %6) local_unnamed_addr #9 comdat {
  %8 = tail call i64 @clock() #17
  store i64 %8, ptr @start_time, align 8, !tbaa !26
  %9 = load i32, ptr @iterations, align 4, !tbaa !9
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %113

11:                                               ; preds = %7
  %12 = icmp sgt i32 %1, 0
  %13 = fmul double %3, %4
  %14 = fdiv double %13, %5
  br i1 %12, label %17, label %15

15:                                               ; preds = %11
  %16 = load double, ptr @init_value, align 8, !tbaa !28
  br label %93

17:                                               ; preds = %11
  %18 = zext i32 %1 to i64
  %19 = and i64 %18, 3
  %20 = icmp ult i32 %1, 4
  %21 = and i64 %18, 4294967292
  %22 = icmp eq i64 %19, 0
  br label %23

23:                                               ; preds = %17, %30
  %24 = phi i32 [ %31, %30 ], [ %9, %17 ]
  %25 = phi i32 [ %32, %30 ], [ 0, %17 ]
  br i1 %20, label %64, label %34

26:                                               ; preds = %80
  %27 = load i32, ptr @current_test, align 4, !tbaa !9
  %28 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %27)
  %29 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %30

30:                                               ; preds = %26, %80
  %31 = phi i32 [ %29, %26 ], [ %24, %80 ]
  %32 = add nuw nsw i32 %25, 1
  %33 = icmp slt i32 %32, %31
  br i1 %33, label %23, label %113, !llvm.loop !553

34:                                               ; preds = %23, %34
  %35 = phi i64 [ %61, %34 ], [ 0, %23 ]
  %36 = phi double [ %60, %34 ], [ 0.000000e+00, %23 ]
  %37 = phi i64 [ %62, %34 ], [ 0, %23 ]
  %38 = getelementptr inbounds double, ptr %0, i64 %35
  %39 = load double, ptr %38, align 8, !tbaa !28
  %40 = fadd double %39, %2
  %41 = fsub double %40, %14
  %42 = fadd double %36, %41
  %43 = or i64 %35, 1
  %44 = getelementptr inbounds double, ptr %0, i64 %43
  %45 = load double, ptr %44, align 8, !tbaa !28
  %46 = fadd double %45, %2
  %47 = fsub double %46, %14
  %48 = fadd double %42, %47
  %49 = or i64 %35, 2
  %50 = getelementptr inbounds double, ptr %0, i64 %49
  %51 = load double, ptr %50, align 8, !tbaa !28
  %52 = fadd double %51, %2
  %53 = fsub double %52, %14
  %54 = fadd double %48, %53
  %55 = or i64 %35, 3
  %56 = getelementptr inbounds double, ptr %0, i64 %55
  %57 = load double, ptr %56, align 8, !tbaa !28
  %58 = fadd double %57, %2
  %59 = fsub double %58, %14
  %60 = fadd double %54, %59
  %61 = add nuw nsw i64 %35, 4
  %62 = add i64 %37, 4
  %63 = icmp eq i64 %62, %21
  br i1 %63, label %64, label %34, !llvm.loop !554

64:                                               ; preds = %34, %23
  %65 = phi double [ undef, %23 ], [ %60, %34 ]
  %66 = phi i64 [ 0, %23 ], [ %61, %34 ]
  %67 = phi double [ 0.000000e+00, %23 ], [ %60, %34 ]
  br i1 %22, label %80, label %68

68:                                               ; preds = %64, %68
  %69 = phi i64 [ %77, %68 ], [ %66, %64 ]
  %70 = phi double [ %76, %68 ], [ %67, %64 ]
  %71 = phi i64 [ %78, %68 ], [ 0, %64 ]
  %72 = getelementptr inbounds double, ptr %0, i64 %69
  %73 = load double, ptr %72, align 8, !tbaa !28
  %74 = fadd double %73, %2
  %75 = fsub double %74, %14
  %76 = fadd double %70, %75
  %77 = add nuw nsw i64 %69, 1
  %78 = add i64 %71, 1
  %79 = icmp eq i64 %78, %19
  br i1 %79, label %80, label %68, !llvm.loop !555

80:                                               ; preds = %68, %64
  %81 = phi double [ %65, %64 ], [ %76, %68 ]
  %82 = load double, ptr @init_value, align 8, !tbaa !28
  %83 = fadd double %82, %2
  %84 = fsub double %83, %14
  %85 = fmul double %84, 8.000000e+03
  %86 = fsub double %81, %85
  %87 = tail call double @llvm.fabs.f64(double %81)
  %88 = fcmp ogt double %87, 1.000000e-08
  %89 = select i1 %88, double %81, double 1.000000e+00
  %90 = fdiv double %86, %89
  %91 = tail call double @llvm.fabs.f64(double %90)
  %92 = fcmp olt double %91, 0x3EB0C6F7A0B5ED8D
  br i1 %92, label %30, label %26

93:                                               ; preds = %15, %108
  %94 = phi i32 [ %109, %108 ], [ %9, %15 ]
  %95 = phi double [ %110, %108 ], [ %16, %15 ]
  %96 = phi i32 [ %111, %108 ], [ 0, %15 ]
  %97 = fadd double %95, %2
  %98 = fsub double %97, %14
  %99 = fmul double %98, 8.000000e+03
  %100 = fsub double 0.000000e+00, %99
  %101 = tail call double @llvm.fabs.f64(double %100)
  %102 = fcmp olt double %101, 0x3EB0C6F7A0B5ED8D
  br i1 %102, label %108, label %103

103:                                              ; preds = %93
  %104 = load i32, ptr @current_test, align 4, !tbaa !9
  %105 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str.179, i32 noundef %104)
  %106 = load double, ptr @init_value, align 8, !tbaa !28
  %107 = load i32, ptr @iterations, align 4, !tbaa !9
  br label %108

108:                                              ; preds = %93, %103
  %109 = phi i32 [ %94, %93 ], [ %107, %103 ]
  %110 = phi double [ %95, %93 ], [ %106, %103 ]
  %111 = add nuw nsw i32 %96, 1
  %112 = icmp slt i32 %111, %109
  br i1 %112, label %93, label %113, !llvm.loop !553

113:                                              ; preds = %108, %30, %7
  %114 = tail call i64 @clock() #17
  store i64 %114, ptr @end_time, align 8, !tbaa !26
  %115 = load i64, ptr @start_time, align 8, !tbaa !26
  %116 = load ptr, ptr @results, align 8, !tbaa !5
  %117 = icmp eq ptr %116, null
  br i1 %117, label %118, label %120

118:                                              ; preds = %113
  %119 = load i32, ptr @allocated_results, align 4, !tbaa !9
  br label %124

120:                                              ; preds = %113
  %121 = load i32, ptr @current_test, align 4, !tbaa !9
  %122 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %123 = icmp slt i32 %121, %122
  br i1 %123, label %136, label %124

124:                                              ; preds = %120, %118
  %125 = phi i32 [ %119, %118 ], [ %122, %120 ]
  %126 = add nsw i32 %125, 10
  store i32 %126, ptr @allocated_results, align 4, !tbaa !9
  %127 = sext i32 %126 to i64
  %128 = shl nsw i64 %127, 4
  %129 = tail call ptr @realloc(ptr noundef %116, i64 noundef %128) #14
  store ptr %129, ptr @results, align 8, !tbaa !5
  %130 = icmp eq ptr %129, null
  br i1 %130, label %133, label %131

131:                                              ; preds = %124
  %132 = load i32, ptr @current_test, align 4, !tbaa !9
  br label %136

133:                                              ; preds = %124
  %134 = load i32, ptr @allocated_results, align 4, !tbaa !9
  %135 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, i32 noundef %134)
  tail call void @exit(i32 noundef -1) #15
  unreachable

136:                                              ; preds = %120, %131
  %137 = phi i32 [ %132, %131 ], [ %121, %120 ]
  %138 = phi ptr [ %129, %131 ], [ %116, %120 ]
  %139 = sub nsw i64 %114, %115
  %140 = sitofp i64 %139 to double
  %141 = fdiv double %140, 1.000000e+06
  %142 = sext i32 %137 to i64
  %143 = getelementptr inbounds %struct.one_result, ptr %138, i64 %142
  store double %141, ptr %143, align 8, !tbaa !11
  %144 = getelementptr inbounds %struct.one_result, ptr %138, i64 %142, i32 1
  store ptr %6, ptr %144, align 8, !tbaa !14
  %145 = add nsw i32 %137, 1
  store i32 %145, ptr @current_test, align 4, !tbaa !9
  ret void
}

; Function Attrs: mustprogress nofree nounwind willreturn
declare i64 @strtol(ptr noundef readonly, ptr nocapture noundef, i32 noundef) local_unnamed_addr #10

; Function Attrs: mustprogress nofree nounwind willreturn
declare double @strtod(ptr noundef readonly, ptr nocapture noundef) local_unnamed_addr #10

; Function Attrs: mustprogress nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare double @llvm.fabs.f64(double) #11

; Function Attrs: mustprogress nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare float @llvm.fabs.f32(float) #11

; Function Attrs: mustprogress nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare float @llvm.fmuladd.f32(float, float, float) #11

; Function Attrs: mustprogress nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare double @llvm.fmuladd.f64(double, double, double) #11

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i32 @llvm.smax.i32(i32, i32) #12

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: write)
declare void @llvm.memset.p0.i64(ptr nocapture writeonly, i8, i64, i1 immarg) #13

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i8 @llvm.vector.reduce.add.v16i8(<16 x i8>) #12

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i8 @llvm.vector.reduce.add.v8i8(<8 x i8>) #12

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i16 @llvm.vector.reduce.add.v8i16(<8 x i16>) #12

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i32 @llvm.vector.reduce.add.v4i32(<4 x i32>) #12

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i64 @llvm.vector.reduce.add.v2i64(<2 x i64>) #12

attributes #0 = { mustprogress nounwind uwtable "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #1 = { mustprogress nounwind willreturn allockind("realloc") allocsize(1) memory(argmem: readwrite, inaccessiblemem: readwrite) "alloc-family"="malloc" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #2 = { nofree nounwind "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #3 = { noreturn nounwind "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #4 = { mustprogress nofree nounwind uwtable "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #5 = { mustprogress nofree nounwind willreturn memory(argmem: read) "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #6 = { mustprogress nofree nounwind willreturn memory(write) "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #7 = { nounwind "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #8 = { mustprogress norecurse uwtable "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #9 = { mustprogress uwtable "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #10 = { mustprogress nofree nounwind willreturn "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #11 = { mustprogress nocallback nofree nosync nounwind speculatable willreturn memory(none) }
attributes #12 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }
attributes #13 = { nocallback nofree nounwind willreturn memory(argmem: write) }
attributes #14 = { nounwind allocsize(1) }
attributes #15 = { noreturn nounwind }
attributes #16 = { nounwind willreturn memory(read) }
attributes #17 = { nounwind }

!llvm.module.flags = !{!0, !1, !2, !3}
!llvm.ident = !{!4}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 8, !"PIC Level", i32 2}
!2 = !{i32 7, !"PIE Level", i32 2}
!3 = !{i32 7, !"uwtable", i32 2}
!4 = !{!"clang version 17.0.0"}
!5 = !{!6, !6, i64 0}
!6 = !{!"any pointer", !7, i64 0}
!7 = !{!"omnipotent char", !8, i64 0}
!8 = !{!"Simple C++ TBAA"}
!9 = !{!10, !10, i64 0}
!10 = !{!"int", !7, i64 0}
!11 = !{!12, !13, i64 0}
!12 = !{!"_ZTS10one_result", !13, i64 0, !6, i64 8}
!13 = !{!"double", !7, i64 0}
!14 = !{!12, !6, i64 8}
!15 = distinct !{!15, !16}
!16 = !{!"llvm.loop.mustprogress"}
!17 = distinct !{!17, !16}
!18 = distinct !{!18, !16}
!19 = distinct !{!19, !20}
!20 = !{!"llvm.loop.unroll.disable"}
!21 = distinct !{!21, !16}
!22 = distinct !{!22, !16}
!23 = distinct !{!23, !16}
!24 = distinct !{!24, !16}
!25 = distinct !{!25, !20}
!26 = !{!27, !27, i64 0}
!27 = !{!"long", !7, i64 0}
!28 = !{!13, !13, i64 0}
!29 = !{!7, !7, i64 0}
!30 = !{!31, !31, i64 0}
!31 = !{!"short", !7, i64 0}
!32 = distinct !{!32, !16, !33, !34}
!33 = !{!"llvm.loop.isvectorized", i32 1}
!34 = !{!"llvm.loop.unroll.runtime.disable"}
!35 = distinct !{!35, !16, !33, !34}
!36 = distinct !{!36, !16, !33, !34}
!37 = distinct !{!37, !16, !33, !34}
!38 = distinct !{!38, !16, !33, !34}
!39 = distinct !{!39, !16, !33, !34}
!40 = !{!41, !41, i64 0}
!41 = !{!"float", !7, i64 0}
!42 = distinct !{!42, !16, !33, !34}
!43 = distinct !{!43, !16, !33, !34}
!44 = distinct !{!44, !16, !33, !34}
!45 = distinct !{!45, !16, !33, !34}
!46 = distinct !{!46, !16}
!47 = distinct !{!47, !16, !34, !33}
!48 = distinct !{!48, !16, !33, !34}
!49 = distinct !{!49, !16, !33, !34}
!50 = distinct !{!50, !16}
!51 = distinct !{!51, !16, !34, !33}
!52 = distinct !{!52, !16, !33, !34}
!53 = distinct !{!53, !16, !33, !34}
!54 = distinct !{!54, !16}
!55 = distinct !{!55, !16, !34, !33}
!56 = distinct !{!56, !16, !33, !34}
!57 = distinct !{!57, !16, !33, !34}
!58 = distinct !{!58, !16}
!59 = distinct !{!59, !16, !34, !33}
!60 = distinct !{!60, !16, !33, !34}
!61 = distinct !{!61, !16, !33, !34}
!62 = distinct !{!62, !16}
!63 = distinct !{!63, !16, !34, !33}
!64 = distinct !{!64, !16, !33, !34}
!65 = distinct !{!65, !16, !33, !34}
!66 = distinct !{!66, !16}
!67 = distinct !{!67, !16, !34, !33}
!68 = distinct !{!68, !16, !33, !34}
!69 = distinct !{!69, !16, !33, !34}
!70 = distinct !{!70, !16}
!71 = distinct !{!71, !16, !34, !33}
!72 = distinct !{!72, !16, !33, !34}
!73 = distinct !{!73, !16, !33, !34}
!74 = distinct !{!74, !16}
!75 = distinct !{!75, !16, !34, !33}
!76 = distinct !{!76, !16}
!77 = distinct !{!77, !16}
!78 = distinct !{!78, !16}
!79 = distinct !{!79, !16}
!80 = distinct !{!80, !16, !33, !34}
!81 = distinct !{!81, !16, !33, !34}
!82 = distinct !{!82, !16}
!83 = distinct !{!83, !16, !34, !33}
!84 = distinct !{!84, !16, !33, !34}
!85 = distinct !{!85, !16, !33, !34}
!86 = distinct !{!86, !16}
!87 = distinct !{!87, !16, !34, !33}
!88 = distinct !{!88, !16, !33, !34}
!89 = distinct !{!89, !16, !33, !34}
!90 = distinct !{!90, !16}
!91 = distinct !{!91, !16, !34, !33}
!92 = distinct !{!92, !16, !33, !34}
!93 = distinct !{!93, !16, !33, !34}
!94 = distinct !{!94, !16}
!95 = distinct !{!95, !16, !34, !33}
!96 = distinct !{!96, !16, !33, !34}
!97 = distinct !{!97, !16, !33, !34}
!98 = distinct !{!98, !16}
!99 = distinct !{!99, !16, !34, !33}
!100 = distinct !{!100, !16, !33, !34}
!101 = distinct !{!101, !16, !33, !34}
!102 = distinct !{!102, !16}
!103 = distinct !{!103, !16, !34, !33}
!104 = distinct !{!104, !16, !33, !34}
!105 = distinct !{!105, !16, !33, !34}
!106 = distinct !{!106, !16}
!107 = distinct !{!107, !16, !34, !33}
!108 = distinct !{!108, !16, !33, !34}
!109 = distinct !{!109, !16, !33, !34}
!110 = distinct !{!110, !16}
!111 = distinct !{!111, !16, !34, !33}
!112 = distinct !{!112, !16, !33, !34}
!113 = distinct !{!113, !16, !33, !34}
!114 = distinct !{!114, !16}
!115 = distinct !{!115, !16, !34, !33}
!116 = distinct !{!116, !16, !33, !34}
!117 = distinct !{!117, !16, !33, !34}
!118 = distinct !{!118, !16}
!119 = distinct !{!119, !16, !34, !33}
!120 = distinct !{!120, !16, !33, !34}
!121 = distinct !{!121, !16, !33, !34}
!122 = distinct !{!122, !16}
!123 = distinct !{!123, !16, !34, !33}
!124 = distinct !{!124, !16, !33, !34}
!125 = distinct !{!125, !16, !33, !34}
!126 = distinct !{!126, !16}
!127 = distinct !{!127, !16, !34, !33}
!128 = distinct !{!128, !16, !33, !34}
!129 = distinct !{!129, !16, !33, !34}
!130 = distinct !{!130, !16}
!131 = distinct !{!131, !16, !34, !33}
!132 = distinct !{!132, !16, !33, !34}
!133 = distinct !{!133, !16, !33, !34}
!134 = distinct !{!134, !16}
!135 = distinct !{!135, !16, !34, !33}
!136 = distinct !{!136, !16, !33, !34}
!137 = distinct !{!137, !16, !33, !34}
!138 = distinct !{!138, !16}
!139 = distinct !{!139, !16, !34, !33}
!140 = distinct !{!140, !16, !33, !34}
!141 = distinct !{!141, !16, !33, !34}
!142 = distinct !{!142, !16}
!143 = distinct !{!143, !16, !34, !33}
!144 = distinct !{!144, !16}
!145 = distinct !{!145, !16}
!146 = distinct !{!146, !16}
!147 = distinct !{!147, !16}
!148 = distinct !{!148, !16, !33, !34}
!149 = distinct !{!149, !16, !33, !34}
!150 = distinct !{!150, !16}
!151 = distinct !{!151, !16, !34, !33}
!152 = distinct !{!152, !16, !33, !34}
!153 = distinct !{!153, !16, !33, !34}
!154 = distinct !{!154, !16}
!155 = distinct !{!155, !16, !34, !33}
!156 = distinct !{!156, !16, !33, !34}
!157 = distinct !{!157, !16, !33, !34}
!158 = distinct !{!158, !16}
!159 = distinct !{!159, !16, !34, !33}
!160 = distinct !{!160, !16, !33, !34}
!161 = distinct !{!161, !16, !33, !34}
!162 = distinct !{!162, !16}
!163 = distinct !{!163, !16, !34, !33}
!164 = distinct !{!164, !16, !33, !34}
!165 = distinct !{!165, !16, !33, !34}
!166 = distinct !{!166, !16}
!167 = distinct !{!167, !16, !34, !33}
!168 = distinct !{!168, !16, !33, !34}
!169 = distinct !{!169, !16, !33, !34}
!170 = distinct !{!170, !16}
!171 = distinct !{!171, !16, !34, !33}
!172 = distinct !{!172, !16, !33, !34}
!173 = distinct !{!173, !16, !33, !34}
!174 = distinct !{!174, !16}
!175 = distinct !{!175, !16, !34, !33}
!176 = distinct !{!176, !16, !33, !34}
!177 = distinct !{!177, !16, !33, !34}
!178 = distinct !{!178, !16}
!179 = distinct !{!179, !16, !34, !33}
!180 = distinct !{!180, !16, !33, !34}
!181 = distinct !{!181, !16}
!182 = distinct !{!182, !16, !34, !33}
!183 = distinct !{!183, !16, !33, !34}
!184 = distinct !{!184, !16}
!185 = distinct !{!185, !16, !34, !33}
!186 = distinct !{!186, !16, !33, !34}
!187 = distinct !{!187, !16}
!188 = distinct !{!188, !16, !34, !33}
!189 = distinct !{!189, !16, !33, !34}
!190 = distinct !{!190, !16}
!191 = distinct !{!191, !16, !34, !33}
!192 = distinct !{!192, !16, !33, !34}
!193 = distinct !{!193, !16}
!194 = distinct !{!194, !16, !34, !33}
!195 = distinct !{!195, !16, !33, !34}
!196 = distinct !{!196, !16}
!197 = distinct !{!197, !16, !34, !33}
!198 = distinct !{!198, !16, !33, !34}
!199 = distinct !{!199, !16}
!200 = distinct !{!200, !16, !34, !33}
!201 = distinct !{!201, !16, !33, !34}
!202 = distinct !{!202, !16}
!203 = distinct !{!203, !16, !34, !33}
!204 = distinct !{!204, !16}
!205 = distinct !{!205, !16}
!206 = distinct !{!206, !16}
!207 = distinct !{!207, !16}
!208 = distinct !{!208, !16, !33, !34}
!209 = distinct !{!209, !16}
!210 = distinct !{!210, !16, !34, !33}
!211 = distinct !{!211, !16, !33, !34}
!212 = distinct !{!212, !16}
!213 = distinct !{!213, !16, !34, !33}
!214 = distinct !{!214, !16, !33, !34}
!215 = distinct !{!215, !16}
!216 = distinct !{!216, !16, !34, !33}
!217 = distinct !{!217, !16, !33, !34}
!218 = distinct !{!218, !16}
!219 = distinct !{!219, !16, !34, !33}
!220 = distinct !{!220, !16, !33, !34}
!221 = distinct !{!221, !16}
!222 = distinct !{!222, !16, !34, !33}
!223 = distinct !{!223, !16, !33, !34}
!224 = distinct !{!224, !16}
!225 = distinct !{!225, !16, !34, !33}
!226 = distinct !{!226, !16, !33, !34}
!227 = distinct !{!227, !16}
!228 = distinct !{!228, !16, !34, !33}
!229 = distinct !{!229, !16, !33, !34}
!230 = distinct !{!230, !16}
!231 = distinct !{!231, !16, !34, !33}
!232 = distinct !{!232, !16, !33, !34}
!233 = distinct !{!233, !16}
!234 = distinct !{!234, !16, !34, !33}
!235 = distinct !{!235, !16, !33, !34}
!236 = distinct !{!236, !16}
!237 = distinct !{!237, !16, !34, !33}
!238 = distinct !{!238, !16, !33, !34}
!239 = distinct !{!239, !16}
!240 = distinct !{!240, !16, !34, !33}
!241 = distinct !{!241, !16, !33, !34}
!242 = distinct !{!242, !16}
!243 = distinct !{!243, !16, !34, !33}
!244 = distinct !{!244, !16, !33, !34}
!245 = distinct !{!245, !16}
!246 = distinct !{!246, !16, !34, !33}
!247 = distinct !{!247, !16, !33, !34}
!248 = distinct !{!248, !16}
!249 = distinct !{!249, !16, !34, !33}
!250 = distinct !{!250, !16, !33, !34}
!251 = distinct !{!251, !16}
!252 = distinct !{!252, !16, !34, !33}
!253 = distinct !{!253, !16, !33, !34}
!254 = distinct !{!254, !16}
!255 = distinct !{!255, !16, !34, !33}
!256 = distinct !{!256, !16}
!257 = distinct !{!257, !16}
!258 = distinct !{!258, !16}
!259 = distinct !{!259, !16}
!260 = distinct !{!260, !16, !33, !34}
!261 = distinct !{!261, !16}
!262 = distinct !{!262, !16, !34, !33}
!263 = distinct !{!263, !16, !33, !34}
!264 = distinct !{!264, !16}
!265 = distinct !{!265, !16, !34, !33}
!266 = distinct !{!266, !16, !33, !34}
!267 = distinct !{!267, !16}
!268 = distinct !{!268, !16, !34, !33}
!269 = distinct !{!269, !16, !33, !34}
!270 = distinct !{!270, !16}
!271 = distinct !{!271, !16, !34, !33}
!272 = distinct !{!272, !16, !33, !34}
!273 = distinct !{!273, !16}
!274 = distinct !{!274, !16, !34, !33}
!275 = distinct !{!275, !16, !33, !34}
!276 = distinct !{!276, !16}
!277 = distinct !{!277, !16, !34, !33}
!278 = distinct !{!278, !16, !33, !34}
!279 = distinct !{!279, !16}
!280 = distinct !{!280, !16, !34, !33}
!281 = distinct !{!281, !16, !33, !34}
!282 = distinct !{!282, !16}
!283 = distinct !{!283, !16, !34, !33}
!284 = distinct !{!284, !16, !33, !34}
!285 = distinct !{!285, !16}
!286 = distinct !{!286, !16, !34, !33}
!287 = distinct !{!287, !16, !33, !34}
!288 = distinct !{!288, !16}
!289 = distinct !{!289, !16, !34, !33}
!290 = distinct !{!290, !16, !33, !34}
!291 = distinct !{!291, !16}
!292 = distinct !{!292, !16, !34, !33}
!293 = distinct !{!293, !16, !33, !34}
!294 = distinct !{!294, !16}
!295 = distinct !{!295, !16, !34, !33}
!296 = distinct !{!296, !16, !33, !34}
!297 = distinct !{!297, !16}
!298 = distinct !{!298, !16, !34, !33}
!299 = distinct !{!299, !16, !33, !34}
!300 = distinct !{!300, !16}
!301 = distinct !{!301, !16, !34, !33}
!302 = distinct !{!302, !16, !33, !34}
!303 = distinct !{!303, !16}
!304 = distinct !{!304, !16, !34, !33}
!305 = distinct !{!305, !16, !33, !34}
!306 = distinct !{!306, !16}
!307 = distinct !{!307, !16, !34, !33}
!308 = distinct !{!308, !16}
!309 = distinct !{!309, !16}
!310 = distinct !{!310, !16}
!311 = distinct !{!311, !16}
!312 = distinct !{!312, !16, !33, !34}
!313 = distinct !{!313, !16}
!314 = distinct !{!314, !16, !34, !33}
!315 = distinct !{!315, !16, !33, !34}
!316 = distinct !{!316, !16}
!317 = distinct !{!317, !16, !34, !33}
!318 = distinct !{!318, !16, !33, !34}
!319 = distinct !{!319, !16}
!320 = distinct !{!320, !16, !34, !33}
!321 = distinct !{!321, !16, !33, !34}
!322 = distinct !{!322, !16}
!323 = distinct !{!323, !16, !34, !33}
!324 = distinct !{!324, !16, !33, !34}
!325 = distinct !{!325, !16}
!326 = distinct !{!326, !16, !34, !33}
!327 = distinct !{!327, !16, !33, !34}
!328 = distinct !{!328, !16}
!329 = distinct !{!329, !16, !34, !33}
!330 = distinct !{!330, !16, !33, !34}
!331 = distinct !{!331, !16}
!332 = distinct !{!332, !16, !34, !33}
!333 = distinct !{!333, !16, !33, !34}
!334 = distinct !{!334, !16}
!335 = distinct !{!335, !16, !34, !33}
!336 = distinct !{!336, !16, !33, !34}
!337 = distinct !{!337, !16}
!338 = distinct !{!338, !16, !34, !33}
!339 = distinct !{!339, !16, !33, !34}
!340 = distinct !{!340, !16}
!341 = distinct !{!341, !16, !34, !33}
!342 = distinct !{!342, !16, !33, !34}
!343 = distinct !{!343, !16}
!344 = distinct !{!344, !16, !34, !33}
!345 = distinct !{!345, !16, !33, !34}
!346 = distinct !{!346, !16}
!347 = distinct !{!347, !16, !34, !33}
!348 = distinct !{!348, !16, !33, !34}
!349 = distinct !{!349, !16}
!350 = distinct !{!350, !16, !34, !33}
!351 = distinct !{!351, !16, !33, !34}
!352 = distinct !{!352, !16}
!353 = distinct !{!353, !16, !34, !33}
!354 = distinct !{!354, !16, !33, !34}
!355 = distinct !{!355, !16}
!356 = distinct !{!356, !16, !34, !33}
!357 = distinct !{!357, !16, !33, !34}
!358 = distinct !{!358, !16}
!359 = distinct !{!359, !16, !34, !33}
!360 = distinct !{!360, !16}
!361 = distinct !{!361, !16}
!362 = distinct !{!362, !16}
!363 = distinct !{!363, !16}
!364 = distinct !{!364, !16, !33, !34}
!365 = distinct !{!365, !16}
!366 = distinct !{!366, !16, !34, !33}
!367 = distinct !{!367, !16, !33, !34}
!368 = distinct !{!368, !16}
!369 = distinct !{!369, !16, !34, !33}
!370 = distinct !{!370, !16, !33, !34}
!371 = distinct !{!371, !16}
!372 = distinct !{!372, !16, !34, !33}
!373 = distinct !{!373, !16, !33, !34}
!374 = distinct !{!374, !16}
!375 = distinct !{!375, !16, !34, !33}
!376 = distinct !{!376, !16, !33, !34}
!377 = distinct !{!377, !16}
!378 = distinct !{!378, !16, !34, !33}
!379 = distinct !{!379, !16, !33, !34}
!380 = distinct !{!380, !16}
!381 = distinct !{!381, !16, !34, !33}
!382 = distinct !{!382, !16, !33, !34}
!383 = distinct !{!383, !16}
!384 = distinct !{!384, !16, !34, !33}
!385 = distinct !{!385, !16, !33, !34}
!386 = distinct !{!386, !16}
!387 = distinct !{!387, !16, !34, !33}
!388 = distinct !{!388, !16, !33, !34}
!389 = distinct !{!389, !16}
!390 = distinct !{!390, !16, !34, !33}
!391 = distinct !{!391, !16, !33, !34}
!392 = distinct !{!392, !16}
!393 = distinct !{!393, !16, !34, !33}
!394 = distinct !{!394, !16, !33, !34}
!395 = distinct !{!395, !16}
!396 = distinct !{!396, !16, !34, !33}
!397 = distinct !{!397, !16, !33, !34}
!398 = distinct !{!398, !16}
!399 = distinct !{!399, !16, !34, !33}
!400 = distinct !{!400, !16, !33, !34}
!401 = distinct !{!401, !16}
!402 = distinct !{!402, !16, !34, !33}
!403 = distinct !{!403, !16}
!404 = distinct !{!404, !16}
!405 = distinct !{!405, !20}
!406 = distinct !{!406, !16}
!407 = distinct !{!407, !16}
!408 = distinct !{!408, !20}
!409 = distinct !{!409, !16, !33, !34}
!410 = distinct !{!410, !16}
!411 = distinct !{!411, !16, !34, !33}
!412 = distinct !{!412, !16}
!413 = distinct !{!413, !16}
!414 = distinct !{!414, !16}
!415 = distinct !{!415, !16}
!416 = distinct !{!416, !16, !33, !34}
!417 = distinct !{!417, !16}
!418 = distinct !{!418, !16, !34, !33}
!419 = distinct !{!419, !16, !33, !34}
!420 = distinct !{!420, !16}
!421 = distinct !{!421, !16, !34, !33}
!422 = distinct !{!422, !16, !33, !34}
!423 = distinct !{!423, !16}
!424 = distinct !{!424, !16, !34, !33}
!425 = distinct !{!425, !16, !33, !34}
!426 = distinct !{!426, !16}
!427 = distinct !{!427, !16, !34, !33}
!428 = distinct !{!428, !16, !33, !34}
!429 = distinct !{!429, !16}
!430 = distinct !{!430, !16, !34, !33}
!431 = distinct !{!431, !16, !33, !34}
!432 = distinct !{!432, !16}
!433 = distinct !{!433, !16, !34, !33}
!434 = distinct !{!434, !16, !33, !34}
!435 = distinct !{!435, !16}
!436 = distinct !{!436, !16, !34, !33}
!437 = distinct !{!437, !16, !33, !34}
!438 = distinct !{!438, !16}
!439 = distinct !{!439, !16, !34, !33}
!440 = distinct !{!440, !16, !33, !34}
!441 = distinct !{!441, !16}
!442 = distinct !{!442, !16, !34, !33}
!443 = distinct !{!443, !16, !33, !34}
!444 = distinct !{!444, !16}
!445 = distinct !{!445, !16, !34, !33}
!446 = distinct !{!446, !16, !33, !34}
!447 = distinct !{!447, !16}
!448 = distinct !{!448, !16, !34, !33}
!449 = distinct !{!449, !16, !33, !34}
!450 = distinct !{!450, !16}
!451 = distinct !{!451, !16, !34, !33}
!452 = distinct !{!452, !16, !33, !34}
!453 = distinct !{!453, !16}
!454 = distinct !{!454, !16, !34, !33}
!455 = distinct !{!455, !16}
!456 = distinct !{!456, !16}
!457 = distinct !{!457, !20}
!458 = distinct !{!458, !16}
!459 = distinct !{!459, !16}
!460 = distinct !{!460, !20}
!461 = distinct !{!461, !16, !33, !34}
!462 = distinct !{!462, !16}
!463 = distinct !{!463, !16, !34, !33}
!464 = distinct !{!464, !16}
!465 = distinct !{!465, !16}
!466 = distinct !{!466, !16}
!467 = distinct !{!467, !16}
!468 = distinct !{!468, !16, !33, !34}
!469 = distinct !{!469, !16}
!470 = distinct !{!470, !16, !34, !33}
!471 = distinct !{!471, !16, !33, !34}
!472 = distinct !{!472, !16}
!473 = distinct !{!473, !16, !34, !33}
!474 = distinct !{!474, !16, !33, !34}
!475 = distinct !{!475, !16}
!476 = distinct !{!476, !16, !34, !33}
!477 = distinct !{!477, !16, !33, !34}
!478 = distinct !{!478, !16}
!479 = distinct !{!479, !16, !34, !33}
!480 = distinct !{!480, !16, !33, !34}
!481 = distinct !{!481, !16}
!482 = distinct !{!482, !16, !34, !33}
!483 = distinct !{!483, !16, !33, !34}
!484 = distinct !{!484, !16}
!485 = distinct !{!485, !16, !34, !33}
!486 = distinct !{!486, !16, !33, !34}
!487 = distinct !{!487, !16}
!488 = distinct !{!488, !16, !34, !33}
!489 = distinct !{!489, !16, !33, !34}
!490 = distinct !{!490, !16}
!491 = distinct !{!491, !16, !34, !33}
!492 = distinct !{!492, !16}
!493 = distinct !{!493, !16}
!494 = distinct !{!494, !20}
!495 = distinct !{!495, !16}
!496 = distinct !{!496, !16}
!497 = distinct !{!497, !20}
!498 = distinct !{!498, !16}
!499 = distinct !{!499, !16}
!500 = distinct !{!500, !16}
!501 = distinct !{!501, !16}
!502 = distinct !{!502, !20}
!503 = distinct !{!503, !16}
!504 = distinct !{!504, !16}
!505 = distinct !{!505, !16}
!506 = distinct !{!506, !16}
!507 = distinct !{!507, !20}
!508 = distinct !{!508, !16}
!509 = distinct !{!509, !16}
!510 = distinct !{!510, !16}
!511 = distinct !{!511, !16}
!512 = distinct !{!512, !20}
!513 = distinct !{!513, !16}
!514 = distinct !{!514, !16}
!515 = distinct !{!515, !20}
!516 = distinct !{!516, !16}
!517 = distinct !{!517, !16}
!518 = distinct !{!518, !16}
!519 = distinct !{!519, !16}
!520 = distinct !{!520, !20}
!521 = distinct !{!521, !16}
!522 = distinct !{!522, !16}
!523 = distinct !{!523, !20}
!524 = distinct !{!524, !16}
!525 = distinct !{!525, !16}
!526 = distinct !{!526, !20}
!527 = distinct !{!527, !16}
!528 = distinct !{!528, !16}
!529 = distinct !{!529, !20}
!530 = distinct !{!530, !16}
!531 = distinct !{!531, !16}
!532 = distinct !{!532, !16}
!533 = distinct !{!533, !16}
!534 = distinct !{!534, !20}
!535 = distinct !{!535, !16}
!536 = distinct !{!536, !16}
!537 = distinct !{!537, !16}
!538 = distinct !{!538, !16}
!539 = distinct !{!539, !20}
!540 = distinct !{!540, !16}
!541 = distinct !{!541, !16}
!542 = distinct !{!542, !16}
!543 = distinct !{!543, !16}
!544 = distinct !{!544, !20}
!545 = distinct !{!545, !16}
!546 = distinct !{!546, !16}
!547 = distinct !{!547, !20}
!548 = distinct !{!548, !16}
!549 = distinct !{!549, !16}
!550 = distinct !{!550, !16}
!551 = distinct !{!551, !16}
!552 = distinct !{!552, !20}
!553 = distinct !{!553, !16}
!554 = distinct !{!554, !16}
!555 = distinct !{!555, !20}
